#ifndef _SWINEHD
#define _SWINEHD

// File generated by pdbripper v2.03 (http://www.ntinfo.biz)
// Bugreports : horsicq@gmail.com

struct UPNPDev
{
    struct UPNPDev * pNext;
    char * descURL;
    char * st;
    char * usn;
    unsigned int scope_id;
    char buffer[3];
};

enum PIDMSI_STATUS_VALUE
{
    PIDMSI_STATUS_NORMAL=0,
    PIDMSI_STATUS_NEW=1,
    PIDMSI_STATUS_PRELIM=2,
    PIDMSI_STATUS_DRAFT=3,
    PIDMSI_STATUS_INPROGRESS=4,
    PIDMSI_STATUS_EDIT=5,
    PIDMSI_STATUS_REVIEW=6,
    PIDMSI_STATUS_PROOF=7,
    PIDMSI_STATUS_FINAL=8,
    PIDMSI_STATUS_OTHER=32767
};

enum tagBINDSTATUS
{
    BINDSTATUS_FINDINGRESOURCE=1,
    BINDSTATUS_CONNECTING=2,
    BINDSTATUS_REDIRECTING=3,
    BINDSTATUS_BEGINDOWNLOADDATA=4,
    BINDSTATUS_DOWNLOADINGDATA=5,
    BINDSTATUS_ENDDOWNLOADDATA=6,
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS=7,
    BINDSTATUS_INSTALLINGCOMPONENTS=8,
    BINDSTATUS_ENDDOWNLOADCOMPONENTS=9,
    BINDSTATUS_USINGCACHEDCOPY=10,
    BINDSTATUS_SENDINGREQUEST=11,
    BINDSTATUS_CLASSIDAVAILABLE=12,
    BINDSTATUS_MIMETYPEAVAILABLE=13,
    BINDSTATUS_CACHEFILENAMEAVAILABLE=14,
    BINDSTATUS_BEGINSYNCOPERATION=15,
    BINDSTATUS_ENDSYNCOPERATION=16,
    BINDSTATUS_BEGINUPLOADDATA=17,
    BINDSTATUS_UPLOADINGDATA=18,
    BINDSTATUS_ENDUPLOADDATA=19,
    BINDSTATUS_PROTOCOLCLASSID=20,
    BINDSTATUS_ENCODING=21,
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE=22,
    BINDSTATUS_CLASSINSTALLLOCATION=23,
    BINDSTATUS_DECODING=24,
    BINDSTATUS_LOADINGMIMEHANDLER=25,
    BINDSTATUS_CONTENTDISPOSITIONATTACH=26,
    BINDSTATUS_FILTERREPORTMIMETYPE=27,
    BINDSTATUS_CLSIDCANINSTANTIATE=28,
    BINDSTATUS_IUNKNOWNAVAILABLE=29,
    BINDSTATUS_DIRECTBIND=30,
    BINDSTATUS_RAWMIMETYPE=31,
    BINDSTATUS_PROXYDETECTING=32,
    BINDSTATUS_ACCEPTRANGES=33,
    BINDSTATUS_COOKIE_SENT=34,
    BINDSTATUS_COMPACT_POLICY_RECEIVED=35,
    BINDSTATUS_COOKIE_SUPPRESSED=36,
    BINDSTATUS_COOKIE_STATE_UNKNOWN=37,
    BINDSTATUS_COOKIE_STATE_ACCEPT=38,
    BINDSTATUS_COOKIE_STATE_REJECT=39,
    BINDSTATUS_COOKIE_STATE_PROMPT=40,
    BINDSTATUS_COOKIE_STATE_LEASH=41,
    BINDSTATUS_COOKIE_STATE_DOWNGRADE=42,
    BINDSTATUS_POLICY_HREF=43,
    BINDSTATUS_P3P_HEADER=44,
    BINDSTATUS_SESSION_COOKIE_RECEIVED=45,
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED=46,
    BINDSTATUS_SESSION_COOKIES_ALLOWED=47,
    BINDSTATUS_CACHECONTROL=48,
    BINDSTATUS_CONTENTDISPOSITIONFILENAME=49,
    BINDSTATUS_MIMETEXTPLAINMISMATCH=50,
    BINDSTATUS_PUBLISHERAVAILABLE=51,
    BINDSTATUS_DISPLAYNAMEAVAILABLE=52,
    BINDSTATUS_SSLUX_NAVBLOCKED=53,
    BINDSTATUS_SERVER_MIMETYPEAVAILABLE=54,
    BINDSTATUS_SNIFFED_CLASSIDAVAILABLE=55,
    BINDSTATUS_64BIT_PROGRESS=56
};

enum tagDOMNodeType
{
    NODE_INVALID=0,
    NODE_ELEMENT=1,
    NODE_ATTRIBUTE=2,
    NODE_TEXT=3,
    NODE_CDATA_SECTION=4,
    NODE_ENTITY_REFERENCE=5,
    NODE_ENTITY=6,
    NODE_PROCESSING_INSTRUCTION=7,
    NODE_COMMENT=8,
    NODE_DOCUMENT=9,
    NODE_DOCUMENT_TYPE=10,
    NODE_DOCUMENT_FRAGMENT=11,
    NODE_NOTATION=12
};

enum tagVARKIND
{
    VAR_PERINSTANCE=0,
    VAR_STATIC=1,
    VAR_CONST=2,
    VAR_DISPATCH=3
};

enum tagCHANGEKIND
{
    CHANGEKIND_ADDMEMBER=0,
    CHANGEKIND_DELETEMEMBER=1,
    CHANGEKIND_SETNAMES=2,
    CHANGEKIND_SETDOCUMENTATION=3,
    CHANGEKIND_GENERAL=4,
    CHANGEKIND_INVALIDATE=5,
    CHANGEKIND_CHANGEFAILED=6,
    CHANGEKIND_MAX=7
};

enum _tagPARSEACTION
{
    PARSE_CANONICALIZE=1,
    PARSE_FRIENDLY=2,
    PARSE_SECURITY_URL=3,
    PARSE_ROOTDOCUMENT=4,
    PARSE_DOCUMENT=5,
    PARSE_ANCHOR=6,
    PARSE_ENCODE_IS_UNESCAPE=7,
    PARSE_DECODE_IS_ESCAPE=8,
    PARSE_PATH_FROM_URL=9,
    PARSE_URL_FROM_PATH=10,
    PARSE_MIME=11,
    PARSE_SERVER=12,
    PARSE_SCHEMA=13,
    PARSE_SITE=14,
    PARSE_DOMAIN=15,
    PARSE_LOCATION=16,
    PARSE_SECURITY_DOMAIN=17,
    PARSE_ESCAPE=18,
    PARSE_UNESCAPE=19
};

enum tagFUNCKIND
{
    FUNC_VIRTUAL=0,
    FUNC_PUREVIRTUAL=1,
    FUNC_NONVIRTUAL=2,
    FUNC_STATIC=3,
    FUNC_DISPATCH=4
};

enum _tagINTERNETFEATURELIST
{
    FEATURE_OBJECT_CACHING=0,
    FEATURE_ZONE_ELEVATION=1,
    FEATURE_MIME_HANDLING=2,
    FEATURE_MIME_SNIFFING=3,
    FEATURE_WINDOW_RESTRICTIONS=4,
    FEATURE_WEBOC_POPUPMANAGEMENT=5,
    FEATURE_BEHAVIORS=6,
    FEATURE_DISABLE_MK_PROTOCOL=7,
    FEATURE_LOCALMACHINE_LOCKDOWN=8,
    FEATURE_SECURITYBAND=9,
    FEATURE_RESTRICT_ACTIVEXINSTALL=10,
    FEATURE_VALIDATE_NAVIGATE_URL=11,
    FEATURE_RESTRICT_FILEDOWNLOAD=12,
    FEATURE_ADDON_MANAGEMENT=13,
    FEATURE_PROTOCOL_LOCKDOWN=14,
    FEATURE_HTTP_USERNAME_PASSWORD_DISABLE=15,
    FEATURE_SAFE_BINDTOOBJECT=16,
    FEATURE_UNC_SAVEDFILECHECK=17,
    FEATURE_GET_URL_DOM_FILEPATH_UNENCODED=18,
    FEATURE_TABBED_BROWSING=19,
    FEATURE_SSLUX=20,
    FEATURE_DISABLE_NAVIGATION_SOUNDS=21,
    FEATURE_DISABLE_LEGACY_COMPRESSION=22,
    FEATURE_FORCE_ADDR_AND_STATUS=23,
    FEATURE_XMLHTTP=24,
    FEATURE_DISABLE_TELNET_PROTOCOL=25,
    FEATURE_FEEDS=26,
    FEATURE_BLOCK_INPUT_PROMPTS=27,
    FEATURE_ENTRY_COUNT=28
};

enum _tagQUERYOPTION
{
    QUERY_EXPIRATION_DATE=1,
    QUERY_TIME_OF_LAST_CHANGE=2,
    QUERY_CONTENT_ENCODING=3,
    QUERY_CONTENT_TYPE=4,
    QUERY_REFRESH=5,
    QUERY_RECOMBINE=6,
    QUERY_CAN_NAVIGATE=7,
    QUERY_USES_NETWORK=8,
    QUERY_IS_CACHED=9,
    QUERY_IS_INSTALLEDENTRY=10,
    QUERY_IS_CACHED_OR_MAPPED=11,
    QUERY_USES_CACHE=12,
    QUERY_IS_SECURE=13,
    QUERY_IS_SAFE=14,
    QUERY_USES_HISTORYFOLDER=15
};

enum VARENUM
{
    VT_EMPTY=0,
    VT_NULL=1,
    VT_I2=2,
    VT_I4=3,
    VT_R4=4,
    VT_R8=5,
    VT_CY=6,
    VT_DATE=7,
    VT_BSTR=8,
    VT_DISPATCH=9,
    VT_ERROR=10,
    VT_BOOL=11,
    VT_VARIANT=12,
    VT_UNKNOWN=13,
    VT_DECIMAL=14,
    VT_I1=16,
    VT_UI1=17,
    VT_UI2=18,
    VT_UI4=19,
    VT_I8=20,
    VT_UI8=21,
    VT_INT=22,
    VT_UINT=23,
    VT_VOID=24,
    VT_HRESULT=25,
    VT_PTR=26,
    VT_SAFEARRAY=27,
    VT_CARRAY=28,
    VT_USERDEFINED=29,
    VT_LPSTR=30,
    VT_LPWSTR=31,
    VT_RECORD=36,
    VT_INT_PTR=37,
    VT_UINT_PTR=38,
    VT_FILETIME=64,
    VT_BLOB=65,
    VT_STREAM=66,
    VT_STORAGE=67,
    VT_STREAMED_OBJECT=68,
    VT_STORED_OBJECT=69,
    VT_BLOB_OBJECT=70,
    VT_CF=71,
    VT_CLSID=72,
    VT_VERSIONED_STREAM=73,
    VT_BSTR_BLOB=4095,
    VT_VECTOR=4096,
    VT_ARRAY=8192,
    VT_BYREF=16384,
    VT_RESERVED=32768,
    VT_ILLEGAL=65535,
    VT_ILLEGALMASKED=4095,
    VT_TYPEMASK=4095
};

enum tagDESCKIND
{
    DESCKIND_NONE=0,
    DESCKIND_FUNCDESC=1,
    DESCKIND_VARDESC=2,
    DESCKIND_TYPECOMP=3,
    DESCKIND_IMPLICITAPPOBJ=4,
    DESCKIND_MAX=5
};

enum tagBINDSTRING
{
    BINDSTRING_HEADERS=1,
    BINDSTRING_ACCEPT_MIMES=2,
    BINDSTRING_EXTRA_URL=3,
    BINDSTRING_LANGUAGE=4,
    BINDSTRING_USERNAME=5,
    BINDSTRING_PASSWORD=6,
    BINDSTRING_UA_PIXELS=7,
    BINDSTRING_UA_COLOR=8,
    BINDSTRING_OS=9,
    BINDSTRING_USER_AGENT=10,
    BINDSTRING_ACCEPT_ENCODINGS=11,
    BINDSTRING_POST_COOKIE=12,
    BINDSTRING_POST_DATA_MIME=13,
    BINDSTRING_URL=14,
    BINDSTRING_IID=15,
    BINDSTRING_FLAG_BIND_TO_OBJECT=16,
    BINDSTRING_PTR_BIND_CONTEXT=17,
    BINDSTRING_XDR_ORIGIN=18
};

enum __MIDL_ICodeInstall_0001
{
    CIP_DISK_FULL=0,
    CIP_ACCESS_DENIED=1,
    CIP_NEWER_VERSION_EXISTS=2,
    CIP_OLDER_VERSION_EXISTS=3,
    CIP_NAME_CONFLICT=4,
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING=5,
    CIP_EXE_SELF_REGISTERATION_TIMEOUT=6,
    CIP_UNSAFE_TO_ABORT=7,
    CIP_NEED_REBOOT=8,
    CIP_NEED_REBOOT_UI_PERMISSION=9
};

enum tagCALLCONV
{
    CC_FASTCALL=0,
    CC_CDECL=1,
    CC_MSCPASCAL=2,
    CC_PASCAL=2,
    CC_MACPASCAL=3,
    CC_STDCALL=4,
    CC_FPFASTCALL=5,
    CC_SYSCALL=6,
    CC_MPWCDECL=7,
    CC_MPWPASCAL=8,
    CC_MAX=9
};

enum _NDIS_802_11_WEP_STATUS
{
    Ndis802_11WEPEnabled=0,
    Ndis802_11Encryption1Enabled=0,
    Ndis802_11WEPDisabled=1,
    Ndis802_11EncryptionDisabled=1,
    Ndis802_11WEPKeyAbsent=2,
    Ndis802_11Encryption1KeyAbsent=2,
    Ndis802_11WEPNotSupported=3,
    Ndis802_11EncryptionNotSupported=3,
    Ndis802_11Encryption2Enabled=4,
    Ndis802_11Encryption2KeyAbsent=5,
    Ndis802_11Encryption3Enabled=6,
    Ndis802_11Encryption3KeyAbsent=7
};

enum tagSYSKIND
{
    SYS_WIN16=0,
    SYS_WIN32=1,
    SYS_MAC=2,
    SYS_WIN64=3
};

enum __MIDL_IUri_0001
{
    Uri_PROPERTY_ABSOLUTE_URI=0,
    Uri_PROPERTY_STRING_START=0,
    Uri_PROPERTY_AUTHORITY=1,
    Uri_PROPERTY_DISPLAY_URI=2,
    Uri_PROPERTY_DOMAIN=3,
    Uri_PROPERTY_EXTENSION=4,
    Uri_PROPERTY_FRAGMENT=5,
    Uri_PROPERTY_HOST=6,
    Uri_PROPERTY_PASSWORD=7,
    Uri_PROPERTY_PATH=8,
    Uri_PROPERTY_PATH_AND_QUERY=9,
    Uri_PROPERTY_QUERY=10,
    Uri_PROPERTY_RAW_URI=11,
    Uri_PROPERTY_SCHEME_NAME=12,
    Uri_PROPERTY_USER_INFO=13,
    Uri_PROPERTY_USER_NAME=14,
    Uri_PROPERTY_STRING_LAST=14,
    Uri_PROPERTY_HOST_TYPE=15,
    Uri_PROPERTY_DWORD_START=15,
    Uri_PROPERTY_PORT=16,
    Uri_PROPERTY_SCHEME=17,
    Uri_PROPERTY_ZONE=18,
    Uri_PROPERTY_DWORD_LAST=18
};

enum _NDIS_PROCESSOR_VENDOR
{
    NdisProcessorVendorUnknown=0,
    NdisProcessorVendorGenuinIntel=1,
    NdisProcessorVendorGenuineIntel=1,
    NdisProcessorVendorAuthenticAMD=2
};

enum DISPLAYCONFIG_SCANLINE_ORDERING
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED=0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE=1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED=2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST=2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST=3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32=-1
};

enum tagTYSPEC
{
    TYSPEC_CLSID=0,
    TYSPEC_FILEEXT=1,
    TYSPEC_MIMETYPE=2,
    TYSPEC_FILENAME=3,
    TYSPEC_PROGID=4,
    TYSPEC_PACKAGENAME=5,
    TYSPEC_OBJECTID=6
};

enum __MIDL_IUri_0002
{
    Uri_HOST_UNKNOWN=0,
    Uri_HOST_DNS=1,
    Uri_HOST_IPV4=2,
    Uri_HOST_IPV6=3,
    Uri_HOST_IDN=4
};

enum tagURLZONE
{
    URLZONE_INVALID=-1,
    URLZONE_PREDEFINED_MIN=0,
    URLZONE_LOCAL_MACHINE=0,
    URLZONE_INTRANET=1,
    URLZONE_TRUSTED=2,
    URLZONE_INTERNET=3,
    URLZONE_UNTRUSTED=4,
    URLZONE_PREDEFINED_MAX=999,
    URLZONE_USER_MIN=1000,
    URLZONE_USER_MAX=10000
};

enum tagTYPEKIND
{
    TKIND_ENUM=0,
    TKIND_RECORD=1,
    TKIND_MODULE=2,
    TKIND_INTERFACE=3,
    TKIND_DISPATCH=4,
    TKIND_COCLASS=5,
    TKIND_ALIAS=6,
    TKIND_UNION=7,
    TKIND_MAX=8
};

enum tagXMLEMEM_TYPE
{
    XMLELEMTYPE_ELEMENT=0,
    XMLELEMTYPE_TEXT=1,
    XMLELEMTYPE_COMMENT=2,
    XMLELEMTYPE_DOCUMENT=3,
    XMLELEMTYPE_DTD=4,
    XMLELEMTYPE_PI=5,
    XMLELEMTYPE_OTHER=6
};

enum _TP_CALLBACK_PRIORITY
{
    TP_CALLBACK_PRIORITY_HIGH=0,
    TP_CALLBACK_PRIORITY_NORMAL=1,
    TP_CALLBACK_PRIORITY_LOW=2,
    TP_CALLBACK_PRIORITY_INVALID=3
};

enum SCOPE_LEVEL
{
    ScopeLevelInterface=1,
    ScopeLevelLink=2,
    ScopeLevelSubnet=3,
    ScopeLevelAdmin=4,
    ScopeLevelSite=5,
    ScopeLevelOrganization=8,
    ScopeLevelGlobal=14,
    ScopeLevelCount=16
};

enum _URLZONEREG
{
    URLZONEREG_DEFAULT=0,
    URLZONEREG_HKLM=1,
    URLZONEREG_HKCU=2
};

enum _tagPSUACTION
{
    PSU_DEFAULT=1,
    PSU_SECURITY_URL_ONLY=2
};

enum _DOT11_PHY_TYPE
{
    dot11_phy_type_unknown=0,
    dot11_phy_type_any=0,
    dot11_phy_type_fhss=1,
    dot11_phy_type_dsss=2,
    dot11_phy_type_irbaseband=3,
    dot11_phy_type_ofdm=4,
    dot11_phy_type_hrdsss=5,
    dot11_phy_type_erp=6,
    dot11_phy_type_ht=7,
    dot11_phy_type_IHV_start=-2147483648,
    dot11_phy_type_IHV_end=-1
};

enum ReplacesCorHdrNumericDefines
{
    COMIMAGE_FLAGS_ILONLY=1,
    COMIMAGE_FLAGS_32BITREQUIRED=2,
    COMIMAGE_FLAGS_IL_LIBRARY=4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED=8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT=16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA=65536,
    COR_VERSION_MAJOR_V2=2,
    COR_VERSION_MAJOR=2,
    COR_VERSION_MINOR=0,
    COR_DELETED_NAME_LENGTH=8,
    COR_VTABLEGAP_NAME_LENGTH=8,
    NATIVE_TYPE_MAX_CB=1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=255,
    IMAGE_COR_MIH_METHODRVA=1,
    IMAGE_COR_MIH_EHRVA=2,
    IMAGE_COR_MIH_BASICBLOCK=8,
    COR_VTABLE_32BIT=1,
    COR_VTABLE_64BIT=2,
    COR_VTABLE_FROM_UNMANAGED=4,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN=8,
    COR_VTABLE_CALL_MOST_DERIVED=16,
    IMAGE_COR_EATJ_THUNK_SIZE=32,
    MAX_CLASS_NAME=1024,
    MAX_PACKAGE_NAME=1024
};

enum tagApplicationType
{
    ServerApplication=0,
    LibraryApplication=1
};

enum tagShutdownType
{
    IdleShutdown=0,
    ForcedShutdown=1
};

enum tagGLOBALOPT_EH_VALUES
{
    COMGLB_EXCEPTION_HANDLE=0,
    COMGLB_EXCEPTION_DONOT_HANDLE_FATAL=1,
    COMGLB_EXCEPTION_DONOT_HANDLE=1,
    COMGLB_EXCEPTION_DONOT_HANDLE_ANY=2
};

struct sockaddr_storage
{
    unsigned int ss_family;
    char __ss_pad1[6];
    int __ss_align;
    char __ss_pad2[112];
};

enum MULTICAST_MODE_TYPE
{
    MCAST_INCLUDE=0,
    MCAST_EXCLUDE=1
};

struct group_filter
{
    unsigned long gf_interface;
    struct sockaddr_storage gf_group;
    enum MULTICAST_MODE_TYPE gf_fmode;
    unsigned long gf_numsrc;
    struct sockaddr_storage gf_slist[1];
};

struct sockaddr
{
    unsigned int sa_family;
    char sa_data[14];
};

struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};

struct _TP_CLEANUP_GROUP
{
};

struct _unnamed_41
{
    unsigned int s_b1;
    unsigned int s_b2;
    unsigned int s_b3;
    unsigned int s_b4;
};

struct _unnamed_42
{
    unsigned int s_w1;
    unsigned int s_w2;
};

union _unnamed_43
{
    struct _unnamed_41 S_un_b;
    struct _unnamed_42 S_un_w;
    unsigned long S_addr;
};

struct in_addr
{
    union _unnamed_43 S_un;
};

struct ip_msfilter
{
    struct in_addr imsf_multiaddr;
    struct in_addr imsf_interface;
    enum MULTICAST_MODE_TYPE imsf_fmode;
    unsigned long imsf_numsrc;
    struct in_addr imsf_slist[1];
};

struct UPNPUrls
{
    char * controlURL;
    char * ipcondescURL;
    char * controlURL_CIF;
    char * controlURL_6FC;
    char * rootdescURL;
};

struct sockaddr_in6
{
    unsigned int sin6_family;
    unsigned int sin6_port;
    unsigned long sin6_flowinfo;
    struct in6_addr sin6_addr;
    unsigned long sin6_scope_id;
    struct SCOPE_ID sin6_scope_struct;
};

struct xmlparser
{
    char * xmlstart;
    char * xmlend;
    char * xml;
    int xmlsize;
    void * data;
    void  ( * starteltfunc)(void * ,char * ,int );
    void  ( * endeltfunc)(void * ,char * ,int );
    void  ( * datafunc)(void * ,char * ,int );
    void  ( * attfunc)(void * ,char * ,int ,char * ,int );
};

struct _TP_POOL
{
};

struct _ACTIVATION_CONTEXT
{
};

struct _TP_CALLBACK_INSTANCE
{
};

struct _unnamed_52
{
    unsigned long LongFunction:1;
    unsigned long Persistent:1;
    unsigned long Private:30;
};

union _unnamed_53
{
    unsigned long Flags;
    struct _unnamed_52 s;
};

struct _TP_CALLBACK_ENVIRON_V3
{
    unsigned long Version;
    struct _TP_POOL * Pool;
    struct _TP_CLEANUP_GROUP * CleanupGroup;
    void  ( * CleanupGroupCancelCallback)(void * ,void * );
    void * RaceDll;
    struct _ACTIVATION_CONTEXT * ActivationContext;
    void  ( * FinalizationCallback)(struct _TP_CALLBACK_INSTANCE * ,void * );
    union _unnamed_53 u;
    enum _TP_CALLBACK_PRIORITY CallbackPriority;
    unsigned long Size;
};

struct UPNParg
{
    char * elt;
    char * val;
};

struct timespec
{
    int tv_sec;
    long tv_nsec;
};

struct IGDdatas
{
    char cureltname[128];
    char urlbase[128];
    char presentationurl[128];
    int level;
    struct IGDdatas_service CIF;
    struct IGDdatas_service first;
    struct IGDdatas_service second;
    struct IGDdatas_service IPv6FC;
    struct IGDdatas_service tmp;
};

union _unnamed_58
{
    unsigned int Byte[16];
    unsigned int Word[8];
};

struct in6_addr
{
    union _unnamed_58 u;
};

struct IGDdatas_service
{
    char controlurl[128];
    char eventsuburl[128];
    char scpdurl[128];
    char servicetype[128];
};

struct _OVERLAPPED
{
    unsigned long Internal;
    unsigned long InternalHigh;
    unsigned long Offset;
    unsigned long OffsetHigh;
    void * Pointer;
    void * hEvent;
};

struct __crt_locale_data_public
{
    unsigned int * _locale_pctype;
    int _locale_mb_cur_max;
    unsigned int _locale_lc_codepage;
};

struct SCOPE_ID
{
    unsigned long Zone:28;
    unsigned long Level:4;
    unsigned long Value;
};

struct _iobuf
{
    void * _Placeholder;
};

struct _timespec64
{
    int tv_sec;
    long tv_nsec;
};

struct __crt_locale_data
{
};

struct __crt_multibyte_data
{
};

struct __crt_locale_pointers
{
    struct __crt_locale_data * locinfo;
    struct __crt_multibyte_data * mbcinfo;
};

struct NameValueParserData
{
    struct NameValue * l_head;
    char curelt[64];
    char * portListing;
    int portListingLength;
    int topelt;
    char * cdata;
    int cdatalen;
};

struct xml_desc
{
    char * xml;
    int size;
    int is_igd;
};

enum portMappingElt
{
    PortMappingEltNone=0,
    PortMappingEntry=1,
    NewRemoteHost=2,
    NewExternalPort=3,
    NewProtocol=4,
    NewInternalPort=5,
    NewInternalClient=6,
    NewEnabled=7,
    NewDescription=8,
    NewLeaseTime=9
};

struct PortMappingParserData
{
    struct PortMapping * l_head;
    enum portMappingElt curelt;
};

struct PortMapping
{
    struct PortMapping * l_next;
    unsigned int leaseTime;
    unsigned int externalPort;
    unsigned int internalPort;
    char remoteHost[64];
    char internalClient[64];
    char description[64];
    char protocol[4];
    unsigned int enabled;
};

struct NameValue
{
    struct NameValue * l_next;
    char name[64];
    char value[128];
};

struct addrinfo
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    unsigned int ai_addrlen;
    char * ai_canonname;
    struct sockaddr * ai_addr;
    struct addrinfo * ai_next;
};

struct addrinfo
{
    int ai_flags;
    int ai_family;
    int ai_socktype;
    int ai_protocol;
    unsigned int ai_addrlen;
    char * ai_canonname;
    struct sockaddr * ai_addr;
    struct addrinfo * ai_next;
};

struct sockaddr
{
    unsigned int sa_family;
    char sa_data[14];
};

enum IPPROTO
{
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_IGMP=2,
    IPPROTO_GGP=3,
    IPPROTO_IPV4=4,
    IPPROTO_ST=5,
    IPPROTO_TCP=6,
    IPPROTO_CBT=7,
    IPPROTO_EGP=8,
    IPPROTO_IGP=9,
    IPPROTO_PUP=12,
    IPPROTO_UDP=17,
    IPPROTO_IDP=22,
    IPPROTO_RDP=27,
    IPPROTO_IPV6=41,
    IPPROTO_ROUTING=43,
    IPPROTO_FRAGMENT=44,
    IPPROTO_ESP=50,
    IPPROTO_AH=51,
    IPPROTO_ICMPV6=58,
    IPPROTO_NONE=59,
    IPPROTO_DSTOPTS=60,
    IPPROTO_ND=77,
    IPPROTO_ICLFXBM=78,
    IPPROTO_PIM=103,
    IPPROTO_PGM=113,
    IPPROTO_L2TP=115,
    IPPROTO_SCTP=132,
    IPPROTO_RAW=255,
    IPPROTO_MAX=256,
    IPPROTO_RESERVED_RAW=257,
    IPPROTO_RESERVED_IPSEC=258,
    IPPROTO_RESERVED_IPSECOFFLOAD=259,
    IPPROTO_RESERVED_MAX=260
};

enum NL_ROUTE_PROTOCOL
{
    RouteProtocolOther=1,
    RouteProtocolLocal=2,
    RouteProtocolNetMgmt=3,
    RouteProtocolIcmp=4,
    RouteProtocolEgp=5,
    RouteProtocolGgp=6,
    RouteProtocolHello=7,
    RouteProtocolRip=8,
    RouteProtocolIsIs=9,
    RouteProtocolEsIs=10,
    RouteProtocolCisco=11,
    RouteProtocolBbn=12,
    RouteProtocolOspf=13,
    RouteProtocolBgp=14,
    MIB_IPPROTO_OTHER=1,
    PROTO_IP_OTHER=1,
    MIB_IPPROTO_LOCAL=2,
    PROTO_IP_LOCAL=2,
    MIB_IPPROTO_NETMGMT=3,
    PROTO_IP_NETMGMT=3,
    MIB_IPPROTO_ICMP=4,
    PROTO_IP_ICMP=4,
    MIB_IPPROTO_EGP=5,
    PROTO_IP_EGP=5,
    MIB_IPPROTO_GGP=6,
    PROTO_IP_GGP=6,
    MIB_IPPROTO_HELLO=7,
    PROTO_IP_HELLO=7,
    MIB_IPPROTO_RIP=8,
    PROTO_IP_RIP=8,
    MIB_IPPROTO_IS_IS=9,
    PROTO_IP_IS_IS=9,
    MIB_IPPROTO_ES_IS=10,
    PROTO_IP_ES_IS=10,
    MIB_IPPROTO_CISCO=11,
    PROTO_IP_CISCO=11,
    MIB_IPPROTO_BBN=12,
    PROTO_IP_BBN=12,
    MIB_IPPROTO_OSPF=13,
    PROTO_IP_OSPF=13,
    MIB_IPPROTO_BGP=14,
    PROTO_IP_BGP=14,
    MIB_IPPROTO_NT_AUTOSTATIC=10002,
    PROTO_IP_NT_AUTOSTATIC=10002,
    MIB_IPPROTO_NT_STATIC=10006,
    PROTO_IP_NT_STATIC=10006,
    MIB_IPPROTO_NT_STATIC_NON_DOD=10007,
    PROTO_IP_NT_STATIC_NON_DOD=10007
};

enum MIB_IPFORWARD_TYPE
{
    MIB_IPROUTE_TYPE_OTHER=1,
    MIB_IPROUTE_TYPE_INVALID=2,
    MIB_IPROUTE_TYPE_DIRECT=3,
    MIB_IPROUTE_TYPE_INDIRECT=4
};

struct _MIB_IPFORWARDROW
{
    unsigned long dwForwardDest;
    unsigned long dwForwardMask;
    unsigned long dwForwardPolicy;
    unsigned long dwForwardNextHop;
    unsigned long dwForwardIfIndex;
    unsigned long dwForwardType;
    enum MIB_IPFORWARD_TYPE ForwardType;
    unsigned long dwForwardProto;
    enum NL_ROUTE_PROTOCOL ForwardProto;
    unsigned long dwForwardAge;
    unsigned long dwForwardNextHopAS;
    unsigned long dwForwardMetric1;
    unsigned long dwForwardMetric2;
    unsigned long dwForwardMetric3;
    unsigned long dwForwardMetric4;
    unsigned long dwForwardMetric5;
};

struct _MIB_IPADDRTABLE
{
    unsigned long dwNumEntries;
    struct _MIB_IPADDRROW_XP table[1];
};

struct _MIB_IPADDRROW_XP
{
    unsigned long dwAddr;
    unsigned long dwIndex;
    unsigned long dwMask;
    unsigned long dwBCastAddr;
    unsigned long dwReasmSize;
    unsigned int unused1;
    unsigned int wType;
};

struct sockaddr_in
{
    unsigned int sin_family;
    unsigned int sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
};

enum portMappingElt
{
    PortMappingEltNone=0,
    PortMappingEntry=1,
    NewRemoteHost=2,
    NewExternalPort=3,
    NewProtocol=4,
    NewInternalPort=5,
    NewInternalClient=6,
    NewEnabled=7,
    NewDescription=8,
    NewLeaseTime=9
};

struct _unnamed_86
{
    const enum portMappingElt code;
    const char * str;
};

struct _unnamed_87
{
    const enum portMappingElt code;
    const char * str;
};

struct fd_set
{
    unsigned int fd_count;
    unsigned int fd_array[64];
};

struct timeval
{
    long tv_sec;
    long tv_usec;
};

struct timeval
{
    long tv_sec;
    long tv_usec;
};

enum SFrameType
{
    FT_EMPTY=0,
    FT_SPRITE=1,
    FT_TEXT=2,
    FT_FIXTEXT=3,
    FT_BOX=4,
    FT_ANIM=5,
    FT_MINIMAP=6,
    FT_SCALER=7,
    FT_SPRITE_9SLICE=8,
    FT_FORCE_INT=2147483647
};

enum SDrawType
{
    DT_NORMAL=0,
    DT_ADD=1,
    DT_SHADOW=2
};

class SWidget
{
    public void SWidget(class SWidget & );
    public void SWidget();
    public void ~SWidget();
    public void GetPosition(int & ,int & ,int & ,int & );
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public bool OnKeyDown(int );
    public bool OnKeyUp(int );
    public bool OnChar(int );
    public void OnMouseDown(int ,int ,int ,int );
    public void OnMouseUp(int ,int ,int ,int );
    public void OnMouseMove(int ,int ,int );
    public void OnMouseWheel(int ,int ,int ,int );
    public void OnMouseOver();
    public void OnMouseOut();
    public void OnMove(int ,int );
    public void OnSize(int ,int );
    public bool OnAction(class SWidget * ,int ,int );
    public void OnUpdate();
    public void OnUserEvent(unsigned long ,unsigned int ,long );
    public void OnTimer(int ,unsigned long );
    public void InsertChild(class SWidget * );
    public void RemoveChild(class SWidget * );
    public class SWidget * GetEventTarget(int ,int ,int & ,int & );
    public void TranslateEventFromWindow(int & ,int & );
    public void ParentToChild(int & ,int & );
    public void ChildToParent(int & ,int & );
    public int GetCurrentCursor();
    public void GetWindowOrParentScalerPosition(int & ,int & ,float & );
    public class SWindow * GetWindowParent();
    public class SWidget * GetWindowOrScalerParent();
    public void CaptureMouse();
    public void ReleaseMouse();
    public bool HasMouseCaptured();
    public bool IsWindow();
    public bool IsScaler();
    public bool CanAcceptEvents();
    public void SetCursor(int );
    public int SetTimer(unsigned long );
    public void KillTimer(int & );
    public void SendAction(int ,int );
    public void SetFocus();
    public void ReleaseFocus();
    public class SWidget * GetKeyEventTarget();
    public int GetFrame();
    public void SetVisible(bool );
    public void SetEnable(bool );
    public void SetGravity(int );
    public void Update();
    public bool IsVisible();
    public bool IsEnabled();
    public class SWidget * GetParent();
    public void SetNavigation(class SWidget * ,class SWidget * ,class SWidget * ,class SWidget * );
    protected int X;
    protected int Y;
    protected class SWidget * LastMouseTarget;
    public const int Width;
    public const int Height;
    protected class SWidget * Parent;
    protected class SWidget * Child;
    protected class SWidget * Sibling;
    protected class SWidget * Focus;
    protected class SWidget * FocusSibling;
    protected class SWidget * Left;
    protected class SWidget * Right;
    protected class SWidget * Up;
    protected class SWidget * Down;
    protected bool Enabled;
    protected bool Visible;
    protected int Cursor;
    protected int Gravity;
    protected class SWidget * CaptureTarget;
    protected class SWidget * GetFocusTargetFromParam(int );
    protected class SWidget * GetFocusTargetFromKeyCode(int );
    private void SetMouseTarget();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SWidget
{
    public void SWidget(class SWidget & );
    public void SWidget();
    public void ~SWidget();
    public void GetPosition(int & ,int & ,int & ,int & );
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public bool OnKeyDown(int );
    public bool OnKeyUp(int );
    public bool OnChar(int );
    public void OnMouseDown(int ,int ,int ,int );
    public void OnMouseUp(int ,int ,int ,int );
    public void OnMouseMove(int ,int ,int );
    public void OnMouseWheel(int ,int ,int ,int );
    public void OnMouseOver();
    public void OnMouseOut();
    public void OnMove(int ,int );
    public void OnSize(int ,int );
    public bool OnAction(class SWidget * ,int ,int );
    public void OnUpdate();
    public void OnUserEvent(unsigned long ,unsigned int ,long );
    public void OnTimer(int ,unsigned long );
    public void InsertChild(class SWidget * );
    public void RemoveChild(class SWidget * );
    public class SWidget * GetEventTarget(int ,int ,int & ,int & );
    public void TranslateEventFromWindow(int & ,int & );
    public void ParentToChild(int & ,int & );
    public void ChildToParent(int & ,int & );
    public int GetCurrentCursor();
    public void GetWindowOrParentScalerPosition(int & ,int & ,float & );
    public class SWindow * GetWindowParent();
    public class SWidget * GetWindowOrScalerParent();
    public void CaptureMouse();
    public void ReleaseMouse();
    public bool HasMouseCaptured();
    public bool IsWindow();
    public bool IsScaler();
    public bool CanAcceptEvents();
    public void SetCursor(int );
    public int SetTimer(unsigned long );
    public void KillTimer(int & );
    public void SendAction(int ,int );
    public void SetFocus();
    public void ReleaseFocus();
    public class SWidget * GetKeyEventTarget();
    public int GetFrame();
    public void SetVisible(bool );
    public void SetEnable(bool );
    public void SetGravity(int );
    public void Update();
    public bool IsVisible();
    public bool IsEnabled();
    public class SWidget * GetParent();
    public void SetNavigation(class SWidget * ,class SWidget * ,class SWidget * ,class SWidget * );
    protected int X;
    protected int Y;
    protected class SWidget * LastMouseTarget;
    public const int Width;
    public const int Height;
    protected class SWidget * Parent;
    protected class SWidget * Child;
    protected class SWidget * Sibling;
    protected class SWidget * Focus;
    protected class SWidget * FocusSibling;
    protected class SWidget * Left;
    protected class SWidget * Right;
    protected class SWidget * Up;
    protected class SWidget * Down;
    protected bool Enabled;
    protected bool Visible;
    protected int Cursor;
    protected int Gravity;
    protected class SWidget * CaptureTarget;
    protected class SWidget * GetFocusTargetFromParam(int );
    protected class SWidget * GetFocusTargetFromKeyCode(int );
    private void SetMouseTarget();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SWindow : public SWidget
{
    public void SWindow(class SWindow & );
    public void SWindow();
    public void ~SWindow();
    public int Create(class SResource ,class SResource ,wchar_t * ,unsigned long ,class SWindow * ,bool );
    public int ProcessMessages();
    public void FlushMessages();
    public void SetPosition(int ,int ,int ,int );
    public struct HWND__ * operator struct HWND__ *();
    public bool IsWindow();
    public void RecordEvents(char * );
    public void PlaybackEvents(char * );
    public void CloseEventStream();
    public bool EventFrame();
    public void RegisterUserEventHandler(unsigned long ,class SWidget * );
    public bool RunModal(class SWidget * );
    public class SWidget * GetEventTarget(int ,int ,int & ,int & );
    public void UpdateMouse();
    public void RestrictMouseCursor(bool );
    public bool IsMouseCursorRestricted();
    public int GetDPI();
    public float GetScaling();
    public void GetLastMousePos(int & ,int & );
    protected void OnPaint(struct HDC__ * );
    protected void OnDestroy();
    protected void OnClose();
    protected bool OnIdle();
    protected int OnSetCursor();
    protected void OnDPIChange(struct tagRECT );
    protected void OnActivateApp(bool );
    protected int WindowProc(unsigned int ,unsigned int ,long );
    protected void UpdateMouseCursorRestriction();
    protected void SetWindowStyle(unsigned long );
    protected bool InitDPI();
    protected wchar_t ClassName[32];
    protected struct HWND__ * hWnd;
    protected unsigned long Style;
    protected int Index;
    protected int ModalResult;
    protected class SWidget * ModalTarget;
    protected class SStream * EventStream;
    protected int EventDirection;
    protected class SHeap<UserEventProp> UserEvents;
    protected int LastMouseX;
    protected int LastMouseY;
    protected int LastMouseButtons;
    protected bool MouseCursorRestricted;
    protected int Dpi;
    protected float Scaling;
    protected bool shouldClose;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SWindow : public SWidget
{
    public void SWindow(class SWindow & );
    public void SWindow();
    public void ~SWindow();
    public int Create(class SResource ,class SResource ,wchar_t * ,unsigned long ,class SWindow * ,bool );
    public int ProcessMessages();
    public void FlushMessages();
    public void SetPosition(int ,int ,int ,int );
    public struct HWND__ * operator struct HWND__ *();
    public bool IsWindow();
    public void RecordEvents(char * );
    public void PlaybackEvents(char * );
    public void CloseEventStream();
    public bool EventFrame();
    public void RegisterUserEventHandler(unsigned long ,class SWidget * );
    public bool RunModal(class SWidget * );
    public class SWidget * GetEventTarget(int ,int ,int & ,int & );
    public void UpdateMouse();
    public void RestrictMouseCursor(bool );
    public bool IsMouseCursorRestricted();
    public int GetDPI();
    public float GetScaling();
    public void GetLastMousePos(int & ,int & );
    protected void OnPaint(struct HDC__ * );
    protected void OnDestroy();
    protected void OnClose();
    protected bool OnIdle();
    protected int OnSetCursor();
    protected void OnDPIChange(struct tagRECT );
    protected void OnActivateApp(bool );
    protected int WindowProc(unsigned int ,unsigned int ,long );
    protected void UpdateMouseCursorRestriction();
    protected void SetWindowStyle(unsigned long );
    protected bool InitDPI();
    protected wchar_t ClassName[32];
    protected struct HWND__ * hWnd;
    protected unsigned long Style;
    protected int Index;
    protected int ModalResult;
    protected class SWidget * ModalTarget;
    protected class SStream * EventStream;
    protected int EventDirection;
    protected class SHeap<UserEventProp> UserEvents;
    protected int LastMouseX;
    protected int LastMouseY;
    protected int LastMouseButtons;
    protected bool MouseCursorRestricted;
    protected int Dpi;
    protected float Scaling;
    protected bool shouldClose;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SResource
{
    public int res_id;
    public void SResource(char * );
    public void SResource(int );
};

struct UserEventProp
{
    unsigned long Event;
    class SWidget * Handler;
};

class SHeap<UserEventProp>
{
    struct __Tstruct
    {
        int use;
        struct UserEventProp data;
    };
    private struct SHeap<UserEventProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<UserEventProp>();
    public void ~SHeap<UserEventProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct UserEventProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<UserEventProp>
{
    struct __Tstruct
    {
        int use;
        struct UserEventProp data;
    };
    private struct SHeap<UserEventProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<UserEventProp>();
    public void ~SHeap<UserEventProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct UserEventProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

enum HDMode
{
    Default=0,
    X2=1,
    FullHD=2,
    FullHD_Shift=3
};

class SVideoView : public SSkippableDXWidget
{
    private unsigned long LastUpdate;
    private int VideoFrame;
    private void ResizeVideoFrame();
    public void SVideoView(class SVideoView & );
    public void SVideoView();
    public void ~SVideoView();
    public bool Create(char * ,int ,bool );
    public void Update();
    public void SetPosition(int ,int ,int ,int );
    public void OnSize();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SVideoView : public SSkippableDXWidget
{
    private unsigned long LastUpdate;
    private int VideoFrame;
    private void ResizeVideoFrame();
    public void SVideoView(class SVideoView & );
    public void SVideoView();
    public void ~SVideoView();
    public bool Create(char * ,int ,bool );
    public void Update();
    public void SetPosition(int ,int ,int ,int );
    public void OnSize();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSkippableDXWidget : public SDXWidget
{
    public void SSkippableDXWidget(class SSkippableDXWidget & );
    public void SSkippableDXWidget();
    public void ~SSkippableDXWidget();
    public void Create(int ,bool );
    public void InsertSkipButton();
    public void Update();
    public bool OnAction(class SWidget * ,int ,int );
    public bool OnKeyDown(int );
    public void OnMouseDown(int ,int ,int ,int );
    public void OnMouseMove(int ,int ,int );
    protected int StartTick;
    protected int SkipVisibleTick;
    protected int ElapsedMs;
    protected const int SkipVisibleInterval;
    private class STextButton SkipButton;
    private int SkipAction;
    private bool ButtonMode;
    private void KickButton();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSkippableDXWidget : public SDXWidget
{
    public void SSkippableDXWidget(class SSkippableDXWidget & );
    public void SSkippableDXWidget();
    public void ~SSkippableDXWidget();
    public void Create(int ,bool );
    public void InsertSkipButton();
    public void Update();
    public bool OnAction(class SWidget * ,int ,int );
    public bool OnKeyDown(int );
    public void OnMouseDown(int ,int ,int ,int );
    public void OnMouseMove(int ,int ,int );
    protected int StartTick;
    protected int SkipVisibleTick;
    protected int ElapsedMs;
    protected const int SkipVisibleInterval;
    private class STextButton SkipButton;
    private int SkipAction;
    private bool ButtonMode;
    private void KickButton();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDXWidget : public SWidget
{
    protected int BackFrame;
    protected int BackFont;
    protected int BackGlyph;
    protected unsigned long BackColor;
    protected bool BackNoresize;
    protected bool Back9Slice;
    protected int TooltipTimer;
    protected int TooltipEndTimer;
    protected int TooltipBackFrame;
    protected int InnerBackFrame;
    protected int TooltipFrame;
    protected int TooltipFont;
    protected int TooltipFrameLeft;
    protected int TooltipFrameMiddle;
    protected int TooltipFrameRight;
    protected char TooltipText[260];
    protected int ToolTipTextWidth;
    protected int ToolTipTextHeight;
    protected bool ToolTipFeatureEnabled;
    public void SDXWidget(class SDXWidget & );
    public void SDXWidget();
    public void ~SDXWidget();
    public void SetBackgroundSprite(int ,int ,bool ,bool );
    public void SetDefaultBackgroundSprite();
    public void SetBackgroundColor(unsigned long );
    public void Create();
    public int GetFrame();
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public void SetVisible(bool );
    public void SetGravity(int );
    public int MessageBoxA(char * ,int );
    public void OnMouseDown(int ,int ,int ,int );
    public void OnMouseMove(int ,int ,int );
    public void OnTimer(int ,unsigned long );
    public void OnMouseOut();
    public void SetTooltipText(char * );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDXWidget : public SWidget
{
    protected int BackFrame;
    protected int BackFont;
    protected int BackGlyph;
    protected unsigned long BackColor;
    protected bool BackNoresize;
    protected bool Back9Slice;
    protected int TooltipTimer;
    protected int TooltipEndTimer;
    protected int TooltipBackFrame;
    protected int InnerBackFrame;
    protected int TooltipFrame;
    protected int TooltipFont;
    protected int TooltipFrameLeft;
    protected int TooltipFrameMiddle;
    protected int TooltipFrameRight;
    protected char TooltipText[260];
    protected int ToolTipTextWidth;
    protected int ToolTipTextHeight;
    protected bool ToolTipFeatureEnabled;
    public void SDXWidget(class SDXWidget & );
    public void SDXWidget();
    public void ~SDXWidget();
    public void SetBackgroundSprite(int ,int ,bool ,bool );
    public void SetDefaultBackgroundSprite();
    public void SetBackgroundColor(unsigned long );
    public void Create();
    public int GetFrame();
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public void SetVisible(bool );
    public void SetGravity(int );
    public int MessageBoxA(char * ,int );
    public void OnMouseDown(int ,int ,int ,int );
    public void OnMouseMove(int ,int ,int );
    public void OnTimer(int ,unsigned long );
    public void OnMouseOut();
    public void SetTooltipText(char * );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class STextButton : public SDXWidget
{
    private int Font;
    private int TextFrame;
    private int Align;
    private class SString Text;
    private unsigned long NormalColor;
    private unsigned long ActiveColor;
    private unsigned long DisabledColor;
    private bool Active;
    private bool Pressed;
    private bool Stuck;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private bool OnKeyDown(int );
    private void Update();
    public void STextButton(class STextButton & );
    public void STextButton();
    public void ~STextButton();
    public void Create(int ,int ,unsigned long ,unsigned long ,unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetStuck(bool );
    public void SetActive(bool );
    public bool isActive();
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class STextButton : public SDXWidget
{
    private int Font;
    private int TextFrame;
    private int Align;
    private class SString Text;
    private unsigned long NormalColor;
    private unsigned long ActiveColor;
    private unsigned long DisabledColor;
    private bool Active;
    private bool Pressed;
    private bool Stuck;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private bool OnKeyDown(int );
    private void Update();
    public void STextButton(class STextButton & );
    public void STextButton();
    public void ~STextButton();
    public void Create(int ,int ,unsigned long ,unsigned long ,unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetStuck(bool );
    public void SetActive(bool );
    public bool isActive();
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SIConcert
{
    public void AddRef();
    public void Release();
    public void SetListener(float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void Update(bool );
    public void SetVolume(int ,int );
    public void SetReverseStereo(bool );
    public int PrecacheSound(char * ,bool );
    public void AddRefToCachedSound(int );
    public void ReleaseCachedSound(int );
    public int CleanupSoundCache();
    public int CreateSound(char * ,float ,float );
    public int CreateSound(int ,float ,float );
    public int CreateSound(char * ,int ,float ,float ,float ,float );
    public int CreateSound(int ,int ,float ,float ,float ,float );
    public void RemoveSound(int );
    public void SetSoundPosition(int ,float ,float ,float );
    public void SetSoundFrequency(int ,unsigned long );
    public void SetSoundMinDistance(int ,float );
    public float PlaySound(char * ,float ,float ,int );
    public float PlaySound(int ,float ,float ,int );
    public float PlaySound(char * ,float ,float ,float ,float );
    public float PlaySound(int ,float ,float ,float ,float );
    public void StartStreamingPlayback(char * ,char * );
    public void StopStreamingPlayback();
    public bool CheckStreamPlayback();
    public void NextTrack();
    public void DumpChannels();
    public void SIConcert(class SIConcert * );
    public void SIConcert(class SIConcert & );
    public void SIConcert();
    public class SIConcert & operator=(class SIConcert * );
    public class SIConcert & operator=(class SIConcert & );
};

class SIConcert
{
    public void AddRef();
    public void Release();
    public void SetListener(float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void Update(bool );
    public void SetVolume(int ,int );
    public void SetReverseStereo(bool );
    public int PrecacheSound(char * ,bool );
    public void AddRefToCachedSound(int );
    public void ReleaseCachedSound(int );
    public int CleanupSoundCache();
    public int CreateSound(char * ,float ,float );
    public int CreateSound(int ,float ,float );
    public int CreateSound(char * ,int ,float ,float ,float ,float );
    public int CreateSound(int ,int ,float ,float ,float ,float );
    public void RemoveSound(int );
    public void SetSoundPosition(int ,float ,float ,float );
    public void SetSoundFrequency(int ,unsigned long );
    public void SetSoundMinDistance(int ,float );
    public float PlaySound(char * ,float ,float ,int );
    public float PlaySound(int ,float ,float ,int );
    public float PlaySound(char * ,float ,float ,float ,float );
    public float PlaySound(int ,float ,float ,float ,float );
    public void StartStreamingPlayback(char * ,char * );
    public void StopStreamingPlayback();
    public bool CheckStreamPlayback();
    public void NextTrack();
    public void DumpChannels();
    public void SIConcert(class SIConcert * );
    public void SIConcert(class SIConcert & );
    public void SIConcert();
    public class SIConcert & operator=(class SIConcert * );
    public class SIConcert & operator=(class SIConcert & );
};

enum TypeFace
{
    None=0,
    Pig=1,
    Rabbit=2,
    Small=3,
    Arial=4,
    ChineseSmall=5,
    ChineseRabbit=6,
    ChinesePig=7
};

enum FontEffect
{
    None=0,
    DropShadow=1,
    GlowDropShadow=2,
    PushedGlowDropShadow=3,
    Emboss=4
};

class SIBoard
{
    public int CreateFrame(enum SFrameType ,int ,int ,int ,int ,bool );
    public void DestroyFrame(int );
    public void MoveFrame(int ,int ,int );
    public void MoveFrameFloat(int ,float ,float );
    public void ResizeFrame(int ,int ,int );
    public void ShowFrame(int ,bool );
    public void GravitateFrame(int ,int );
    public void GetFrameSize(int ,int & ,int & );
    public void SetSpriteGlyph(int ,int ,int );
    public void SetSpriteSepiaFilter(int ,bool ,unsigned long );
    public void SetTextColor(int ,unsigned long );
    public void SetText(int ,int ,int ,char * );
    public void SetTextF(int ,int ,int ,char * ,<btNoType> );
    public void SetTextV(int ,int ,int ,char * ,char * );
    public void SetBoxColor(int ,unsigned long );
    public void StartAnim(int ,char * ,int ,int ,int );
    public void StopAnim(int );
    public bool IsAnimPlaying(int );
    public void SetMinimapFont(int ,int );
    public void SetMinimapRotation(int ,float );
    public float GetMinimapRotation(int );
    public void SetScaleFactor(int ,float );
    public void SetPixelRounding(bool );
    public int LoadProportionalFont(char * ,int ,int ,unsigned int * ,int ,int ,int ,int );
    public int LoadTrueTypeFont(int ,enum TypeFace ,enum FontEffect ,int ,bool ,bool );
    public int LoadFixedFont(char * ,int ,int ,int ,int ,unsigned int * ,enum HDMode );
    public int LoadCustomFont(char * ,int ,struct SCustomGlyph * ,enum HDMode );
    public int LoadSingleFont(char * ,enum HDMode );
    public void ReleaseFont(int );
    public int GetFontTexture(int );
    public float GetTextEffectiveScaleFactor(int );
    public void GetTextExtent(int ,char * ,int ,int & ,int & ,float );
    public void LoadCursorSet(float );
    public void UnloadCursorSet();
    public void SetCursor(int ,int ,int );
    public void ApplyHardwareCursor();
    public void SIBoard(class SIBoard * );
    public void SIBoard(class SIBoard & );
    public void SIBoard();
    public class SIBoard & operator=(class SIBoard * );
    public class SIBoard & operator=(class SIBoard & );
};

class SIBoard
{
    public int CreateFrame(enum SFrameType ,int ,int ,int ,int ,bool );
    public void DestroyFrame(int );
    public void MoveFrame(int ,int ,int );
    public void MoveFrameFloat(int ,float ,float );
    public void ResizeFrame(int ,int ,int );
    public void ShowFrame(int ,bool );
    public void GravitateFrame(int ,int );
    public void GetFrameSize(int ,int & ,int & );
    public void SetSpriteGlyph(int ,int ,int );
    public void SetSpriteSepiaFilter(int ,bool ,unsigned long );
    public void SetTextColor(int ,unsigned long );
    public void SetText(int ,int ,int ,char * );
    public void SetTextF(int ,int ,int ,char * ,<btNoType> );
    public void SetTextV(int ,int ,int ,char * ,char * );
    public void SetBoxColor(int ,unsigned long );
    public void StartAnim(int ,char * ,int ,int ,int );
    public void StopAnim(int );
    public bool IsAnimPlaying(int );
    public void SetMinimapFont(int ,int );
    public void SetMinimapRotation(int ,float );
    public float GetMinimapRotation(int );
    public void SetScaleFactor(int ,float );
    public void SetPixelRounding(bool );
    public int LoadProportionalFont(char * ,int ,int ,unsigned int * ,int ,int ,int ,int );
    public int LoadTrueTypeFont(int ,enum TypeFace ,enum FontEffect ,int ,bool ,bool );
    public int LoadFixedFont(char * ,int ,int ,int ,int ,unsigned int * ,enum HDMode );
    public int LoadCustomFont(char * ,int ,struct SCustomGlyph * ,enum HDMode );
    public int LoadSingleFont(char * ,enum HDMode );
    public void ReleaseFont(int );
    public int GetFontTexture(int );
    public float GetTextEffectiveScaleFactor(int );
    public void GetTextExtent(int ,char * ,int ,int & ,int & ,float );
    public void LoadCursorSet(float );
    public void UnloadCursorSet();
    public void SetCursor(int ,int ,int );
    public void ApplyHardwareCursor();
    public void SIBoard(class SIBoard * );
    public void SIBoard(class SIBoard & );
    public void SIBoard();
    public class SIBoard & operator=(class SIBoard * );
    public class SIBoard & operator=(class SIBoard & );
};

struct SCustomGlyph
{
    int X;
    int Y;
    int Width;
    int Height;
};

class SIGepard
{
    public void SetBoardVisibility(bool );
    public void SetResolution(int ,int );
    public void GetResolution(int & ,int & );
    public int getViewWidth();
    public int getViewHeight();
    public void AddRef();
    public void Release();
    public void CreateHill(struct SHillRing ** );
    public void SetMode(bool ,bool ,int ,int ,int );
    public void SetResolutionScale(float );
    public void Resize(unsigned long ,unsigned long );
    public void InitEditor();
    public void RenderScene(bool );
    public void RenderBoardOnly();
    public struct HBITMAP__ * RenderToWinBitmap(int ,int ,int );
    public unsigned int * RenderMinimap(int ,int );
    public void UpdateMinimap(int ,int ,int ,unsigned int * );
    public void MakeScreenshot(int ,int ,char * ,unsigned long );
    public void BackbufferScreenshot(char * );
    public void CreateScene();
    public void DestroyScene();
    public void SetPerspectiveProjection(float ,float ,float );
    public void SetOrthogonalProjection(float ,float ,float );
    public float GetFOV();
    public void SetViewProperties(float ,float ,float ,float ,float );
    public void CreateSpline(struct SHillRing * ,struct SSplineRing ** ,float ,int );
    public void GetSelectedNode(float ,float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void GetSelectedNode2(float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void SelectNode(struct SSplineRing * ,struct SNode * );
    public void SelectAllNode(struct SSplineRing * );
    public void DeselectAllNode(struct SSplineRing * );
    public void DeleteSelectedNodes(struct SHillRing * ,struct SSplineRing * );
    public void CloseSpline(struct SHillRing * );
    public void GetNodePosition(struct SSplineRing * ,int ,float * ,float * ,float * );
    public void MoveSplineNode(struct SHillRing * ,struct SSplineRing * ,struct SNode * ,float ,float ,float );
    public void SetTopSplineAltitude(struct SHillRing * ,float );
    public void SetTopSplineAltitude2(struct SHillRing * ,float );
    public float GetTopSplineAltitude(struct SHillRing * );
    public float GetTopSplineAltitude2(struct SHillRing * );
    public void DestroySpline(struct SHillRing * ,struct SSplineRing * );
    public void DestroyHill(struct SHillRing * );
    public void RecalculateCentralNodes(struct SHillRing * );
    public void SetSplineAltitude2(float ,struct SSplineRing * );
    public float GetSplineAltitude2(struct SSplineRing * );
    public void DrawLine(float ,float ,float ,float ,float ,float );
    public void SelectSplineRing(struct SSplineRing * );
    public void SelectHillRing(struct SHillRing * );
    public int GetCheckBoxNr(struct SSplineRing * );
    public void SetSplineVisibility(struct SSplineRing * ,bool );
    public bool GetSplineVisibility(struct SSplineRing * );
    public void JezusAtmentAVizenMiMiertNe();
    public void SetUpObjectEffects();
    public void SaveSplines(class SStream * ,bool );
    public void SaveSplinesSel(class SStream * );
    public void LoadSplines(class SStream * );
    public void LoadSplinesSel(class SStream * );
    public void DestroySplines();
    public void DoAltitude1(struct SHillRing * );
    public void DoAltitude2(struct SHillRing * );
    public void SetRiverSize(struct SHillRing * ,float );
    public float GetRiverSize(struct SHillRing * );
    public void GetSelections(struct SHillRing ** ,struct SSplineRing ** );
    public void RecalculateNodesAltitude();
    public void RecalculateControlPoints(struct SHillRing * );
    public void SetSplineSize(float ,struct SSplineRing * );
    public float GetSplineSize(struct SSplineRing * );
    public void BringToFront();
    public void SendToBack();
    public void RefreshShader(struct SShaderInfo * );
    public void RedrawHill(struct SHillRing * );
    public void ReleaseMesh(struct SHillRing * );
    public void SetSplineDisplay(bool );
    public void UpdateShaders();
    public void SaveShaders(class SStream * );
    public void LoadShaders(class SStream * );
    public void CopyShaders(class SDArray<SShaderClipboard> & ,int ,int ,int ,int );
    public void PasteShaders(class SDArray<SShaderClipboard> & ,int ,int );
    public struct SShaderInfo * CreateShader(float ,float ,int ,float ,int ,bool ,bool );
    public struct SShaderInfo * CreateShader(float ,float ,char * ,int ,bool ,bool );
    public struct SShader2Info * CreateShader2(float ,float ,int ,int ,enum SDrawType ,bool ,bool ,bool );
    public void MoveShader2(struct SShader2Info * ,float ,float ,bool );
    public void DestroyShader2(struct SShader2Info * );
    public struct SShaderInfo * GetIndexFromCoordinates(float ,float );
    public void SetSelectedShader(struct SShaderInfo * );
    public void DeleteSelectedShader();
    public bool IsShaderSelected();
    public void RotateShaderToLeft();
    public void RotateShaderToRight();
    public struct SShaderInfo * GetSelectedShader();
    public void RefreshHill(struct SHillRing * );
    public void AddNewSplineNode(struct SHillRing * ,float ,float ,float );
    public void AddToShaderFolderList(char * );
    public void ClearShaderFolderList();
    public void EnableFPS(bool ,int ,int );
    public bool GetFPSEnabled();
    public int GetDebugTextFrame();
    public void AdvanceTime(unsigned long ,unsigned long );
    public void SetInterpolation(float );
    public unsigned long GetAnimElapsedTime();
    public void TransformScreenToCamera(float & ,float & );
    public int CreateDirectionalLight(float ,float ,float ,float ,float ,float );
    public int CreatePointLight(float ,float ,float ,float ,float ,float ,float ,float );
    public void SetLightPosition(int ,float ,float ,float );
    public void DestroyLight(int );
    public void SetAmbientLight(float ,float ,float );
    public void SetBottomAmbientLight(float ,float ,float );
    public void SetSunLight(float ,float ,float ,float ,float );
    public void SetEnvironmentLight();
    public void SetFog(float ,float ,float ,float ,float );
    public void TransformScaledPointUi(float ,float ,float ,float ,float & ,float & ,float & );
    public int PrecacheObject(char * ,float ,enum SDrawType );
    public int CleanupObjectCache();
    public class SIObject * CreateObject(char * ,float ,bool );
    public class SIObject * CreateObject(int ,bool );
    public void ReplaceObject(class SIObject * ,char * ,float );
    public void ReplaceObject(class SIObject * ,int );
    public int GetShadowQuality();
    public void SetShadowQuality(int );
    public int GetMaxShadowQuality();
    public float GetShadowDistance();
    public void SetShadowDistance(float );
    public void SkipObjectShadowMask(class SIObject * ,class SStream * );
    public void GenerateAllShadowShaders();
    public class SIPlane * CreatePlane(int ,int );
    public void DestroyPlane();
    public int LoadTexture(char * ,bool ,bool );
    public void ReleaseTexture(int ,bool );
    public void SetTextureFilter(int );
    public int GetTextureFilter();
    public void SetTextureDetail(int );
    public int GetTextureDetail();
    public int CreateDynamicShader(int ,float ,float ,float ,unsigned long );
    public void RemoveDynamicShader(int );
    public void SetDynamicShaderPosition(int ,float ,float );
    public int CreateRect(unsigned long ,int ,int ,int ,int );
    public void RemoveRect(int );
    public void SetRectColor(int ,unsigned long );
    public void SetRectPosition(int ,int ,int ,int ,int );
    public void UpdateRects();
    public int CreateSmokeTrail(int ,float ,float ,float ,int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackSmokeTrail(int ,float ,float ,float ,float );
    public void CloseSmokeTrail(int );
    public int CreateGroundTrail(int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackGroundTrail(int ,float ,float ,float );
    public void CloseGroundTrail(int );
    public void RemoveGroundTrail(int );
    public int CreateLake(int ,float ,float ,float ,int ,int );
    public void RemoveLake(int );
    public void ChangeLakeHeight(int ,float );
    public void DrawLakesToWaterMap();
    public void SetTileset(int );
    public void ClearGlow();
    public void AddGlow(float ,float ,float ,int ,int ,int ,int ,float );
    public void TurnOnGlow();
    public void EgysegAlattiTalajKoszolas(float ,float ,int );
    public void CreateEffectsHandler();
    public void DestroyEffectsHandler();
    public int LoadEffect(char * ,char * );
    public void PlayEffect(int ,class SIObject * ,class SDArray<SAblak> * );
    public void PlayEffect(int ,class SIObject * ,char * ,int );
    public void * PlayEffect(int ,float ,float ,float ,float );
    public void PlayEffect(int ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void TrackEffect(void * ,float ,float ,float ,float );
    public void StopEffect(void * );
    public void RefreshIndices(void * );
    public void SetFullBright(bool );
    public float GetCameraHRot();
    public class SVector GetCameraForward();
    public int GetTileset();
    public int _izzo_robbanas_darabok;
    public int _izzo_robbanas_darabok2;
    public int _izzo_robbanas_darabok3;
    public int _shader_light;
    public int _shader_light_long;
    public int _becsapodas_anim_small;
    public int _becsapodas_anim_medium;
    public int _robbanas_anim;
    public int _robbanas_anim2;
    public int _robbanas_anim_fuel;
    public int _lovegtorony_robbanas_anim;
    public int _lovegtorony_robbanas_anim2;
    public int _lovegtorony_darabok;
    public int _nagy_robbanas_darabok;
    public int _tuzijatek_robbanas_anim;
    public int _tuzijatek_robbanas_anim2;
    public int _becsapodo_darab_nyom1;
    public int _becsapodo_darab_nyom2;
    public int _becsapodo_darab_nyom3;
    public int _becsapodo_darab_nyom4;
    public int _egyseg_alatti_talaj_koszolas1;
    public int _egyseg_alatti_talaj_koszolas2;
    public int _egyseg_alatti_talaj_koszolas3;
    public int _egyseg_alatti_talaj_koszolas_rabbit;
    public int _egyseg_alatti_talaj_koszolas_pig;
    public int _tankloves_alatti_talaj_koszolas1;
    public int _tankloves_alatti_talaj_koszolas2;
    public int _tankloves_alatti_talaj_koszolas3;
    public int _raketa_alatti_talaj_koszolas1;
    public int _raketa_alatti_talaj_koszolas2;
    public int _kis_robbanas_darabok;
    public int _rain;
    public int _snowfall;
    public int _tank_foldbeloves_particles;
    public int _tank_foldbeloves_kis_darabok;
    public int _raketas_foldbeloves_particles;
    public int _raketas_foldbeloves_kis_darabok;
    public int _raketas_foldbeloves_nagy_darabok;
    public int _becsapodas_fust;
    public int _rocket_boom;
    public int _rocket_boom2;
    public int _folyo;
    public int _folyo_csillogas;
    public int _gepfegyveres_kozepso_torkolattuz;
    public int _gepfegyveres_oldalso_torkolattuz;
    public int _loveg_torkolattuz;
    public int _tank_torkolattuz;
    public int _egysegfust_gyenge;
    public int _egysegfust_eros;
    public int _raketa_robbanas_talaj_feny;
    public int _torkolattuz_talaj_feny;
    public int _torkolattuz_talaj_feny2;
    public int _torkolat_fust;
    public int _heli_celfust;
    public int _normal_porzas;
    public int _desert_porzas;
    public int _rock_porzas;
    public int _a_foldbe_csapodo_darabok_fustje;
    public int _unit_reflektor;
    public int _lighting;
    public int _kis_kor;
    public int _bomba_lokeshullam;
    public int _uzemanyag_lokeshullam;
    public int _haz_fust;
    public int _haz_fust2;
    public int _haz_fust3;
    public int _glow;
    public int _szintlepes_csillagok;
    public int _szintlepes_csillagok2;
    public int _levelup_lens;
    public int _ablak_mozgas;
    public int _eryngo;
    public int _eryngo_porzas;
    public int _objektum_fust;
    public int _gray_texture;
    public struct SEXPLOSIONPARAMS _robbanastipusok[100];
    public float GlobalisSzelirany;
    public void SIGepard(class SIGepard * );
    public void SIGepard(class SIGepard & );
    public void SIGepard();
    public class SIGepard & operator=(class SIGepard * );
    public class SIGepard & operator=(class SIGepard & );
};

class SIGepard
{
    public void SetBoardVisibility(bool );
    public void SetResolution(int ,int );
    public void GetResolution(int & ,int & );
    public int getViewWidth();
    public int getViewHeight();
    public void AddRef();
    public void Release();
    public void CreateHill(struct SHillRing ** );
    public void SetMode(bool ,bool ,int ,int ,int );
    public void SetResolutionScale(float );
    public void Resize(unsigned long ,unsigned long );
    public void InitEditor();
    public void RenderScene(bool );
    public void RenderBoardOnly();
    public struct HBITMAP__ * RenderToWinBitmap(int ,int ,int );
    public unsigned int * RenderMinimap(int ,int );
    public void UpdateMinimap(int ,int ,int ,unsigned int * );
    public void MakeScreenshot(int ,int ,char * ,unsigned long );
    public void BackbufferScreenshot(char * );
    public void CreateScene();
    public void DestroyScene();
    public void SetPerspectiveProjection(float ,float ,float );
    public void SetOrthogonalProjection(float ,float ,float );
    public float GetFOV();
    public void SetViewProperties(float ,float ,float ,float ,float );
    public void CreateSpline(struct SHillRing * ,struct SSplineRing ** ,float ,int );
    public void GetSelectedNode(float ,float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void GetSelectedNode2(float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void SelectNode(struct SSplineRing * ,struct SNode * );
    public void SelectAllNode(struct SSplineRing * );
    public void DeselectAllNode(struct SSplineRing * );
    public void DeleteSelectedNodes(struct SHillRing * ,struct SSplineRing * );
    public void CloseSpline(struct SHillRing * );
    public void GetNodePosition(struct SSplineRing * ,int ,float * ,float * ,float * );
    public void MoveSplineNode(struct SHillRing * ,struct SSplineRing * ,struct SNode * ,float ,float ,float );
    public void SetTopSplineAltitude(struct SHillRing * ,float );
    public void SetTopSplineAltitude2(struct SHillRing * ,float );
    public float GetTopSplineAltitude(struct SHillRing * );
    public float GetTopSplineAltitude2(struct SHillRing * );
    public void DestroySpline(struct SHillRing * ,struct SSplineRing * );
    public void DestroyHill(struct SHillRing * );
    public void RecalculateCentralNodes(struct SHillRing * );
    public void SetSplineAltitude2(float ,struct SSplineRing * );
    public float GetSplineAltitude2(struct SSplineRing * );
    public void DrawLine(float ,float ,float ,float ,float ,float );
    public void SelectSplineRing(struct SSplineRing * );
    public void SelectHillRing(struct SHillRing * );
    public int GetCheckBoxNr(struct SSplineRing * );
    public void SetSplineVisibility(struct SSplineRing * ,bool );
    public bool GetSplineVisibility(struct SSplineRing * );
    public void JezusAtmentAVizenMiMiertNe();
    public void SetUpObjectEffects();
    public void SaveSplines(class SStream * ,bool );
    public void SaveSplinesSel(class SStream * );
    public void LoadSplines(class SStream * );
    public void LoadSplinesSel(class SStream * );
    public void DestroySplines();
    public void DoAltitude1(struct SHillRing * );
    public void DoAltitude2(struct SHillRing * );
    public void SetRiverSize(struct SHillRing * ,float );
    public float GetRiverSize(struct SHillRing * );
    public void GetSelections(struct SHillRing ** ,struct SSplineRing ** );
    public void RecalculateNodesAltitude();
    public void RecalculateControlPoints(struct SHillRing * );
    public void SetSplineSize(float ,struct SSplineRing * );
    public float GetSplineSize(struct SSplineRing * );
    public void BringToFront();
    public void SendToBack();
    public void RefreshShader(struct SShaderInfo * );
    public void RedrawHill(struct SHillRing * );
    public void ReleaseMesh(struct SHillRing * );
    public void SetSplineDisplay(bool );
    public void UpdateShaders();
    public void SaveShaders(class SStream * );
    public void LoadShaders(class SStream * );
    public void CopyShaders(class SDArray<SShaderClipboard> & ,int ,int ,int ,int );
    public void PasteShaders(class SDArray<SShaderClipboard> & ,int ,int );
    public struct SShaderInfo * CreateShader(float ,float ,int ,float ,int ,bool ,bool );
    public struct SShaderInfo * CreateShader(float ,float ,char * ,int ,bool ,bool );
    public struct SShader2Info * CreateShader2(float ,float ,int ,int ,enum SDrawType ,bool ,bool ,bool );
    public void MoveShader2(struct SShader2Info * ,float ,float ,bool );
    public void DestroyShader2(struct SShader2Info * );
    public struct SShaderInfo * GetIndexFromCoordinates(float ,float );
    public void SetSelectedShader(struct SShaderInfo * );
    public void DeleteSelectedShader();
    public bool IsShaderSelected();
    public void RotateShaderToLeft();
    public void RotateShaderToRight();
    public struct SShaderInfo * GetSelectedShader();
    public void RefreshHill(struct SHillRing * );
    public void AddNewSplineNode(struct SHillRing * ,float ,float ,float );
    public void AddToShaderFolderList(char * );
    public void ClearShaderFolderList();
    public void EnableFPS(bool ,int ,int );
    public bool GetFPSEnabled();
    public int GetDebugTextFrame();
    public void AdvanceTime(unsigned long ,unsigned long );
    public void SetInterpolation(float );
    public unsigned long GetAnimElapsedTime();
    public void TransformScreenToCamera(float & ,float & );
    public int CreateDirectionalLight(float ,float ,float ,float ,float ,float );
    public int CreatePointLight(float ,float ,float ,float ,float ,float ,float ,float );
    public void SetLightPosition(int ,float ,float ,float );
    public void DestroyLight(int );
    public void SetAmbientLight(float ,float ,float );
    public void SetBottomAmbientLight(float ,float ,float );
    public void SetSunLight(float ,float ,float ,float ,float );
    public void SetEnvironmentLight();
    public void SetFog(float ,float ,float ,float ,float );
    public void TransformScaledPointUi(float ,float ,float ,float ,float & ,float & ,float & );
    public int PrecacheObject(char * ,float ,enum SDrawType );
    public int CleanupObjectCache();
    public class SIObject * CreateObject(char * ,float ,bool );
    public class SIObject * CreateObject(int ,bool );
    public void ReplaceObject(class SIObject * ,char * ,float );
    public void ReplaceObject(class SIObject * ,int );
    public int GetShadowQuality();
    public void SetShadowQuality(int );
    public int GetMaxShadowQuality();
    public float GetShadowDistance();
    public void SetShadowDistance(float );
    public void SkipObjectShadowMask(class SIObject * ,class SStream * );
    public void GenerateAllShadowShaders();
    public class SIPlane * CreatePlane(int ,int );
    public void DestroyPlane();
    public int LoadTexture(char * ,bool ,bool );
    public void ReleaseTexture(int ,bool );
    public void SetTextureFilter(int );
    public int GetTextureFilter();
    public void SetTextureDetail(int );
    public int GetTextureDetail();
    public int CreateDynamicShader(int ,float ,float ,float ,unsigned long );
    public void RemoveDynamicShader(int );
    public void SetDynamicShaderPosition(int ,float ,float );
    public int CreateRect(unsigned long ,int ,int ,int ,int );
    public void RemoveRect(int );
    public void SetRectColor(int ,unsigned long );
    public void SetRectPosition(int ,int ,int ,int ,int );
    public void UpdateRects();
    public int CreateSmokeTrail(int ,float ,float ,float ,int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackSmokeTrail(int ,float ,float ,float ,float );
    public void CloseSmokeTrail(int );
    public int CreateGroundTrail(int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackGroundTrail(int ,float ,float ,float );
    public void CloseGroundTrail(int );
    public void RemoveGroundTrail(int );
    public int CreateLake(int ,float ,float ,float ,int ,int );
    public void RemoveLake(int );
    public void ChangeLakeHeight(int ,float );
    public void DrawLakesToWaterMap();
    public void SetTileset(int );
    public void ClearGlow();
    public void AddGlow(float ,float ,float ,int ,int ,int ,int ,float );
    public void TurnOnGlow();
    public void EgysegAlattiTalajKoszolas(float ,float ,int );
    public void CreateEffectsHandler();
    public void DestroyEffectsHandler();
    public int LoadEffect(char * ,char * );
    public void PlayEffect(int ,class SIObject * ,class SDArray<SAblak> * );
    public void PlayEffect(int ,class SIObject * ,char * ,int );
    public void * PlayEffect(int ,float ,float ,float ,float );
    public void PlayEffect(int ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void TrackEffect(void * ,float ,float ,float ,float );
    public void StopEffect(void * );
    public void RefreshIndices(void * );
    public void SetFullBright(bool );
    public float GetCameraHRot();
    public class SVector GetCameraForward();
    public int GetTileset();
    public int _izzo_robbanas_darabok;
    public int _izzo_robbanas_darabok2;
    public int _izzo_robbanas_darabok3;
    public int _shader_light;
    public int _shader_light_long;
    public int _becsapodas_anim_small;
    public int _becsapodas_anim_medium;
    public int _robbanas_anim;
    public int _robbanas_anim2;
    public int _robbanas_anim_fuel;
    public int _lovegtorony_robbanas_anim;
    public int _lovegtorony_robbanas_anim2;
    public int _lovegtorony_darabok;
    public int _nagy_robbanas_darabok;
    public int _tuzijatek_robbanas_anim;
    public int _tuzijatek_robbanas_anim2;
    public int _becsapodo_darab_nyom1;
    public int _becsapodo_darab_nyom2;
    public int _becsapodo_darab_nyom3;
    public int _becsapodo_darab_nyom4;
    public int _egyseg_alatti_talaj_koszolas1;
    public int _egyseg_alatti_talaj_koszolas2;
    public int _egyseg_alatti_talaj_koszolas3;
    public int _egyseg_alatti_talaj_koszolas_rabbit;
    public int _egyseg_alatti_talaj_koszolas_pig;
    public int _tankloves_alatti_talaj_koszolas1;
    public int _tankloves_alatti_talaj_koszolas2;
    public int _tankloves_alatti_talaj_koszolas3;
    public int _raketa_alatti_talaj_koszolas1;
    public int _raketa_alatti_talaj_koszolas2;
    public int _kis_robbanas_darabok;
    public int _rain;
    public int _snowfall;
    public int _tank_foldbeloves_particles;
    public int _tank_foldbeloves_kis_darabok;
    public int _raketas_foldbeloves_particles;
    public int _raketas_foldbeloves_kis_darabok;
    public int _raketas_foldbeloves_nagy_darabok;
    public int _becsapodas_fust;
    public int _rocket_boom;
    public int _rocket_boom2;
    public int _folyo;
    public int _folyo_csillogas;
    public int _gepfegyveres_kozepso_torkolattuz;
    public int _gepfegyveres_oldalso_torkolattuz;
    public int _loveg_torkolattuz;
    public int _tank_torkolattuz;
    public int _egysegfust_gyenge;
    public int _egysegfust_eros;
    public int _raketa_robbanas_talaj_feny;
    public int _torkolattuz_talaj_feny;
    public int _torkolattuz_talaj_feny2;
    public int _torkolat_fust;
    public int _heli_celfust;
    public int _normal_porzas;
    public int _desert_porzas;
    public int _rock_porzas;
    public int _a_foldbe_csapodo_darabok_fustje;
    public int _unit_reflektor;
    public int _lighting;
    public int _kis_kor;
    public int _bomba_lokeshullam;
    public int _uzemanyag_lokeshullam;
    public int _haz_fust;
    public int _haz_fust2;
    public int _haz_fust3;
    public int _glow;
    public int _szintlepes_csillagok;
    public int _szintlepes_csillagok2;
    public int _levelup_lens;
    public int _ablak_mozgas;
    public int _eryngo;
    public int _eryngo_porzas;
    public int _objektum_fust;
    public int _gray_texture;
    public struct SEXPLOSIONPARAMS _robbanastipusok[100];
    public float GlobalisSzelirany;
    public void SIGepard(class SIGepard * );
    public void SIGepard(class SIGepard & );
    public void SIGepard();
    public class SIGepard & operator=(class SIGepard * );
    public class SIGepard & operator=(class SIGepard & );
};

struct SHillRing
{
    struct SHillRing * prev;
    struct SHillRing * next;
    class SChain<SSplineRing> * SplineChain;
    int Type;
    bool WaterEnabled;
    float RiverSize;
    class SMesh * HillMesh;
    class SMesh * HillMesh2;
};

struct SSplineRing
{
    struct SSplineRing * prev;
    struct SSplineRing * next;
    class SSpline * spline;
};

struct SShaderInfo
{
    struct SShaderInfo * next;
    struct SShaderInfo * prev;
    char filename[120];
    float xpos;
    float zpos;
    class SMesh * mesh;
    int ShaderTHandle;
    int XVertices;
    int ZVertices;
    int Rotation;
};

struct SRCOLOR
{
    float r;
    float g;
    float b;
};

struct SShader2Info
{
    struct SShader2Info * next;
    struct SShader2Info * prev;
    float xpos;
    float zpos;
    class SMesh * mesh;
    int ShaderTHandle;
    int XVertices;
    int ZVertices;
    enum SDrawType DrawType;
    float Erosseg;
    float R;
    float G;
    float B;
    bool ForceBright;
    struct SRCOLOR * vertexlight;
};

struct SEXPLOSIONPARAMS
{
    int index;
    int hangindex;
    int fust;
};

enum <unnamed-enum-GCR_OK>
{
    GCR_OK=0,
    GCR_NO_DIRECT3D9=1,
    GCR_DIRECT3D_INTERNAL=2,
    GCR_DEVICE_INITIALIZATION=3,
    GCR_TEXTURE_SIZE=4
};

class SFileSystem
{
    private char * BasePath;
    private char AppDataPath[260];
    private class SDArray<SSearchPath> SearchPaths;
    public void SFileSystem(class SFileSystem & );
    public void SFileSystem();
    public void ~SFileSystem();
    public void SetGameDataPath(char * );
    public char * GetGameDataPath();
    public class SStream * OpenRead(char * ,char * );
    public class SStream * OpenWrite(char * ,char * );
    public class SStream * OpenAppend(char * ,char * );
    public bool IsFullPath(char * );
    public char * FindFileInSearchPath(char * );
    public void FindFiles(char * ,char * ,class SDArray<SString> & );
    public char * MakeFullPath(char * );
    public char * MakeAppDataPath(char * );
    public void ReadFile(char * ,char &** ,unsigned int & ,char * );
    public bool GenerateFileCRC(char * ,unsigned long & ,char * );
    public unsigned long GetCRC(unsigned int * ,int );
    public void AddSearchPath(char * );
    public void RemoveAllSearchPaths();
    public struct SArchiveInfo & OpenArchive(char * );
    public void MakePath(class SString );
    public int Stat(char * ,struct stat * );
    public class SFileSystem & operator=(class SFileSystem & );
    public void * __vecDelDtor(unsigned int );
};

enum <unnamed-enum-LITE_AMBIENT_HUE>
{
    LITE_AMBIENT_HUE=0,
    LITE_AMBIENT_SAT=1,
    LITE_AMBIENT_VAL=2,
    LITE_SUN_HUE=3,
    LITE_SUN_SAT=4,
    LITE_SUN_VAL=5,
    LITE_SUN_DIR=6,
    LITE_SUN_ELEV=7,
    LITE_FOG_HUE=8,
    LITE_FOG_SAT=9,
    LITE_FOG_VAL=10,
    LITE_FOG_START=11,
    LITE_FOG_END=12,
    LITE_FX_RAIN=13,
    LITE_FX_THUNDER=14,
    LITE_FX_SNOWFALL=15,
    LITE_FX_NIGHT=16,
    LITE_ARRAYSIZE_OLD=17,
    LITE_BOTTOM_AMBIENT_HUE=17,
    LITE_BOTTOM_AMBIENT_SAT=18,
    LITE_BOTTOM_AMBIENT_VAL=19,
    LITE_ARRAYSIZE=20
};

enum <unnamed-enum-VOLUME_MUSIC>
{
    VOLUME_MUSIC=0,
    VOLUME_SFX=1,
    VOLUME_VOICE=2
};

enum ConnectionManagerMessageId
{
    ID_UNUSED_ID=134,
    ID_CMAN_USER_PACKET_ENUM=135
};

enum SAchievementID
{
    ACH_COMPLETE_PIG_CAMPAIGN=0,
    ACH_COMPLETE_RABBIT_CAMPAIGN=1,
    ACH_DESTROY_1000_PIG_UNITS=2,
    ACH_DESTROY_1000_RABBIT_UNITS=3,
    ACH_DESTROY_100_UNITS_WITH_MINES=4,
    ACH_REACH_MAX_RANK_WITH_UNIT=5,
    ACH_HAVE_UNIT_SURVIVE_ENTIRE_CAMPAIGN=6,
    ACH_1_UNIT_DESTROY_100_UNITS_IN_CAMPAIGN=7,
    ACH_DESTROY_DUG_IN_WITH_MORTAR=8,
    ACH_DESTROY_ELITE_WITH_STANDARD=9,
    ACH_COMPLETE_MISSION_WITH_ONLY_MORTAR=10,
    ACH_DESTROY_UNIT_IN_FOW=11,
    ACH_GET_HIT_BY_UNIT_IN_FOW=12,
    ACH_GET_UNIT_WITH_AIRDROP=13,
    ACH_DESTROY_3_UNITS_WITH_1_AIR_STRIKE=14,
    ACH_LOAD_3_TIMES_IN_A_MISSION=15,
    ACH_HAVE_3_EQUIPMENTS_FOR_1_UNIT=16,
    ACH_CAPTURE_ENEMY_TRAILER=17,
    ACH_WATCH_CREDITS=18,
    ACH_REACH_HUGE_XP_WITH_1_UNIT=19,
    ACH_REACH_HUGE_XP_WITH_3_UNIT=20,
    ACH_REACH_HUGE_XP_WITH_5_UNIT=21,
    ACH_REACH_HUGE_XP_WITH_10_UNIT=22
};

enum PacketPriority
{
    IMMEDIATE_PRIORITY=0,
    HIGH_PRIORITY=1,
    MEDIUM_PRIORITY=2,
    LOW_PRIORITY=3,
    NUMBER_OF_PRIORITIES=4
};

enum SFollowMode
{
    FOLLOW_NORMAL=0,
    FOLLOW_ATTACK=1,
    FOLLOW_RETREAT=2
};

struct RakNet::SystemAddress
{
    void SystemAddress(char * ,unsigned int );
    void SystemAddress(char * );
    void SystemAddress();
    union <unnamed-type-address>
    {
        struct sockaddr_in addr4;
    };
    union RakNet::SystemAddress::<unnamed-type-address> address;
    unsigned int debugPort;
    int size();
    unsigned long ToInteger(struct RakNet::SystemAddress & );
    unsigned int GetIPVersion();
    unsigned int GetIPPROTO();
    void SetToLoopback(unsigned int );
    void SetToLoopback();
    bool IsLoopback();
    void ToString(bool ,char * ,char );
    char * ToString(bool ,char );
    bool FromString(char * ,char ,int );
    bool FromStringExplicitPort(char * ,unsigned int ,int );
    void CopyPort(struct RakNet::SystemAddress & );
    bool EqualsExcludingPort(struct RakNet::SystemAddress & );
    unsigned int GetPort();
    unsigned int GetPortNetworkOrder();
    void SetPortHostOrder(unsigned int );
    void SetPortNetworkOrder(unsigned int );
    bool SetBinaryAddress(char * ,char );
    void ToString_Old(bool ,char * ,char );
    void FixForIPVersion(struct RakNet::SystemAddress & );
    bool IsLANAddress();
    struct RakNet::SystemAddress & operator=(struct RakNet::SystemAddress & );
    bool operator==(struct RakNet::SystemAddress & );
    bool operator!=(struct RakNet::SystemAddress & );
    bool operator>(struct RakNet::SystemAddress & );
    bool operator<(struct RakNet::SystemAddress & );
    unsigned int systemIndex;
};

struct RakNet::SystemAddress
{
    void SystemAddress(char * ,unsigned int );
    void SystemAddress(char * );
    void SystemAddress();
    union <unnamed-type-address>
    {
        struct sockaddr_in addr4;
    };
    union RakNet::SystemAddress::<unnamed-type-address> address;
    unsigned int debugPort;
    int size();
    unsigned long ToInteger(struct RakNet::SystemAddress & );
    unsigned int GetIPVersion();
    unsigned int GetIPPROTO();
    void SetToLoopback(unsigned int );
    void SetToLoopback();
    bool IsLoopback();
    void ToString(bool ,char * ,char );
    char * ToString(bool ,char );
    bool FromString(char * ,char ,int );
    bool FromStringExplicitPort(char * ,unsigned int ,int );
    void CopyPort(struct RakNet::SystemAddress & );
    bool EqualsExcludingPort(struct RakNet::SystemAddress & );
    unsigned int GetPort();
    unsigned int GetPortNetworkOrder();
    void SetPortHostOrder(unsigned int );
    void SetPortNetworkOrder(unsigned int );
    bool SetBinaryAddress(char * ,char );
    void ToString_Old(bool ,char * ,char );
    void FixForIPVersion(struct RakNet::SystemAddress & );
    bool IsLANAddress();
    struct RakNet::SystemAddress & operator=(struct RakNet::SystemAddress & );
    bool operator==(struct RakNet::SystemAddress & );
    bool operator!=(struct RakNet::SystemAddress & );
    bool operator>(struct RakNet::SystemAddress & );
    bool operator<(struct RakNet::SystemAddress & );
    unsigned int systemIndex;
};

struct RakNet::RakNetGUID
{
    void RakNetGUID(unsigned int );
    void RakNetGUID();
    unsigned int g;
    void ToString(char * );
    char * ToString();
    bool FromString(char * );
    unsigned long ToUint32(struct RakNet::RakNetGUID & );
    struct RakNet::RakNetGUID & operator=(struct RakNet::RakNetGUID & );
    unsigned int systemIndex;
    int size();
    bool operator==(struct RakNet::RakNetGUID & );
    bool operator!=(struct RakNet::RakNetGUID & );
    bool operator>(struct RakNet::RakNetGUID & );
    bool operator<(struct RakNet::RakNetGUID & );
};

struct RakNet::RakNetGUID
{
    void RakNetGUID(unsigned int );
    void RakNetGUID();
    unsigned int g;
    void ToString(char * );
    char * ToString();
    bool FromString(char * );
    unsigned long ToUint32(struct RakNet::RakNetGUID & );
    struct RakNet::RakNetGUID & operator=(struct RakNet::RakNetGUID & );
    unsigned int systemIndex;
    int size();
    bool operator==(struct RakNet::RakNetGUID & );
    bool operator!=(struct RakNet::RakNetGUID & );
    bool operator>(struct RakNet::RakNetGUID & );
    bool operator<(struct RakNet::RakNetGUID & );
};

enum <unnamed-enum-CAMP_LOAD_BRIEFING>
{
    CAMP_LOAD_BRIEFING=0,
    CAMP_LOAD_MARKET=1,
    CAMP_LOAD_MAP=2,
    CAMP_LOAD_RESULTS=3,
    CAMP_LOAD_MULTI=4,
    CAMP_LOAD_MAIN=5,
    CAMP_LOAD_ANIM_CREDITS=6,
    CAMP_LOAD_ANIM_PRE_INTRO=7,
    CAMP_LOAD_ANIM_INTRO=8,
    CAMP_LOAD_ANIM_OUTRO=9,
    CAMP_LOAD_ANIM_DEFEAT=10
};

enum SHorizontalAlign
{
    ALIGN_LEFT=0,
    ALIGN_RIGHT=1,
    ALIGN_CENTER=2
};

enum <unnamed-enum-SMALL_FONT>
{
    SMALL_FONT=0,
    SMALL_FONT_HL=1,
    SMALL_FONT_PUSHED=2,
    CREDITS_TITLE_FONT=3,
    CREDITS_NAME_FONT=4,
    PANEL_BACKGROUND_FONT=5,
    MEDIUM_TEXT_FONT=6,
    MEDIUM_TEXT_FONT_HL=7,
    MEDIUM_TEXT_FONT_PUSHED=8,
    MEDIUM_BUTTON_FONT=9,
    MEDIUM_BUTTON_FONT_HL=10,
    MEDIUM_BUTTON_FONT_PUSHED=11,
    LARGE_FONT=12,
    LARGE_FONT_HL=13,
    LARGE_FONT_PUSHED=14,
    HEADER_FONT=15
};

enum <unnamed-enum-RACE_RABBIT>
{
    RACE_RABBIT=0,
    RACE_PIG=1
};

enum SwineLanguage
{
    English=0,
    German=1,
    French=2,
    Hungarian=3,
    Czech=4,
    Spanish=5,
    Italian=6,
    Russian=7,
    Chinese=8
};

enum DefaultMessageIDTypes
{
    ID_CONNECTED_PING=0,
    ID_UNCONNECTED_PING=1,
    ID_UNCONNECTED_PING_OPEN_CONNECTIONS=2,
    ID_CONNECTED_PONG=3,
    ID_DETECT_LOST_CONNECTIONS=4,
    ID_OPEN_CONNECTION_REQUEST_1=5,
    ID_OPEN_CONNECTION_REPLY_1=6,
    ID_OPEN_CONNECTION_REQUEST_2=7,
    ID_OPEN_CONNECTION_REPLY_2=8,
    ID_CONNECTION_REQUEST=9,
    ID_REMOTE_SYSTEM_REQUIRES_PUBLIC_KEY=10,
    ID_OUR_SYSTEM_REQUIRES_SECURITY=11,
    ID_PUBLIC_KEY_MISMATCH=12,
    ID_OUT_OF_BAND_INTERNAL=13,
    ID_SND_RECEIPT_ACKED=14,
    ID_SND_RECEIPT_LOSS=15,
    ID_CONNECTION_REQUEST_ACCEPTED=16,
    ID_CONNECTION_ATTEMPT_FAILED=17,
    ID_ALREADY_CONNECTED=18,
    ID_NEW_INCOMING_CONNECTION=19,
    ID_NO_FREE_INCOMING_CONNECTIONS=20,
    ID_DISCONNECTION_NOTIFICATION=21,
    ID_CONNECTION_LOST=22,
    ID_CONNECTION_BANNED=23,
    ID_INVALID_PASSWORD=24,
    ID_INCOMPATIBLE_PROTOCOL_VERSION=25,
    ID_IP_RECENTLY_CONNECTED=26,
    ID_TIMESTAMP=27,
    ID_UNCONNECTED_PONG=28,
    ID_ADVERTISE_SYSTEM=29,
    ID_DOWNLOAD_PROGRESS=30,
    ID_REMOTE_DISCONNECTION_NOTIFICATION=31,
    ID_REMOTE_CONNECTION_LOST=32,
    ID_REMOTE_NEW_INCOMING_CONNECTION=33,
    ID_FILE_LIST_TRANSFER_HEADER=34,
    ID_FILE_LIST_TRANSFER_FILE=35,
    ID_FILE_LIST_REFERENCE_PUSH_ACK=36,
    ID_DDT_DOWNLOAD_REQUEST=37,
    ID_TRANSPORT_STRING=38,
    ID_REPLICA_MANAGER_CONSTRUCTION=39,
    ID_REPLICA_MANAGER_SCOPE_CHANGE=40,
    ID_REPLICA_MANAGER_SERIALIZE=41,
    ID_REPLICA_MANAGER_DOWNLOAD_STARTED=42,
    ID_REPLICA_MANAGER_DOWNLOAD_COMPLETE=43,
    ID_RAKVOICE_OPEN_CHANNEL_REQUEST=44,
    ID_RAKVOICE_OPEN_CHANNEL_REPLY=45,
    ID_RAKVOICE_CLOSE_CHANNEL=46,
    ID_RAKVOICE_DATA=47,
    ID_AUTOPATCHER_GET_CHANGELIST_SINCE_DATE=48,
    ID_AUTOPATCHER_CREATION_LIST=49,
    ID_AUTOPATCHER_DELETION_LIST=50,
    ID_AUTOPATCHER_GET_PATCH=51,
    ID_AUTOPATCHER_PATCH_LIST=52,
    ID_AUTOPATCHER_REPOSITORY_FATAL_ERROR=53,
    ID_AUTOPATCHER_CANNOT_DOWNLOAD_ORIGINAL_UNMODIFIED_FILES=54,
    ID_AUTOPATCHER_FINISHED_INTERNAL=55,
    ID_AUTOPATCHER_FINISHED=56,
    ID_AUTOPATCHER_RESTART_APPLICATION=57,
    ID_NAT_PUNCHTHROUGH_REQUEST=58,
    ID_NAT_CONNECT_AT_TIME=59,
    ID_NAT_GET_MOST_RECENT_PORT=60,
    ID_NAT_CLIENT_READY=61,
    ID_NAT_TARGET_NOT_CONNECTED=62,
    ID_NAT_TARGET_UNRESPONSIVE=63,
    ID_NAT_CONNECTION_TO_TARGET_LOST=64,
    ID_NAT_ALREADY_IN_PROGRESS=65,
    ID_NAT_PUNCHTHROUGH_FAILED=66,
    ID_NAT_PUNCHTHROUGH_SUCCEEDED=67,
    ID_READY_EVENT_SET=68,
    ID_READY_EVENT_UNSET=69,
    ID_READY_EVENT_ALL_SET=70,
    ID_READY_EVENT_QUERY=71,
    ID_LOBBY_GENERAL=72,
    ID_RPC_REMOTE_ERROR=73,
    ID_RPC_PLUGIN=74,
    ID_FILE_LIST_REFERENCE_PUSH=75,
    ID_READY_EVENT_FORCE_ALL_SET=76,
    ID_ROOMS_EXECUTE_FUNC=77,
    ID_ROOMS_LOGON_STATUS=78,
    ID_ROOMS_HANDLE_CHANGE=79,
    ID_LOBBY2_SEND_MESSAGE=80,
    ID_LOBBY2_SERVER_ERROR=81,
    ID_FCM2_NEW_HOST=82,
    ID_FCM2_REQUEST_FCMGUID=83,
    ID_FCM2_RESPOND_CONNECTION_COUNT=84,
    ID_FCM2_INFORM_FCMGUID=85,
    ID_FCM2_UPDATE_MIN_TOTAL_CONNECTION_COUNT=86,
    ID_FCM2_VERIFIED_JOIN_START=87,
    ID_FCM2_VERIFIED_JOIN_CAPABLE=88,
    ID_FCM2_VERIFIED_JOIN_FAILED=89,
    ID_FCM2_VERIFIED_JOIN_ACCEPTED=90,
    ID_FCM2_VERIFIED_JOIN_REJECTED=91,
    ID_UDP_PROXY_GENERAL=92,
    ID_SQLite3_EXEC=93,
    ID_SQLite3_UNKNOWN_DB=94,
    ID_SQLLITE_LOGGER=95,
    ID_NAT_TYPE_DETECTION_REQUEST=96,
    ID_NAT_TYPE_DETECTION_RESULT=97,
    ID_ROUTER_2_INTERNAL=98,
    ID_ROUTER_2_FORWARDING_NO_PATH=99,
    ID_ROUTER_2_FORWARDING_ESTABLISHED=100,
    ID_ROUTER_2_REROUTED=101,
    ID_TEAM_BALANCER_INTERNAL=102,
    ID_TEAM_BALANCER_REQUESTED_TEAM_FULL=103,
    ID_TEAM_BALANCER_REQUESTED_TEAM_LOCKED=104,
    ID_TEAM_BALANCER_TEAM_REQUESTED_CANCELLED=105,
    ID_TEAM_BALANCER_TEAM_ASSIGNED=106,
    ID_LIGHTSPEED_INTEGRATION=107,
    ID_XBOX_LOBBY=108,
    ID_TWO_WAY_AUTHENTICATION_INCOMING_CHALLENGE_SUCCESS=109,
    ID_TWO_WAY_AUTHENTICATION_OUTGOING_CHALLENGE_SUCCESS=110,
    ID_TWO_WAY_AUTHENTICATION_INCOMING_CHALLENGE_FAILURE=111,
    ID_TWO_WAY_AUTHENTICATION_OUTGOING_CHALLENGE_FAILURE=112,
    ID_TWO_WAY_AUTHENTICATION_OUTGOING_CHALLENGE_TIMEOUT=113,
    ID_TWO_WAY_AUTHENTICATION_NEGOTIATION=114,
    ID_CLOUD_POST_REQUEST=115,
    ID_CLOUD_RELEASE_REQUEST=116,
    ID_CLOUD_GET_REQUEST=117,
    ID_CLOUD_GET_RESPONSE=118,
    ID_CLOUD_UNSUBSCRIBE_REQUEST=119,
    ID_CLOUD_SERVER_TO_SERVER_COMMAND=120,
    ID_CLOUD_SUBSCRIPTION_NOTIFICATION=121,
    ID_LIB_VOICE=122,
    ID_RELAY_PLUGIN=123,
    ID_NAT_REQUEST_BOUND_ADDRESSES=124,
    ID_NAT_RESPOND_BOUND_ADDRESSES=125,
    ID_FCM2_UPDATE_USER_CONTEXT=126,
    ID_RESERVED_3=127,
    ID_RESERVED_4=128,
    ID_RESERVED_5=129,
    ID_RESERVED_6=130,
    ID_RESERVED_7=131,
    ID_RESERVED_8=132,
    ID_RESERVED_9=133,
    ID_USER_PACKET_ENUM=134
};

enum RakNet::PluginReceiveResult
{
    RR_STOP_PROCESSING_AND_DEALLOCATE=0,
    RR_CONTINUE_PROCESSING=1,
    RR_STOP_PROCESSING=2
};

enum <unnamed-enum-TF_LINEAR_MIPMAP>
{
    TF_LINEAR_MIPMAP=1,
    TF_ANISOTROPHIC=2
};

enum SDisplayMode
{
    Windowed=0,
    BorderlessWindowed=1,
    ExclusiveFullscreen=2
};

enum SAntialiasingMode
{
    Off=0,
    MSAA2x=1,
    MSAA4x=2,
    MSAA8x=3
};

class SDXWindow : public SWindow
{
    protected void OnSize(int ,int );
    protected void OnPaint(struct HDC__ * );
    protected void OnClose();
    protected void OnDestroy();
    protected bool OnIdle();
    protected int OnSetCursor();
    protected enum SDisplayMode DisplayMode;
    protected bool VSync;
    protected enum SAntialiasingMode AntialiasingMode;
    protected int Monitor;
    protected int FullScreenWidth;
    protected int FullScreenHeight;
    protected int WindowedX;
    protected int WindowedY;
    protected int WindowedWidth;
    protected int WindowedHeight;
    protected int DesktopX;
    protected int DesktopY;
    protected int DesktopWidth;
    protected int DesktopHeight;
    protected class SDArray<tagRECT> MonitorRects;
    protected int CursorX;
    protected int CursorY;
    protected class SMessageBox * MBox;
    protected int GetMSAALevel();
    protected int WindowProc(unsigned int ,unsigned int ,long );
    protected int AddMonitorsCallBack(struct HMONITOR__ * ,struct HDC__ * ,struct tagRECT * ,long );
    public void SDXWindow(class SDXWindow * );
    public void SDXWindow(class SDXWindow & );
    public void SDXWindow();
    public void SetPosition(int ,int ,int ,int );
    public void InitDesktopSize(int & );
    public void SetDisplayMode(enum SDisplayMode ,bool ,enum SAntialiasingMode ,int ,int ,int );
    public bool IsFullScreen();
    public int Create(class SResource ,class SResource ,wchar_t * );
    public void SetCursorPos(int ,int );
    public int GetFrame();
    public int MessageBoxA(class SWidget * ,char * ,int );
    public bool IsThereMessageBox();
    public void ~SDXWindow();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct tagRECT
{
    long left;
    long top;
    long right;
    long bottom;
};

class SDArray<tagRECT>
{
    private int size;
    private int maxsize;
    public struct tagRECT * array;
    public void SDArray<tagRECT>(class SDArray<tagRECT> & );
    public void SDArray<tagRECT>();
    public void ~SDArray<tagRECT>();
    public int Add(struct tagRECT & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct tagRECT & operator[](int );
    public void operator=(class SDArray<tagRECT> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<tagRECT>
{
    private int size;
    private int maxsize;
    public struct tagRECT * array;
    public void SDArray<tagRECT>(class SDArray<tagRECT> & );
    public void SDArray<tagRECT>();
    public void ~SDArray<tagRECT>();
    public int Add(struct tagRECT & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct tagRECT & operator[](int );
    public void operator=(class SDArray<tagRECT> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SMessageBox : public SDialog
{
    private class STextButton OKButton;
    private class STextButton YesButton;
    private class STextButton NoButton;
    private class STextButton RetryButton;
    private class STextButton IgnoreButton;
    private class STextButton CancelButton;
    private class SListBox ListBox;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool OnChar(int );
    private int Type;
    public void SMessageBox(class SMessageBox * );
    public void SMessageBox(class SMessageBox & );
    public void SMessageBox();
    public void Create(char * ,int );
    protected void Cancel();
    public void ~SMessageBox();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct in_addr
{
    union <unnamed-type-S_un>
    {
        struct <unnamed-type-S_un_b>
        {
            unsigned int s_b1;
            unsigned int s_b2;
            unsigned int s_b3;
            unsigned int s_b4;
        };
        struct in_addr::<unnamed-type-S_un>::<unnamed-type-S_un_b> S_un_b;
        struct <unnamed-type-S_un_w>
        {
            unsigned int s_w1;
            unsigned int s_w2;
        };
        struct in_addr::<unnamed-type-S_un>::<unnamed-type-S_un_w> S_un_w;
        unsigned long S_addr;
    };
    union in_addr::<unnamed-type-S_un> S_un;
};

struct MatchInfo
{
    int id;
    class SString name;
    class SString hostName;
    class SString hostAddress;
    class SString hostPrivateAddress;
    class SString hostGuid;
    int hostPort;
    unsigned int numPlayers;
    unsigned int maxPlayers;
    int clientVersion;
    unsigned int gameType;
    unsigned int isClosed;
    void operator=(struct MatchInfo & );
    void MatchInfo(struct MatchInfo & );
    void MatchInfo();
    void ~MatchInfo();
    void * __vecDelDtor(unsigned int );
};

struct MatchInfo
{
    int id;
    class SString name;
    class SString hostName;
    class SString hostAddress;
    class SString hostPrivateAddress;
    class SString hostGuid;
    int hostPort;
    unsigned int numPlayers;
    unsigned int maxPlayers;
    int clientVersion;
    unsigned int gameType;
    unsigned int isClosed;
    void operator=(struct MatchInfo & );
    void MatchInfo(struct MatchInfo & );
    void MatchInfo();
    void ~MatchInfo();
    void * __vecDelDtor(unsigned int );
};

enum UserStatus
{
    Available=0,
    InLobby=1,
    Playing=2,
    Away=3
};

enum ChatMessageType
{
    Normal=0,
    Action=1,
    Private=2,
    PlayerJoined=3,
    PlayerLeft=4,
    GameSettingsLocked=5,
    Other=6,
    NumMessageTypes=7
};

class MatchMaking
{
    public class MatchMaking * ConnectToServer(class IMatchMakingEventHandler * );
    public void MatchMaking(class MatchMaking & );
    public void MatchMaking();
    public void ~MatchMaking();
    public void Disconnect();
    public void Update();
    public bool IsConnected();
    public void SendLoginMessage(char * );
    public void SendUpdateUserMessage(char * ,enum UserStatus );
    public void SendCreateMatchMessage(char * ,int ,char * ,char * ,int );
    public void SendUpdateMatchMessage(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void SendRemoveMatchMessage();
    public void SendChatMessage(char * ,char * ,enum ChatMessageType );
    public char * GetMyUserName();
    public char * GetMyPublicAddress();
    private unsigned int sock;
    private class SDArray<unsigned char> msg;
    private class SDArray<unsigned char> sendBuffer;
    private class SDArray<unsigned char> recvBuffer;
    private int readPtr;
    private class IMatchMakingEventHandler * eventHandler;
    private class SString myPublicAddress;
    private class SString myUserName;
    private void ClearMessageBuffer();
    private void WriteString(char * );
    private void WriteByte(unsigned int );
    private void WriteInt(int );
    private void SendMessageA();
    private void TryDecodeMessages();
    private unsigned int ReadByte();
    private int ReadInt();
    private class SString ReadString();
    private void DecodeMessage();
    public class MatchMaking & operator=(class MatchMaking & );
    public void * __vecDelDtor(unsigned int );
};

struct UserInfo
{
    class SString name;
    enum UserStatus status;
    void UserInfo(struct UserInfo * );
    void UserInfo(struct UserInfo & );
    void UserInfo();
    void ~UserInfo();
    struct UserInfo & operator=(struct UserInfo * );
    struct UserInfo & operator=(struct UserInfo & );
    void * __vecDelDtor(unsigned int );
};

class IMatchMakingEventHandler
{
    public void OnAccept(char * );
    public void OnUpdateUsers(int ,struct UserInfo * );
    public void OnUpdateMatches(int ,struct MatchInfo * );
    public void OnUpdateChat(char * ,char * ,enum ChatMessageType );
    public void IMatchMakingEventHandler(class IMatchMakingEventHandler * );
    public void IMatchMakingEventHandler(class IMatchMakingEventHandler & );
    public void IMatchMakingEventHandler();
    public class IMatchMakingEventHandler & operator=(class IMatchMakingEventHandler * );
    public class IMatchMakingEventHandler & operator=(class IMatchMakingEventHandler & );
};

class IMatchMakingEventHandler
{
    public void OnAccept(char * );
    public void OnUpdateUsers(int ,struct UserInfo * );
    public void OnUpdateMatches(int ,struct MatchInfo * );
    public void OnUpdateChat(char * ,char * ,enum ChatMessageType );
    public void IMatchMakingEventHandler(class IMatchMakingEventHandler * );
    public void IMatchMakingEventHandler(class IMatchMakingEventHandler & );
    public void IMatchMakingEventHandler();
    public class IMatchMakingEventHandler & operator=(class IMatchMakingEventHandler * );
    public class IMatchMakingEventHandler & operator=(class IMatchMakingEventHandler & );
};

class SDArray<unsigned char>
{
    private int size;
    private int maxsize;
    public unsigned int * array;
    public void SDArray<unsigned char>(class SDArray<unsigned char> & );
    public void SDArray<unsigned char>();
    public void ~SDArray<unsigned char>();
    public int Add(unsigned int & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int & operator[](int );
    public void operator=(class SDArray<unsigned char> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<unsigned char>
{
    private int size;
    private int maxsize;
    public unsigned int * array;
    public void SDArray<unsigned char>(class SDArray<unsigned char> & );
    public void SDArray<unsigned char>();
    public void ~SDArray<unsigned char>();
    public int Add(unsigned int & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int & operator[](int );
    public void operator=(class SDArray<unsigned char> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct in6_addr
{
    union <unnamed-type-u>
    {
        unsigned int Byte[16];
        unsigned int Word[8];
    };
    union in6_addr::<unnamed-type-u> u;
};

union in6_addr::<unnamed-type-u>
{
    unsigned int Byte[16];
    unsigned int Word[8];
};

union in_addr::<unnamed-type-S_un>
{
    struct <unnamed-type-S_un_b>
    {
        unsigned int s_b1;
        unsigned int s_b2;
        unsigned int s_b3;
        unsigned int s_b4;
    };
    struct in_addr::<unnamed-type-S_un>::<unnamed-type-S_un_b> S_un_b;
    struct <unnamed-type-S_un_w>
    {
        unsigned int s_w1;
        unsigned int s_w2;
    };
    struct in_addr::<unnamed-type-S_un>::<unnamed-type-S_un_w> S_un_w;
    unsigned long S_addr;
};

struct group_filter
{
    unsigned long gf_interface;
    struct sockaddr_storage gf_group;
    enum MULTICAST_MODE_TYPE gf_fmode;
    unsigned long gf_numsrc;
    struct sockaddr_storage gf_slist[1];
};

union RakNet::SystemAddress::<unnamed-type-address>
{
    struct sockaddr_in addr4;
};

struct RakNet::AddressOrGUID
{
    struct RakNet::RakNetGUID rakNetGuid;
    struct RakNet::SystemAddress systemAddress;
    unsigned int GetSystemIndex();
    bool IsUndefined();
    void SetUndefined();
    unsigned long ToInteger(struct RakNet::AddressOrGUID & );
    void ToString(bool ,char * );
    char * ToString(bool );
    void AddressOrGUID(struct RakNet::RakNetGUID & );
    void AddressOrGUID(struct RakNet::Packet * );
    void AddressOrGUID(struct RakNet::SystemAddress & );
    void AddressOrGUID(struct RakNet::AddressOrGUID & );
    void AddressOrGUID();
    struct RakNet::AddressOrGUID & operator=(struct RakNet::RakNetGUID & );
    struct RakNet::AddressOrGUID & operator=(struct RakNet::SystemAddress & );
    struct RakNet::AddressOrGUID & operator=(struct RakNet::AddressOrGUID & );
    bool operator==(struct RakNet::AddressOrGUID & );
};

struct RakNet::AddressOrGUID
{
    struct RakNet::RakNetGUID rakNetGuid;
    struct RakNet::SystemAddress systemAddress;
    unsigned int GetSystemIndex();
    bool IsUndefined();
    void SetUndefined();
    unsigned long ToInteger(struct RakNet::AddressOrGUID & );
    void ToString(bool ,char * );
    char * ToString(bool );
    void AddressOrGUID(struct RakNet::RakNetGUID & );
    void AddressOrGUID(struct RakNet::Packet * );
    void AddressOrGUID(struct RakNet::SystemAddress & );
    void AddressOrGUID(struct RakNet::AddressOrGUID & );
    void AddressOrGUID();
    struct RakNet::AddressOrGUID & operator=(struct RakNet::RakNetGUID & );
    struct RakNet::AddressOrGUID & operator=(struct RakNet::SystemAddress & );
    struct RakNet::AddressOrGUID & operator=(struct RakNet::AddressOrGUID & );
    bool operator==(struct RakNet::AddressOrGUID & );
};

struct RakNet::Packet
{
    struct RakNet::SystemAddress systemAddress;
    struct RakNet::RakNetGUID guid;
    unsigned int length;
    unsigned int bitSize;
    unsigned int * data;
    bool deleteData;
    bool wasGeneratedLocally;
    void Packet();
    struct RakNet::Packet & operator=(struct RakNet::Packet * );
    struct RakNet::Packet & operator=(struct RakNet::Packet & );
};

struct RakNet::Packet
{
    struct RakNet::SystemAddress systemAddress;
    struct RakNet::RakNetGUID guid;
    unsigned int length;
    unsigned int bitSize;
    unsigned int * data;
    bool deleteData;
    bool wasGeneratedLocally;
    void Packet();
    struct RakNet::Packet & operator=(struct RakNet::Packet * );
    struct RakNet::Packet & operator=(struct RakNet::Packet & );
};

struct RakNet::uint24_t
{
    unsigned int val;
    void uint24_t(unsigned int & );
    void uint24_t(struct RakNet::uint24_t & );
    void uint24_t();
    unsigned int operator unsigned int();
    unsigned int operator unsigned int();
    struct RakNet::uint24_t operator++(int );
    struct RakNet::uint24_t operator++();
    struct RakNet::uint24_t operator--(int );
    struct RakNet::uint24_t operator--();
    struct RakNet::uint24_t operator&(unsigned int & );
    struct RakNet::uint24_t operator&(struct RakNet::uint24_t & );
    struct RakNet::uint24_t & operator=(unsigned int & );
    struct RakNet::uint24_t & operator=(struct RakNet::uint24_t & );
    struct RakNet::uint24_t & operator+=(unsigned int & );
    struct RakNet::uint24_t & operator+=(struct RakNet::uint24_t & );
    struct RakNet::uint24_t & operator-=(unsigned int & );
    struct RakNet::uint24_t & operator-=(struct RakNet::uint24_t & );
    bool operator==(unsigned int & );
    bool operator==(struct RakNet::uint24_t & );
    bool operator!=(unsigned int & );
    bool operator!=(struct RakNet::uint24_t & );
    bool operator>(unsigned int & );
    bool operator>(struct RakNet::uint24_t & );
    bool operator<(unsigned int & );
    bool operator<(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator+(unsigned int & );
    const struct RakNet::uint24_t operator+(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator-(unsigned int & );
    const struct RakNet::uint24_t operator-(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator/(unsigned int & );
    const struct RakNet::uint24_t operator/(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator*(unsigned int & );
    const struct RakNet::uint24_t operator*(struct RakNet::uint24_t & );
};

struct RakNet::uint24_t
{
    unsigned int val;
    void uint24_t(unsigned int & );
    void uint24_t(struct RakNet::uint24_t & );
    void uint24_t();
    unsigned int operator unsigned int();
    unsigned int operator unsigned int();
    struct RakNet::uint24_t operator++(int );
    struct RakNet::uint24_t operator++();
    struct RakNet::uint24_t operator--(int );
    struct RakNet::uint24_t operator--();
    struct RakNet::uint24_t operator&(unsigned int & );
    struct RakNet::uint24_t operator&(struct RakNet::uint24_t & );
    struct RakNet::uint24_t & operator=(unsigned int & );
    struct RakNet::uint24_t & operator=(struct RakNet::uint24_t & );
    struct RakNet::uint24_t & operator+=(unsigned int & );
    struct RakNet::uint24_t & operator+=(struct RakNet::uint24_t & );
    struct RakNet::uint24_t & operator-=(unsigned int & );
    struct RakNet::uint24_t & operator-=(struct RakNet::uint24_t & );
    bool operator==(unsigned int & );
    bool operator==(struct RakNet::uint24_t & );
    bool operator!=(unsigned int & );
    bool operator!=(struct RakNet::uint24_t & );
    bool operator>(unsigned int & );
    bool operator>(struct RakNet::uint24_t & );
    bool operator<(unsigned int & );
    bool operator<(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator+(unsigned int & );
    const struct RakNet::uint24_t operator+(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator-(unsigned int & );
    const struct RakNet::uint24_t operator-(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator/(unsigned int & );
    const struct RakNet::uint24_t operator/(struct RakNet::uint24_t & );
    const struct RakNet::uint24_t operator*(unsigned int & );
    const struct RakNet::uint24_t operator*(struct RakNet::uint24_t & );
};

class RakNet::ReferenceCounter
{
    private int refCount;
    public void ReferenceCounter();
    public void ~ReferenceCounter();
    public void AddRef();
    public int Release();
    public int GetRefCount();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::ReferenceCounter
{
    private int refCount;
    public void ReferenceCounter();
    public void ~ReferenceCounter();
    public void AddRef();
    public int Release();
    public int GetRefCount();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::LocklessUint32_t
{
    public void LocklessUint32_t(class RakNet::LocklessUint32_t * );
    public void LocklessUint32_t(class RakNet::LocklessUint32_t & );
    public void LocklessUint32_t(unsigned int );
    public void LocklessUint32_t();
    public unsigned int Increment();
    public unsigned int Decrement();
    public unsigned int GetValue();
    protected long value;
    public class RakNet::LocklessUint32_t & operator=(class RakNet::LocklessUint32_t * );
    public class RakNet::LocklessUint32_t & operator=(class RakNet::LocklessUint32_t & );
};

class RakNet::LocklessUint32_t
{
    public void LocklessUint32_t(class RakNet::LocklessUint32_t * );
    public void LocklessUint32_t(class RakNet::LocklessUint32_t & );
    public void LocklessUint32_t(unsigned int );
    public void LocklessUint32_t();
    public unsigned int Increment();
    public unsigned int Decrement();
    public unsigned int GetValue();
    protected long value;
    public class RakNet::LocklessUint32_t & operator=(class RakNet::LocklessUint32_t * );
    public class RakNet::LocklessUint32_t & operator=(class RakNet::LocklessUint32_t & );
};

struct RakNet::RNS2_SendParameters
{
    void RNS2_SendParameters();
    char * data;
    int length;
    struct RakNet::SystemAddress systemAddress;
    int ttl;
    struct RakNet::RNS2_SendParameters & operator=(struct RakNet::RNS2_SendParameters * );
    struct RakNet::RNS2_SendParameters & operator=(struct RakNet::RNS2_SendParameters & );
};

struct RakNet::RNS2_SendParameters
{
    void RNS2_SendParameters();
    char * data;
    int length;
    struct RakNet::SystemAddress systemAddress;
    int ttl;
    struct RakNet::RNS2_SendParameters & operator=(struct RakNet::RNS2_SendParameters * );
    struct RakNet::RNS2_SendParameters & operator=(struct RakNet::RNS2_SendParameters & );
};

class RakNet::RNS2EventHandler
{
    public void RNS2EventHandler(class RakNet::RNS2EventHandler & );
    public void RNS2EventHandler();
    public void ~RNS2EventHandler();
    public void OnRNS2Recv(struct RakNet::RNS2RecvStruct * );
    public void DeallocRNS2RecvStruct(struct RakNet::RNS2RecvStruct * ,char * ,unsigned int );
    public struct RakNet::RNS2RecvStruct * AllocRNS2RecvStruct(char * ,unsigned int );
    public class RakNet::RNS2EventHandler & operator=(class RakNet::RNS2EventHandler & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RNS2EventHandler
{
    public void RNS2EventHandler(class RakNet::RNS2EventHandler & );
    public void RNS2EventHandler();
    public void ~RNS2EventHandler();
    public void OnRNS2Recv(struct RakNet::RNS2RecvStruct * );
    public void DeallocRNS2RecvStruct(struct RakNet::RNS2RecvStruct * ,char * ,unsigned int );
    public struct RakNet::RNS2RecvStruct * AllocRNS2RecvStruct(char * ,unsigned int );
    public class RakNet::RNS2EventHandler & operator=(class RakNet::RNS2EventHandler & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::RNS2RecvStruct
{
    char data[1492];
    int bytesRead;
    struct RakNet::SystemAddress systemAddress;
    unsigned int timeRead;
    class RakNet::RakNetSocket2 * socket;
    void RNS2RecvStruct();
    struct RakNet::RNS2RecvStruct & operator=(struct RakNet::RNS2RecvStruct * );
    struct RakNet::RNS2RecvStruct & operator=(struct RakNet::RNS2RecvStruct & );
};

struct RakNet::RNS2RecvStruct
{
    char data[1492];
    int bytesRead;
    struct RakNet::SystemAddress systemAddress;
    unsigned int timeRead;
    class RakNet::RakNetSocket2 * socket;
    void RNS2RecvStruct();
    struct RakNet::RNS2RecvStruct & operator=(struct RakNet::RNS2RecvStruct * );
    struct RakNet::RNS2RecvStruct & operator=(struct RakNet::RNS2RecvStruct & );
};

class RakNet::SocketLayerOverride
{
    public void SocketLayerOverride(class RakNet::SocketLayerOverride & );
    public void SocketLayerOverride();
    public void ~SocketLayerOverride();
    public int RakNetSendTo(char * ,int ,struct RakNet::SystemAddress & );
    public int RakNetRecvFrom(char * ,struct RakNet::SystemAddress * ,bool );
    public class RakNet::SocketLayerOverride & operator=(class RakNet::SocketLayerOverride & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::SocketLayerOverride
{
    public void SocketLayerOverride(class RakNet::SocketLayerOverride & );
    public void SocketLayerOverride();
    public void ~SocketLayerOverride();
    public int RakNetSendTo(char * ,int ,struct RakNet::SystemAddress & );
    public int RakNetRecvFrom(char * ,struct RakNet::SystemAddress * ,bool );
    public class RakNet::SocketLayerOverride & operator=(class RakNet::SocketLayerOverride & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::StartupResult
{
    RAKNET_STARTED=0,
    RAKNET_ALREADY_STARTED=1,
    INVALID_SOCKET_DESCRIPTORS=2,
    INVALID_MAX_CONNECTIONS=3,
    SOCKET_FAMILY_NOT_SUPPORTED=4,
    SOCKET_PORT_ALREADY_IN_USE=5,
    SOCKET_FAILED_TO_BIND=6,
    SOCKET_FAILED_TEST_SEND=7,
    PORT_CANNOT_BE_ZERO=8,
    FAILED_TO_CREATE_NETWORK_THREAD=9,
    COULD_NOT_GENERATE_GUID=10,
    STARTUP_OTHER_FAILURE=11
};

class RakNet::RakPeerInterface
{
    public class RakNet::RakPeerInterface * GetInstance();
    public void DestroyInstance(class RakNet::RakPeerInterface * );
    public void ~RakPeerInterface();
    public enum RakNet::StartupResult Startup(unsigned int ,struct RakNet::SocketDescriptor * ,unsigned int ,int );
    public bool InitializeSecurity(char * ,char * ,bool );
    public void DisableSecurity();
    public void AddToSecurityExceptionList(char * );
    public void RemoveFromSecurityExceptionList(char * );
    public bool IsInSecurityExceptionList(char * );
    public void SetMaximumIncomingConnections(unsigned int );
    public unsigned int GetMaximumIncomingConnections();
    public unsigned int NumberOfConnections();
    public void SetIncomingPassword(char * ,int );
    public void GetIncomingPassword(char * ,int * );
    public enum RakNet::ConnectionAttemptResult Connect(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public enum RakNet::ConnectionAttemptResult ConnectWithSocket(char * ,unsigned int ,char * ,int ,class RakNet::RakNetSocket2 * ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int );
    public void Shutdown(unsigned int ,unsigned int ,enum PacketPriority );
    public bool IsActive();
    public bool GetConnectionList(struct RakNet::SystemAddress * ,unsigned int * );
    public unsigned int GetNextSendReceipt();
    public unsigned int IncrementNextSendReceipt();
    public unsigned int Send(class RakNet::BitStream * ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public unsigned int Send(char * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public void SendLoopback(char * ,const int );
    public unsigned int SendList(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public struct RakNet::Packet * Receive();
    public void DeallocatePacket(struct RakNet::Packet * );
    public unsigned int GetMaximumNumberOfPeers();
    public void CloseConnection(const struct RakNet::AddressOrGUID ,bool ,unsigned int ,enum PacketPriority );
    public enum RakNet::ConnectionState GetConnectionState(const struct RakNet::AddressOrGUID );
    public void CancelConnectionAttempt(const struct RakNet::SystemAddress );
    public int GetIndexFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromIndex(unsigned int );
    public struct RakNet::RakNetGUID GetGUIDFromIndex(unsigned int );
    public void GetSystemList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & );
    public void AddToBanList(char * ,unsigned int );
    public void RemoveFromBanList(char * );
    public void ClearBanList();
    public bool IsBanned(char * );
    public void SetLimitIPConnectionFrequency(bool );
    public bool Ping(char * ,unsigned int ,bool ,unsigned int );
    public void Ping(const struct RakNet::SystemAddress );
    public int GetAveragePing(const struct RakNet::AddressOrGUID );
    public int GetLastPing(const struct RakNet::AddressOrGUID );
    public int GetLowestPing(const struct RakNet::AddressOrGUID );
    public void SetOccasionalPing(bool );
    public unsigned int GetClockDifferential(const struct RakNet::AddressOrGUID );
    public void SetOfflinePingResponse(char * ,const unsigned int );
    public void GetOfflinePingResponse(char ** ,unsigned int * );
    public struct RakNet::SystemAddress GetInternalID(const struct RakNet::SystemAddress ,const int );
    public void SetInternalID(struct RakNet::SystemAddress ,int );
    public struct RakNet::SystemAddress GetExternalID(const struct RakNet::SystemAddress );
    public const struct RakNet::RakNetGUID GetMyGUID();
    public struct RakNet::SystemAddress GetMyBoundAddress(const int );
    public unsigned int Get64BitUniqueRandomNumber();
    public struct RakNet::RakNetGUID & GetGuidFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromGuid(const struct RakNet::RakNetGUID );
    public bool GetClientPublicKeyFromSystemAddress(const struct RakNet::SystemAddress ,char * );
    public void SetTimeoutTime(unsigned int ,const struct RakNet::SystemAddress );
    public unsigned int GetTimeoutTime(const struct RakNet::SystemAddress );
    public int GetMTUSize(const struct RakNet::SystemAddress );
    public unsigned int GetNumberOfAddresses();
    public char * GetLocalIP(unsigned int );
    public bool IsLocalIP(char * );
    public void AllowConnectionResponseIPMigration(bool );
    public bool AdvertiseSystem(char * ,unsigned int ,char * ,int ,unsigned int );
    public void SetSplitMessageProgressInterval(int );
    public int GetSplitMessageProgressInterval();
    public void SetUnreliableTimeout(unsigned int );
    public void SendTTL(char * ,unsigned int ,int ,unsigned int );
    public void AttachPlugin(class RakNet::PluginInterface2 * );
    public void DetachPlugin(class RakNet::PluginInterface2 * );
    public void PushBackPacket(struct RakNet::Packet * ,bool );
    public void ChangeSystemAddress(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    public struct RakNet::Packet * AllocatePacket(unsigned int );
    public class RakNet::RakNetSocket2 * GetSocket(const struct RakNet::SystemAddress );
    public void GetSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void ReleaseSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void WriteOutOfBandHeader(class RakNet::BitStream * );
    public void SetUserUpdateThread(void  ( * )(class RakNet::RakPeerInterface * ,void * ),void * );
    public void SetIncomingDatagramEventHandler(bool  ( * )(struct RakNet::RNS2RecvStruct * ));
    public void ApplyNetworkSimulator(float ,unsigned int ,unsigned int );
    public void SetPerConnectionOutgoingBandwidthLimit(unsigned int );
    public bool IsNetworkSimulatorActive();
    public bool GetStatistics(const unsigned int ,struct RakNet::RakNetStatistics * );
    public struct RakNet::RakNetStatistics * GetStatistics(const struct RakNet::SystemAddress ,struct RakNet::RakNetStatistics * );
    public void GetStatisticsList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & ,class DataStructures::List<RakNet::RakNetStatistics> & );
    public unsigned int GetReceiveBufferSize();
    public bool RunUpdateCycle(class RakNet::BitStream & );
    public bool SendOutOfBand(char * ,unsigned int ,char * ,unsigned int ,unsigned int );
    public void RakPeerInterface(class RakNet::RakPeerInterface & );
    public void RakPeerInterface();
    public class RakNet::RakPeerInterface & operator=(class RakNet::RakPeerInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::ConnectionAttemptResult
{
    CONNECTION_ATTEMPT_STARTED=0,
    INVALID_PARAMETER=1,
    CANNOT_RESOLVE_DOMAIN_NAME=2,
    ALREADY_CONNECTED_TO_ENDPOINT=3,
    CONNECTION_ATTEMPT_ALREADY_IN_PROGRESS=4,
    SECURITY_INITIALIZATION_FAILED=5
};

class RakNet::BitStream
{
    public class RakNet::BitStream * GetInstance();
    public void DestroyInstance(class RakNet::BitStream * );
    private void BitStream(class RakNet::BitStream & );
    public void BitStream(unsigned int * ,const unsigned int ,bool );
    public void BitStream(const unsigned int );
    public void BitStream();
    public void ~BitStream();
    public void Reset();
    public bool Serialize(bool ,char * ,const unsigned int );
    public bool SerializeFloat16(bool ,float & ,float ,float );
    public bool SerializeBits(bool ,unsigned int * ,const unsigned int ,const bool );
    public void Write(const unsigned int * );
    public void Write(const char * );
    public void Write(const unsigned int * );
    public void Write(const wchar_t * );
    public void Write(const char * );
    public void Write(class RakNet::BitStream & );
    public void Write(class RakNet::BitStream & ,unsigned int );
    public void Write(class RakNet::BitStream * );
    public void Write(class RakNet::BitStream * ,unsigned int );
    public void Write(char * ,const unsigned int );
    private void WriteCompressed(unsigned int * ,const unsigned int ,const bool );
    public void WriteCompressed(const unsigned int * );
    public void WriteCompressed(const char * );
    public void WriteCompressed(const unsigned int * );
    public void WriteCompressed(const wchar_t * );
    public void WriteCompressed(const char * );
    public bool Read(unsigned int * );
    public bool Read(char * );
    public bool Read(char * ,const unsigned int );
    public bool Read(class RakNet::BitStream & );
    public bool Read(class RakNet::BitStream & ,unsigned int );
    public bool Read(class RakNet::BitStream * );
    public bool Read(class RakNet::BitStream * ,unsigned int );
    private bool ReadCompressed(unsigned int * ,const unsigned int ,const bool );
    public void WriteFloat16(float ,float ,float );
    public bool ReadFloat16(float & ,float ,float );
    public void ResetReadPointer();
    public void ResetWritePointer();
    public void AssertStreamEmpty();
    public void PrintBits();
    public void PrintBits(char * );
    public void PrintHex();
    public void PrintHex(char * );
    public void IgnoreBits(const unsigned int );
    public void IgnoreBytes(const unsigned int );
    public void SetWriteOffset(const unsigned int );
    public unsigned int GetNumberOfBitsUsed();
    public unsigned int GetWriteOffset();
    public unsigned int GetNumberOfBytesUsed();
    public unsigned int GetReadOffset();
    public void SetReadOffset(const unsigned int );
    public unsigned int GetNumberOfUnreadBits();
    public unsigned int CopyData(unsigned int ** );
    public void SetData(unsigned int * );
    public unsigned int * GetData();
    public void WriteBits(unsigned int * ,unsigned int ,const bool );
    public void WriteAlignedBytes(unsigned int * ,const unsigned int );
    public void EndianSwapBytes(int ,int );
    public void WriteAlignedBytesSafe(char * ,const unsigned int ,const unsigned int );
    public bool ReadAlignedBytes(unsigned int * ,const unsigned int );
    public bool ReadAlignedBytesSafe(char * ,unsigned int & ,const unsigned int );
    public bool ReadAlignedBytesSafe(char * ,int & ,const int );
    public bool ReadAlignedBytesSafeAlloc(char ** ,unsigned int & ,const unsigned int );
    public bool ReadAlignedBytesSafeAlloc(char ** ,int & ,const unsigned int );
    public void AlignWriteToByteBoundary();
    public void AlignReadToByteBoundary();
    public bool ReadBits(unsigned int * ,unsigned int ,const bool );
    public void Write0();
    public void Write1();
    public bool ReadBit();
    public void AssertCopyData();
    public void SetNumberOfBitsAllocated(const unsigned int );
    public void AddBitsAndReallocate(const unsigned int );
    public unsigned int GetNumberOfBitsAllocated();
    public void PadWithZeroToByteLength(unsigned int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(unsigned int );
    public int NumberOfLeadingZeroes(unsigned int );
    public int NumberOfLeadingZeroes(unsigned int );
    public int NumberOfLeadingZeroes(unsigned int );
    public void WriteAlignedVar8(char * );
    public bool ReadAlignedVar8(char * );
    public void WriteAlignedVar16(char * );
    public bool ReadAlignedVar16(char * );
    public void WriteAlignedVar32(char * );
    public bool ReadAlignedVar32(char * );
    public bool DoEndianSwap();
    public bool IsBigEndian();
    public bool IsNetworkOrder();
    public bool IsNetworkOrderInternal();
    public void ReverseBytes(unsigned int * ,unsigned int * ,const unsigned int );
    public void ReverseBytesInPlace(unsigned int * ,const unsigned int );
    private class RakNet::BitStream & operator=(class RakNet::BitStream & );
    private unsigned int numberOfBitsUsed;
    private unsigned int numberOfBitsAllocated;
    private unsigned int readOffset;
    private unsigned int * data;
    private bool copyData;
    private unsigned int stackData[256];
    public void * __vecDelDtor(unsigned int );
};

enum PacketReliability
{
    UNRELIABLE=0,
    UNRELIABLE_SEQUENCED=1,
    RELIABLE=2,
    RELIABLE_ORDERED=3,
    RELIABLE_SEQUENCED=4,
    UNRELIABLE_WITH_ACK_RECEIPT=5,
    RELIABLE_WITH_ACK_RECEIPT=6,
    RELIABLE_ORDERED_WITH_ACK_RECEIPT=7,
    NUMBER_OF_RELIABILITIES=8
};

enum RakNet::ConnectionState
{
    IS_PENDING=0,
    IS_CONNECTING=1,
    IS_CONNECTED=2,
    IS_DISCONNECTING=3,
    IS_SILENTLY_DISCONNECTING=4,
    IS_DISCONNECTED=5,
    IS_NOT_CONNECTED=6
};

class RakNet::RakPeerInterface
{
    public class RakNet::RakPeerInterface * GetInstance();
    public void DestroyInstance(class RakNet::RakPeerInterface * );
    public void ~RakPeerInterface();
    public enum RakNet::StartupResult Startup(unsigned int ,struct RakNet::SocketDescriptor * ,unsigned int ,int );
    public bool InitializeSecurity(char * ,char * ,bool );
    public void DisableSecurity();
    public void AddToSecurityExceptionList(char * );
    public void RemoveFromSecurityExceptionList(char * );
    public bool IsInSecurityExceptionList(char * );
    public void SetMaximumIncomingConnections(unsigned int );
    public unsigned int GetMaximumIncomingConnections();
    public unsigned int NumberOfConnections();
    public void SetIncomingPassword(char * ,int );
    public void GetIncomingPassword(char * ,int * );
    public enum RakNet::ConnectionAttemptResult Connect(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public enum RakNet::ConnectionAttemptResult ConnectWithSocket(char * ,unsigned int ,char * ,int ,class RakNet::RakNetSocket2 * ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int );
    public void Shutdown(unsigned int ,unsigned int ,enum PacketPriority );
    public bool IsActive();
    public bool GetConnectionList(struct RakNet::SystemAddress * ,unsigned int * );
    public unsigned int GetNextSendReceipt();
    public unsigned int IncrementNextSendReceipt();
    public unsigned int Send(class RakNet::BitStream * ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public unsigned int Send(char * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public void SendLoopback(char * ,const int );
    public unsigned int SendList(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public struct RakNet::Packet * Receive();
    public void DeallocatePacket(struct RakNet::Packet * );
    public unsigned int GetMaximumNumberOfPeers();
    public void CloseConnection(const struct RakNet::AddressOrGUID ,bool ,unsigned int ,enum PacketPriority );
    public enum RakNet::ConnectionState GetConnectionState(const struct RakNet::AddressOrGUID );
    public void CancelConnectionAttempt(const struct RakNet::SystemAddress );
    public int GetIndexFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromIndex(unsigned int );
    public struct RakNet::RakNetGUID GetGUIDFromIndex(unsigned int );
    public void GetSystemList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & );
    public void AddToBanList(char * ,unsigned int );
    public void RemoveFromBanList(char * );
    public void ClearBanList();
    public bool IsBanned(char * );
    public void SetLimitIPConnectionFrequency(bool );
    public bool Ping(char * ,unsigned int ,bool ,unsigned int );
    public void Ping(const struct RakNet::SystemAddress );
    public int GetAveragePing(const struct RakNet::AddressOrGUID );
    public int GetLastPing(const struct RakNet::AddressOrGUID );
    public int GetLowestPing(const struct RakNet::AddressOrGUID );
    public void SetOccasionalPing(bool );
    public unsigned int GetClockDifferential(const struct RakNet::AddressOrGUID );
    public void SetOfflinePingResponse(char * ,const unsigned int );
    public void GetOfflinePingResponse(char ** ,unsigned int * );
    public struct RakNet::SystemAddress GetInternalID(const struct RakNet::SystemAddress ,const int );
    public void SetInternalID(struct RakNet::SystemAddress ,int );
    public struct RakNet::SystemAddress GetExternalID(const struct RakNet::SystemAddress );
    public const struct RakNet::RakNetGUID GetMyGUID();
    public struct RakNet::SystemAddress GetMyBoundAddress(const int );
    public unsigned int Get64BitUniqueRandomNumber();
    public struct RakNet::RakNetGUID & GetGuidFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromGuid(const struct RakNet::RakNetGUID );
    public bool GetClientPublicKeyFromSystemAddress(const struct RakNet::SystemAddress ,char * );
    public void SetTimeoutTime(unsigned int ,const struct RakNet::SystemAddress );
    public unsigned int GetTimeoutTime(const struct RakNet::SystemAddress );
    public int GetMTUSize(const struct RakNet::SystemAddress );
    public unsigned int GetNumberOfAddresses();
    public char * GetLocalIP(unsigned int );
    public bool IsLocalIP(char * );
    public void AllowConnectionResponseIPMigration(bool );
    public bool AdvertiseSystem(char * ,unsigned int ,char * ,int ,unsigned int );
    public void SetSplitMessageProgressInterval(int );
    public int GetSplitMessageProgressInterval();
    public void SetUnreliableTimeout(unsigned int );
    public void SendTTL(char * ,unsigned int ,int ,unsigned int );
    public void AttachPlugin(class RakNet::PluginInterface2 * );
    public void DetachPlugin(class RakNet::PluginInterface2 * );
    public void PushBackPacket(struct RakNet::Packet * ,bool );
    public void ChangeSystemAddress(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    public struct RakNet::Packet * AllocatePacket(unsigned int );
    public class RakNet::RakNetSocket2 * GetSocket(const struct RakNet::SystemAddress );
    public void GetSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void ReleaseSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void WriteOutOfBandHeader(class RakNet::BitStream * );
    public void SetUserUpdateThread(void  ( * )(class RakNet::RakPeerInterface * ,void * ),void * );
    public void SetIncomingDatagramEventHandler(bool  ( * )(struct RakNet::RNS2RecvStruct * ));
    public void ApplyNetworkSimulator(float ,unsigned int ,unsigned int );
    public void SetPerConnectionOutgoingBandwidthLimit(unsigned int );
    public bool IsNetworkSimulatorActive();
    public bool GetStatistics(const unsigned int ,struct RakNet::RakNetStatistics * );
    public struct RakNet::RakNetStatistics * GetStatistics(const struct RakNet::SystemAddress ,struct RakNet::RakNetStatistics * );
    public void GetStatisticsList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & ,class DataStructures::List<RakNet::RakNetStatistics> & );
    public unsigned int GetReceiveBufferSize();
    public bool RunUpdateCycle(class RakNet::BitStream & );
    public bool SendOutOfBand(char * ,unsigned int ,char * ,unsigned int ,unsigned int );
    public void RakPeerInterface(class RakNet::RakPeerInterface & );
    public void RakPeerInterface();
    public class RakNet::RakPeerInterface & operator=(class RakNet::RakPeerInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::SocketDescriptor
{
    void SocketDescriptor(unsigned int ,char * );
    void SocketDescriptor();
    unsigned int port;
    char hostAddress[32];
    int socketFamily;
    unsigned int remotePortRakNetWasStartedOn_PS3_PSP2;
    int chromeInstance;
    bool blockingSocket;
    unsigned int extraSocketOptions;
};

enum RakNet::PublicKeyMode
{
    PKM_INSECURE_CONNECTION=0,
    PKM_ACCEPT_ANY_PUBLIC_KEY=1,
    PKM_USE_KNOWN_PUBLIC_KEY=2,
    PKM_USE_TWO_WAY_AUTHENTICATION=3
};

struct RakNet::PublicKey
{
    enum RakNet::PublicKeyMode publicKeyMode;
    char * remoteServerPublicKey;
    char * myPublicKey;
    char * myPrivateKey;
};

class RakNet::RakNetSocket2
{
    public void RakNetSocket2(class RakNet::RakNetSocket2 & );
    public void RakNetSocket2();
    public void ~RakNetSocket2();
    public void SetRecvEventHandler(class RakNet::RNS2EventHandler * );
    public int Send(struct RakNet::RNS2_SendParameters * ,char * ,unsigned int );
    public enum RakNet::RNS2Type GetSocketType();
    public void SetSocketType(enum RakNet::RNS2Type );
    public bool IsBerkleySocket();
    public struct RakNet::SystemAddress GetBoundAddress();
    public unsigned int GetUserConnectionSocketIndex();
    public void SetUserConnectionSocketIndex(unsigned int );
    public class RakNet::RNS2EventHandler * GetEventHandler();
    public void GetMyIP(struct RakNet::SystemAddress * );
    public void DomainNameToIP(char * ,char * );
    protected class RakNet::RNS2EventHandler * eventHandler;
    protected enum RakNet::RNS2Type socketType;
    protected struct RakNet::SystemAddress boundAddress;
    protected unsigned int userConnectionSocketIndex;
    public class RakNet::RakNetSocket2 & operator=(class RakNet::RakNetSocket2 & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::RNS2Type
{
    RNS2T_WINDOWS_STORE_8=0,
    RNS2T_PS3=1,
    RNS2T_PS4=2,
    RNS2T_CHROME=3,
    RNS2T_VITA=4,
    RNS2T_XBOX_360=5,
    RNS2T_XBOX_720=6,
    RNS2T_WINDOWS=7,
    RNS2T_LINUX=8
};

class RakNet::RakNetSocket2
{
    public void RakNetSocket2(class RakNet::RakNetSocket2 & );
    public void RakNetSocket2();
    public void ~RakNetSocket2();
    public void SetRecvEventHandler(class RakNet::RNS2EventHandler * );
    public int Send(struct RakNet::RNS2_SendParameters * ,char * ,unsigned int );
    public enum RakNet::RNS2Type GetSocketType();
    public void SetSocketType(enum RakNet::RNS2Type );
    public bool IsBerkleySocket();
    public struct RakNet::SystemAddress GetBoundAddress();
    public unsigned int GetUserConnectionSocketIndex();
    public void SetUserConnectionSocketIndex(unsigned int );
    public class RakNet::RNS2EventHandler * GetEventHandler();
    public void GetMyIP(struct RakNet::SystemAddress * );
    public void DomainNameToIP(char * ,char * );
    protected class RakNet::RNS2EventHandler * eventHandler;
    protected enum RakNet::RNS2Type socketType;
    protected struct RakNet::SystemAddress boundAddress;
    protected unsigned int userConnectionSocketIndex;
    public class RakNet::RakNetSocket2 & operator=(class RakNet::RakNetSocket2 & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::BitStream
{
    public class RakNet::BitStream * GetInstance();
    public void DestroyInstance(class RakNet::BitStream * );
    private void BitStream(class RakNet::BitStream & );
    public void BitStream(unsigned int * ,const unsigned int ,bool );
    public void BitStream(const unsigned int );
    public void BitStream();
    public void ~BitStream();
    public void Reset();
    public bool Serialize(bool ,char * ,const unsigned int );
    public bool SerializeFloat16(bool ,float & ,float ,float );
    public bool SerializeBits(bool ,unsigned int * ,const unsigned int ,const bool );
    public void Write(const unsigned int * );
    public void Write(const char * );
    public void Write(const unsigned int * );
    public void Write(const wchar_t * );
    public void Write(const char * );
    public void Write(class RakNet::BitStream & );
    public void Write(class RakNet::BitStream & ,unsigned int );
    public void Write(class RakNet::BitStream * );
    public void Write(class RakNet::BitStream * ,unsigned int );
    public void Write(char * ,const unsigned int );
    private void WriteCompressed(unsigned int * ,const unsigned int ,const bool );
    public void WriteCompressed(const unsigned int * );
    public void WriteCompressed(const char * );
    public void WriteCompressed(const unsigned int * );
    public void WriteCompressed(const wchar_t * );
    public void WriteCompressed(const char * );
    public bool Read(unsigned int * );
    public bool Read(char * );
    public bool Read(char * ,const unsigned int );
    public bool Read(class RakNet::BitStream & );
    public bool Read(class RakNet::BitStream & ,unsigned int );
    public bool Read(class RakNet::BitStream * );
    public bool Read(class RakNet::BitStream * ,unsigned int );
    private bool ReadCompressed(unsigned int * ,const unsigned int ,const bool );
    public void WriteFloat16(float ,float ,float );
    public bool ReadFloat16(float & ,float ,float );
    public void ResetReadPointer();
    public void ResetWritePointer();
    public void AssertStreamEmpty();
    public void PrintBits();
    public void PrintBits(char * );
    public void PrintHex();
    public void PrintHex(char * );
    public void IgnoreBits(const unsigned int );
    public void IgnoreBytes(const unsigned int );
    public void SetWriteOffset(const unsigned int );
    public unsigned int GetNumberOfBitsUsed();
    public unsigned int GetWriteOffset();
    public unsigned int GetNumberOfBytesUsed();
    public unsigned int GetReadOffset();
    public void SetReadOffset(const unsigned int );
    public unsigned int GetNumberOfUnreadBits();
    public unsigned int CopyData(unsigned int ** );
    public void SetData(unsigned int * );
    public unsigned int * GetData();
    public void WriteBits(unsigned int * ,unsigned int ,const bool );
    public void WriteAlignedBytes(unsigned int * ,const unsigned int );
    public void EndianSwapBytes(int ,int );
    public void WriteAlignedBytesSafe(char * ,const unsigned int ,const unsigned int );
    public bool ReadAlignedBytes(unsigned int * ,const unsigned int );
    public bool ReadAlignedBytesSafe(char * ,unsigned int & ,const unsigned int );
    public bool ReadAlignedBytesSafe(char * ,int & ,const int );
    public bool ReadAlignedBytesSafeAlloc(char ** ,unsigned int & ,const unsigned int );
    public bool ReadAlignedBytesSafeAlloc(char ** ,int & ,const unsigned int );
    public void AlignWriteToByteBoundary();
    public void AlignReadToByteBoundary();
    public bool ReadBits(unsigned int * ,unsigned int ,const bool );
    public void Write0();
    public void Write1();
    public bool ReadBit();
    public void AssertCopyData();
    public void SetNumberOfBitsAllocated(const unsigned int );
    public void AddBitsAndReallocate(const unsigned int );
    public unsigned int GetNumberOfBitsAllocated();
    public void PadWithZeroToByteLength(unsigned int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(int );
    public int NumberOfLeadingZeroes(unsigned int );
    public int NumberOfLeadingZeroes(unsigned int );
    public int NumberOfLeadingZeroes(unsigned int );
    public int NumberOfLeadingZeroes(unsigned int );
    public void WriteAlignedVar8(char * );
    public bool ReadAlignedVar8(char * );
    public void WriteAlignedVar16(char * );
    public bool ReadAlignedVar16(char * );
    public void WriteAlignedVar32(char * );
    public bool ReadAlignedVar32(char * );
    public bool DoEndianSwap();
    public bool IsBigEndian();
    public bool IsNetworkOrder();
    public bool IsNetworkOrderInternal();
    public void ReverseBytes(unsigned int * ,unsigned int * ,const unsigned int );
    public void ReverseBytesInPlace(unsigned int * ,const unsigned int );
    private class RakNet::BitStream & operator=(class RakNet::BitStream & );
    private unsigned int numberOfBitsUsed;
    private unsigned int numberOfBitsAllocated;
    private unsigned int readOffset;
    private unsigned int * data;
    private bool copyData;
    private unsigned int stackData[256];
    public void * __vecDelDtor(unsigned int );
};

class RakNet::PluginInterface2
{
    public void PluginInterface2(class RakNet::PluginInterface2 & );
    public void PluginInterface2();
    public void ~PluginInterface2();
    public void OnAttach();
    public void OnDetach();
    public void Update();
    public enum RakNet::PluginReceiveResult OnReceive(struct RakNet::Packet * );
    public void OnRakPeerStartup();
    public void OnRakPeerShutdown();
    public void OnClosedConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,enum RakNet::PI2_LostConnectionReason );
    public void OnNewConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,bool );
    public void OnFailedConnectionAttempt(struct RakNet::Packet * ,enum RakNet::PI2_FailedConnectionAttemptReason );
    public bool UsesReliabilityLayer();
    public void OnDirectSocketSend(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnDirectSocketReceive(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnReliabilityLayerNotification(char * ,const unsigned int ,struct RakNet::SystemAddress ,bool );
    public void OnInternalPacket(struct RakNet::InternalPacket * ,unsigned int ,struct RakNet::SystemAddress ,unsigned int ,int );
    public void OnAck(unsigned int ,struct RakNet::SystemAddress ,unsigned int );
    public void OnPushBackPacket(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public class RakNet::RakPeerInterface * GetRakPeerInterface();
    public struct RakNet::RakNetGUID GetMyGUIDUnified();
    public void SetRakPeerInterface(class RakNet::RakPeerInterface * );
    public void SetTCPInterface(class RakNet::TCPInterface * );
    protected void SendUnified(char * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool );
    protected void SendUnified(class RakNet::BitStream * ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool );
    protected bool SendListUnified(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool );
    protected struct RakNet::Packet * AllocatePacketUnified(unsigned int );
    protected void PushBackPacketUnified(struct RakNet::Packet * ,bool );
    protected void DeallocPacketUnified(struct RakNet::Packet * );
    protected class RakNet::RakPeerInterface * rakPeerInterface;
    protected class RakNet::TCPInterface * tcpInterface;
    public class RakNet::PluginInterface2 & operator=(class RakNet::PluginInterface2 & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::PI2_LostConnectionReason
{
    LCR_CLOSED_BY_USER=0,
    LCR_DISCONNECTION_NOTIFICATION=1,
    LCR_CONNECTION_LOST=2
};

enum RakNet::PI2_FailedConnectionAttemptReason
{
    FCAR_CONNECTION_ATTEMPT_FAILED=0,
    FCAR_ALREADY_CONNECTED=1,
    FCAR_NO_FREE_INCOMING_CONNECTIONS=2,
    FCAR_SECURITY_PUBLIC_KEY_MISMATCH=3,
    FCAR_CONNECTION_BANNED=4,
    FCAR_INVALID_PASSWORD=5,
    FCAR_INCOMPATIBLE_PROTOCOL=6,
    FCAR_IP_RECENTLY_CONNECTED=7,
    FCAR_REMOTE_SYSTEM_REQUIRES_PUBLIC_KEY=8,
    FCAR_OUR_SYSTEM_REQUIRES_SECURITY=9,
    FCAR_PUBLIC_KEY_MISMATCH=10
};

class RakNet::PluginInterface2
{
    public void PluginInterface2(class RakNet::PluginInterface2 & );
    public void PluginInterface2();
    public void ~PluginInterface2();
    public void OnAttach();
    public void OnDetach();
    public void Update();
    public enum RakNet::PluginReceiveResult OnReceive(struct RakNet::Packet * );
    public void OnRakPeerStartup();
    public void OnRakPeerShutdown();
    public void OnClosedConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,enum RakNet::PI2_LostConnectionReason );
    public void OnNewConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,bool );
    public void OnFailedConnectionAttempt(struct RakNet::Packet * ,enum RakNet::PI2_FailedConnectionAttemptReason );
    public bool UsesReliabilityLayer();
    public void OnDirectSocketSend(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnDirectSocketReceive(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnReliabilityLayerNotification(char * ,const unsigned int ,struct RakNet::SystemAddress ,bool );
    public void OnInternalPacket(struct RakNet::InternalPacket * ,unsigned int ,struct RakNet::SystemAddress ,unsigned int ,int );
    public void OnAck(unsigned int ,struct RakNet::SystemAddress ,unsigned int );
    public void OnPushBackPacket(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public class RakNet::RakPeerInterface * GetRakPeerInterface();
    public struct RakNet::RakNetGUID GetMyGUIDUnified();
    public void SetRakPeerInterface(class RakNet::RakPeerInterface * );
    public void SetTCPInterface(class RakNet::TCPInterface * );
    protected void SendUnified(char * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool );
    protected void SendUnified(class RakNet::BitStream * ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool );
    protected bool SendListUnified(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool );
    protected struct RakNet::Packet * AllocatePacketUnified(unsigned int );
    protected void PushBackPacketUnified(struct RakNet::Packet * ,bool );
    protected void DeallocPacketUnified(struct RakNet::Packet * );
    protected class RakNet::RakPeerInterface * rakPeerInterface;
    protected class RakNet::TCPInterface * tcpInterface;
    public class RakNet::PluginInterface2 & operator=(class RakNet::PluginInterface2 & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct ServerInfo
{
    int gameVersion;
    class SString serverName;
    struct RakNet::SystemAddress serverAddress;
    unsigned int lastSeenTime;
    void operator=(struct ServerInfo & );
    void ServerInfo(struct ServerInfo & );
    void ServerInfo();
    void ~ServerInfo();
    void * __vecDelDtor(unsigned int );
};

struct ServerInfo
{
    int gameVersion;
    class SString serverName;
    struct RakNet::SystemAddress serverAddress;
    unsigned int lastSeenTime;
    void operator=(struct ServerInfo & );
    void ServerInfo(struct ServerInfo & );
    void ServerInfo();
    void ~ServerInfo();
    void * __vecDelDtor(unsigned int );
};

class LanDiscovery
{
    public void LanDiscovery(class LanDiscovery & );
    public void LanDiscovery(class ILanDiscoveryEventHandler * );
    public void ~LanDiscovery();
    public bool IsStarted();
    public void Update();
    private class RakNet::RakPeerInterface * peer;
    private int listenPort;
    private class Array<ServerInfo> serverList;
    private class ILanDiscoveryEventHandler * eventHandler;
    public class LanDiscovery & operator=(class LanDiscovery & );
    public void * __vecDelDtor(unsigned int );
};

class LanDiscovery
{
    public void LanDiscovery(class LanDiscovery & );
    public void LanDiscovery(class ILanDiscoveryEventHandler * );
    public void ~LanDiscovery();
    public bool IsStarted();
    public void Update();
    private class RakNet::RakPeerInterface * peer;
    private int listenPort;
    private class Array<ServerInfo> serverList;
    private class ILanDiscoveryEventHandler * eventHandler;
    public class LanDiscovery & operator=(class LanDiscovery & );
    public void * __vecDelDtor(unsigned int );
};

class ILanDiscoveryEventHandler
{
    public void OnUpdateServers(int ,struct ServerInfo * );
    public void ILanDiscoveryEventHandler(class ILanDiscoveryEventHandler * );
    public void ILanDiscoveryEventHandler(class ILanDiscoveryEventHandler & );
    public void ILanDiscoveryEventHandler();
    public class ILanDiscoveryEventHandler & operator=(class ILanDiscoveryEventHandler * );
    public class ILanDiscoveryEventHandler & operator=(class ILanDiscoveryEventHandler & );
};

class ILanDiscoveryEventHandler
{
    public void OnUpdateServers(int ,struct ServerInfo * );
    public void ILanDiscoveryEventHandler(class ILanDiscoveryEventHandler * );
    public void ILanDiscoveryEventHandler(class ILanDiscoveryEventHandler & );
    public void ILanDiscoveryEventHandler();
    public class ILanDiscoveryEventHandler & operator=(class ILanDiscoveryEventHandler * );
    public class ILanDiscoveryEventHandler & operator=(class ILanDiscoveryEventHandler & );
};

class Array<ServerInfo>
{
    public void Array<ServerInfo>(class Array<ServerInfo> * );
    public void Array<ServerInfo>(class Array<ServerInfo> & );
    public void Array<ServerInfo>();
    public void ~Array<ServerInfo>();
    public void operator=(class ArrayRef<ServerInfo> & );
    public void operator=(class Array<ServerInfo> * );
    public void operator=(class Array<ServerInfo> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct ServerInfo & operator[](unsigned int );
    public struct ServerInfo & operator[](unsigned int );
    public struct ServerInfo & GetLast();
    public struct ServerInfo & GetLast();
    public void Add(struct ServerInfo * );
    public void Add(struct ServerInfo & );
    public void Insert(unsigned int ,struct ServerInfo * );
    public void Insert(unsigned int ,struct ServerInfo & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct ServerInfo & );
    public void RemoveLast();
    public struct ServerInfo * begin();
    public struct ServerInfo * begin();
    public struct ServerInfo * end();
    public struct ServerInfo * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<ServerInfo> operator class ArrayRef<struct ServerInfo>();
    private struct ServerInfo * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct ServerInfo * Allocate(unsigned int );
    private void Deallocate(struct ServerInfo * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ReadIOBuffer
{
};

class WriteIOBuffer
{
};

class Array<ServerInfo>
{
    public void Array<ServerInfo>(class Array<ServerInfo> * );
    public void Array<ServerInfo>(class Array<ServerInfo> & );
    public void Array<ServerInfo>();
    public void ~Array<ServerInfo>();
    public void operator=(class ArrayRef<ServerInfo> & );
    public void operator=(class Array<ServerInfo> * );
    public void operator=(class Array<ServerInfo> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct ServerInfo & operator[](unsigned int );
    public struct ServerInfo & operator[](unsigned int );
    public struct ServerInfo & GetLast();
    public struct ServerInfo & GetLast();
    public void Add(struct ServerInfo * );
    public void Add(struct ServerInfo & );
    public void Insert(unsigned int ,struct ServerInfo * );
    public void Insert(unsigned int ,struct ServerInfo & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct ServerInfo & );
    public void RemoveLast();
    public struct ServerInfo * begin();
    public struct ServerInfo * begin();
    public struct ServerInfo * end();
    public struct ServerInfo * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<ServerInfo> operator class ArrayRef<struct ServerInfo>();
    private struct ServerInfo * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct ServerInfo * Allocate(unsigned int );
    private void Deallocate(struct ServerInfo * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RakString
{
    public void RakString(struct RakNet::RakString::SharedString * );
    public void RakString(class RakNet::RakString & );
    public void RakString(char * ,<btNoType> );
    public void RakString(unsigned int * ,<btNoType> );
    public void RakString(unsigned int );
    public void RakString(char );
    public void RakString();
    public void ~RakString();
    public char * operator const char *();
    public char * C_String();
    public char * C_StringUnsafe();
    public class RakNet::RakString & operator=(const char );
    public class RakNet::RakString & operator=(unsigned int * );
    public class RakNet::RakString & operator=(unsigned int * );
    public class RakNet::RakString & operator=(char * );
    public class RakNet::RakString & operator=(char * );
    public class RakNet::RakString & operator=(class RakNet::RakString & );
    public class RakNet::RakString & operator+=(const char );
    public class RakNet::RakString & operator+=(unsigned int * );
    public class RakNet::RakString & operator+=(unsigned int * );
    public class RakNet::RakString & operator+=(char * );
    public class RakNet::RakString & operator+=(char * );
    public class RakNet::RakString & operator+=(class RakNet::RakString & );
    public unsigned int operator[](const unsigned int );
    public wchar_t * ToWideChar();
    public void DeallocWideChar(wchar_t * );
    public void FromWideChar(wchar_t * );
    public class RakNet::RakString FromWideChar_S(wchar_t * );
    public unsigned int Find(char * ,unsigned int );
    public bool operator==(char * );
    public bool operator==(char * );
    public bool operator==(class RakNet::RakString & );
    public bool operator<(class RakNet::RakString & );
    public bool operator<=(class RakNet::RakString & );
    public bool operator>(class RakNet::RakString & );
    public bool operator>=(class RakNet::RakString & );
    public bool operator!=(char * );
    public bool operator!=(char * );
    public bool operator!=(class RakNet::RakString & );
    protected unsigned int ToLower(unsigned int );
    public char * ToLower();
    protected unsigned int ToUpper(unsigned int );
    public char * ToUpper();
    public void Set(char * ,<btNoType> );
    protected void Assign(char * ,char * );
    protected void Assign(char * );
    public class RakNet::RakString Assign(char * ,unsigned int ,unsigned int );
    public bool IsEmpty();
    public unsigned int GetLength();
    public unsigned int GetLengthUTF8();
    public void Replace(unsigned int ,unsigned int ,unsigned int );
    public void SetChar(unsigned int ,class RakNet::RakString );
    public void SetChar(unsigned int ,unsigned int );
    public void Truncate(unsigned int );
    public void TruncateUTF8(unsigned int );
    public class RakNet::RakString SubStr(unsigned int ,unsigned int );
    public void Erase(unsigned int ,unsigned int );
    public void TerminateAtFirstCharacter(char );
    public void TerminateAtLastCharacter(char );
    public void StartAfterFirstCharacter(char );
    public void StartAfterLastCharacter(char );
    public int GetCharacterCount(char );
    public void RemoveCharacter(char );
    public class RakNet::RakString NonVariadic(char * );
    public unsigned long ToInteger(class RakNet::RakString & );
    public unsigned long ToInteger(char * );
    public int ReadIntFromSubstring(char * ,unsigned int ,unsigned int );
    public void AppendBytes(char * ,unsigned int );
    public int StrCmp(class RakNet::RakString & );
    public int StrNCmp(class RakNet::RakString & ,unsigned int );
    public int StrICmp(class RakNet::RakString & );
    public void Clear();
    public void Printf();
    public void FPrintf(struct _iobuf * );
    public bool IPAddressMatch(char * );
    public bool ContainsNonprintableExceptSpaces();
    public bool IsEmailAddress();
    public class RakNet::RakString & URLEncode();
    public class RakNet::RakString & URLDecode();
    public void SplitURI(class RakNet::RakString & ,class RakNet::RakString & ,class RakNet::RakString & );
    public class RakNet::RakString & SQLEscape();
    public class RakNet::RakString FormatForPOST(char * ,char * ,char * ,char * );
    public class RakNet::RakString FormatForPUT(char * ,char * ,char * ,char * );
    public class RakNet::RakString FormatForGET(char * ,char * );
    public class RakNet::RakString FormatForDELETE(char * ,char * );
    public class RakNet::RakString & MakeFilePath();
    public void FreeMemory();
    public void FreeMemoryNoMutex();
    public void Serialize(char * ,class RakNet::BitStream * );
    public void Serialize(class RakNet::BitStream * );
    public void SerializeCompressed(char * ,class RakNet::BitStream * ,unsigned int ,bool );
    public void SerializeCompressed(class RakNet::BitStream * ,unsigned int ,bool );
    public bool Deserialize(char * ,class RakNet::BitStream * );
    public bool Deserialize(class RakNet::BitStream * );
    public bool DeserializeCompressed(char * ,class RakNet::BitStream * ,bool );
    public bool DeserializeCompressed(class RakNet::BitStream * ,bool );
    public char * ToString(unsigned int );
    public char * ToString(int );
    public unsigned int GetSizeToAllocate(unsigned int );
    struct SharedString
    {
        class RakNet::SimpleMutex * refCountMutex;
        unsigned int refCount;
        unsigned int bytesUsed;
        char * bigString;
        char * c_str;
        char smallString[112];
    };
    public struct RakNet::RakString::SharedString * sharedString;
    public struct RakNet::RakString::SharedString emptyString;
    public class DataStructures::List<RakNet::RakString::SharedString *> freeList;
    public int RakStringComp(class RakNet::RakString & ,class RakNet::RakString & );
    public void LockMutex();
    public void UnlockMutex();
    protected class RakNet::RakString FormatForPUTOrPost(char * ,char * ,char * ,char * ,char * );
    protected void Allocate(unsigned int );
    protected void Clone();
    protected void Free();
    protected void Realloc(struct RakNet::RakString::SharedString * ,unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RakString
{
    public void RakString(struct RakNet::RakString::SharedString * );
    public void RakString(class RakNet::RakString & );
    public void RakString(char * ,<btNoType> );
    public void RakString(unsigned int * ,<btNoType> );
    public void RakString(unsigned int );
    public void RakString(char );
    public void RakString();
    public void ~RakString();
    public char * operator const char *();
    public char * C_String();
    public char * C_StringUnsafe();
    public class RakNet::RakString & operator=(const char );
    public class RakNet::RakString & operator=(unsigned int * );
    public class RakNet::RakString & operator=(unsigned int * );
    public class RakNet::RakString & operator=(char * );
    public class RakNet::RakString & operator=(char * );
    public class RakNet::RakString & operator=(class RakNet::RakString & );
    public class RakNet::RakString & operator+=(const char );
    public class RakNet::RakString & operator+=(unsigned int * );
    public class RakNet::RakString & operator+=(unsigned int * );
    public class RakNet::RakString & operator+=(char * );
    public class RakNet::RakString & operator+=(char * );
    public class RakNet::RakString & operator+=(class RakNet::RakString & );
    public unsigned int operator[](const unsigned int );
    public wchar_t * ToWideChar();
    public void DeallocWideChar(wchar_t * );
    public void FromWideChar(wchar_t * );
    public class RakNet::RakString FromWideChar_S(wchar_t * );
    public unsigned int Find(char * ,unsigned int );
    public bool operator==(char * );
    public bool operator==(char * );
    public bool operator==(class RakNet::RakString & );
    public bool operator<(class RakNet::RakString & );
    public bool operator<=(class RakNet::RakString & );
    public bool operator>(class RakNet::RakString & );
    public bool operator>=(class RakNet::RakString & );
    public bool operator!=(char * );
    public bool operator!=(char * );
    public bool operator!=(class RakNet::RakString & );
    protected unsigned int ToLower(unsigned int );
    public char * ToLower();
    protected unsigned int ToUpper(unsigned int );
    public char * ToUpper();
    public void Set(char * ,<btNoType> );
    protected void Assign(char * ,char * );
    protected void Assign(char * );
    public class RakNet::RakString Assign(char * ,unsigned int ,unsigned int );
    public bool IsEmpty();
    public unsigned int GetLength();
    public unsigned int GetLengthUTF8();
    public void Replace(unsigned int ,unsigned int ,unsigned int );
    public void SetChar(unsigned int ,class RakNet::RakString );
    public void SetChar(unsigned int ,unsigned int );
    public void Truncate(unsigned int );
    public void TruncateUTF8(unsigned int );
    public class RakNet::RakString SubStr(unsigned int ,unsigned int );
    public void Erase(unsigned int ,unsigned int );
    public void TerminateAtFirstCharacter(char );
    public void TerminateAtLastCharacter(char );
    public void StartAfterFirstCharacter(char );
    public void StartAfterLastCharacter(char );
    public int GetCharacterCount(char );
    public void RemoveCharacter(char );
    public class RakNet::RakString NonVariadic(char * );
    public unsigned long ToInteger(class RakNet::RakString & );
    public unsigned long ToInteger(char * );
    public int ReadIntFromSubstring(char * ,unsigned int ,unsigned int );
    public void AppendBytes(char * ,unsigned int );
    public int StrCmp(class RakNet::RakString & );
    public int StrNCmp(class RakNet::RakString & ,unsigned int );
    public int StrICmp(class RakNet::RakString & );
    public void Clear();
    public void Printf();
    public void FPrintf(struct _iobuf * );
    public bool IPAddressMatch(char * );
    public bool ContainsNonprintableExceptSpaces();
    public bool IsEmailAddress();
    public class RakNet::RakString & URLEncode();
    public class RakNet::RakString & URLDecode();
    public void SplitURI(class RakNet::RakString & ,class RakNet::RakString & ,class RakNet::RakString & );
    public class RakNet::RakString & SQLEscape();
    public class RakNet::RakString FormatForPOST(char * ,char * ,char * ,char * );
    public class RakNet::RakString FormatForPUT(char * ,char * ,char * ,char * );
    public class RakNet::RakString FormatForGET(char * ,char * );
    public class RakNet::RakString FormatForDELETE(char * ,char * );
    public class RakNet::RakString & MakeFilePath();
    public void FreeMemory();
    public void FreeMemoryNoMutex();
    public void Serialize(char * ,class RakNet::BitStream * );
    public void Serialize(class RakNet::BitStream * );
    public void SerializeCompressed(char * ,class RakNet::BitStream * ,unsigned int ,bool );
    public void SerializeCompressed(class RakNet::BitStream * ,unsigned int ,bool );
    public bool Deserialize(char * ,class RakNet::BitStream * );
    public bool Deserialize(class RakNet::BitStream * );
    public bool DeserializeCompressed(char * ,class RakNet::BitStream * ,bool );
    public bool DeserializeCompressed(class RakNet::BitStream * ,bool );
    public char * ToString(unsigned int );
    public char * ToString(int );
    public unsigned int GetSizeToAllocate(unsigned int );
    struct SharedString
    {
        class RakNet::SimpleMutex * refCountMutex;
        unsigned int refCount;
        unsigned int bytesUsed;
        char * bigString;
        char * c_str;
        char smallString[112];
    };
    public struct RakNet::RakString::SharedString * sharedString;
    public struct RakNet::RakString::SharedString emptyString;
    public class DataStructures::List<RakNet::RakString::SharedString *> freeList;
    public int RakStringComp(class RakNet::RakString & ,class RakNet::RakString & );
    public void LockMutex();
    public void UnlockMutex();
    protected class RakNet::RakString FormatForPUTOrPost(char * ,char * ,char * ,char * ,char * );
    protected void Allocate(unsigned int );
    protected void Clone();
    protected void Free();
    protected void Realloc(struct RakNet::RakString::SharedString * ,unsigned int );
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::RakString::SharedString
{
    class RakNet::SimpleMutex * refCountMutex;
    unsigned int refCount;
    unsigned int bytesUsed;
    char * bigString;
    char * c_str;
    char smallString[112];
};

class RakNet::SimpleMutex
{
    public void SimpleMutex();
    public void ~SimpleMutex();
    public void Lock();
    public void Unlock();
    private void Init();
    private struct _RTL_CRITICAL_SECTION criticalSection;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RakWString
{
    public void RakWString(char * );
    public void RakWString(class RakNet::RakWString & );
    public void RakWString(wchar_t * );
    public void RakWString(class RakNet::RakString & );
    public void RakWString();
    public void ~RakWString();
    public wchar_t * operator wchar_t *();
    public wchar_t * C_String();
    public class RakNet::RakWString & operator=(char * );
    public class RakNet::RakWString & operator=(const char * );
    public class RakNet::RakWString & operator=(wchar_t * );
    public class RakNet::RakWString & operator=(const wchar_t * );
    public class RakNet::RakWString & operator=(class RakNet::RakString & );
    public class RakNet::RakWString & operator=(class RakNet::RakWString & );
    public class RakNet::RakWString & operator+=(wchar_t * );
    public class RakNet::RakWString & operator+=(const wchar_t * );
    public class RakNet::RakWString & operator+=(class RakNet::RakWString & );
    public bool operator==(class RakNet::RakWString & );
    public bool operator<(class RakNet::RakWString & );
    public bool operator<=(class RakNet::RakWString & );
    public bool operator>(class RakNet::RakWString & );
    public bool operator>=(class RakNet::RakWString & );
    public bool operator!=(class RakNet::RakWString & );
    public void Set(wchar_t * );
    public bool IsEmpty();
    public unsigned int GetLength();
    public unsigned long ToInteger(class RakNet::RakWString & );
    public int StrCmp(class RakNet::RakWString & );
    public int StrICmp(class RakNet::RakWString & );
    public void Clear();
    public void Printf();
    public void FPrintf(struct _iobuf * );
    public void Serialize(const wchar_t * ,class RakNet::BitStream * );
    public void Serialize(class RakNet::BitStream * );
    public bool Deserialize(wchar_t * ,class RakNet::BitStream * );
    public bool Deserialize(class RakNet::BitStream * );
    protected wchar_t * c_str;
    protected unsigned int c_strCharLength;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RakWString
{
    public void RakWString(char * );
    public void RakWString(class RakNet::RakWString & );
    public void RakWString(wchar_t * );
    public void RakWString(class RakNet::RakString & );
    public void RakWString();
    public void ~RakWString();
    public wchar_t * operator wchar_t *();
    public wchar_t * C_String();
    public class RakNet::RakWString & operator=(char * );
    public class RakNet::RakWString & operator=(const char * );
    public class RakNet::RakWString & operator=(wchar_t * );
    public class RakNet::RakWString & operator=(const wchar_t * );
    public class RakNet::RakWString & operator=(class RakNet::RakString & );
    public class RakNet::RakWString & operator=(class RakNet::RakWString & );
    public class RakNet::RakWString & operator+=(wchar_t * );
    public class RakNet::RakWString & operator+=(const wchar_t * );
    public class RakNet::RakWString & operator+=(class RakNet::RakWString & );
    public bool operator==(class RakNet::RakWString & );
    public bool operator<(class RakNet::RakWString & );
    public bool operator<=(class RakNet::RakWString & );
    public bool operator>(class RakNet::RakWString & );
    public bool operator>=(class RakNet::RakWString & );
    public bool operator!=(class RakNet::RakWString & );
    public void Set(wchar_t * );
    public bool IsEmpty();
    public unsigned int GetLength();
    public unsigned long ToInteger(class RakNet::RakWString & );
    public int StrCmp(class RakNet::RakWString & );
    public int StrICmp(class RakNet::RakWString & );
    public void Clear();
    public void Printf();
    public void FPrintf(struct _iobuf * );
    public void Serialize(const wchar_t * ,class RakNet::BitStream * );
    public void Serialize(class RakNet::BitStream * );
    public bool Deserialize(wchar_t * ,class RakNet::BitStream * );
    public bool Deserialize(class RakNet::BitStream * );
    protected wchar_t * c_str;
    protected unsigned int c_strCharLength;
    public void * __vecDelDtor(unsigned int );
};

struct in_addr::<unnamed-type-S_un>::<unnamed-type-S_un_b>
{
    unsigned int s_b1;
    unsigned int s_b2;
    unsigned int s_b3;
    unsigned int s_b4;
};

struct in_addr::<unnamed-type-S_un>::<unnamed-type-S_un_w>
{
    unsigned int s_w1;
    unsigned int s_w2;
};

struct FileListNodeContext
{
    void FileListNodeContext(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void FileListNodeContext();
    void ~FileListNodeContext();
    unsigned int op;
    unsigned int flnc_extraData1;
    unsigned int flnc_extraData2;
    unsigned int flnc_extraData3;
    void * dataPtr;
    unsigned int dataLength;
    void * __vecDelDtor(unsigned int );
};

class RakNet::FileListProgress
{
    public class RakNet::FileListProgress * GetInstance();
    public void DestroyInstance(class RakNet::FileListProgress * );
    public void FileListProgress(class RakNet::FileListProgress & );
    public void FileListProgress();
    public void ~FileListProgress();
    public void OnAddFilesFromDirectoryStarted(class RakNet::FileList * ,char * );
    public void OnDirectory(class RakNet::FileList * ,char * ,unsigned int );
    public void OnFile(class RakNet::FileList * ,char * ,char * ,unsigned int );
    public void OnFilePush(char * ,unsigned int ,unsigned int ,unsigned int ,bool ,struct RakNet::SystemAddress ,unsigned int );
    public void OnFilePushesComplete(struct RakNet::SystemAddress ,unsigned int );
    public void OnSendAborted(struct RakNet::SystemAddress );
    public class RakNet::FileListProgress & operator=(class RakNet::FileListProgress & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileListProgress
{
    public class RakNet::FileListProgress * GetInstance();
    public void DestroyInstance(class RakNet::FileListProgress * );
    public void FileListProgress(class RakNet::FileListProgress & );
    public void FileListProgress();
    public void ~FileListProgress();
    public void OnAddFilesFromDirectoryStarted(class RakNet::FileList * ,char * );
    public void OnDirectory(class RakNet::FileList * ,char * ,unsigned int );
    public void OnFile(class RakNet::FileList * ,char * ,char * ,unsigned int );
    public void OnFilePush(char * ,unsigned int ,unsigned int ,unsigned int ,bool ,struct RakNet::SystemAddress ,unsigned int );
    public void OnFilePushesComplete(struct RakNet::SystemAddress ,unsigned int );
    public void OnSendAborted(struct RakNet::SystemAddress );
    public class RakNet::FileListProgress & operator=(class RakNet::FileListProgress & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::FileListNode>
{
    public void List<RakNet::FileListNode>(class DataStructures::List<RakNet::FileListNode> & );
    public void List<RakNet::FileListNode>();
    public void ~List<RakNet::FileListNode>();
    public class DataStructures::List<RakNet::FileListNode> & operator=(class DataStructures::List<RakNet::FileListNode> & );
    public struct RakNet::FileListNode & operator[](const unsigned int );
    public struct RakNet::FileListNode & Get(const unsigned int );
    public void Push(struct RakNet::FileListNode & ,char * ,unsigned int );
    public struct RakNet::FileListNode & Pop();
    public void Insert(struct RakNet::FileListNode & ,char * ,unsigned int );
    public void Insert(struct RakNet::FileListNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::FileListNode & );
    public void Replace(struct RakNet::FileListNode & ,const struct RakNet::FileListNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::FileListNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::FileListNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListNode
{
    class RakNet::RakString filename;
    class RakNet::RakString fullPathToFile;
    char * data;
    unsigned int dataLengthBytes;
    unsigned int fileLengthBytes;
    struct FileListNodeContext context;
    bool isAReference;
    void FileListNode(struct RakNet::FileListNode * );
    void FileListNode(struct RakNet::FileListNode & );
    void FileListNode();
    void ~FileListNode();
    struct RakNet::FileListNode & operator=(struct RakNet::FileListNode * );
    struct RakNet::FileListNode & operator=(struct RakNet::FileListNode & );
    void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::FileListNode>
{
    public void List<RakNet::FileListNode>(class DataStructures::List<RakNet::FileListNode> & );
    public void List<RakNet::FileListNode>();
    public void ~List<RakNet::FileListNode>();
    public class DataStructures::List<RakNet::FileListNode> & operator=(class DataStructures::List<RakNet::FileListNode> & );
    public struct RakNet::FileListNode & operator[](const unsigned int );
    public struct RakNet::FileListNode & Get(const unsigned int );
    public void Push(struct RakNet::FileListNode & ,char * ,unsigned int );
    public struct RakNet::FileListNode & Pop();
    public void Insert(struct RakNet::FileListNode & ,char * ,unsigned int );
    public void Insert(struct RakNet::FileListNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::FileListNode & );
    public void Replace(struct RakNet::FileListNode & ,const struct RakNet::FileListNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::FileListNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::FileListNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileList
{
    public class RakNet::FileList * GetInstance();
    public void DestroyInstance(class RakNet::FileList * );
    public void FileList(class RakNet::FileList & );
    public void FileList();
    public void ~FileList();
    public void AddFilesFromDirectory(char * ,char * ,bool ,bool ,bool ,struct FileListNodeContext );
    public void Clear();
    public void Serialize(class RakNet::BitStream * );
    public bool Deserialize(class RakNet::BitStream * );
    public void ListMissingOrChangedFiles(char * ,class RakNet::FileList * ,bool ,bool );
    public void GetDeltaToCurrent(class RakNet::FileList * ,class RakNet::FileList * ,char * ,char * );
    public void PopulateDataFromDisk(char * ,bool ,bool ,bool );
    public void FlagFilesAsReferences();
    public void WriteDataToDisk(char * );
    public void AddFile(char * ,char * ,struct FileListNodeContext );
    public void AddFile(char * ,char * ,char * ,const unsigned int ,const unsigned int ,struct FileListNodeContext ,bool ,bool );
    public void DeleteFiles(char * );
    public void AddCallback(class RakNet::FileListProgress * );
    public void RemoveCallback(class RakNet::FileListProgress * );
    public void ClearCallbacks();
    public void GetCallbacks(class DataStructures::List<RakNet::FileListProgress *> & );
    public class DataStructures::List<RakNet::FileListNode> fileList;
    public bool FixEndingSlash(char * );
    protected class DataStructures::List<RakNet::FileListProgress *> fileListProgressCallbacks;
    public class RakNet::FileList & operator=(class RakNet::FileList & );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileList
{
    public class RakNet::FileList * GetInstance();
    public void DestroyInstance(class RakNet::FileList * );
    public void FileList(class RakNet::FileList & );
    public void FileList();
    public void ~FileList();
    public void AddFilesFromDirectory(char * ,char * ,bool ,bool ,bool ,struct FileListNodeContext );
    public void Clear();
    public void Serialize(class RakNet::BitStream * );
    public bool Deserialize(class RakNet::BitStream * );
    public void ListMissingOrChangedFiles(char * ,class RakNet::FileList * ,bool ,bool );
    public void GetDeltaToCurrent(class RakNet::FileList * ,class RakNet::FileList * ,char * ,char * );
    public void PopulateDataFromDisk(char * ,bool ,bool ,bool );
    public void FlagFilesAsReferences();
    public void WriteDataToDisk(char * );
    public void AddFile(char * ,char * ,struct FileListNodeContext );
    public void AddFile(char * ,char * ,char * ,const unsigned int ,const unsigned int ,struct FileListNodeContext ,bool ,bool );
    public void DeleteFiles(char * );
    public void AddCallback(class RakNet::FileListProgress * );
    public void RemoveCallback(class RakNet::FileListProgress * );
    public void ClearCallbacks();
    public void GetCallbacks(class DataStructures::List<RakNet::FileListProgress *> & );
    public class DataStructures::List<RakNet::FileListNode> fileList;
    public bool FixEndingSlash(char * );
    protected class DataStructures::List<RakNet::FileListProgress *> fileListProgressCallbacks;
    public class RakNet::FileList & operator=(class RakNet::FileList & );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FLP_Printf : public RakNet::FileListProgress
{
    public class RakNet::FLP_Printf * GetInstance();
    public void DestroyInstance(class RakNet::FLP_Printf * );
    public void FLP_Printf(class RakNet::FLP_Printf & );
    public void FLP_Printf();
    public void ~FLP_Printf();
    public void OnAddFilesFromDirectoryStarted(class RakNet::FileList * ,char * );
    public void OnDirectory(class RakNet::FileList * ,char * ,unsigned int );
    public void OnFilePushesComplete(struct RakNet::SystemAddress ,unsigned int );
    public void OnSendAborted(struct RakNet::SystemAddress );
    public class RakNet::FLP_Printf & operator=(class RakNet::FLP_Printf & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FLP_Printf : public RakNet::FileListProgress
{
    public class RakNet::FLP_Printf * GetInstance();
    public void DestroyInstance(class RakNet::FLP_Printf * );
    public void FLP_Printf(class RakNet::FLP_Printf & );
    public void FLP_Printf();
    public void ~FLP_Printf();
    public void OnAddFilesFromDirectoryStarted(class RakNet::FileList * ,char * );
    public void OnDirectory(class RakNet::FileList * ,char * ,unsigned int );
    public void OnFilePushesComplete(struct RakNet::SystemAddress ,unsigned int );
    public void OnSendAborted(struct RakNet::SystemAddress );
    public class RakNet::FLP_Printf & operator=(class RakNet::FLP_Printf & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class ThreadDataInterface
{
    public void ThreadDataInterface(class ThreadDataInterface & );
    public void ThreadDataInterface();
    public void ~ThreadDataInterface();
    public void * PerThreadFactory(void * );
    public void PerThreadDestructor(void * ,void * );
    public class ThreadDataInterface & operator=(class ThreadDataInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class ThreadDataInterface
{
    public void ThreadDataInterface(class ThreadDataInterface & );
    public void ThreadDataInterface();
    public void ~ThreadDataInterface();
    public void * PerThreadFactory(void * );
    public void PerThreadDestructor(void * ,void * );
    public class ThreadDataInterface & operator=(class ThreadDataInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileListTransferCBInterface
{
    struct OnFileStruct
    {
        unsigned int fileIndex;
        char fileName[512];
        char * fileData;
        unsigned int byteLengthOfThisFile;
        unsigned int bytesDownloadedForThisFile;
        unsigned int setID;
        unsigned int numberOfFilesInThisSet;
        unsigned int byteLengthOfThisSet;
        unsigned int bytesDownloadedForThisSet;
        struct FileListNodeContext context;
        struct RakNet::SystemAddress senderSystemAddress;
        struct RakNet::RakNetGUID senderGuid;
        void OnFileStruct();
        void ~OnFileStruct();
        struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
        struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct & );
        void * __vecDelDtor(unsigned int );
    };
    struct FileProgressStruct
    {
        struct RakNet::FileListTransferCBInterface::OnFileStruct * onFileStruct;
        unsigned int partCount;
        unsigned int partTotal;
        unsigned int dataChunkLength;
        char * firstDataChunk;
        char * iriDataChunk;
        unsigned int iriWriteOffset;
        struct RakNet::SystemAddress senderSystemAddress;
        struct RakNet::RakNetGUID senderGuid;
        bool allocateIrIDataChunkAutomatically;
        void FileProgressStruct();
        struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
        struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct & );
    };
    struct DownloadCompleteStruct
    {
        unsigned int setID;
        unsigned int numberOfFilesInThisSet;
        unsigned int byteLengthOfThisSet;
        struct RakNet::SystemAddress senderSystemAddress;
        struct RakNet::RakNetGUID senderGuid;
        void DownloadCompleteStruct();
        struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct * );
        struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & );
    };
    public void FileListTransferCBInterface(class RakNet::FileListTransferCBInterface & );
    public void FileListTransferCBInterface();
    public void ~FileListTransferCBInterface();
    public bool OnFile(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
    public void OnFileProgress(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
    public bool Update();
    public bool OnDownloadComplete(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct * );
    public void OnDereference();
    public class RakNet::FileListTransferCBInterface & operator=(class RakNet::FileListTransferCBInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileListTransferCBInterface
{
    struct OnFileStruct
    {
        unsigned int fileIndex;
        char fileName[512];
        char * fileData;
        unsigned int byteLengthOfThisFile;
        unsigned int bytesDownloadedForThisFile;
        unsigned int setID;
        unsigned int numberOfFilesInThisSet;
        unsigned int byteLengthOfThisSet;
        unsigned int bytesDownloadedForThisSet;
        struct FileListNodeContext context;
        struct RakNet::SystemAddress senderSystemAddress;
        struct RakNet::RakNetGUID senderGuid;
        void OnFileStruct();
        void ~OnFileStruct();
        struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
        struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct & );
        void * __vecDelDtor(unsigned int );
    };
    struct FileProgressStruct
    {
        struct RakNet::FileListTransferCBInterface::OnFileStruct * onFileStruct;
        unsigned int partCount;
        unsigned int partTotal;
        unsigned int dataChunkLength;
        char * firstDataChunk;
        char * iriDataChunk;
        unsigned int iriWriteOffset;
        struct RakNet::SystemAddress senderSystemAddress;
        struct RakNet::RakNetGUID senderGuid;
        bool allocateIrIDataChunkAutomatically;
        void FileProgressStruct();
        struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
        struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct & );
    };
    struct DownloadCompleteStruct
    {
        unsigned int setID;
        unsigned int numberOfFilesInThisSet;
        unsigned int byteLengthOfThisSet;
        struct RakNet::SystemAddress senderSystemAddress;
        struct RakNet::RakNetGUID senderGuid;
        void DownloadCompleteStruct();
        struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct * );
        struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & );
    };
    public void FileListTransferCBInterface(class RakNet::FileListTransferCBInterface & );
    public void FileListTransferCBInterface();
    public void ~FileListTransferCBInterface();
    public bool OnFile(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
    public void OnFileProgress(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
    public bool Update();
    public bool OnDownloadComplete(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct * );
    public void OnDereference();
    public class RakNet::FileListTransferCBInterface & operator=(class RakNet::FileListTransferCBInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransferCBInterface::OnFileStruct
{
    unsigned int fileIndex;
    char fileName[512];
    char * fileData;
    unsigned int byteLengthOfThisFile;
    unsigned int bytesDownloadedForThisFile;
    unsigned int setID;
    unsigned int numberOfFilesInThisSet;
    unsigned int byteLengthOfThisSet;
    unsigned int bytesDownloadedForThisSet;
    struct FileListNodeContext context;
    struct RakNet::SystemAddress senderSystemAddress;
    struct RakNet::RakNetGUID senderGuid;
    void OnFileStruct();
    void ~OnFileStruct();
    struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
    struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransferCBInterface::OnFileStruct
{
    unsigned int fileIndex;
    char fileName[512];
    char * fileData;
    unsigned int byteLengthOfThisFile;
    unsigned int bytesDownloadedForThisFile;
    unsigned int setID;
    unsigned int numberOfFilesInThisSet;
    unsigned int byteLengthOfThisSet;
    unsigned int bytesDownloadedForThisSet;
    struct FileListNodeContext context;
    struct RakNet::SystemAddress senderSystemAddress;
    struct RakNet::RakNetGUID senderGuid;
    void OnFileStruct();
    void ~OnFileStruct();
    struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
    struct RakNet::FileListTransferCBInterface::OnFileStruct & operator=(struct RakNet::FileListTransferCBInterface::OnFileStruct & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransferCBInterface::FileProgressStruct
{
    struct RakNet::FileListTransferCBInterface::OnFileStruct * onFileStruct;
    unsigned int partCount;
    unsigned int partTotal;
    unsigned int dataChunkLength;
    char * firstDataChunk;
    char * iriDataChunk;
    unsigned int iriWriteOffset;
    struct RakNet::SystemAddress senderSystemAddress;
    struct RakNet::RakNetGUID senderGuid;
    bool allocateIrIDataChunkAutomatically;
    void FileProgressStruct();
    struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
    struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct & );
};

struct RakNet::FileListTransferCBInterface::FileProgressStruct
{
    struct RakNet::FileListTransferCBInterface::OnFileStruct * onFileStruct;
    unsigned int partCount;
    unsigned int partTotal;
    unsigned int dataChunkLength;
    char * firstDataChunk;
    char * iriDataChunk;
    unsigned int iriWriteOffset;
    struct RakNet::SystemAddress senderSystemAddress;
    struct RakNet::RakNetGUID senderGuid;
    bool allocateIrIDataChunkAutomatically;
    void FileProgressStruct();
    struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
    struct RakNet::FileListTransferCBInterface::FileProgressStruct & operator=(struct RakNet::FileListTransferCBInterface::FileProgressStruct & );
};

struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct
{
    unsigned int setID;
    unsigned int numberOfFilesInThisSet;
    unsigned int byteLengthOfThisSet;
    struct RakNet::SystemAddress senderSystemAddress;
    struct RakNet::RakNetGUID senderGuid;
    void DownloadCompleteStruct();
    struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct * );
    struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & );
};

struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct
{
    unsigned int setID;
    unsigned int numberOfFilesInThisSet;
    unsigned int byteLengthOfThisSet;
    struct RakNet::SystemAddress senderSystemAddress;
    struct RakNet::RakNetGUID senderGuid;
    void DownloadCompleteStruct();
    struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct * );
    struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & operator=(struct RakNet::FileListTransferCBInterface::DownloadCompleteStruct & );
};

struct RakNet::PunchthroughConfiguration
{
    void PunchthroughConfiguration();
    unsigned int TIME_BETWEEN_PUNCH_ATTEMPTS_INTERNAL;
    unsigned int TIME_BETWEEN_PUNCH_ATTEMPTS_EXTERNAL;
    int UDP_SENDS_PER_PORT_INTERNAL;
    int UDP_SENDS_PER_PORT_EXTERNAL;
    int INTERNAL_IP_WAIT_AFTER_ATTEMPTS;
    int MAX_PREDICTIVE_PORT_RANGE;
    int EXTERNAL_IP_WAIT_AFTER_FIRST_TTL;
    int EXTERNAL_IP_WAIT_BETWEEN_PORTS;
    int EXTERNAL_IP_WAIT_AFTER_ALL_ATTEMPTS;
    int MAXIMUM_NUMBER_OF_INTERNAL_IDS_TO_CHECK;
    bool retryOnFailure;
};

struct RakNet::NatPunchthroughDebugInterface
{
    void NatPunchthroughDebugInterface(struct RakNet::NatPunchthroughDebugInterface & );
    void NatPunchthroughDebugInterface();
    void ~NatPunchthroughDebugInterface();
    void OnClientMessage(char * );
    struct RakNet::NatPunchthroughDebugInterface & operator=(struct RakNet::NatPunchthroughDebugInterface & );
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughDebugInterface
{
    void NatPunchthroughDebugInterface(struct RakNet::NatPunchthroughDebugInterface & );
    void NatPunchthroughDebugInterface();
    void ~NatPunchthroughDebugInterface();
    void OnClientMessage(char * );
    struct RakNet::NatPunchthroughDebugInterface & operator=(struct RakNet::NatPunchthroughDebugInterface & );
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughDebugInterface_PacketLogger : public RakNet::NatPunchthroughDebugInterface
{
    class RakNet::PacketLogger * pl;
    void NatPunchthroughDebugInterface_PacketLogger(struct RakNet::NatPunchthroughDebugInterface_PacketLogger & );
    void NatPunchthroughDebugInterface_PacketLogger();
    void ~NatPunchthroughDebugInterface_PacketLogger();
    void OnClientMessage(char * );
    struct RakNet::NatPunchthroughDebugInterface_PacketLogger & operator=(struct RakNet::NatPunchthroughDebugInterface_PacketLogger & );
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughDebugInterface_PacketLogger : public RakNet::NatPunchthroughDebugInterface
{
    class RakNet::PacketLogger * pl;
    void NatPunchthroughDebugInterface_PacketLogger(struct RakNet::NatPunchthroughDebugInterface_PacketLogger & );
    void NatPunchthroughDebugInterface_PacketLogger();
    void ~NatPunchthroughDebugInterface_PacketLogger();
    void OnClientMessage(char * );
    struct RakNet::NatPunchthroughDebugInterface_PacketLogger & operator=(struct RakNet::NatPunchthroughDebugInterface_PacketLogger & );
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

enum ConnectionId
{
    Invalid=-1,
    MaxConnections=8
};

enum MessageType
{
    Guaranteed=0,
    NonSequential=1
};

class ConnectionManager
{
    public void ConnectionManager(class ConnectionManager & );
    public void ConnectionManager(class IConnectionManagerEventHandler * );
    public void ~ConnectionManager();
    public enum ConnectionId ConnectTo(struct RakNet::RakNetGUID );
    public enum ConnectionId ConnectTo(struct RakNet::SystemAddress );
    public void Disconnect(enum ConnectionId );
    public bool EnableNatPunchtrough();
    public bool IsNatPunchtroughAvailable();
    public void EnableLanBroadcast(char * ,int );
    public void DisableLanBroadcast();
    public void SetMaxPlayers(int );
    public void DisableIncomingConnections();
    public void Update();
    public void Send(enum ConnectionId ,void * ,int ,enum MessageType );
    public void SendFile(enum ConnectionId ,char * ,char * ,unsigned int );
    public unsigned int ReceiveFile(enum ConnectionId );
    public void StopReceiveFile(unsigned int );
    public int GetPing(enum ConnectionId );
    public unsigned int GetRaknetGuidForConnection(enum ConnectionId );
    public unsigned int GetMyRaknetGuid();
    public char * GetMyRaknetGuidAsString();
    public char * GetMyIp();
    public int GetListenPort();
    private class IConnectionManagerEventHandler * eventHandler;
    private class RakNet::RakPeerInterface * peer;
    private class RakNet::FileListTransfer fileListTransfer;
    private class RakNet::NatPunchthroughClient natPunchthroughClient;
    private struct RakNet::SystemAddress natPunchthroughServer;
    private enum ConnectionState natPunchthroughConnectionState;
    private bool enableNatPunchtrough;
    private int listenPort;
    private class SString serverName;
    private int gameVersion;
    private bool lanBroadcast;
    private bool isConnectionsLocked;
    private unsigned int lastBroadcastTime;
    private struct RakNet::RakNetGUID myGuid;
    private struct ConnectionInfo connections[8];
    class FileTransferCallback : public RakNet::FileListTransferCBInterface
    {
        public void FileTransferCallback(class ConnectionManager::FileTransferCallback * );
        public void FileTransferCallback(class ConnectionManager::FileTransferCallback & );
        public void FileTransferCallback(class ConnectionManager & );
        public bool OnFile(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
        public void OnFileProgress(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
        public class ConnectionManager & connectionManager;
        public void ~FileTransferCallback();
        public void * __vecDelDtor(unsigned int );
    };
    private class ConnectionManager::FileTransferCallback fileTransferCallback;
    class NatPunchthroughCallback : public RakNet::NatPunchthroughDebugInterface
    {
        public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback * );
        public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback & );
        public void NatPunchthroughCallback(class ConnectionManager & );
        public void OnClientMessage(char * );
        public class ConnectionManager & connectionManager;
        public void ~NatPunchthroughCallback();
        public void * __vecDelDtor(unsigned int );
    };
    private class ConnectionManager::NatPunchthroughCallback natPunchthroughCallback;
    private void CreatePeer();
    private int AddConnection(struct ConnectionInfo * );
    private int GetConnectionIndexFromSystemAddress(struct RakNet::SystemAddress );
    private int GetConnectionIndexFromGuid(struct RakNet::RakNetGUID );
    private void OnPeerConnected(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress );
    public void * __vecDelDtor(unsigned int );
};

enum ConnectionState
{
    Disconnected=0,
    Connecting=1,
    Connected=2
};

class ConnectionManager
{
    public void ConnectionManager(class ConnectionManager & );
    public void ConnectionManager(class IConnectionManagerEventHandler * );
    public void ~ConnectionManager();
    public enum ConnectionId ConnectTo(struct RakNet::RakNetGUID );
    public enum ConnectionId ConnectTo(struct RakNet::SystemAddress );
    public void Disconnect(enum ConnectionId );
    public bool EnableNatPunchtrough();
    public bool IsNatPunchtroughAvailable();
    public void EnableLanBroadcast(char * ,int );
    public void DisableLanBroadcast();
    public void SetMaxPlayers(int );
    public void DisableIncomingConnections();
    public void Update();
    public void Send(enum ConnectionId ,void * ,int ,enum MessageType );
    public void SendFile(enum ConnectionId ,char * ,char * ,unsigned int );
    public unsigned int ReceiveFile(enum ConnectionId );
    public void StopReceiveFile(unsigned int );
    public int GetPing(enum ConnectionId );
    public unsigned int GetRaknetGuidForConnection(enum ConnectionId );
    public unsigned int GetMyRaknetGuid();
    public char * GetMyRaknetGuidAsString();
    public char * GetMyIp();
    public int GetListenPort();
    private class IConnectionManagerEventHandler * eventHandler;
    private class RakNet::RakPeerInterface * peer;
    private class RakNet::FileListTransfer fileListTransfer;
    private class RakNet::NatPunchthroughClient natPunchthroughClient;
    private struct RakNet::SystemAddress natPunchthroughServer;
    private enum ConnectionState natPunchthroughConnectionState;
    private bool enableNatPunchtrough;
    private int listenPort;
    private class SString serverName;
    private int gameVersion;
    private bool lanBroadcast;
    private bool isConnectionsLocked;
    private unsigned int lastBroadcastTime;
    private struct RakNet::RakNetGUID myGuid;
    private struct ConnectionInfo connections[8];
    class FileTransferCallback : public RakNet::FileListTransferCBInterface
    {
        public void FileTransferCallback(class ConnectionManager::FileTransferCallback * );
        public void FileTransferCallback(class ConnectionManager::FileTransferCallback & );
        public void FileTransferCallback(class ConnectionManager & );
        public bool OnFile(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
        public void OnFileProgress(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
        public class ConnectionManager & connectionManager;
        public void ~FileTransferCallback();
        public void * __vecDelDtor(unsigned int );
    };
    private class ConnectionManager::FileTransferCallback fileTransferCallback;
    class NatPunchthroughCallback : public RakNet::NatPunchthroughDebugInterface
    {
        public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback * );
        public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback & );
        public void NatPunchthroughCallback(class ConnectionManager & );
        public void OnClientMessage(char * );
        public class ConnectionManager & connectionManager;
        public void ~NatPunchthroughCallback();
        public void * __vecDelDtor(unsigned int );
    };
    private class ConnectionManager::NatPunchthroughCallback natPunchthroughCallback;
    private void CreatePeer();
    private int AddConnection(struct ConnectionInfo * );
    private int GetConnectionIndexFromSystemAddress(struct RakNet::SystemAddress );
    private int GetConnectionIndexFromGuid(struct RakNet::RakNetGUID );
    private void OnPeerConnected(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress );
    public void * __vecDelDtor(unsigned int );
};

enum ConnectionFailedReason
{
    Failed=0,
    HostFull=1
};

class IConnectionManagerEventHandler
{
    public void OnConnectionSuccessful(enum ConnectionId ,unsigned int );
    public void OnConnectionFailed(enum ConnectionFailedReason );
    public void OnPeerConnected(enum ConnectionId ,unsigned int );
    public void OnDisconnected(unsigned int );
    public void OnMessage(enum ConnectionId ,unsigned int * ,int );
    public void OnFileDownloaded(char * ,unsigned int * ,int );
    public void OnFileProgress(int );
    public void IConnectionManagerEventHandler(class IConnectionManagerEventHandler * );
    public void IConnectionManagerEventHandler(class IConnectionManagerEventHandler & );
    public void IConnectionManagerEventHandler();
    public class IConnectionManagerEventHandler & operator=(class IConnectionManagerEventHandler * );
    public class IConnectionManagerEventHandler & operator=(class IConnectionManagerEventHandler & );
};

class IConnectionManagerEventHandler
{
    public void OnConnectionSuccessful(enum ConnectionId ,unsigned int );
    public void OnConnectionFailed(enum ConnectionFailedReason );
    public void OnPeerConnected(enum ConnectionId ,unsigned int );
    public void OnDisconnected(unsigned int );
    public void OnMessage(enum ConnectionId ,unsigned int * ,int );
    public void OnFileDownloaded(char * ,unsigned int * ,int );
    public void OnFileProgress(int );
    public void IConnectionManagerEventHandler(class IConnectionManagerEventHandler * );
    public void IConnectionManagerEventHandler(class IConnectionManagerEventHandler & );
    public void IConnectionManagerEventHandler();
    public class IConnectionManagerEventHandler & operator=(class IConnectionManagerEventHandler * );
    public class IConnectionManagerEventHandler & operator=(class IConnectionManagerEventHandler & );
};

class DataStructures::List<RakNet::FileListProgress *>
{
    public void List<RakNet::FileListProgress *>(class DataStructures::List<RakNet::FileListProgress *> & );
    public void List<RakNet::FileListProgress *>();
    public void ~List<RakNet::FileListProgress *>();
    public class DataStructures::List<RakNet::FileListProgress *> & operator=(class DataStructures::List<RakNet::FileListProgress *> & );
    public class RakNet::FileListProgress &** operator[](const unsigned int );
    public class RakNet::FileListProgress &** Get(const unsigned int );
    public void Push(class RakNet::FileListProgress &** ,char * ,unsigned int );
    public class RakNet::FileListProgress &** Pop();
    public void Insert(class RakNet::FileListProgress &** ,char * ,unsigned int );
    public void Insert(class RakNet::FileListProgress &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::FileListProgress &** );
    public void Replace(class RakNet::FileListProgress &** ,const class RakNet::FileListProgress * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::FileListProgress &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::FileListProgress ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::FileListProgress *>
{
    public void List<RakNet::FileListProgress *>(class DataStructures::List<RakNet::FileListProgress *> & );
    public void List<RakNet::FileListProgress *>();
    public void ~List<RakNet::FileListProgress *>();
    public class DataStructures::List<RakNet::FileListProgress *> & operator=(class DataStructures::List<RakNet::FileListProgress *> & );
    public class RakNet::FileListProgress &** operator[](const unsigned int );
    public class RakNet::FileListProgress &** Get(const unsigned int );
    public void Push(class RakNet::FileListProgress &** ,char * ,unsigned int );
    public class RakNet::FileListProgress &** Pop();
    public void Insert(class RakNet::FileListProgress &** ,char * ,unsigned int );
    public void Insert(class RakNet::FileListProgress &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::FileListProgress &** );
    public void Replace(class RakNet::FileListProgress &** ,const class RakNet::FileListProgress * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::FileListProgress &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::FileListProgress ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *>
{
    public void List<RakNet::FileListTransfer::FileToPushRecipient *>(class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> & );
    public void List<RakNet::FileListTransfer::FileToPushRecipient *>();
    public void ~List<RakNet::FileListTransfer::FileToPushRecipient *>();
    public class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> & operator=(class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> & );
    public struct RakNet::FileListTransfer::FileToPushRecipient &** operator[](const unsigned int );
    public struct RakNet::FileListTransfer::FileToPushRecipient &** Get(const unsigned int );
    public void Push(struct RakNet::FileListTransfer::FileToPushRecipient &** ,char * ,unsigned int );
    public struct RakNet::FileListTransfer::FileToPushRecipient &** Pop();
    public void Insert(struct RakNet::FileListTransfer::FileToPushRecipient &** ,char * ,unsigned int );
    public void Insert(struct RakNet::FileListTransfer::FileToPushRecipient &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::FileListTransfer::FileToPushRecipient &** );
    public void Replace(struct RakNet::FileListTransfer::FileToPushRecipient &** ,const struct RakNet::FileListTransfer::FileToPushRecipient * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::FileListTransfer::FileToPushRecipient &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::FileListTransfer::FileToPushRecipient ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *>
{
    public void List<RakNet::FileListTransfer::FileToPushRecipient *>(class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> & );
    public void List<RakNet::FileListTransfer::FileToPushRecipient *>();
    public void ~List<RakNet::FileListTransfer::FileToPushRecipient *>();
    public class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> & operator=(class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> & );
    public struct RakNet::FileListTransfer::FileToPushRecipient &** operator[](const unsigned int );
    public struct RakNet::FileListTransfer::FileToPushRecipient &** Get(const unsigned int );
    public void Push(struct RakNet::FileListTransfer::FileToPushRecipient &** ,char * ,unsigned int );
    public struct RakNet::FileListTransfer::FileToPushRecipient &** Pop();
    public void Insert(struct RakNet::FileListTransfer::FileToPushRecipient &** ,char * ,unsigned int );
    public void Insert(struct RakNet::FileListTransfer::FileToPushRecipient &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::FileListTransfer::FileToPushRecipient &** );
    public void Replace(struct RakNet::FileListTransfer::FileToPushRecipient &** ,const struct RakNet::FileListTransfer::FileToPushRecipient * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::FileListTransfer::FileToPushRecipient &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::FileListTransfer::FileToPushRecipient ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>
{
    public void Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>(class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)> & );
    public void Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>();
    public void ~Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>();
    public bool operator=(class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)> & );
    public void Push(int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ),char * ,unsigned int );
    public void PushAtHead(int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ),unsigned int ,char * ,unsigned int );
    public int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) Peek();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) PeekTail();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) Pop();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) PopTail();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ));
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private int  ( ** array)(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * );
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>
{
    public void Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>(class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)> & );
    public void Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>();
    public void ~Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)>();
    public bool operator=(class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)> & );
    public void Push(int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ),char * ,unsigned int );
    public void PushAtHead(int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ),unsigned int ,char * ,unsigned int );
    public int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) Peek();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) PeekTail();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) Pop();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) PopTail();
    public int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ) PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(int  ( &** )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ));
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private int  ( ** array)(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * );
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::FileListTransfer::ThreadData>
{
    public void Queue<RakNet::FileListTransfer::ThreadData>(class DataStructures::Queue<RakNet::FileListTransfer::ThreadData> & );
    public void Queue<RakNet::FileListTransfer::ThreadData>();
    public void ~Queue<RakNet::FileListTransfer::ThreadData>();
    public bool operator=(class DataStructures::Queue<RakNet::FileListTransfer::ThreadData> & );
    public void Push(struct RakNet::FileListTransfer::ThreadData & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::FileListTransfer::ThreadData & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::FileListTransfer::ThreadData & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::FileListTransfer::ThreadData Peek();
    public struct RakNet::FileListTransfer::ThreadData PeekTail();
    public struct RakNet::FileListTransfer::ThreadData Pop();
    public struct RakNet::FileListTransfer::ThreadData PopTail();
    public struct RakNet::FileListTransfer::ThreadData PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::FileListTransfer::ThreadData & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::FileListTransfer::ThreadData * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransfer::ThreadData
{
    class RakNet::FileListTransfer * fileListTransfer;
    struct RakNet::SystemAddress systemAddress;
    unsigned int setId;
    void ThreadData();
    struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData * );
    struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData & );
};

class DataStructures::Queue<RakNet::FileListTransfer::ThreadData>
{
    public void Queue<RakNet::FileListTransfer::ThreadData>(class DataStructures::Queue<RakNet::FileListTransfer::ThreadData> & );
    public void Queue<RakNet::FileListTransfer::ThreadData>();
    public void ~Queue<RakNet::FileListTransfer::ThreadData>();
    public bool operator=(class DataStructures::Queue<RakNet::FileListTransfer::ThreadData> & );
    public void Push(struct RakNet::FileListTransfer::ThreadData & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::FileListTransfer::ThreadData & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::FileListTransfer::ThreadData & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::FileListTransfer::ThreadData Peek();
    public struct RakNet::FileListTransfer::ThreadData PeekTail();
    public struct RakNet::FileListTransfer::ThreadData Pop();
    public struct RakNet::FileListTransfer::ThreadData PopTail();
    public struct RakNet::FileListTransfer::ThreadData PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::FileListTransfer::ThreadData & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::FileListTransfer::ThreadData * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<int>
{
    public void Queue<int>(class DataStructures::Queue<int> & );
    public void Queue<int>();
    public void ~Queue<int>();
    public bool operator=(class DataStructures::Queue<int> & );
    public void Push(int & ,char * ,unsigned int );
    public void PushAtHead(int & ,unsigned int ,char * ,unsigned int );
    public int & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public int Peek();
    public int PeekTail();
    public int Pop();
    public int PopTail();
    public int PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(int & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private int * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<int>
{
    public void Queue<int>(class DataStructures::Queue<int> & );
    public void Queue<int>();
    public void ~Queue<int>();
    public bool operator=(class DataStructures::Queue<int> & );
    public void Push(int & ,char * ,unsigned int );
    public void PushAtHead(int & ,unsigned int ,char * ,unsigned int );
    public int & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public int Peek();
    public int PeekTail();
    public int Pop();
    public int PopTail();
    public int PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(int & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private int * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::SignaledEvent
{
    public void SignaledEvent();
    public void ~SignaledEvent();
    public void InitEvent();
    public void CloseEvent();
    public void SetEvent();
    public void WaitOnEvent(int );
    protected void * eventList;
    public void * __vecDelDtor(unsigned int );
};

struct ThreadPool<RakNet::FileListTransfer::ThreadData,int>
{
    void ThreadPool<RakNet::FileListTransfer::ThreadData,int>(struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> & );
    void ThreadPool<RakNet::FileListTransfer::ThreadData,int>();
    void ~ThreadPool<RakNet::FileListTransfer::ThreadData,int>();
    bool StartThreads(int ,int ,void *  ( * )(),void  ( * )(void * ));
    void SetThreadDataInterface(class ThreadDataInterface * ,void * );
    void StopThreads();
    void AddInput(int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ),struct RakNet::FileListTransfer::ThreadData );
    void AddOutput(int );
    bool HasOutput();
    bool HasOutputFast();
    bool HasInput();
    bool HasInputFast();
    int GetOutput();
    void Clear();
    void LockInput();
    void UnlockInput();
    unsigned int InputSize();
    struct RakNet::FileListTransfer::ThreadData GetInputAtIndex(unsigned int );
    void RemoveInputAtIndex(unsigned int );
    void LockOutput();
    void UnlockOutput();
    unsigned int OutputSize();
    int GetOutputAtIndex(unsigned int );
    void RemoveOutputAtIndex(unsigned int );
    void ClearInput();
    void ClearOutput();
    bool IsWorking();
    int NumThreadsWorking();
    bool WasStarted();
    bool Pause();
    void Resume();
    class RakNet::SimpleMutex inputQueueMutex;
    class RakNet::SimpleMutex outputQueueMutex;
    class RakNet::SimpleMutex workingThreadCountMutex;
    class RakNet::SimpleMutex runThreadsMutex;
    void *  ( * perThreadDataFactory)();
    void  ( * perThreadDataDestructor)(void * );
    class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)> inputFunctionQueue;
    class DataStructures::Queue<RakNet::FileListTransfer::ThreadData> inputQueue;
    class DataStructures::Queue<int> outputQueue;
    class ThreadDataInterface * threadDataInterface;
    void * tdiContext;
    bool runThreads;
    int numThreadsRunning;
    int numThreadsWorking;
    class RakNet::SimpleMutex numThreadsRunningMutex;
    class RakNet::SignaledEvent quitAndIncomingDataEvents;
    struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> & operator=(struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> & );
    void * __vecDelDtor(unsigned int );
};

struct ThreadPool<RakNet::FileListTransfer::ThreadData,int>
{
    void ThreadPool<RakNet::FileListTransfer::ThreadData,int>(struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> & );
    void ThreadPool<RakNet::FileListTransfer::ThreadData,int>();
    void ~ThreadPool<RakNet::FileListTransfer::ThreadData,int>();
    bool StartThreads(int ,int ,void *  ( * )(),void  ( * )(void * ));
    void SetThreadDataInterface(class ThreadDataInterface * ,void * );
    void StopThreads();
    void AddInput(int  ( * )(struct RakNet::FileListTransfer::ThreadData ,bool * ,void * ),struct RakNet::FileListTransfer::ThreadData );
    void AddOutput(int );
    bool HasOutput();
    bool HasOutputFast();
    bool HasInput();
    bool HasInputFast();
    int GetOutput();
    void Clear();
    void LockInput();
    void UnlockInput();
    unsigned int InputSize();
    struct RakNet::FileListTransfer::ThreadData GetInputAtIndex(unsigned int );
    void RemoveInputAtIndex(unsigned int );
    void LockOutput();
    void UnlockOutput();
    unsigned int OutputSize();
    int GetOutputAtIndex(unsigned int );
    void RemoveOutputAtIndex(unsigned int );
    void ClearInput();
    void ClearOutput();
    bool IsWorking();
    int NumThreadsWorking();
    bool WasStarted();
    bool Pause();
    void Resume();
    class RakNet::SimpleMutex inputQueueMutex;
    class RakNet::SimpleMutex outputQueueMutex;
    class RakNet::SimpleMutex workingThreadCountMutex;
    class RakNet::SimpleMutex runThreadsMutex;
    void *  ( * perThreadDataFactory)();
    void  ( * perThreadDataDestructor)(void * );
    class DataStructures::Queue<int (__cdecl*)(RakNet::FileListTransfer::ThreadData,bool *,void *)> inputFunctionQueue;
    class DataStructures::Queue<RakNet::FileListTransfer::ThreadData> inputQueue;
    class DataStructures::Queue<int> outputQueue;
    class ThreadDataInterface * threadDataInterface;
    void * tdiContext;
    bool runThreads;
    int numThreadsRunning;
    int numThreadsWorking;
    class RakNet::SimpleMutex numThreadsRunningMutex;
    class RakNet::SignaledEvent quitAndIncomingDataEvents;
    struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> & operator=(struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListNode
{
    class RakNet::RakString filename;
    class RakNet::RakString fullPathToFile;
    char * data;
    unsigned int dataLengthBytes;
    unsigned int fileLengthBytes;
    struct FileListNodeContext context;
    bool isAReference;
    void FileListNode(struct RakNet::FileListNode * );
    void FileListNode(struct RakNet::FileListNode & );
    void FileListNode();
    void ~FileListNode();
    struct RakNet::FileListNode & operator=(struct RakNet::FileListNode * );
    struct RakNet::FileListNode & operator=(struct RakNet::FileListNode & );
    void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *>
{
    public void Queue<RakNet::FileListTransfer::FileToPush *>(class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> & );
    public void Queue<RakNet::FileListTransfer::FileToPush *>();
    public void ~Queue<RakNet::FileListTransfer::FileToPush *>();
    public bool operator=(class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> & );
    public void Push(struct RakNet::FileListTransfer::FileToPush &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::FileListTransfer::FileToPush &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::FileListTransfer::FileToPush &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::FileListTransfer::FileToPush * Peek();
    public struct RakNet::FileListTransfer::FileToPush * PeekTail();
    public struct RakNet::FileListTransfer::FileToPush * Pop();
    public struct RakNet::FileListTransfer::FileToPush * PopTail();
    public struct RakNet::FileListTransfer::FileToPush * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::FileListTransfer::FileToPush &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::FileListTransfer::FileToPush ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *>
{
    public void Queue<RakNet::FileListTransfer::FileToPush *>(class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> & );
    public void Queue<RakNet::FileListTransfer::FileToPush *>();
    public void ~Queue<RakNet::FileListTransfer::FileToPush *>();
    public bool operator=(class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> & );
    public void Push(struct RakNet::FileListTransfer::FileToPush &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::FileListTransfer::FileToPush &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::FileListTransfer::FileToPush &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::FileListTransfer::FileToPush * Peek();
    public struct RakNet::FileListTransfer::FileToPush * PeekTail();
    public struct RakNet::FileListTransfer::FileToPush * Pop();
    public struct RakNet::FileListTransfer::FileToPush * PopTail();
    public struct RakNet::FileListTransfer::FileToPush * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::FileListTransfer::FileToPush &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::FileListTransfer::FileToPush ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileListTransfer : public RakNet::PluginInterface2
{
    public class RakNet::FileListTransfer * GetInstance();
    public void DestroyInstance(class RakNet::FileListTransfer * );
    public void FileListTransfer(class RakNet::FileListTransfer & );
    public void FileListTransfer();
    public void ~FileListTransfer();
    public void StartIncrementalReadThreads(int ,int );
    public unsigned int SetupReceive(class RakNet::FileListTransferCBInterface * ,bool ,struct RakNet::SystemAddress );
    public void Send(class RakNet::FileList * ,class RakNet::RakPeerInterface * ,struct RakNet::SystemAddress ,unsigned int ,enum PacketPriority ,char ,class RakNet::IncrementalReadInterface * ,unsigned int );
    public unsigned int GetPendingFilesToAddress(struct RakNet::SystemAddress );
    public void CancelReceive(unsigned int );
    public void RemoveReceiver(struct RakNet::SystemAddress );
    public bool IsHandlerActive(unsigned int );
    public void AddCallback(class RakNet::FileListProgress * );
    public void RemoveCallback(class RakNet::FileListProgress * );
    public void ClearCallbacks();
    public void GetCallbacks(class DataStructures::List<RakNet::FileListProgress *> & );
    public enum RakNet::PluginReceiveResult OnReceive(struct RakNet::Packet * );
    public void OnRakPeerShutdown();
    public void OnClosedConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,enum RakNet::PI2_LostConnectionReason );
    public void Update();
    protected bool DecodeSetHeader(struct RakNet::Packet * );
    protected bool DecodeFile(struct RakNet::Packet * ,bool );
    protected void Clear();
    protected void OnReferencePush(struct RakNet::Packet * ,bool );
    protected void OnReferencePushAck(struct RakNet::Packet * );
    protected void SendIRIToAddress(struct RakNet::SystemAddress ,unsigned int );
    protected class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > fileListReceivers;
    protected unsigned int setId;
    protected class DataStructures::List<RakNet::FileListProgress *> fileListProgressCallbacks;
    struct FileToPush
    {
        struct RakNet::FileListNode fileListNode;
        enum PacketPriority packetPriority;
        char orderingChannel;
        unsigned int currentOffset;
        unsigned int setIndex;
        class RakNet::IncrementalReadInterface * incrementalReadInterface;
        unsigned int chunkSize;
        void FileToPush(struct RakNet::FileListTransfer::FileToPush * );
        void FileToPush(struct RakNet::FileListTransfer::FileToPush & );
        void FileToPush();
        void ~FileToPush();
        struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush * );
        struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush & );
        void * __vecDelDtor(unsigned int );
    };
    struct FileToPushRecipient
    {
        unsigned int refCount;
        class RakNet::SimpleMutex refCountMutex;
        void DeleteThis();
        void AddRef();
        void Deref();
        struct RakNet::SystemAddress systemAddress;
        unsigned int setId;
        class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> filesToPush;
        void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient * );
        void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient & );
        void FileToPushRecipient();
        void ~FileToPushRecipient();
        struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient * );
        struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient & );
        void * __vecDelDtor(unsigned int );
    };
    protected class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> fileToPushRecipientList;
    protected class RakNet::SimpleMutex fileToPushRecipientListMutex;
    protected void RemoveFromList(struct RakNet::FileListTransfer::FileToPushRecipient * );
    struct ThreadData
    {
        class RakNet::FileListTransfer * fileListTransfer;
        struct RakNet::SystemAddress systemAddress;
        unsigned int setId;
        void ThreadData();
        struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData * );
        struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData & );
    };
    protected struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> threadPool;
    public class RakNet::FileListTransfer & operator=(class RakNet::FileListTransfer & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::FileListTransfer : public RakNet::PluginInterface2
{
    public class RakNet::FileListTransfer * GetInstance();
    public void DestroyInstance(class RakNet::FileListTransfer * );
    public void FileListTransfer(class RakNet::FileListTransfer & );
    public void FileListTransfer();
    public void ~FileListTransfer();
    public void StartIncrementalReadThreads(int ,int );
    public unsigned int SetupReceive(class RakNet::FileListTransferCBInterface * ,bool ,struct RakNet::SystemAddress );
    public void Send(class RakNet::FileList * ,class RakNet::RakPeerInterface * ,struct RakNet::SystemAddress ,unsigned int ,enum PacketPriority ,char ,class RakNet::IncrementalReadInterface * ,unsigned int );
    public unsigned int GetPendingFilesToAddress(struct RakNet::SystemAddress );
    public void CancelReceive(unsigned int );
    public void RemoveReceiver(struct RakNet::SystemAddress );
    public bool IsHandlerActive(unsigned int );
    public void AddCallback(class RakNet::FileListProgress * );
    public void RemoveCallback(class RakNet::FileListProgress * );
    public void ClearCallbacks();
    public void GetCallbacks(class DataStructures::List<RakNet::FileListProgress *> & );
    public enum RakNet::PluginReceiveResult OnReceive(struct RakNet::Packet * );
    public void OnRakPeerShutdown();
    public void OnClosedConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,enum RakNet::PI2_LostConnectionReason );
    public void Update();
    protected bool DecodeSetHeader(struct RakNet::Packet * );
    protected bool DecodeFile(struct RakNet::Packet * ,bool );
    protected void Clear();
    protected void OnReferencePush(struct RakNet::Packet * ,bool );
    protected void OnReferencePushAck(struct RakNet::Packet * );
    protected void SendIRIToAddress(struct RakNet::SystemAddress ,unsigned int );
    protected class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > fileListReceivers;
    protected unsigned int setId;
    protected class DataStructures::List<RakNet::FileListProgress *> fileListProgressCallbacks;
    struct FileToPush
    {
        struct RakNet::FileListNode fileListNode;
        enum PacketPriority packetPriority;
        char orderingChannel;
        unsigned int currentOffset;
        unsigned int setIndex;
        class RakNet::IncrementalReadInterface * incrementalReadInterface;
        unsigned int chunkSize;
        void FileToPush(struct RakNet::FileListTransfer::FileToPush * );
        void FileToPush(struct RakNet::FileListTransfer::FileToPush & );
        void FileToPush();
        void ~FileToPush();
        struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush * );
        struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush & );
        void * __vecDelDtor(unsigned int );
    };
    struct FileToPushRecipient
    {
        unsigned int refCount;
        class RakNet::SimpleMutex refCountMutex;
        void DeleteThis();
        void AddRef();
        void Deref();
        struct RakNet::SystemAddress systemAddress;
        unsigned int setId;
        class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> filesToPush;
        void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient * );
        void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient & );
        void FileToPushRecipient();
        void ~FileToPushRecipient();
        struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient * );
        struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient & );
        void * __vecDelDtor(unsigned int );
    };
    protected class DataStructures::List<RakNet::FileListTransfer::FileToPushRecipient *> fileToPushRecipientList;
    protected class RakNet::SimpleMutex fileToPushRecipientListMutex;
    protected void RemoveFromList(struct RakNet::FileListTransfer::FileToPushRecipient * );
    struct ThreadData
    {
        class RakNet::FileListTransfer * fileListTransfer;
        struct RakNet::SystemAddress systemAddress;
        unsigned int setId;
        void ThreadData();
        struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData * );
        struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData & );
    };
    protected struct ThreadPool<RakNet::FileListTransfer::ThreadData,int> threadPool;
    public class RakNet::FileListTransfer & operator=(class RakNet::FileListTransfer & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransfer::ThreadData
{
    class RakNet::FileListTransfer * fileListTransfer;
    struct RakNet::SystemAddress systemAddress;
    unsigned int setId;
    void ThreadData();
    struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData * );
    struct RakNet::FileListTransfer::ThreadData & operator=(struct RakNet::FileListTransfer::ThreadData & );
};

struct RakNet::FileListTransfer::FileToPushRecipient
{
    unsigned int refCount;
    class RakNet::SimpleMutex refCountMutex;
    void DeleteThis();
    void AddRef();
    void Deref();
    struct RakNet::SystemAddress systemAddress;
    unsigned int setId;
    class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> filesToPush;
    void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient * );
    void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient & );
    void FileToPushRecipient();
    void ~FileToPushRecipient();
    struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient * );
    struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransfer::FileToPushRecipient
{
    unsigned int refCount;
    class RakNet::SimpleMutex refCountMutex;
    void DeleteThis();
    void AddRef();
    void Deref();
    struct RakNet::SystemAddress systemAddress;
    unsigned int setId;
    class DataStructures::Queue<RakNet::FileListTransfer::FileToPush *> filesToPush;
    void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient * );
    void FileToPushRecipient(struct RakNet::FileListTransfer::FileToPushRecipient & );
    void FileToPushRecipient();
    void ~FileToPushRecipient();
    struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient * );
    struct RakNet::FileListTransfer::FileToPushRecipient & operator=(struct RakNet::FileListTransfer::FileToPushRecipient & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransfer::FileToPush
{
    struct RakNet::FileListNode fileListNode;
    enum PacketPriority packetPriority;
    char orderingChannel;
    unsigned int currentOffset;
    unsigned int setIndex;
    class RakNet::IncrementalReadInterface * incrementalReadInterface;
    unsigned int chunkSize;
    void FileToPush(struct RakNet::FileListTransfer::FileToPush * );
    void FileToPush(struct RakNet::FileListTransfer::FileToPush & );
    void FileToPush();
    void ~FileToPush();
    struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush * );
    struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListTransfer::FileToPush
{
    struct RakNet::FileListNode fileListNode;
    enum PacketPriority packetPriority;
    char orderingChannel;
    unsigned int currentOffset;
    unsigned int setIndex;
    class RakNet::IncrementalReadInterface * incrementalReadInterface;
    unsigned int chunkSize;
    void FileToPush(struct RakNet::FileListTransfer::FileToPush * );
    void FileToPush(struct RakNet::FileListTransfer::FileToPush & );
    void FileToPush();
    void ~FileToPush();
    struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush * );
    struct RakNet::FileListTransfer::FileToPush & operator=(struct RakNet::FileListTransfer::FileToPush & );
    void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid>
{
    public void List<RakNet::NatPunchthroughClient::AddrAndGuid>(class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> & );
    public void List<RakNet::NatPunchthroughClient::AddrAndGuid>();
    public void ~List<RakNet::NatPunchthroughClient::AddrAndGuid>();
    public class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> & operator=(class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> & );
    public struct RakNet::NatPunchthroughClient::AddrAndGuid & operator[](const unsigned int );
    public struct RakNet::NatPunchthroughClient::AddrAndGuid & Get(const unsigned int );
    public void Push(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,char * ,unsigned int );
    public struct RakNet::NatPunchthroughClient::AddrAndGuid & Pop();
    public void Insert(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,char * ,unsigned int );
    public void Insert(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
    public void Replace(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,const struct RakNet::NatPunchthroughClient::AddrAndGuid ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::NatPunchthroughClient::AddrAndGuid * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughClient::AddrAndGuid
{
    struct RakNet::SystemAddress addr;
    struct RakNet::RakNetGUID guid;
    void AddrAndGuid();
    struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid * );
    struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
};

class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid>
{
    public void List<RakNet::NatPunchthroughClient::AddrAndGuid>(class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> & );
    public void List<RakNet::NatPunchthroughClient::AddrAndGuid>();
    public void ~List<RakNet::NatPunchthroughClient::AddrAndGuid>();
    public class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> & operator=(class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> & );
    public struct RakNet::NatPunchthroughClient::AddrAndGuid & operator[](const unsigned int );
    public struct RakNet::NatPunchthroughClient::AddrAndGuid & Get(const unsigned int );
    public void Push(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,char * ,unsigned int );
    public struct RakNet::NatPunchthroughClient::AddrAndGuid & Pop();
    public void Insert(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,char * ,unsigned int );
    public void Insert(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
    public void Replace(struct RakNet::NatPunchthroughClient::AddrAndGuid & ,const struct RakNet::NatPunchthroughClient::AddrAndGuid ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::NatPunchthroughClient::AddrAndGuid * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac>
{
    public void Queue<RakNet::NatPunchthroughClient::DSTAndFac>(class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac> & );
    public void Queue<RakNet::NatPunchthroughClient::DSTAndFac>();
    public void ~Queue<RakNet::NatPunchthroughClient::DSTAndFac>();
    public bool operator=(class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac> & );
    public void Push(struct RakNet::NatPunchthroughClient::DSTAndFac & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::NatPunchthroughClient::DSTAndFac & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::NatPunchthroughClient::DSTAndFac & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::NatPunchthroughClient::DSTAndFac Peek();
    public struct RakNet::NatPunchthroughClient::DSTAndFac PeekTail();
    public struct RakNet::NatPunchthroughClient::DSTAndFac Pop();
    public struct RakNet::NatPunchthroughClient::DSTAndFac PopTail();
    public struct RakNet::NatPunchthroughClient::DSTAndFac PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::NatPunchthroughClient::DSTAndFac & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::NatPunchthroughClient::DSTAndFac * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughClient::DSTAndFac
{
    struct RakNet::RakNetGUID destination;
    struct RakNet::SystemAddress facilitator;
    void DSTAndFac();
    struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac * );
    struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac & );
};

class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac>
{
    public void Queue<RakNet::NatPunchthroughClient::DSTAndFac>(class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac> & );
    public void Queue<RakNet::NatPunchthroughClient::DSTAndFac>();
    public void ~Queue<RakNet::NatPunchthroughClient::DSTAndFac>();
    public bool operator=(class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac> & );
    public void Push(struct RakNet::NatPunchthroughClient::DSTAndFac & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::NatPunchthroughClient::DSTAndFac & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::NatPunchthroughClient::DSTAndFac & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::NatPunchthroughClient::DSTAndFac Peek();
    public struct RakNet::NatPunchthroughClient::DSTAndFac PeekTail();
    public struct RakNet::NatPunchthroughClient::DSTAndFac Pop();
    public struct RakNet::NatPunchthroughClient::DSTAndFac PopTail();
    public struct RakNet::NatPunchthroughClient::DSTAndFac PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::NatPunchthroughClient::DSTAndFac & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::NatPunchthroughClient::DSTAndFac * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::NatPunchthroughClient::<unnamed-type-hasPortStride>
{
    HAS_PORT_STRIDE=0,
    UNKNOWN_PORT_STRIDE=1,
    CALCULATING_PORT_STRIDE=2,
    INCAPABLE_PORT_STRIDE=3
};

class RakNet::NatPunchthroughClient : public RakNet::PluginInterface2
{
    public class RakNet::NatPunchthroughClient * GetInstance();
    public void DestroyInstance(class RakNet::NatPunchthroughClient * );
    public void NatPunchthroughClient(class RakNet::NatPunchthroughClient & );
    public void NatPunchthroughClient();
    public void ~NatPunchthroughClient();
    public void FindRouterPortStride(struct RakNet::SystemAddress & );
    public bool OpenNAT(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    public struct RakNet::PunchthroughConfiguration * GetPunchthroughConfiguration();
    public void SetDebugInterface(struct RakNet::NatPunchthroughDebugInterface * );
    public void GetUPNPPortMappings(char * ,char * ,struct RakNet::SystemAddress & );
    public void Update();
    public enum RakNet::PluginReceiveResult OnReceive(struct RakNet::Packet * );
    public void OnNewConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,bool );
    public void OnClosedConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,enum RakNet::PI2_LostConnectionReason );
    public void OnAttach();
    public void OnDetach();
    public void OnRakPeerShutdown();
    public void Clear();
    struct SendPing
    {
        unsigned int nextActionTime;
        struct RakNet::SystemAddress targetAddress;
        struct RakNet::SystemAddress facilitator;
        struct RakNet::SystemAddress internalIds[10];
        struct RakNet::RakNetGUID targetGuid;
        bool weAreSender;
        int attemptCount;
        int retryCount;
        int punchingFixedPortAttempts;
        unsigned int sessionId;
        bool sentTTL;
        enum TestMode
        {
            TESTING_INTERNAL_IPS=0,
            WAITING_FOR_INTERNAL_IPS_RESPONSE=1,
            TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_FACILITATOR_PORT=2,
            TESTING_EXTERNAL_IPS_1024_TO_FACILITATOR_PORT=3,
            TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_1024=4,
            TESTING_EXTERNAL_IPS_1024_TO_1024=5,
            WAITING_AFTER_ALL_ATTEMPTS=6,
            PUNCHING_FIXED_PORT=7
        };
        enum RakNet::NatPunchthroughClient::SendPing::TestMode testMode;
        void SendPing();
        struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing * );
        struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing & );
    };
    public struct RakNet::NatPunchthroughClient::SendPing sp;
    protected unsigned int mostRecentExternalPort;
    protected void OnFailureNotification(struct RakNet::Packet * );
    protected void OnGetMostRecentPort(struct RakNet::Packet * );
    protected void OnConnectAtTime(struct RakNet::Packet * );
    protected unsigned int GetPendingOpenNATIndex(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    protected void SendPunchthrough(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    protected void QueueOpenNAT(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    protected void SendQueuedOpenNAT();
    protected void SendTTL(struct RakNet::SystemAddress & );
    protected void SendOutOfBand(struct RakNet::SystemAddress ,unsigned int );
    protected void OnPunchthroughFailure();
    protected void OnReadyForNextPunchthrough();
    protected void PushFailure();
    protected bool RemoveFromFailureQueue();
    protected void PushSuccess();
    protected struct RakNet::PunchthroughConfiguration pc;
    protected struct RakNet::NatPunchthroughDebugInterface * natPunchthroughDebugInterface;
    struct AddrAndGuid
    {
        struct RakNet::SystemAddress addr;
        struct RakNet::RakNetGUID guid;
        void AddrAndGuid();
        struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid * );
        struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
    };
    protected class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> failedAttemptList;
    struct DSTAndFac
    {
        struct RakNet::RakNetGUID destination;
        struct RakNet::SystemAddress facilitator;
        void DSTAndFac();
        struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac * );
        struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac & );
    };
    protected class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac> queuedOpenNat;
    protected void IncrementExternalAttemptCount(unsigned int ,unsigned int );
    protected unsigned int portStride;
    enum <unnamed-type-hasPortStride>
    {
        HAS_PORT_STRIDE=0,
        UNKNOWN_PORT_STRIDE=1,
        CALCULATING_PORT_STRIDE=2,
        INCAPABLE_PORT_STRIDE=3
    };
    protected enum RakNet::NatPunchthroughClient::<unnamed-type-hasPortStride> hasPortStride;
    protected unsigned int portStrideCalTimeout;
    public class RakNet::NatPunchthroughClient & operator=(class RakNet::NatPunchthroughClient & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::NatPunchthroughClient : public RakNet::PluginInterface2
{
    public class RakNet::NatPunchthroughClient * GetInstance();
    public void DestroyInstance(class RakNet::NatPunchthroughClient * );
    public void NatPunchthroughClient(class RakNet::NatPunchthroughClient & );
    public void NatPunchthroughClient();
    public void ~NatPunchthroughClient();
    public void FindRouterPortStride(struct RakNet::SystemAddress & );
    public bool OpenNAT(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    public struct RakNet::PunchthroughConfiguration * GetPunchthroughConfiguration();
    public void SetDebugInterface(struct RakNet::NatPunchthroughDebugInterface * );
    public void GetUPNPPortMappings(char * ,char * ,struct RakNet::SystemAddress & );
    public void Update();
    public enum RakNet::PluginReceiveResult OnReceive(struct RakNet::Packet * );
    public void OnNewConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,bool );
    public void OnClosedConnection(struct RakNet::SystemAddress & ,struct RakNet::RakNetGUID ,enum RakNet::PI2_LostConnectionReason );
    public void OnAttach();
    public void OnDetach();
    public void OnRakPeerShutdown();
    public void Clear();
    struct SendPing
    {
        unsigned int nextActionTime;
        struct RakNet::SystemAddress targetAddress;
        struct RakNet::SystemAddress facilitator;
        struct RakNet::SystemAddress internalIds[10];
        struct RakNet::RakNetGUID targetGuid;
        bool weAreSender;
        int attemptCount;
        int retryCount;
        int punchingFixedPortAttempts;
        unsigned int sessionId;
        bool sentTTL;
        enum TestMode
        {
            TESTING_INTERNAL_IPS=0,
            WAITING_FOR_INTERNAL_IPS_RESPONSE=1,
            TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_FACILITATOR_PORT=2,
            TESTING_EXTERNAL_IPS_1024_TO_FACILITATOR_PORT=3,
            TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_1024=4,
            TESTING_EXTERNAL_IPS_1024_TO_1024=5,
            WAITING_AFTER_ALL_ATTEMPTS=6,
            PUNCHING_FIXED_PORT=7
        };
        enum RakNet::NatPunchthroughClient::SendPing::TestMode testMode;
        void SendPing();
        struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing * );
        struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing & );
    };
    public struct RakNet::NatPunchthroughClient::SendPing sp;
    protected unsigned int mostRecentExternalPort;
    protected void OnFailureNotification(struct RakNet::Packet * );
    protected void OnGetMostRecentPort(struct RakNet::Packet * );
    protected void OnConnectAtTime(struct RakNet::Packet * );
    protected unsigned int GetPendingOpenNATIndex(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    protected void SendPunchthrough(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    protected void QueueOpenNAT(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    protected void SendQueuedOpenNAT();
    protected void SendTTL(struct RakNet::SystemAddress & );
    protected void SendOutOfBand(struct RakNet::SystemAddress ,unsigned int );
    protected void OnPunchthroughFailure();
    protected void OnReadyForNextPunchthrough();
    protected void PushFailure();
    protected bool RemoveFromFailureQueue();
    protected void PushSuccess();
    protected struct RakNet::PunchthroughConfiguration pc;
    protected struct RakNet::NatPunchthroughDebugInterface * natPunchthroughDebugInterface;
    struct AddrAndGuid
    {
        struct RakNet::SystemAddress addr;
        struct RakNet::RakNetGUID guid;
        void AddrAndGuid();
        struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid * );
        struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
    };
    protected class DataStructures::List<RakNet::NatPunchthroughClient::AddrAndGuid> failedAttemptList;
    struct DSTAndFac
    {
        struct RakNet::RakNetGUID destination;
        struct RakNet::SystemAddress facilitator;
        void DSTAndFac();
        struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac * );
        struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac & );
    };
    protected class DataStructures::Queue<RakNet::NatPunchthroughClient::DSTAndFac> queuedOpenNat;
    protected void IncrementExternalAttemptCount(unsigned int ,unsigned int );
    protected unsigned int portStride;
    enum <unnamed-type-hasPortStride>
    {
        HAS_PORT_STRIDE=0,
        UNKNOWN_PORT_STRIDE=1,
        CALCULATING_PORT_STRIDE=2,
        INCAPABLE_PORT_STRIDE=3
    };
    protected enum RakNet::NatPunchthroughClient::<unnamed-type-hasPortStride> hasPortStride;
    protected unsigned int portStrideCalTimeout;
    public class RakNet::NatPunchthroughClient & operator=(class RakNet::NatPunchthroughClient & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughClient::DSTAndFac
{
    struct RakNet::RakNetGUID destination;
    struct RakNet::SystemAddress facilitator;
    void DSTAndFac();
    struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac * );
    struct RakNet::NatPunchthroughClient::DSTAndFac & operator=(struct RakNet::NatPunchthroughClient::DSTAndFac & );
};

struct RakNet::NatPunchthroughClient::AddrAndGuid
{
    struct RakNet::SystemAddress addr;
    struct RakNet::RakNetGUID guid;
    void AddrAndGuid();
    struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid * );
    struct RakNet::NatPunchthroughClient::AddrAndGuid & operator=(struct RakNet::NatPunchthroughClient::AddrAndGuid & );
};

enum RakNet::NatPunchthroughClient::SendPing::TestMode
{
    TESTING_INTERNAL_IPS=0,
    WAITING_FOR_INTERNAL_IPS_RESPONSE=1,
    TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_FACILITATOR_PORT=2,
    TESTING_EXTERNAL_IPS_1024_TO_FACILITATOR_PORT=3,
    TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_1024=4,
    TESTING_EXTERNAL_IPS_1024_TO_1024=5,
    WAITING_AFTER_ALL_ATTEMPTS=6,
    PUNCHING_FIXED_PORT=7
};

struct RakNet::NatPunchthroughClient::SendPing
{
    unsigned int nextActionTime;
    struct RakNet::SystemAddress targetAddress;
    struct RakNet::SystemAddress facilitator;
    struct RakNet::SystemAddress internalIds[10];
    struct RakNet::RakNetGUID targetGuid;
    bool weAreSender;
    int attemptCount;
    int retryCount;
    int punchingFixedPortAttempts;
    unsigned int sessionId;
    bool sentTTL;
    enum TestMode
    {
        TESTING_INTERNAL_IPS=0,
        WAITING_FOR_INTERNAL_IPS_RESPONSE=1,
        TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_FACILITATOR_PORT=2,
        TESTING_EXTERNAL_IPS_1024_TO_FACILITATOR_PORT=3,
        TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_1024=4,
        TESTING_EXTERNAL_IPS_1024_TO_1024=5,
        WAITING_AFTER_ALL_ATTEMPTS=6,
        PUNCHING_FIXED_PORT=7
    };
    enum RakNet::NatPunchthroughClient::SendPing::TestMode testMode;
    void SendPing();
    struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing * );
    struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing & );
};

struct RakNet::NatPunchthroughClient::SendPing
{
    unsigned int nextActionTime;
    struct RakNet::SystemAddress targetAddress;
    struct RakNet::SystemAddress facilitator;
    struct RakNet::SystemAddress internalIds[10];
    struct RakNet::RakNetGUID targetGuid;
    bool weAreSender;
    int attemptCount;
    int retryCount;
    int punchingFixedPortAttempts;
    unsigned int sessionId;
    bool sentTTL;
    enum TestMode
    {
        TESTING_INTERNAL_IPS=0,
        WAITING_FOR_INTERNAL_IPS_RESPONSE=1,
        TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_FACILITATOR_PORT=2,
        TESTING_EXTERNAL_IPS_1024_TO_FACILITATOR_PORT=3,
        TESTING_EXTERNAL_IPS_FACILITATOR_PORT_TO_1024=4,
        TESTING_EXTERNAL_IPS_1024_TO_1024=5,
        WAITING_AFTER_ALL_ATTEMPTS=6,
        PUNCHING_FIXED_PORT=7
    };
    enum RakNet::NatPunchthroughClient::SendPing::TestMode testMode;
    void SendPing();
    struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing * );
    struct RakNet::NatPunchthroughClient::SendPing & operator=(struct RakNet::NatPunchthroughClient::SendPing & );
};

struct ConnectionInfo
{
    struct RakNet::RakNetGUID guid;
    struct RakNet::SystemAddress systemAddress;
    enum ConnectionState connectionState;
    void ConnectionInfo();
    struct ConnectionInfo & operator=(struct ConnectionInfo * );
    struct ConnectionInfo & operator=(struct ConnectionInfo & );
};

struct ConnectionInfo
{
    struct RakNet::RakNetGUID guid;
    struct RakNet::SystemAddress systemAddress;
    enum ConnectionState connectionState;
    void ConnectionInfo();
    struct ConnectionInfo & operator=(struct ConnectionInfo * );
    struct ConnectionInfo & operator=(struct ConnectionInfo & );
};

class ConnectionManager::FileTransferCallback : public RakNet::FileListTransferCBInterface
{
    public void FileTransferCallback(class ConnectionManager::FileTransferCallback * );
    public void FileTransferCallback(class ConnectionManager::FileTransferCallback & );
    public void FileTransferCallback(class ConnectionManager & );
    public bool OnFile(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
    public void OnFileProgress(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
    public class ConnectionManager & connectionManager;
    public void ~FileTransferCallback();
    public void * __vecDelDtor(unsigned int );
};

class ConnectionManager::FileTransferCallback : public RakNet::FileListTransferCBInterface
{
    public void FileTransferCallback(class ConnectionManager::FileTransferCallback * );
    public void FileTransferCallback(class ConnectionManager::FileTransferCallback & );
    public void FileTransferCallback(class ConnectionManager & );
    public bool OnFile(struct RakNet::FileListTransferCBInterface::OnFileStruct * );
    public void OnFileProgress(struct RakNet::FileListTransferCBInterface::FileProgressStruct * );
    public class ConnectionManager & connectionManager;
    public void ~FileTransferCallback();
    public void * __vecDelDtor(unsigned int );
};

class ConnectionManager::NatPunchthroughCallback : public RakNet::NatPunchthroughDebugInterface
{
    public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback * );
    public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback & );
    public void NatPunchthroughCallback(class ConnectionManager & );
    public void OnClientMessage(char * );
    public class ConnectionManager & connectionManager;
    public void ~NatPunchthroughCallback();
    public void * __vecDelDtor(unsigned int );
};

class ConnectionManager::NatPunchthroughCallback : public RakNet::NatPunchthroughDebugInterface
{
    public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback * );
    public void NatPunchthroughCallback(class ConnectionManager::NatPunchthroughCallback & );
    public void NatPunchthroughCallback(class ConnectionManager & );
    public void OnClientMessage(char * );
    public class ConnectionManager & connectionManager;
    public void ~NatPunchthroughCallback();
    public void * __vecDelDtor(unsigned int );
};

struct SFrameData
{
    int frameCount;
    int length;
    unsigned int * data;
    void ~SFrameData();
    void SFrameData();
    void * __vecDelDtor(unsigned int );
};

struct SUnitDescription
{
    class SString ClassName;
    int Upgrades[3];
    int Level;
    float XP;
    bool IsStarter;
    int Kills;
    void Save(class SStream * );
    void Load(class SStream * );
    int TotalCost(class SProperties * );
    bool IsFightingUnit(class SProperties * );
    void SUnitDescription(struct SUnitDescription * );
    void SUnitDescription(struct SUnitDescription & );
    void SUnitDescription();
    void ~SUnitDescription();
    struct SUnitDescription & operator=(struct SUnitDescription * );
    struct SUnitDescription & operator=(struct SUnitDescription & );
    void * __vecDelDtor(unsigned int );
};

struct SUnitDescription
{
    class SString ClassName;
    int Upgrades[3];
    int Level;
    float XP;
    bool IsStarter;
    int Kills;
    void Save(class SStream * );
    void Load(class SStream * );
    int TotalCost(class SProperties * );
    bool IsFightingUnit(class SProperties * );
    void SUnitDescription(struct SUnitDescription * );
    void SUnitDescription(struct SUnitDescription & );
    void SUnitDescription();
    void ~SUnitDescription();
    struct SUnitDescription & operator=(struct SUnitDescription * );
    struct SUnitDescription & operator=(struct SUnitDescription & );
    void * __vecDelDtor(unsigned int );
};

enum SUnitCommandType
{
    UCT_MOVE_TO_POINT=0,
    UCT_PATROL_TO_POINT=1,
    UCT_FOLLOW=2,
    UCT_STOP=3,
    UCT_CHASE=4,
    UCT_RETREAT=5,
    UCT_ATTACK_GROUND=6,
    UCT_ATTACK=7,
    UCT_HOLD_FIRE=8,
    UCT_RETURN_FIRE=9,
    UCT_FIRE_AT_WILL=10,
    UCT_SPEC_ACTION=11,
    UCT_SPEC_TARGET_GROUND=12,
    UCT_SPEC_TARGET_UNIT=13,
    UCT_ATTACK_DOODAD=14
};

struct SUnitCommand
{
    enum SUnitCommandType Type;
    struct SUnitCommand::_anonymous_304::<unnamed-type-Point> Point;
    int Target;
    int NumMates;
    void Save(class SStream * );
    void Load(class SStream * );
};

struct SUnitCommand::_anonymous_304::<unnamed-type-Point>
{
    float X;
    float Z;
};

enum EGhostState
{
    GS_NORMAL=0,
    GS_COLLISION_FIX=1,
    GS_COLLISION_MOVING=2,
    GS_ATGOAL=3,
    GS_DONE=4
};

class SUnit
{
    private class SGameWorld * World;
    private int WorldIdx;
    private int VedelmiTimer;
    private bool AreWeInFollow;
    private char * Nick;
    private char * Name;
    private char * Character;
    private char * Voice;
    private char * Model;
    private float OrigMaxHP;
    private float MaxHP;
    private float RepairKit;
    private int Level2XP;
    private int Level3XP;
    private float FrontArmor;
    private float BackArmor;
    private float TopArmor;
    private float Sight;
    private float MinRange;
    private float MaxRange;
    private float ActionRange;
    private bool Detector;
    private bool Invisible;
    private bool AlwaysVisible;
    private bool Invulnerable;
    private int UnitType;
    private bool Selectable;
    private int MoveType;
    private float _WheelSpeed;
    private float OriMaxMoveSpeed;
    private float MaxSpinSpeed;
    private float UnitSizeFloat;
    private int UnitSize;
    private int MaxFuel;
    private float Consume;
    private int GroundTrail[2];
    private float TrailOffset;
    private int ShotType;
    private float TurretSpeed;
    private int MaxAmmo;
    private int ReloadTime;
    private int ReshotTime;
    private float Damage;
    private float ShotSpread;
    private float ShotAngle;
    private float ShotSpeed;
    private float ShotHeight;
    private char * Projectile;
    private char * Projectile2;
    private float KickSize;
    private int KickTime;
    private int ShotEffect;
    private int SpecialType;
    private int SpecialTime;
    private float ExtraArmor;
    private class SIObject * BurrowObject;
    private int MaxCargo;
    private float SpringStrength;
    private float SpringDecay;
    private float SpringScale;
    private float BodyKick;
    private float RodSpringStrength;
    private float RodSpringDecay;
    private float RodSpringScale;
    private float MaxSpringAngleTangent;
    private float MaxSpringAngleTangent2;
    private float ChainSpeed;
    private float WheelRadius;
    private int ShotSound;
    private int ExplodeSound;
    private int ExplodeSound2;
    private int EngineSound;
    private int SpecialSound1;
    private int SpecialSound2;
    private int ExplodeType;
    private int SpiritHandle;
    private class SIObject * Object;
    private int TorkolatID[8];
    private int TorkolatNum;
    private int RodID;
    private int Rotor1ID;
    private int Rotor2ID;
    private int Rotor3ID;
    private int Rotor4ID;
    private int BombaID[8];
    private int LovegtoronyID;
    private int AknarakoCsoID;
    private int LenyomoKarID;
    private int HelikopterTestID;
    private int BombazoTestID;
    private int TestID;
    private int CsoID;
    private int CsoToID;
    private int BalCsoID;
    private int JobbCsoID;
    private int CsoaljaID;
    private int KotelID;
    private int TetolapFelsoID;
    private int TetolapAlsoID;
    private int HidraulikaHatsoID;
    private int HidraulikaElsoID;
    private int TalpHatsoID;
    private int TalpElsoID;
    private int CsoVedoID;
    private int BalHatsoHidraulikaID;
    private int JobbHatsoHidraulikaID;
    private int BalElsoHidraulikaID;
    private int JobbElsoHidraulikaID;
    private int CsovedoID;
    private int HidraulikaID;
    private class SDArray<SWheelData> Wheels;
    private class SDArray<SChainData> Chains;
    private bool ServerInitCalled;
    private float SpringX;
    private float SpringZ;
    private float SpringVX;
    private float SpringVZ;
    private float RodSpringX;
    private float RodSpringZ;
    private float RodSpringVX;
    private float RodSpringVZ;
    private float RodLastX;
    private float RodLastZ;
    private int RodFirst;
    private char * ClassName;
    private int Player;
    private int Color;
    private int ShootSource;
    private float X;
    private float RepulesiMagassag;
    private float Z;
    private float Dir;
    private float TurretDir;
    private float SlideBack;
    private float LastX;
    private float LastYrel;
    private float LastZ;
    private float HP;
    private float Fuel;
    private int Ammo;
    private int Cargo;
    private float IpolX;
    private float IpolZ;
    private float Y;
    private float XP;
    private int Level;
    private bool IsStarter;
    private int Kills;
    private int Event;
    private int EventTime;
    private bool Moveable;
    private bool Neutral;
    private int Resource;
    private bool Wreck;
    private bool MarkedForDemolition;
    private int MovementMask;
    private int Upgrades[3];
    private int HaveSeenEnemy;
    private int HaveBeenAttackedByUnseenEnemy;
    private int UnitFrame;
    private int GroupFrame;
    private int FuelFrame;
    private int AmmoFrame;
    private int BlackFrame;
    private int LifeFrame;
    private int BracketFrame1;
    private int BracketFrame2;
    private int MinimapFrame;
    private float Prop1;
    private float Prop2;
    private float Prop3;
    private float Prop4;
    private int OwnerUnit;
    private bool Swimming;
    private bool InnerAirspace;
    private class SIObject * FlagObject;
    private void InitWheelsAndChains();
    private void UpdateWheelsAndChains();
    private void SetModelColorizeProperties(class SIObject * ,char * );
    public void SUnit(class SUnit & );
    public void SUnit(class SWorld * ,int );
    public void Create(int ,char * ,int * ,int ,float ,bool ,int );
    public void Load(class SStream * );
    public void Save(class SStream * ,bool ,bool );
    public void InitVariables();
    public void ~SUnit();
    public int UnitSelection;
    public int GroupID;
    public int GlobalLogFlag;
    public void SetPosition(float ,float ,float ,float );
    public void SetRelativePosition(float ,float ,float ,float );
    public void SetPlayer(int );
    public void SetLevel(int );
    public void LoadNewSkinObject();
    public void SetSpecialState(bool );
    public void Realign();
    public bool IsAirplane();
    public bool IsMortarOrNonFighting();
    private class SDArray<SUnitCommand> Commands;
    private struct SAIDriver Driver;
    private struct SAIGunner Gunner;
    private struct SAISpecial Special;
    private bool AimTarget(float );
    private bool doHeartbeat;
    private void Heartbeat();
    private void ThinkDriver();
    private void ThinkGunner();
    private void DoGunner();
    private bool IsShootable(float ,float );
    private void ShowEvent(int );
    public void ExecuteCommand(struct SUnitCommand );
    public void IssueCommandWithPoint(enum SUnitCommandType ,float ,float ,int ,bool );
    public void IssueCommandWithIndex(enum SUnitCommandType ,int ,bool );
    public void IssueCommand(enum SUnitCommandType ,bool );
    public void EC_MoveToPoint(float ,float ,int );
    public void EC_PatrolToPoint(float ,float );
    public void EC_Follow(int );
    public void EC_SetDriverAI();
    public void EC_AttackGround(float ,float );
    public void EC_Attack(int );
    public void EC_AttackDoodad(int );
    public void EC_HoldFire();
    public void EC_ReturnFire();
    public void EC_FireAtWill();
    public void EC_SetGunnerAI();
    public void EC_SpecTargetGround(float ,float );
    public void EC_SpecTargetUnit(int );
    public void EC_SpecAction();
    public void ServerInit();
    public void ServerInit2();
    public void ServerShutdown();
    public void BackupParameters();
    public void ServerRefresh();
    public void CalculateDynamics();
    public void UpdateObject();
    public void ClientRefresh();
    public float CalculateArmor(class SVector & ,int );
    public void TakeDamage(float ,int ,class SVector & ,int ,int ,bool );
    public void IncreaseXP(float ,bool );
    public void IncrementKills(int );
    public void Explode();
    public void TakeResource(float ,float ,float );
    public int EngineSoundHandle;
    public int SpecialSoundHandle;
    public int CountDownDestroy;
    public bool ReCreateRangeDecals;
    private float QuickSlip;
    private float GetMaxSpinSpeed();
    private float GetMaxMoveSpeed();
    private bool GA_FirstOverLength;
    private float GCsuszasIrany;
    private float GCsuszasEro;
    private float CsuszasIrany;
    private float CsuszasEro;
    private float GCsuszasIrany2;
    private float GCsuszasEro2;
    private float CsuszasIrany2;
    private float CsuszasEro2;
    private float GForgasSebesseg;
    private bool GA_Lassitas_Minusz;
    private bool Birkaturelem;
    private bool AreYouReallyMoving();
    private int Szintlepes_szamlalo;
    private struct SUnitDescription UD;
    private int UnitToPlaceUnitSize;
    private float HelicopterHeight;
    private float HelicopterEmelkedes;
    private float Fadeing[10];
    private bool AutoDestruct;
    private int FollowMode;
    private float Varakozo_Tav1;
    private float Varakozo_Tav2;
    private int BajtarsDB;
    private void Nop();
    private bool AreWeGoneThroughGoal();
    private int CutCT(int );
    private void ResetGhost();
    private void NextGhostStep();
    private void GA_FaceToPoint_CallBack();
    private void GA_Celratartas_CallBack();
    private void GA_Kikerules_CallBack();
    private void GA_Frusztracio_CallBack();
    private void GA_Lassitas_CallBack();
    private bool FollowGhost();
    private void FillUpGhost(int );
    private float GetWheelToZeroDist(float );
    private float GetWheelToZeroDist2(float ,float ,float ,float );
    private float GetSpeedToZeroDist(float );
    private void GA_Tolatas_CallBack();
    private float GhostX;
    private float GhostZ;
    private enum EGhostState GhostState;
    private enum EGhostState GhostState2;
    private float GDir;
    private float GMoveSpeed;
    private float GWheel;
    private float GX;
    private float GZ;
    private float PGX;
    private float PGZ;
    private float PGDir;
    private float GAS_GetGWaypointDist();
    private float GAS_GetGWaypointDir();
    private int TolatasFrames;
    private class SFifo<SGhostData,30> GhostDatas;
    private int UnatkozasSzamlalo;
    private void Driver_FaceToPoint(float ,float );
    private void Putty(char * );
    private class SChain<SWaypointFlag> WaypointFlags;
    private int DA_CT_MoveWhilePossible;
    private float Yacc;
    private class SIObject * FlyingUnit;
    private int KotelMesh;
    private float LastWheelToZero;
    private int BombTime;
    private int BombCounter;
    private int BombRnd;
    private void * HeliCelFust;
    private int StandingFlag;
    private int NeedToCollect;
    private class SChain<SIndex> FindPathUnits1;
    private class SChain<SIndex> FindPathUnits2;
    private class SChain<SIndex> UnitsForGhost;
    private int FlagCounter;
    private int FlagCounter2;
    private int AutoWheelC_RightDir;
    private class SStack<SWaypoint> * WayPoints;
    private float GoalX;
    private float GoalZ;
    private void CleanUpFlags();
    private void CreateNewFlag(float ,float ,float );
    private void GetNextWaypoint();
    private bool FindPath();
    private bool FindPath__(float & );
    private class SVector GetVec(float ,float );
    private void DeleteWaypoints();
    private bool TestLine();
    private bool TestCurrentLineWithGhost();
    private bool TestCurrentLineWithUnit();
    private bool TestNextLine();
    private void NextWP();
    private void HelicopterCallBack();
    private void AirPlaneCallBack();
    private void ZeppelinCallBack();
    private void HelicopterDirectionControl();
    private void SetHelicopterHeight(float );
    private void Driver_MoveToPoint(float ,float );
    private void Driver_Stop();
    private void StopAndBlock();
    private void SetDriverAction(int ,int ,int ,int );
    private void StayOnPathCallBack();
    private void DA_FaceToPoint_CallBack();
    private void DA_Celratartas_CallBack();
    private void RefreshGoal();
    private void Driver_Follow(int ,bool ,int );
    private void DA_Kikerules_CallBack();
    private void DA_Frusztracio_CallBack();
    private void DA_Lassitas_CallBack();
    private void DA_Tolatas_CallBack();
    private void DA_WaitWhileNear_CallBack();
    private void DA_Indulas_CallBack();
    private void ContinueMoving(int );
    private bool AreThereMoreWP();
    private int HowManyWP();
    private int GetCloserDirection();
    private int GetCloserDirection2(float ,float );
    private void SetStandingFlag(bool );
    private bool StopWhenReady();
    private float Turbo;
    private void * Fust1;
    private void * Fust2;
    private void * Porzas1;
    private void * Porzas2;
    private void SetPuller(int );
    private int TryToMoveAfterPuller(float ,float ,float ,float * ,float * ,float * ,float );
    private void Driver_AttachGivenUnit(int );
    private void Driver_DetachUnit();
    private void DA_Attaching_CallBack();
    private void DA_Detaching_CallBack();
    private void LogicalDisconnect();
    private void GA_Attaching_CallBack();
    private void GA_Detaching_CallBack();
    private bool TryToMoveBack(float * ,float * ,float * );
    private float GoalDist;
    private bool MozgovalUtkozes;
    private int DirectionTip;
    private int GoalType;
    private int FollowedUnitIndex;
    private int DriverAction;
    private float Wheel;
    private float MoveSpeed;
    private int DriverParam;
    private int DriverParam2;
    private int DriverParam3;
    private int FrusztracioCounter;
    private int KikerulesCounter;
    private float WaypointX;
    private float WaypointZ;
    private float PrevWPX;
    private float PrevWPZ;
    private bool CanWeGetNextWP();
    private bool PathFinded;
    private int PullerUnitIndex;
    private int PulledUnitIndex;
    private int Reverse;
    private int PulledUnitIndexWill;
    private float AttachingDist;
    private void SetTowBlocking(bool );
    private void GAS_WheelToDir(float ,float );
    private void GAS_RotateUnit();
    private void GAS_AppendNewGhostDatas();
    private void GAS_WheelToWP();
    private int GAS_CheckCollision(float ,float ,int );
    private int GAS_MoveGhost(float );
    private int GAS_MoveTrailerGhost(float ,float );
    private int GAS_AutoSpeedControl();
    private void GAS_AutoWheelControl();
    private float GAS_GetDirDist();
    private void GAS_RefreshNewGhostDatas();
    private bool FirstTime;
    public class SUnit & operator=(class SUnit & );
    public void * __vecDelDtor(unsigned int );
};

struct SWheelData
{
    int meshID;
    float steeringMultiplier;
    class SVector position;
    class SVector lastPosition;
    float distance;
    bool left;
    void SWheelData();
};

struct SWheelData
{
    int meshID;
    float steeringMultiplier;
    class SVector position;
    class SVector lastPosition;
    float distance;
    bool left;
    void SWheelData();
};

class SDArray<SWheelData>
{
    private int size;
    private int maxsize;
    public struct SWheelData * array;
    public void SDArray<SWheelData>(class SDArray<SWheelData> & );
    public void SDArray<SWheelData>();
    public void ~SDArray<SWheelData>();
    public int Add(struct SWheelData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SWheelData & operator[](int );
    public void operator=(class SDArray<SWheelData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SWheelData>
{
    private int size;
    private int maxsize;
    public struct SWheelData * array;
    public void SDArray<SWheelData>(class SDArray<SWheelData> & );
    public void SDArray<SWheelData>();
    public void ~SDArray<SWheelData>();
    public int Add(struct SWheelData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SWheelData & operator[](int );
    public void operator=(class SDArray<SWheelData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SChainData
{
    int meshID;
    class SVector position;
    class SVector lastPosition;
    float distance;
    bool left;
    void SChainData();
};

struct SChainData
{
    int meshID;
    class SVector position;
    class SVector lastPosition;
    float distance;
    bool left;
    void SChainData();
};

class SDArray<SChainData>
{
    private int size;
    private int maxsize;
    public struct SChainData * array;
    public void SDArray<SChainData>(class SDArray<SChainData> & );
    public void SDArray<SChainData>();
    public void ~SDArray<SChainData>();
    public int Add(struct SChainData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SChainData & operator[](int );
    public void operator=(class SDArray<SChainData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SChainData>
{
    private int size;
    private int maxsize;
    public struct SChainData * array;
    public void SDArray<SChainData>(class SDArray<SChainData> & );
    public void SDArray<SChainData>();
    public void ~SDArray<SChainData>();
    public int Add(struct SChainData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SChainData & operator[](int );
    public void operator=(class SDArray<SChainData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SWorld
{
    protected int DefaultFont;
    public void SWorld(class SWorld & );
    public void SWorld(int );
    public void ~SWorld();
    public void Initialize();
    public void Update();
    protected int Tileset;
    public void GetTileset(char * );
    protected float CamBorder;
    protected float CamElevationMin;
    protected float CamElevationMax;
    protected float CamDistanceMin;
    protected float CamDistanceMax;
    protected class SVector CamTarget;
    protected float CamDirection;
    protected float CamForwardX;
    protected float CamForwardZ;
    protected float CamElevation;
    protected float CamDistance;
    protected class SVector SlowCamTarget;
    protected float SlowCamDistance;
    protected float SlowCamLastTime;
    protected class SVector CamPos;
    protected class SVector CamHead;
    protected class SVector CamRight;
    protected class SVector CamUp;
    protected int CamLockOnGroup;
    protected int CamLockOnTrigger;
    protected class SVector CamDisplacement;
    public void InitCamera();
    public void MoveCameraTo(float ,float );
    public void MoveCamera(float ,float );
    public void RotateCameraTo(float ,float );
    public void RotateCamera(float ,float );
    public void ZoomCameraTo(float );
    public void ZoomCamera(float );
    public void GetCamera(struct SCamera & );
    public void SetCamera(struct SCamera & );
    public void ComputeCamera();
    public void LimitCamera(bool );
    public void SetCameraDisplacement(class SVector );
    protected int XSize;
    protected int ZSize;
    protected class SIPlane * Plane;
    protected float * HeightMap;
    protected float * OldHeightMap;
    protected unsigned int * BlendMap[9];
    protected struct STile * TileMap;
    protected unsigned int * WaterMap;
    public bool IsOnTheMap(float ,float );
    public float GetHeight(float ,float );
    public float GetOldHeight(float ,float );
    public void GetTarget(float ,float ,float & ,float & ,float & );
    public void SetPlaneViewType(int );
    public void ComputeShadows();
    public void CreatePlane2();
    protected int SelectionFont;
    protected int SelectionFrames[4];
    protected int SelectionFillFrame;
    protected int GameViewBackFrame;
    protected void LoadSelection(class SStream * );
    protected void SaveSelection(class SStream * );
    public void SetBoxSelection(int ,int ,int ,int );
    public void ClearBoxSelection();
    public void SetGameViewBackFrame(int );
    protected class SHeap<SDoodad> Doodads;
    protected class SProperties * ObjectsIni;
    protected void LoadDoodads(class SStream * ,bool ,int );
    protected void SaveDoodads(class SStream * ,bool );
    protected void LoadDoodadsWithHoles(class SStream * );
    protected void SaveDoodadsWithHoles(class SStream * );
    public int CreateDoodad(char * ,float ,float ,float ,float ,float ,float );
    public void RemoveDoodad(int );
    public int GetTargetDoodad(float ,float );
    public void SelectDoodad(int );
    public void SelectDoodad(int ,int );
    public void SelectDoodad(float ,float ,float ,float ,int );
    public void SelectDoodad(float ,float ,int );
    public bool IsDoodadSelected(int );
    public int CountSelectedDoodads();
    public void RemoveSelectedDoodads();
    public void MoveSelectedDoodads(float ,float ,bool );
    public void LiftSelectedDoodads(float );
    public void RotateSelectedDoodads(float ,bool );
    public void TiltSelectedDoodads(float ,float );
    public void ActivateDoodad(int ,bool );
    public int GetTargetDoodadByMapCoordinate(float ,float );
    protected struct SPlayer Players[9];
    protected int ControllingPlayer;
    protected bool GodMode;
    protected void LoadPlayers(class SStream * );
    protected void SavePlayers(class SStream * );
    public struct SPlayer * GetPlayer(int );
    public void SetPlayer(int );
    public int GetControllingPlayer();
    public bool IsAlly(int ,int );
    public class SHeap<SUnit *> Units;
    protected class SProperties * UnitsIni;
    protected class SProperties * UnitsIniColor;
    protected class SProperties * UnitsIniLocale;
    protected void LoadUnits(class SStream * );
    protected void SaveUnits(class SStream * ,bool );
    protected void LoadUnitsWithHoles(class SStream * );
    protected void SaveUnitsWithHoles(class SStream * );
    protected int LastUnitRange;
    protected int UnitRangeTexture;
    protected int NumMinRangeShaders;
    protected int NumMaxRangeShaders;
    protected int * MinRangeShaders;
    protected int * MaxRangeShaders;
    public int CreateUnit(int ,char * ,float ,float ,float ,int * ,int ,float ,bool ,int );
    public void RemoveUnit(int );
    public int GetTargetUnit(float ,float );
    public void SelectUnit(int );
    public void SelectUnit(int ,int );
    public void SelectUnit(float ,float ,float ,float ,int );
    public int SelectUnit(float ,float ,int );
    public void SelectUnitByType(int ,int );
    public bool IsUnitSelected(int );
    public int CountSelectedUnits();
    public void RemoveSelectedUnits();
    public void MoveSelectedUnits(float ,float );
    public void LiftSelectedUnits(float );
    public void RotateSelectedUnits(float );
    public void GetSelectedUnitStats(struct SUnitStats & );
    public void SetSelectedUnitStats(struct SUnitStats & );
    public void CreateUnitGroup(int );
    public void JoinUnitGroup(int ,int );
    public void SelectUnitGroup(int );
    public void DeleteUnitGroup(int );
    public void QueryUnitGroups(struct SGroupStatus & );
    public bool QueryUnitGroupCenter(int ,float & ,float & );
    public void InitUnitRange();
    public void ShutdownUnitRange();
    public void ShowUnitRange(int );
    public void EditorRefresh();
    protected int Lite[20];
    public void SetLite(int ,int );
    public int GetLite(int );
    public void UpdateLite();
    private char * SketchTextureName;
    public char * GetSketchTexture();
    public void SetSketchTexture(char * );
    protected class SHeap<SAmbient> Ambients;
    protected void LoadAmbients(class SStream * ,bool );
    protected void SaveAmbients(class SStream * ,bool );
    public int CreateAmbient(char * ,float ,float );
    public void RemoveAmbient(int );
    public void RealizeAmbients();
    protected class SHeap<SLake> Lakes;
    protected void RefreshLake(int );
    protected void LoadLakes(class SStream * ,bool ,int );
    protected void SaveLakes(class SStream * ,bool );
    public int CreateLake(char * ,float ,float );
    public void RemoveLake(int );
    protected class SDArray<STrigger> Triggers;
    protected void SaveTriggers(class SStream * );
    protected void LoadTriggers(class SStream * );
    protected class SHeap<SLocation> Locations;
    protected void SaveLocations(class SStream * );
    protected void LoadLocations(class SStream * );
    protected void LoadOldLocations(class SStream * );
    protected unsigned int * MinimapImage;
    public unsigned int * GetMinimapImage();
    public void SetMinimapImage(unsigned int * );
    protected void SaveMap(class SStream * ,bool );
    protected void LoadMap(class SStream * );
    public void New(int ,int ,int );
    public bool Load(class SStream * );
    public bool Save(class SStream * ,bool );
    public void InvertBlockViewing();
    public int EsoSound;
    public int VillamSound;
    public int EffectSound1;
    public int EffectSound2;
    public int EffectSound3;
    public int EffectSound4;
    public int VizbecsapodasHang;
    public int LightingRandom;
    public int RecalcTimer;
    public int RecalcIdx;
    public int RecalcIdx2;
    public void Echo(char * ,<btNoType> );
    public void ShowLoadingPictures(int );
    public class SWorld & operator=(class SWorld & );
    public void * __vecDelDtor(unsigned int );
};

class SWorld
{
    protected int DefaultFont;
    public void SWorld(class SWorld & );
    public void SWorld(int );
    public void ~SWorld();
    public void Initialize();
    public void Update();
    protected int Tileset;
    public void GetTileset(char * );
    protected float CamBorder;
    protected float CamElevationMin;
    protected float CamElevationMax;
    protected float CamDistanceMin;
    protected float CamDistanceMax;
    protected class SVector CamTarget;
    protected float CamDirection;
    protected float CamForwardX;
    protected float CamForwardZ;
    protected float CamElevation;
    protected float CamDistance;
    protected class SVector SlowCamTarget;
    protected float SlowCamDistance;
    protected float SlowCamLastTime;
    protected class SVector CamPos;
    protected class SVector CamHead;
    protected class SVector CamRight;
    protected class SVector CamUp;
    protected int CamLockOnGroup;
    protected int CamLockOnTrigger;
    protected class SVector CamDisplacement;
    public void InitCamera();
    public void MoveCameraTo(float ,float );
    public void MoveCamera(float ,float );
    public void RotateCameraTo(float ,float );
    public void RotateCamera(float ,float );
    public void ZoomCameraTo(float );
    public void ZoomCamera(float );
    public void GetCamera(struct SCamera & );
    public void SetCamera(struct SCamera & );
    public void ComputeCamera();
    public void LimitCamera(bool );
    public void SetCameraDisplacement(class SVector );
    protected int XSize;
    protected int ZSize;
    protected class SIPlane * Plane;
    protected float * HeightMap;
    protected float * OldHeightMap;
    protected unsigned int * BlendMap[9];
    protected struct STile * TileMap;
    protected unsigned int * WaterMap;
    public bool IsOnTheMap(float ,float );
    public float GetHeight(float ,float );
    public float GetOldHeight(float ,float );
    public void GetTarget(float ,float ,float & ,float & ,float & );
    public void SetPlaneViewType(int );
    public void ComputeShadows();
    public void CreatePlane2();
    protected int SelectionFont;
    protected int SelectionFrames[4];
    protected int SelectionFillFrame;
    protected int GameViewBackFrame;
    protected void LoadSelection(class SStream * );
    protected void SaveSelection(class SStream * );
    public void SetBoxSelection(int ,int ,int ,int );
    public void ClearBoxSelection();
    public void SetGameViewBackFrame(int );
    protected class SHeap<SDoodad> Doodads;
    protected class SProperties * ObjectsIni;
    protected void LoadDoodads(class SStream * ,bool ,int );
    protected void SaveDoodads(class SStream * ,bool );
    protected void LoadDoodadsWithHoles(class SStream * );
    protected void SaveDoodadsWithHoles(class SStream * );
    public int CreateDoodad(char * ,float ,float ,float ,float ,float ,float );
    public void RemoveDoodad(int );
    public int GetTargetDoodad(float ,float );
    public void SelectDoodad(int );
    public void SelectDoodad(int ,int );
    public void SelectDoodad(float ,float ,float ,float ,int );
    public void SelectDoodad(float ,float ,int );
    public bool IsDoodadSelected(int );
    public int CountSelectedDoodads();
    public void RemoveSelectedDoodads();
    public void MoveSelectedDoodads(float ,float ,bool );
    public void LiftSelectedDoodads(float );
    public void RotateSelectedDoodads(float ,bool );
    public void TiltSelectedDoodads(float ,float );
    public void ActivateDoodad(int ,bool );
    public int GetTargetDoodadByMapCoordinate(float ,float );
    protected struct SPlayer Players[9];
    protected int ControllingPlayer;
    protected bool GodMode;
    protected void LoadPlayers(class SStream * );
    protected void SavePlayers(class SStream * );
    public struct SPlayer * GetPlayer(int );
    public void SetPlayer(int );
    public int GetControllingPlayer();
    public bool IsAlly(int ,int );
    public class SHeap<SUnit *> Units;
    protected class SProperties * UnitsIni;
    protected class SProperties * UnitsIniColor;
    protected class SProperties * UnitsIniLocale;
    protected void LoadUnits(class SStream * );
    protected void SaveUnits(class SStream * ,bool );
    protected void LoadUnitsWithHoles(class SStream * );
    protected void SaveUnitsWithHoles(class SStream * );
    protected int LastUnitRange;
    protected int UnitRangeTexture;
    protected int NumMinRangeShaders;
    protected int NumMaxRangeShaders;
    protected int * MinRangeShaders;
    protected int * MaxRangeShaders;
    public int CreateUnit(int ,char * ,float ,float ,float ,int * ,int ,float ,bool ,int );
    public void RemoveUnit(int );
    public int GetTargetUnit(float ,float );
    public void SelectUnit(int );
    public void SelectUnit(int ,int );
    public void SelectUnit(float ,float ,float ,float ,int );
    public int SelectUnit(float ,float ,int );
    public void SelectUnitByType(int ,int );
    public bool IsUnitSelected(int );
    public int CountSelectedUnits();
    public void RemoveSelectedUnits();
    public void MoveSelectedUnits(float ,float );
    public void LiftSelectedUnits(float );
    public void RotateSelectedUnits(float );
    public void GetSelectedUnitStats(struct SUnitStats & );
    public void SetSelectedUnitStats(struct SUnitStats & );
    public void CreateUnitGroup(int );
    public void JoinUnitGroup(int ,int );
    public void SelectUnitGroup(int );
    public void DeleteUnitGroup(int );
    public void QueryUnitGroups(struct SGroupStatus & );
    public bool QueryUnitGroupCenter(int ,float & ,float & );
    public void InitUnitRange();
    public void ShutdownUnitRange();
    public void ShowUnitRange(int );
    public void EditorRefresh();
    protected int Lite[20];
    public void SetLite(int ,int );
    public int GetLite(int );
    public void UpdateLite();
    private char * SketchTextureName;
    public char * GetSketchTexture();
    public void SetSketchTexture(char * );
    protected class SHeap<SAmbient> Ambients;
    protected void LoadAmbients(class SStream * ,bool );
    protected void SaveAmbients(class SStream * ,bool );
    public int CreateAmbient(char * ,float ,float );
    public void RemoveAmbient(int );
    public void RealizeAmbients();
    protected class SHeap<SLake> Lakes;
    protected void RefreshLake(int );
    protected void LoadLakes(class SStream * ,bool ,int );
    protected void SaveLakes(class SStream * ,bool );
    public int CreateLake(char * ,float ,float );
    public void RemoveLake(int );
    protected class SDArray<STrigger> Triggers;
    protected void SaveTriggers(class SStream * );
    protected void LoadTriggers(class SStream * );
    protected class SHeap<SLocation> Locations;
    protected void SaveLocations(class SStream * );
    protected void LoadLocations(class SStream * );
    protected void LoadOldLocations(class SStream * );
    protected unsigned int * MinimapImage;
    public unsigned int * GetMinimapImage();
    public void SetMinimapImage(unsigned int * );
    protected void SaveMap(class SStream * ,bool );
    protected void LoadMap(class SStream * );
    public void New(int ,int ,int );
    public bool Load(class SStream * );
    public bool Save(class SStream * ,bool );
    public void InvertBlockViewing();
    public int EsoSound;
    public int VillamSound;
    public int EffectSound1;
    public int EffectSound2;
    public int EffectSound3;
    public int EffectSound4;
    public int VizbecsapodasHang;
    public int LightingRandom;
    public int RecalcTimer;
    public int RecalcIdx;
    public int RecalcIdx2;
    public void Echo(char * ,<btNoType> );
    public void ShowLoadingPictures(int );
    public class SWorld & operator=(class SWorld & );
    public void * __vecDelDtor(unsigned int );
};

struct SUnitCommand
{
    enum SUnitCommandType Type;
    struct SUnitCommand::_anonymous_304::<unnamed-type-Point> Point;
    int Target;
    int NumMates;
    void Save(class SStream * );
    void Load(class SStream * );
};

class SDArray<SUnitCommand>
{
    private int size;
    private int maxsize;
    public struct SUnitCommand * array;
    public void SDArray<SUnitCommand>(class SDArray<SUnitCommand> & );
    public void SDArray<SUnitCommand>();
    public void ~SDArray<SUnitCommand>();
    public int Add(struct SUnitCommand & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SUnitCommand & operator[](int );
    public void operator=(class SDArray<SUnitCommand> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SUnitCommand>
{
    private int size;
    private int maxsize;
    public struct SUnitCommand * array;
    public void SDArray<SUnitCommand>(class SDArray<SUnitCommand> & );
    public void SDArray<SUnitCommand>();
    public void ~SDArray<SUnitCommand>();
    public int Add(struct SUnitCommand & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SUnitCommand & operator[](int );
    public void operator=(class SDArray<SUnitCommand> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SAIDriver
{
    int Present;
    int Enabled;
    int Target;
    int Order;
    struct SAIDriver::_anonymous_321::<unnamed-type-Point> Point;
    int UnitIdx;
    int DoodadIdx;
    int Mode;
    int Notify;
    int PatrolMode;
    float PatrolX;
    float PatrolZ;
};

struct SAIDriver::_anonymous_321::<unnamed-type-Point>
{
    float X;
    float Z;
};

struct SAIGunner
{
    int Present;
    int Enabled;
    int Target;
    int Order;
    struct SAIGunner::_anonymous_323::<unnamed-type-Point> Point;
    int UnitIdx;
    int DoodadIdx;
    int Mode;
    int IdleTime;
    float IdleTarget;
    int Reload;
    int Reshot;
    int Burst;
    int ToLoad;
    int Loaded;
    int KickCountdown;
};

struct SAIGunner::_anonymous_323::<unnamed-type-Point>
{
    float X;
    float Z;
};

struct SAISpecial
{
    int Present;
    int SpecialChanging;
    int SpecialActivated;
    int CurrentTime;
    int LoadTarget;
    int MineTarget;
    float MineX;
    float MineZ;
};

struct SGhostData
{
    float x;
    float z;
    float dir;
    float speed;
    float wheel;
    float csuszasirany;
    float csuszasero;
    float csuszasirany2;
    float csuszasero2;
};

class SFifo<SGhostData,30>
{
    private struct SGhostData array[30];
    private int pos;
    private int quantity;
    public void SFifo<SGhostData,30>();
    public void ~SFifo<SGhostData,30>();
    public struct SGhostData * Add();
    public void Clear();
    public struct SGhostData * Get();
    public struct SGhostData * Peek(int );
    public struct SGhostData * GetLast();
    public int GetSize();
    public void * __vecDelDtor(unsigned int );
};

class SFifo<SGhostData,30>
{
    private struct SGhostData array[30];
    private int pos;
    private int quantity;
    public void SFifo<SGhostData,30>();
    public void ~SFifo<SGhostData,30>();
    public struct SGhostData * Add();
    public void Clear();
    public struct SGhostData * Get();
    public struct SGhostData * Peek(int );
    public struct SGhostData * GetLast();
    public int GetSize();
    public void * __vecDelDtor(unsigned int );
};

struct SWaypointFlag
{
    struct SWaypointFlag * next;
    struct SWaypointFlag * prev;
    class SIObject * object;
};

class SChain<SWaypointFlag>
{
    private struct SWaypointFlag * first;
    private struct SWaypointFlag * last;
    private struct SWaypointFlag * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SWaypointFlag>();
    public void ~SChain<SWaypointFlag>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SWaypointFlag * StepToFirst();
    public struct SWaypointFlag * StepToLast();
    public struct SWaypointFlag * GetNext();
    public struct SWaypointFlag * GetNext2();
    public struct SWaypointFlag * GetPrev();
    public struct SWaypointFlag * GetCurrent();
    public struct SWaypointFlag * StepToNext();
    public struct SWaypointFlag * StepToPrev();
    public struct SWaypointFlag * Append(struct SWaypointFlag * ,bool );
    public struct SWaypointFlag * AppendNew(bool );
    public struct SWaypointFlag * GetFirst();
    public struct SWaypointFlag * GetSecond();
    public struct SWaypointFlag * GetThird();
    public struct SWaypointFlag * GetLastButOne();
    public struct SWaypointFlag * GetLast();
    public struct SWaypointFlag * InsertOver(struct SWaypointFlag * ,bool );
    public struct SWaypointFlag * InsertOverNew(bool );
    public struct SWaypointFlag * InsertUnder(struct SWaypointFlag * ,bool );
    public struct SWaypointFlag * InsertUnderNew(bool );
    public void Delete(struct SWaypointFlag * );
    public void Delete();
    public void DeleteAll();
    public struct SWaypointFlag * GetPointer(int );
    public struct SWaypointFlag * StepToIndex(int );
    public struct SWaypointFlag & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SWaypointFlag * );
    public void StepToPointer(struct SWaypointFlag * );
    public void SendToBack(struct SWaypointFlag * );
    public void BringToFront(struct SWaypointFlag * );
    public void Swap(struct SWaypointFlag * ,struct SWaypointFlag * );
    public void * __vecDelDtor(unsigned int );
};

struct SIndex
{
    struct SIndex * next;
    struct SIndex * prev;
    int unitindex;
};

class SChain<SIndex>
{
    private struct SIndex * first;
    private struct SIndex * last;
    private struct SIndex * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SIndex>();
    public void ~SChain<SIndex>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SIndex * StepToFirst();
    public struct SIndex * StepToLast();
    public struct SIndex * GetNext();
    public struct SIndex * GetNext2();
    public struct SIndex * GetPrev();
    public struct SIndex * GetCurrent();
    public struct SIndex * StepToNext();
    public struct SIndex * StepToPrev();
    public struct SIndex * Append(struct SIndex * ,bool );
    public struct SIndex * AppendNew(bool );
    public struct SIndex * GetFirst();
    public struct SIndex * GetSecond();
    public struct SIndex * GetThird();
    public struct SIndex * GetLastButOne();
    public struct SIndex * GetLast();
    public struct SIndex * InsertOver(struct SIndex * ,bool );
    public struct SIndex * InsertOverNew(bool );
    public struct SIndex * InsertUnder(struct SIndex * ,bool );
    public struct SIndex * InsertUnderNew(bool );
    public void Delete(struct SIndex * );
    public void Delete();
    public void DeleteAll();
    public struct SIndex * GetPointer(int );
    public struct SIndex * StepToIndex(int );
    public struct SIndex & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SIndex * );
    public void StepToPointer(struct SIndex * );
    public void SendToBack(struct SIndex * );
    public void BringToFront(struct SIndex * );
    public void Swap(struct SIndex * ,struct SIndex * );
    public void * __vecDelDtor(unsigned int );
};

class SCampaign
{
    private int GameMode;
    private int Race;
    private int Difficulty;
    private class SString MapName;
    private int MissionSP;
    private class SDArray<SUnitDescription> MissionUnits;
    private int CurrentSP;
    private class SDArray<SUnitDescription> CurrentUnits;
    private class SString MissionName;
    private int MenuToLoad;
    private int MapStatus;
    private class SString ArmyName;
    private class SString ArmyFileName;
    private int Result_Score;
    private int Result_ElapsedTime;
    private int Result_DestroyedEnemyUnits;
    private int Result_OwnUnitsOutOfAction;
    private int Result_LostUnits;
    private int Result_AmmoUsed;
    private int Result_FuelUsed;
    private int PayTime;
    private int Salary;
    private bool SkipBriefing;
    private class SString LastLoadedMapName;
    private int SameMapLoadedCount;
    public void SCampaign(class SCampaign & );
    public void SCampaign();
    public void ~SCampaign();
    public class SProperties * MissionIni;
    public class SProperties * MissionIniLocale;
    public class SProperties * UnitsIni;
    public class SProperties * UnitsIniColor;
    public class SProperties * UnitsIniLocale;
    public void InitScenarioMode(char * ,int ,int );
    public void InitTutorialMode(char * ,int ,int );
    public bool IsTutorialMode();
    public void InitCampaignMode(int ,int );
    public bool IsFirstMission();
    public bool IsLastMission();
    public bool IsCampaignMode();
    public bool IsScenarioMode();
    public void InitMultiMode();
    public void SetRace(int );
    public void SetMapFileName(char * );
    public bool IsMultiMode();
    public void SetArmyName(char * );
    public char * GetArmyName();
    public void SetArmyFileName(char * );
    public char * GetArmyFileName();
    public int LoadWhat();
    public void LetAnimDone();
    public void LetBriefingDone();
    public void LetMarketDone();
    public void LetMarketCancel();
    public void LetChatroomDone();
    public void LetMapDone();
    public void LetResultsDone();
    public void LetResultsRestart();
    public class SString GetAnimFileName();
    public bool GetBriefingSkip();
    public void SetBriefingSkip(bool );
    public int GetBriefingParts();
    public class SString GetBriefingSpeech(int );
    public char * GetBriefingText(int );
    public char * GetToDoText();
    public char * GetTypeText();
    public char * GetSizeText();
    public char * GetWeatherText();
    public char * GetResultText();
    public char * GetMissionCode();
    public void SetMissionSP(int );
    public int GetMissionSP();
    public void SetCurrentSP(int );
    public int GetCurrentSP();
    public void SpendSP(int );
    public int GetRace();
    public int GetDifficulty();
    public char * GetEnemy();
    public char * GetMapFileName();
    public char * GetName();
    public void ClearCurrentUnits();
    public void SetCurrentUnits(class SDArray<SUnitDescription> & ,bool );
    public void GetCurrentUnits(class SDArray<SUnitDescription> & );
    public char * GetMarketUnitMask();
    public char * GetEnemyUnitMask();
    public char * GetEnemyUnitLevel();
    public char * GetNewUnitMask();
    public int GetMapStatus();
    public void SetMapStatus(int );
    public bool IsMapRunning();
    public bool BuyUnit(struct SUnitDescription & );
    public bool IsPigCampaign();
    public bool SaveGame(char * ,char * );
    public void LoadGame(char * );
    public void LoadSavedGameNames(class SSaveLoadListBox & ,bool );
    public class SGameWorld * World;
    public class SChatRoomMenu * m_pChatRoomMenu;
    public bool bEquipment;
    public bool bLimitedAmmo;
    public bool bLimitedFuel;
    public bool bBomber;
    public bool bMovingForce;
    public bool bNewUnit;
    public bool bRandomStartPosition;
    public bool bCountdown;
    public bool bDomination;
    public int StartRandomseed;
    public unsigned int GameType;
    public int CountMinute;
    public void SetResults(int ,int ,int ,int ,int ,int ,int );
    public int GetScore();
    public int GetElapsedTime();
    public int GetDestroyedEnemyUnits();
    public int GetOwnUnitsOutOfAction();
    public int GetLostUnits();
    public int GetAmmoUsed();
    public int GetFuelUsed();
    public int GetPayTime();
    public int GetSalary();
    public void SetPayTime(int );
    public void SetSalary(int );
    public int GetStartRandomSeed();
    public void SetStartRandomSeed(int );
    public unsigned int NetworkLatency;
    public class SCampaign & operator=(class SCampaign & );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SUnitDescription>
{
    private int size;
    private int maxsize;
    public struct SUnitDescription * array;
    public void SDArray<SUnitDescription>(class SDArray<SUnitDescription> & );
    public void SDArray<SUnitDescription>();
    public void ~SDArray<SUnitDescription>();
    public int Add(struct SUnitDescription & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SUnitDescription & operator[](int );
    public void operator=(class SDArray<SUnitDescription> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SUnitDescription>
{
    private int size;
    private int maxsize;
    public struct SUnitDescription * array;
    public void SDArray<SUnitDescription>(class SDArray<SUnitDescription> & );
    public void SDArray<SUnitDescription>();
    public void ~SDArray<SUnitDescription>();
    public int Add(struct SUnitDescription & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SUnitDescription & operator[](int );
    public void operator=(class SDArray<SUnitDescription> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SSaveLoadListBoxItem
{
    char ItemText1[261];
    char ItemText2[261];
    char ItemText3[261];
    char ItemText4[261];
    char DifficultyText[261];
    struct _SYSTEMTIME time;
    unsigned long Color;
};

struct SSaveLoadListBoxItem
{
    char ItemText1[261];
    char ItemText2[261];
    char ItemText3[261];
    char ItemText4[261];
    char DifficultyText[261];
    struct _SYSTEMTIME time;
    unsigned long Color;
};

class SDArray<SSaveLoadListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SSaveLoadListBoxItem * array;
    public void SDArray<SSaveLoadListBoxItem>(class SDArray<SSaveLoadListBoxItem> & );
    public void SDArray<SSaveLoadListBoxItem>();
    public void ~SDArray<SSaveLoadListBoxItem>();
    public int Add(struct SSaveLoadListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSaveLoadListBoxItem & operator[](int );
    public void operator=(class SDArray<SSaveLoadListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SSaveLoadListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SSaveLoadListBoxItem * array;
    public void SDArray<SSaveLoadListBoxItem>(class SDArray<SSaveLoadListBoxItem> & );
    public void SDArray<SSaveLoadListBoxItem>();
    public void ~SDArray<SSaveLoadListBoxItem>();
    public int Add(struct SSaveLoadListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSaveLoadListBoxItem & operator[](int );
    public void operator=(class SDArray<SSaveLoadListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SSaveLoadListBox : public SDXWidget
{
    private int Font;
    private int RowHeight;
    private int VisibleTextLines;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private int SliderMarginLeft;
    private int SliderMarginRight;
    private int SliderMarginTop;
    private int SliderMarginBottom;
    private int MaxInnerTextLines;
    private int * TextLineFrames1;
    private int * TextLineFrames2;
    private int * TextLineFrames3;
    private int * DifficultyTextFrames;
    private int * TextLineBackFrames;
    private class SSliderV Slider;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private int CurActive;
    private int LastClickTime;
    public void SSaveLoadListBox(class SSaveLoadListBox & );
    public void SSaveLoadListBox();
    public void ~SSaveLoadListBox();
    public void Create(int ,unsigned int ,bool );
    public int DeleteItem(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public struct _SYSTEMTIME GetItemData(int );
    public int SetItemData(int ,struct _SYSTEMTIME );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int GetText(int ,char * ,char * ,char * ,char * ,char * ,int );
    public int SetText(int ,char * ,char * ,char * ,char * ,char * );
    public int GetTextLen(int );
    public int AddItem(char * ,char * ,char * ,char * ,char * ,struct _SYSTEMTIME ,unsigned long );
    public void SetMargin(int ,int ,int ,int );
    public void SetSliderMargin(int ,int ,int ,int );
    public void ResetContent();
    public int WidthMiddle;
    public void QSort(int );
    protected struct SSaveLoadListBoxItem m_ListBoxItem;
    protected class SDArray<SSaveLoadListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSaveLoadListBox : public SDXWidget
{
    private int Font;
    private int RowHeight;
    private int VisibleTextLines;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private int SliderMarginLeft;
    private int SliderMarginRight;
    private int SliderMarginTop;
    private int SliderMarginBottom;
    private int MaxInnerTextLines;
    private int * TextLineFrames1;
    private int * TextLineFrames2;
    private int * TextLineFrames3;
    private int * DifficultyTextFrames;
    private int * TextLineBackFrames;
    private class SSliderV Slider;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private int CurActive;
    private int LastClickTime;
    public void SSaveLoadListBox(class SSaveLoadListBox & );
    public void SSaveLoadListBox();
    public void ~SSaveLoadListBox();
    public void Create(int ,unsigned int ,bool );
    public int DeleteItem(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public struct _SYSTEMTIME GetItemData(int );
    public int SetItemData(int ,struct _SYSTEMTIME );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int GetText(int ,char * ,char * ,char * ,char * ,char * ,int );
    public int SetText(int ,char * ,char * ,char * ,char * ,char * );
    public int GetTextLen(int );
    public int AddItem(char * ,char * ,char * ,char * ,char * ,struct _SYSTEMTIME ,unsigned long );
    public void SetMargin(int ,int ,int ,int );
    public void SetSliderMargin(int ,int ,int ,int );
    public void ResetContent();
    public int WidthMiddle;
    public void QSort(int );
    protected struct SSaveLoadListBoxItem m_ListBoxItem;
    protected class SDArray<SSaveLoadListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SChatRoomMenu : public SDXWidget
{
    private bool OnAction(class SWidget * ,int ,int );
    private void OnUserEvent(unsigned long ,unsigned int ,long );
    private bool OnKeyDown(int );
    private bool OnKeyUp(int );
    private void OnTimer(int ,unsigned long );
    private bool CtrlPressed;
    private int MenuFont;
    private int MiniMapBackGroundFont;
    private int MiniMapBracketFont;
    private int MinimapBracketFrame;
    private unsigned int * MinimapImage;
    private class SDXWidget MiniMapPicture;
    private class SDXWidget MiniMapBracket;
    public class SEditBox EditBox;
    public int prevMenu;
    private class STextButton Cancel;
    private class SListBox MiniMapTextListBox;
    private void CancelGame();
    private void DeleteSelectedArmy();
    private void BackToTitleRoom();
    private void LockSettings();
    private void CreateNewArmy();
    private void EditSelectedArmy();
    private void LoadCurrentArmy();
    private void CheckArmy(class SStream & ,char &** ,class SStreamBuffer & );
    private int TimerPing;
    private int TimerThink;
    private int TimerStart;
    private int StartCounter;
    public void SChatRoomMenu(class SChatRoomMenu & );
    public void SChatRoomMenu();
    public void ~SChatRoomMenu();
    public void Create(class SMulti * ,bool ,int );
    public void SetVisible(bool );
    public bool bLoadArmyNames;
    public bool LoadMiniMap(char * );
    public bool GetMapFileCRC(char * ,unsigned long & );
    public bool IsMap(char * );
    public void LoadArmyNames();
    public void SetVisibleEverything(bool ,bool );
    private void ChangeGameSettings();
    public class SMulti * m_pMulti;
    public class SListBox ChatListBox;
    public class SFileListBox ArmyListBox;
    public class SFileListBox MapListBox;
    public int PingFrame[8];
    public int ReadyFrame[8];
    public int BuyingFrame[8];
    public int LoadingMapFrame[8];
    public class SDropList RaceDropList[8];
    public class SDropList PlayerNameDropList[8];
    public class STextButton StartGame;
    public class STextButton SettingsOk;
    public class STextButton NewArmy;
    public class STextButton EditArmy;
    public class STextButton DeleteArmy;
    public class STextButton ImReady;
    public class STextButton MyIP;
    public class STextButton Team[8];
    public class SColorButton PlayerColor[8];
    public class SDropList GameSettingsDropList_SPPeriodicLimit;
    public class SDropList GameSettingsDropList_SPStartLimit;
    public class SDropList GameSettingsDropList_GameType;
    public int MapText;
    public int MapName;
    public class SDropList GameSettingsDropList_CountMinutes;
    public class SCheckBox GameSettingsCheckBox_Equipment;
    public class SCheckBox GameSettingsCheckBox_Ammo;
    public class SCheckBox GameSettingsCheckBox_Fuel;
    public class SCheckBox GameSettingsCheckBox_MovingForce;
    public class SCheckBox GameSettingsCheckBox_Bomber;
    public class SCheckBox GameSettingsCheckBox_NewUnits;
    public class SCheckBox GameSettingsCheckBox_RandomStartPosition;
    public class SCheckBox GameSettingsCheckBox_Domination;
    public unsigned int MyRace;
    public int SettingsLockedText;
    public int SelectedArmy;
    public bool CompareArmyName(char * );
    public class STextButton BackToTitleRoomButton;
    public void OnChatMessage(char * ,unsigned long );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum SVerticalAlign
{
    Top=0,
    Middle=1,
    Bottom=2
};

class SQuickMarket : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private class SProperties * UnitsIni;
    private class SProperties * UnitsIniColor;
    private class SProperties * UnitsIniLocale;
    private class STextButton Buy;
    private class STextButton Cancel;
    private class SMarketButton UnitButtons[12];
    private class SDXWidget UpgradesBackground;
    private class SMarketButton UpgradeButtons[9];
    private char * UnitName;
    private char * UnitNick;
    private char * UnitDesc;
    private char * UnitAnim;
    private int UnitPrice;
    private int UnitHP;
    private int UnitAmmo;
    private int UnitFuel;
    private int UnitSpeed;
    private int UpgradeMask;
    private int ExtraArmor;
    private int ExtraAmmo;
    private int ExtraFuel;
    private int ExtraSpeed;
    private unsigned int Race;
    private int UnitPictureFonts[13];
    private int UpgradePictureGlyphs[9];
    private int SelectionFont;
    private int QuickBuyBoxFont;
    private int UpgradeFont;
    private int QuickBuyBoxFrame;
    private int NumUnits;
    private int SelUnit;
    private int Units[13];
    private void LoadUnitInfo();
    private class SListBox UnitPropertiesText;
    private class SListBox UnitPropertiesValue;
    private class SListBox UnitDescriptionListBox;
    private int UnitNameFrame;
    private int UnitSPFrame;
    private int UnitLevel;
    private class STextBox EquipmentDisabledText;
    public void SQuickMarket(class SQuickMarket & );
    public void SQuickMarket();
    public void ~SQuickMarket();
    public void Create();
    public bool isUnitSelected();
    public struct SUnitDescription UnitToBuy;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMenu : public SDXWidget
{
    protected int FaceFont;
    protected int FaceFrame;
    protected int VersionFrame;
    public void SMenu(class SMenu & );
    public void SMenu();
    public void ~SMenu();
    public void Create(char * ,bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMenu : public SDXWidget
{
    protected int FaceFont;
    protected int FaceFrame;
    protected int VersionFrame;
    public void SMenu(class SMenu & );
    public void SMenu();
    public void ~SMenu();
    public void Create(char * ,bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMarketButton : public SDXWidget
{
    private int SelectionFont;
    private int SpriteFrame1;
    private int SpriteFrame2;
    private void OnMouseDown(int ,int ,int ,int );
    public void SMarketButton(class SMarketButton * );
    public void SMarketButton(class SMarketButton & );
    public void SMarketButton();
    public void Create(int );
    public void SetPicture(int ,int );
    public void SetSelected(bool );
    public void ~SMarketButton();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMarketButton : public SDXWidget
{
    private int SelectionFont;
    private int SpriteFrame1;
    private int SpriteFrame2;
    private void OnMouseDown(int ,int ,int ,int );
    public void SMarketButton(class SMarketButton * );
    public void SMarketButton(class SMarketButton & );
    public void SMarketButton();
    public void Create(int );
    public void SetPicture(int ,int );
    public void SetSelected(bool );
    public void ~SMarketButton();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct SListBox::SListBoxItem
{
    char ItemText[261];
    unsigned long ItemData;
    unsigned long Color;
};

class SDArray<SListBox::SListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SListBox::SListBoxItem * array;
    public void SDArray<SListBox::SListBoxItem>(class SDArray<SListBox::SListBoxItem> & );
    public void SDArray<SListBox::SListBoxItem>();
    public void ~SDArray<SListBox::SListBoxItem>();
    public int Add(struct SListBox::SListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SListBox::SListBoxItem & operator[](int );
    public void operator=(class SDArray<SListBox::SListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SListBox::SListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SListBox::SListBoxItem * array;
    public void SDArray<SListBox::SListBoxItem>(class SDArray<SListBox::SListBoxItem> & );
    public void SDArray<SListBox::SListBoxItem>();
    public void ~SDArray<SListBox::SListBoxItem>();
    public int Add(struct SListBox::SListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SListBox::SListBoxItem & operator[](int );
    public void operator=(class SDArray<SListBox::SListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SListBox : public SDXWidget
{
    struct SListBoxItem
    {
        char ItemText[261];
        unsigned long ItemData;
        unsigned long Color;
    };
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private int SliderMarginLeft;
    private int SliderMarginRight;
    private int SliderMarginTop;
    private int SliderMarginBottom;
    private int * TextLineFrames;
    private int * TextLineBackFrames;
    private bool scrollbars;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private class SSliderV Slider;
    private bool nobreaklines;
    private int aligntext;
    private bool alignverticalcenter;
    private int CurActive;
    private int RowHeight;
    private int LastClickTime;
    public void SListBox(class SListBox & );
    public void SListBox();
    public void ~SListBox();
    public void Create(int ,unsigned int ,bool ,bool ,bool ,bool ,int ,bool );
    public int DeleteItem(int );
    public bool IsIndexVisible(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetVisibleTextLines();
    public int GetCurSel();
    public int SetCurSel(int );
    public unsigned long GetItemData(int );
    public int SetItemData(int ,unsigned long );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int GetText(int ,char * ,int );
    public int SetText(int ,char * );
    public int GetTextLen(int );
    public int AddItem(char * ,unsigned long ,unsigned long );
    public void SetMargin(int ,int ,int ,int );
    public void SetSliderMargin(int ,int ,int ,int );
    public void ResetContent();
    protected struct SListBox::SListBoxItem m_ListBoxItem;
    protected class SDArray<SListBox::SListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SListBox : public SDXWidget
{
    struct SListBoxItem
    {
        char ItemText[261];
        unsigned long ItemData;
        unsigned long Color;
    };
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private int SliderMarginLeft;
    private int SliderMarginRight;
    private int SliderMarginTop;
    private int SliderMarginBottom;
    private int * TextLineFrames;
    private int * TextLineBackFrames;
    private bool scrollbars;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private class SSliderV Slider;
    private bool nobreaklines;
    private int aligntext;
    private bool alignverticalcenter;
    private int CurActive;
    private int RowHeight;
    private int LastClickTime;
    public void SListBox(class SListBox & );
    public void SListBox();
    public void ~SListBox();
    public void Create(int ,unsigned int ,bool ,bool ,bool ,bool ,int ,bool );
    public int DeleteItem(int );
    public bool IsIndexVisible(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetVisibleTextLines();
    public int GetCurSel();
    public int SetCurSel(int );
    public unsigned long GetItemData(int );
    public int SetItemData(int ,unsigned long );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int GetText(int ,char * ,int );
    public int SetText(int ,char * );
    public int GetTextLen(int );
    public int AddItem(char * ,unsigned long ,unsigned long );
    public void SetMargin(int ,int ,int ,int );
    public void SetSliderMargin(int ,int ,int ,int );
    public void ResetContent();
    protected struct SListBox::SListBoxItem m_ListBoxItem;
    protected class SDArray<SListBox::SListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct SListBox::SListBoxItem
{
    char ItemText[261];
    unsigned long ItemData;
    unsigned long Color;
};

class STextBox : public SDXWidget
{
    private int Font;
    private int TopIndex;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private class SDArray<int> TextFrames;
    private bool Scrollbars;
    private class SSliderV Slider;
    private enum SHorizontalAlign horizontalAlign;
    private enum SVerticalAlign verticalAlign;
    private bool alignverticalcenter;
    private void Update();
    public void STextBox(class STextBox & );
    public void STextBox();
    public void ~STextBox();
    public void Create(int ,unsigned int ,bool ,bool ,enum SHorizontalAlign ,enum SVerticalAlign );
    public int SetText(char * );
    public int GetTopIndex();
    public int GetRowCount();
    public void ResetContent();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class STextBox : public SDXWidget
{
    private int Font;
    private int TopIndex;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private class SDArray<int> TextFrames;
    private bool Scrollbars;
    private class SSliderV Slider;
    private enum SHorizontalAlign horizontalAlign;
    private enum SVerticalAlign verticalAlign;
    private bool alignverticalcenter;
    private void Update();
    public void STextBox(class STextBox & );
    public void STextBox();
    public void ~STextBox();
    public void Create(int ,unsigned int ,bool ,bool ,enum SHorizontalAlign ,enum SVerticalAlign );
    public int SetText(char * );
    public int GetTopIndex();
    public int GetRowCount();
    public void ResetContent();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMinimap : public SDXWidget
{
    private int TextFont;
    private int InfoFrame1;
    private int InfoFrame2;
    private int MinimapFrame;
    private int CursorFrame[2];
    private bool Pressed;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void CalculateInfoCoords(int ,int ,int & ,int & );
    public void SMinimap(class SMinimap * );
    public void SMinimap(class SMinimap & );
    public void SMinimap();
    public void Create(int ,int ,int );
    public int GetMinimapFrame();
    public void ~SMinimap();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMinimap : public SDXWidget
{
    private int TextFont;
    private int InfoFrame1;
    private int InfoFrame2;
    private int MinimapFrame;
    private int CursorFrame[2];
    private bool Pressed;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void CalculateInfoCoords(int ,int ,int & ,int & );
    public void SMinimap(class SMinimap * );
    public void SMinimap(class SMinimap & );
    public void SMinimap();
    public void Create(int ,int ,int );
    public int GetMinimapFrame();
    public void ~SMinimap();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SScaler : public SWidget
{
    protected int BackFrame;
    protected float ScaleFactor;
    public void SScaler(class SScaler & );
    public void SScaler();
    public void ~SScaler();
    public void Create();
    public int GetFrame();
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public void SetVisible(bool );
    public void SetGravity(int );
    public void SetScaleFactor(float );
    public float GetScaleFactor();
    public void ParentToChild(int & ,int & );
    public void ChildToParent(int & ,int & );
    public bool IsScaler();
    public bool CanAcceptEvents();
    public bool acceptEventsWhenHaveChildren;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SScaler : public SWidget
{
    protected int BackFrame;
    protected float ScaleFactor;
    public void SScaler(class SScaler & );
    public void SScaler();
    public void ~SScaler();
    public void Create();
    public int GetFrame();
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public void SetVisible(bool );
    public void SetGravity(int );
    public void SetScaleFactor(float );
    public float GetScaleFactor();
    public void ParentToChild(int & ,int & );
    public void ChildToParent(int & ,int & );
    public bool IsScaler();
    public bool CanAcceptEvents();
    public bool acceptEventsWhenHaveChildren;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class STriggerCondition
{
    private char * GetPlayerText();
    private char * GetQuantityText();
    private char * GetLocationText(class SEditorWorld * );
    private char * GetUnitsText();
    public int Type;
    public int Player;
    public bool QuantityMore;
    public int Quantity;
    public int Location;
    public int UnitType;
    public class SString UnitClass;
    public bool SwitchSet;
    public int SwitchNum;
    public void STriggerCondition(class STriggerCondition & );
    public void STriggerCondition();
    public void operator=(class STriggerCondition & );
    public int GetPropertyMask();
    public void GetText(class SEditorWorld * ,char * );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void ~STriggerCondition();
    public void * __vecDelDtor(unsigned int );
};

class SEditorWorld
{
};

class STriggerCondition
{
    private char * GetPlayerText();
    private char * GetQuantityText();
    private char * GetLocationText(class SEditorWorld * );
    private char * GetUnitsText();
    public int Type;
    public int Player;
    public bool QuantityMore;
    public int Quantity;
    public int Location;
    public int UnitType;
    public class SString UnitClass;
    public bool SwitchSet;
    public int SwitchNum;
    public void STriggerCondition(class STriggerCondition & );
    public void STriggerCondition();
    public void operator=(class STriggerCondition & );
    public int GetPropertyMask();
    public void GetText(class SEditorWorld * ,char * );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void ~STriggerCondition();
    public void * __vecDelDtor(unsigned int );
};

class STriggerAction
{
    private char * GetPlayerText();
    private char * GetLocationText(class SEditorWorld * );
    private char * GetDestinationText(class SEditorWorld * );
    private char * GetUnitsText();
    private char * GetNewUnitText();
    public int Type;
    public int Player;
    public int Location;
    public int UnitType;
    public class SString UnitClass;
    public class SString NewUnitClass;
    public int Destination;
    public int SwitchOp;
    public int SwitchNum;
    public int Number;
    public void STriggerAction(class STriggerAction & );
    public void STriggerAction();
    public void operator=(class STriggerAction & );
    public int GetPropertyMask();
    public void GetText(class SEditorWorld * ,char * );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void ~STriggerAction();
    public void * __vecDelDtor(unsigned int );
};

class STriggerAction
{
    private char * GetPlayerText();
    private char * GetLocationText(class SEditorWorld * );
    private char * GetDestinationText(class SEditorWorld * );
    private char * GetUnitsText();
    private char * GetNewUnitText();
    public int Type;
    public int Player;
    public int Location;
    public int UnitType;
    public class SString UnitClass;
    public class SString NewUnitClass;
    public int Destination;
    public int SwitchOp;
    public int SwitchNum;
    public int Number;
    public void STriggerAction(class STriggerAction & );
    public void STriggerAction();
    public void operator=(class STriggerAction & );
    public int GetPropertyMask();
    public void GetText(class SEditorWorld * ,char * );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void ~STriggerAction();
    public void * __vecDelDtor(unsigned int );
};

class STrigger
{
    public int PlayerMask;
    public class SString Name;
    public class SDArray<STriggerCondition> Conditions;
    public class SDArray<STriggerAction> Actions;
    public void STrigger(class STrigger & );
    public void STrigger();
    public void operator=(class STrigger & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void ~STrigger();
    public void * __vecDelDtor(unsigned int );
};

class SDArray<STriggerCondition>
{
    private int size;
    private int maxsize;
    public class STriggerCondition * array;
    public void SDArray<STriggerCondition>(class SDArray<STriggerCondition> & );
    public void SDArray<STriggerCondition>();
    public void ~SDArray<STriggerCondition>();
    public int Add(class STriggerCondition & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class STriggerCondition & operator[](int );
    public void operator=(class SDArray<STriggerCondition> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<STriggerCondition>
{
    private int size;
    private int maxsize;
    public class STriggerCondition * array;
    public void SDArray<STriggerCondition>(class SDArray<STriggerCondition> & );
    public void SDArray<STriggerCondition>();
    public void ~SDArray<STriggerCondition>();
    public int Add(class STriggerCondition & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class STriggerCondition & operator[](int );
    public void operator=(class SDArray<STriggerCondition> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<STriggerAction>
{
    private int size;
    private int maxsize;
    public class STriggerAction * array;
    public void SDArray<STriggerAction>(class SDArray<STriggerAction> & );
    public void SDArray<STriggerAction>();
    public void ~SDArray<STriggerAction>();
    public int Add(class STriggerAction & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class STriggerAction & operator[](int );
    public void operator=(class SDArray<STriggerAction> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<STriggerAction>
{
    private int size;
    private int maxsize;
    public class STriggerAction * array;
    public void SDArray<STriggerAction>(class SDArray<STriggerAction> & );
    public void SDArray<STriggerAction>();
    public void ~SDArray<STriggerAction>();
    public int Add(class STriggerAction & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class STriggerAction & operator[](int );
    public void operator=(class SDArray<STriggerAction> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SCamera
{
    float X;
    float Z;
    float Direction;
    float Elevation;
    float Zoom;
};

class SIPlane
{
    public void Acquire(float &** ,float &** ,unsigned int &** [9],struct STile &** ,unsigned int &** );
    public void InitTileVariations(char * );
    public void InitTileset2();
    public void ReleaseTileset();
    public void LoadSketchTexture(char * );
    public void SetViewType(int );
    public void ComputeShadows();
    public void UpdateVisMap(unsigned int * ,unsigned int * ,int );
    public void Update(int ,int ,int ,int );
    public void UpdateColorMap(int ,int ,int ,int );
    public void EnableGodMode(bool );
    public void SetCompactMode(bool );
    public bool GetCompactMode();
    public void SetBlockMapAddress(unsigned int * ,unsigned int * );
    public void SetBlockMapMode(bool );
    public bool GetBlockMapMode();
    public void SIPlane(class SIPlane * );
    public void SIPlane(class SIPlane & );
    public void SIPlane();
    public class SIPlane & operator=(class SIPlane * );
    public class SIPlane & operator=(class SIPlane & );
};

class SIPlane
{
    public void Acquire(float &** ,float &** ,unsigned int &** [9],struct STile &** ,unsigned int &** );
    public void InitTileVariations(char * );
    public void InitTileset2();
    public void ReleaseTileset();
    public void LoadSketchTexture(char * );
    public void SetViewType(int );
    public void ComputeShadows();
    public void UpdateVisMap(unsigned int * ,unsigned int * ,int );
    public void Update(int ,int ,int ,int );
    public void UpdateColorMap(int ,int ,int ,int );
    public void EnableGodMode(bool );
    public void SetCompactMode(bool );
    public bool GetCompactMode();
    public void SetBlockMapAddress(unsigned int * ,unsigned int * );
    public void SetBlockMapMode(bool );
    public bool GetBlockMapMode();
    public void SIPlane(class SIPlane * );
    public void SIPlane(class SIPlane & );
    public void SIPlane();
    public class SIPlane & operator=(class SIPlane * );
    public class SIPlane & operator=(class SIPlane & );
};

struct STile
{
    unsigned int Level;
    unsigned int Variation;
};

struct SDoodad
{
    class SString FileName;
    float x;
    float yrel;
    float z;
    float dir;
    float tiltx;
    float tiltz;
    class SIObject * Object;
    class SIObject * ObjectRuins;
    int Selection;
    bool AlignMove;
    bool AlignRotate;
    int bx0;
    int bz0;
    int bx1;
    int bz1;
    int vx0;
    int vz0;
    int vx1;
    int vz1;
    float hp;
    float maxhp;
    int Bozot;
    int Sebezhetetlen;
    int Kidontheto;
    int Szetdurhato;
    int Robbanastipus;
    int Atlatszo;
    int Hidszelesseg;
    int Forgatas;
    float TreeBending;
    float TreeWobble;
    float ForgasSebesseg;
    int BoundsComputed;
    float xmin;
    float xmax;
    float zmin;
    float zmax;
    void SDoodad(struct SDoodad * );
    void SDoodad(struct SDoodad & );
    void SDoodad();
    void ~SDoodad();
    struct SDoodad & operator=(struct SDoodad * );
    struct SDoodad & operator=(struct SDoodad & );
    void * __vecDelDtor(unsigned int );
};

struct SDoodad
{
    class SString FileName;
    float x;
    float yrel;
    float z;
    float dir;
    float tiltx;
    float tiltz;
    class SIObject * Object;
    class SIObject * ObjectRuins;
    int Selection;
    bool AlignMove;
    bool AlignRotate;
    int bx0;
    int bz0;
    int bx1;
    int bz1;
    int vx0;
    int vz0;
    int vx1;
    int vz1;
    float hp;
    float maxhp;
    int Bozot;
    int Sebezhetetlen;
    int Kidontheto;
    int Szetdurhato;
    int Robbanastipus;
    int Atlatszo;
    int Hidszelesseg;
    int Forgatas;
    float TreeBending;
    float TreeWobble;
    float ForgasSebesseg;
    int BoundsComputed;
    float xmin;
    float xmax;
    float zmin;
    float zmax;
    void SDoodad(struct SDoodad * );
    void SDoodad(struct SDoodad & );
    void SDoodad();
    void ~SDoodad();
    struct SDoodad & operator=(struct SDoodad * );
    struct SDoodad & operator=(struct SDoodad & );
    void * __vecDelDtor(unsigned int );
};

class SHeap<SDoodad>
{
    struct __Tstruct
    {
        int use;
        struct SDoodad data;
        void __Tstruct(struct SHeap<SDoodad>::__Tstruct * );
        void __Tstruct(struct SHeap<SDoodad>::__Tstruct & );
        void __Tstruct();
        void ~__Tstruct();
        struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct * );
        struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct & );
        void * __vecDelDtor(unsigned int );
    };
    private struct SHeap<SDoodad>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SDoodad>();
    public void ~SHeap<SDoodad>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SDoodad & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SDoodad>
{
    struct __Tstruct
    {
        int use;
        struct SDoodad data;
        void __Tstruct(struct SHeap<SDoodad>::__Tstruct * );
        void __Tstruct(struct SHeap<SDoodad>::__Tstruct & );
        void __Tstruct();
        void ~__Tstruct();
        struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct * );
        struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct & );
        void * __vecDelDtor(unsigned int );
    };
    private struct SHeap<SDoodad>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SDoodad>();
    public void ~SHeap<SDoodad>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SDoodad & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

enum SPlayerControl
{
    CONTROL_HUMAN=0,
    CONTROL_COMPUTER=1,
    CONTROL_NEUTRAL=2,
    CONTROL_RESCUABLE=3,
    CONTROL_SPY=4
};

struct SPlayer
{
    int Color;
    int Race;
    enum SPlayerControl Control;
    int Team;
    bool Connected;
    int StartingPosition;
    float RepStartX;
    float RepStartZ;
    bool HaveBomber;
    bool HaveHelicopter;
    int NumberOfFlyingBombers;
    int NumberOfFlyingHelicopters;
    int OwnScore;
    int TeamScore;
    int Kills;
    int Lost;
    int AmmoUsed;
    int CurrentSP;
    float FuelUsed;
    class SString Name;
    int MapStatus;
    int LastFrameThatCheckedForLateArrival;
    int FrameDelayFactor;
    void SPlayer(struct SPlayer * );
    void SPlayer(struct SPlayer & );
    void SPlayer();
    void ~SPlayer();
    struct SPlayer & operator=(struct SPlayer * );
    struct SPlayer & operator=(struct SPlayer & );
    void * __vecDelDtor(unsigned int );
};

struct SPlayer
{
    int Color;
    int Race;
    enum SPlayerControl Control;
    int Team;
    bool Connected;
    int StartingPosition;
    float RepStartX;
    float RepStartZ;
    bool HaveBomber;
    bool HaveHelicopter;
    int NumberOfFlyingBombers;
    int NumberOfFlyingHelicopters;
    int OwnScore;
    int TeamScore;
    int Kills;
    int Lost;
    int AmmoUsed;
    int CurrentSP;
    float FuelUsed;
    class SString Name;
    int MapStatus;
    int LastFrameThatCheckedForLateArrival;
    int FrameDelayFactor;
    void SPlayer(struct SPlayer * );
    void SPlayer(struct SPlayer & );
    void SPlayer();
    void ~SPlayer();
    struct SPlayer & operator=(struct SPlayer * );
    struct SPlayer & operator=(struct SPlayer & );
    void * __vecDelDtor(unsigned int );
};

class SHeap<SUnit *>
{
    struct __Tstruct
    {
        int use;
        class SUnit * data;
    };
    private struct SHeap<SUnit *>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SUnit *>();
    public void ~SHeap<SUnit *>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public class SUnit &** operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SUnit *>
{
    struct __Tstruct
    {
        int use;
        class SUnit * data;
    };
    private struct SHeap<SUnit *>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SUnit *>();
    public void ~SHeap<SUnit *>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public class SUnit &** operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SUnitStats
{
    int Owner;
    int HP;
    int Ammo;
    int Fuel;
    int Cargo;
    int Level;
    int DriverMode;
    int GunnerMode;
    int SpecialMode;
    int Upgrades[3];
};

struct SGroupStatus
{
    int SelectedGroup;
    int GroupPresent[9];
};

struct SAmbient
{
    char * FileName;
    float X;
    float Yrel;
    float Z;
    float Distance;
    int SoundIdx;
    int Selection;
};

class SHeap<SAmbient>
{
    struct __Tstruct
    {
        int use;
        struct SAmbient data;
    };
    private struct SHeap<SAmbient>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SAmbient>();
    public void ~SHeap<SAmbient>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SAmbient & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SAmbient>
{
    struct __Tstruct
    {
        int use;
        struct SAmbient data;
    };
    private struct SHeap<SAmbient>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SAmbient>();
    public void ~SHeap<SAmbient>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SAmbient & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SLake
{
    char * FileName;
    float X;
    float Yrel;
    float Z;
    int TextureIdx;
    int LakeIdx;
    int Selection;
    int Flow;
    int Sparkle;
    float FloodYrel;
    float FloodDepth;
    unsigned long FloodTime;
};

class SHeap<SLake>
{
    struct __Tstruct
    {
        int use;
        struct SLake data;
    };
    private struct SHeap<SLake>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SLake>();
    public void ~SHeap<SLake>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SLake & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SLake>
{
    struct __Tstruct
    {
        int use;
        struct SLake data;
    };
    private struct SHeap<SLake>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SLake>();
    public void ~SHeap<SLake>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SLake & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class STrigger
{
    public int PlayerMask;
    public class SString Name;
    public class SDArray<STriggerCondition> Conditions;
    public class SDArray<STriggerAction> Actions;
    public void STrigger(class STrigger & );
    public void STrigger();
    public void operator=(class STrigger & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void ~STrigger();
    public void * __vecDelDtor(unsigned int );
};

class SDArray<STrigger>
{
    private int size;
    private int maxsize;
    public class STrigger * array;
    public void SDArray<STrigger>(class SDArray<STrigger> & );
    public void SDArray<STrigger>();
    public void ~SDArray<STrigger>();
    public int Add(class STrigger & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class STrigger & operator[](int );
    public void operator=(class SDArray<STrigger> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<STrigger>
{
    private int size;
    private int maxsize;
    public class STrigger * array;
    public void SDArray<STrigger>(class SDArray<STrigger> & );
    public void SDArray<STrigger>();
    public void ~SDArray<STrigger>();
    public int Add(class STrigger & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class STrigger & operator[](int );
    public void operator=(class SDArray<STrigger> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SLocation
{
    int X0;
    int Z0;
    int X1;
    int Z1;
    char * Name;
    int Rect;
    int TextFrame;
    int Color;
    void Save(class SStream * );
    void Load(class SStream * );
    void ~SLocation();
    void * __vecDelDtor(unsigned int );
};

class SHeap<SLocation>
{
    struct __Tstruct
    {
        int use;
        struct SLocation data;
        void ~__Tstruct();
        void * __vecDelDtor(unsigned int );
    };
    private struct SHeap<SLocation>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SLocation>();
    public void ~SHeap<SLocation>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SLocation & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SLocation>
{
    struct __Tstruct
    {
        int use;
        struct SLocation data;
        void ~__Tstruct();
        void * __vecDelDtor(unsigned int );
    };
    private struct SHeap<SLocation>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SLocation>();
    public void ~SHeap<SLocation>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SLocation & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SSuperWindow : public SDXWindow
{
    private class SMainMenu * MainMenu;
    private class SSingleMenu * SingleMenu;
    private class SMultiLANMenu * MultiLANMenu;
    private class SMultiDirectIPMenu * MultiDirectIPMenu;
    private class SMultiPreMenu * MultiPreMenu;
    private class SOptionsMenu * OptionsMenu;
    private class SGameOptionsMenu * GameOptionsMenu;
    private class SGraphicsOptionsMenu * GraphicsOptionsMenu;
    private class SAudioOptionsMenu * AudioOptionsMenu;
    private class SLanguageOptionsMenu * LanguageOptionsMenu;
    private class SLoadMenu * LoadGameMenu;
    private class SChatRoomMenu * ChatRoomMenu;
    private class STitleRoom * TitleRoom;
    private class SIntroduction * Introduction;
    private class SSplash * Splash;
    private class SBriefingMenu * BriefingMenu;
    private class SResultsMenu * ResultsMenu;
    private class SGameView * GameView;
    private class SMenuBackGroundView * MenuBackgroundView;
    private class SVideoView * VideoView;
    private class SMarket * Market;
    private class SCredits * Credits;
    private class SProperties * MenuIni;
    private bool OnKeyDown(int );
    private bool OnAction(class SWidget * ,int ,int );
    private void OnDestroy();
    private bool OnIdle();
    private void OnSize(int ,int );
    private void OnTimer(int ,unsigned long );
    private void OnDPIChange(struct tagRECT );
    private void OnActivateApp(bool );
    private void LoadMainMenu();
    private void LoadCredits();
    private void LoadSingleMenu();
    private void LoadMultiLANMenu();
    private void LoadMultiDirectIPMenu();
    private void LoadMultiPreMenu();
    private void LoadOptionsMenu();
    private void LoadOptionsGameMenu();
    private void LoadOptionsGraphicsMenu();
    private void LoadOptionsAudioMenu();
    private void LoadOptionsLanguageMenu();
    private void LoadLoadGameMenu();
    private void LoadChatRoomMenu(bool ,int );
    private void LoadTitleRoom();
    private void LoadIntroduction();
    private void LoadNextCampaignMenu();
    private class SScaler * MenuBackgroundScaler;
    private void SetScalerPosition();
    private void LoadMenuBackground();
    private void UnloadMenuBackground();
    private void LoadMenuMusic();
    private void CreateHostFromCommandLine(char * );
    private void ConnectToHostFromCommandLine(char * ,char * );
    private bool bStartMultiFromCommandLine;
    private int QuitTimer;
    private bool Initialized;
    private void Initialize0();
    private void Initialize1();
    private void InitializeFastMode();
    private void LoadMenuFont(unsigned int ,bool );
    private void LoadRaceFonts(unsigned int ,bool );
    private void LoadSmallFonts(bool );
    private void InitFileSystem();
    private void CreateVideoView(char * ,int ,bool );
    private class SMulti * pMulti;
    public void SSuperWindow(class SSuperWindow & );
    public void SSuperWindow();
    public void ~SSuperWindow();
    public int Create(class SResource ,class SResource ,wchar_t * );
    public void Play();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMainMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void OnMouseMove(int ,int ,int );
    private void UnactivateAll();
    private class STextButton Buttons[6];
    private int FaceFont;
    private int FaceFrame;
    public void SMainMenu(class SMainMenu & );
    public void SMainMenu();
    public void ~SMainMenu();
    public void Create();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMainMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void OnMouseMove(int ,int ,int );
    private void UnactivateAll();
    private class STextButton Buttons[6];
    private int FaceFont;
    private int FaceFrame;
    public void SMainMenu(class SMainMenu & );
    public void SMainMenu();
    public void ~SMainMenu();
    public void Create();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSingleMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void OnMouseMove(int ,int ,int );
    private int PigFont;
    private int RabbitFont;
    private class STextButton Buttons[4];
    private class SButton PigPicture;
    private class SButton RabbitPicture;
    private class SLabel Difficulty;
    private class SRadioButton RadioButton_Easy;
    private class SRadioButton RadioButton_Medium;
    private class SRadioButton RadioButton_Hard;
    private class SDXWidget DifficultyBackGround;
    private void UnactivateAll();
    public void SSingleMenu(class SSingleMenu & );
    public void SSingleMenu();
    public void ~SSingleMenu();
    public void Create();
    public int DifficultyValue;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSingleMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void OnMouseMove(int ,int ,int );
    private int PigFont;
    private int RabbitFont;
    private class STextButton Buttons[4];
    private class SButton PigPicture;
    private class SButton RabbitPicture;
    private class SLabel Difficulty;
    private class SRadioButton RadioButton_Easy;
    private class SRadioButton RadioButton_Medium;
    private class SRadioButton RadioButton_Hard;
    private class SDXWidget DifficultyBackGround;
    private void UnactivateAll();
    public void SSingleMenu(class SSingleMenu & );
    public void SSingleMenu();
    public void ~SSingleMenu();
    public void Create();
    public int DifficultyValue;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMultiLANMenu : public SMenu, public ILanDiscoveryEventHandler
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool OnChar(int );
    private void JoinGame();
    private void CreateGame();
    private void OnUpdateServers(int ,struct ServerInfo * );
    private void InitJoinListbox();
    private void OnUserEvent(unsigned long ,unsigned int ,long );
    private class STextButton CreateButton;
    private class STextButton CancelButton;
    private class SLabel ConnectionType;
    private class SMessageBoxWithoutButtons Message;
    private class STextButton JoinButton;
    private class SMulti * m_pMulti;
    private class SListBox JoinListBox;
    private class LanDiscovery * lanDiscovery;
    private class Array<ServerInfo> serverList;
    private bool isJoinGameInProgress;
    public void SMultiLANMenu(class SMultiLANMenu & );
    public void SMultiLANMenu();
    public void ~SMultiLANMenu();
    public void Create(class SMulti * );
    public void Update();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMultiDirectIPMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool OnChar(int );
    private void CreateGame();
    private void JoinGame();
    private void GetLocalIP();
    private void OnUserEvent(unsigned long ,unsigned int ,long );
    private class STextButton CreateButton;
    private class STextButton CancelButton;
    private bool m_bJoinToHostFromCommandLine;
    private class SEditBox HostIPBox;
    private class SLabel HostIPText;
    private int LocalIPText;
    private class SMessageBoxWithoutButtons Message;
    private bool isJoinGameInProgress;
    public void SMultiDirectIPMenu(class SMultiDirectIPMenu & );
    public void SMultiDirectIPMenu();
    public void ~SMultiDirectIPMenu();
    public void Create(class SMulti * ,char * );
    public class STextButton JoinButton;
    public class SMulti * m_pMulti;
    public class STextButton SpecifyButton;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMultiPreMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool NameValidation();
    private class STextButton CreateButton;
    private class STextButton CancelButton;
    private class SEditBoxWithText Name;
    private class SMulti * m_pMulti;
    private class STextButton Cancel;
    private class STextButton InternetGame;
    private class STextButton Local;
    public void SMultiPreMenu(class SMultiPreMenu & );
    public void SMultiPreMenu();
    public void ~SMultiPreMenu();
    public void Create(class SMulti * );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMultiPreMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool NameValidation();
    private class STextButton CreateButton;
    private class STextButton CancelButton;
    private class SEditBoxWithText Name;
    private class SMulti * m_pMulti;
    private class STextButton Cancel;
    private class STextButton InternetGame;
    private class STextButton Local;
    public void SMultiPreMenu(class SMultiPreMenu & );
    public void SMultiPreMenu();
    public void ~SMultiPreMenu();
    public void Create(class SMulti * );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SOptionsMenu : public SMenu
{
    private class STextButton Cancel;
    private class STextButton Audio;
    private class STextButton Graphics;
    private class STextButton Game;
    private class STextButton Language;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void UnactivateAll();
    public void SOptionsMenu(class SOptionsMenu & );
    public void SOptionsMenu();
    public void ~SOptionsMenu();
    public void Create(bool ,bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SOptionsMenu : public SMenu
{
    private class STextButton Cancel;
    private class STextButton Audio;
    private class STextButton Graphics;
    private class STextButton Game;
    private class STextButton Language;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void UnactivateAll();
    public void SOptionsMenu(class SOptionsMenu & );
    public void SOptionsMenu();
    public void ~SOptionsMenu();
    public void Create(bool ,bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SGameOptionsMenu : public SMenu
{
    private class STextButton Ok;
    private class STextButton Cancel;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool HaveToSave();
    private void UnactivateAll();
    private class SSliderH SliderMouseScrollSpeed;
    private class SSliderH SliderKeyboardScrollSpeed;
    private class SCheckBox ShowTipsCheckBox;
    private class SDropList MouseRestrictionDropList;
    private class SDropList SubtitlesDropList;
    private class SDropList FogOfWarDropList;
    private class SDropList UnitAcknowledgementDropList;
    private class SDropList OtherUnitVoiceDropList;
    public void SGameOptionsMenu(class SGameOptionsMenu & );
    public void SGameOptionsMenu();
    public void ~SGameOptionsMenu();
    public void Create(bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SGraphicsOptionsMenu : public SMenu
{
    private class STextButton Ok;
    private class STextButton Cancel;
    private class SSliderH ResolutionScaleSlider;
    private int CurrentResolutionFrame;
    private class SDropList MonitorDropList;
    private class SDropList DisplayModeDroplist;
    private class SDropList ScreenResolutionDropList;
    private class SDropList VSyncDropList;
    private class SDropList AntialiasingDropList;
    private class SDropList AnisotropicFilteringDropList;
    private class SDropList ShadowsDropList;
    private class SDropList TexturesDetailDropList;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void UnactivateAll();
    private bool HaveToSave();
    private float GetResolutionScale();
    private int GetResolutionSliderPos(float ,int );
    private void UpdateResolutionText();
    private class SSliderH SliderBrightness;
    public void SGraphicsOptionsMenu(class SGraphicsOptionsMenu & );
    public void SGraphicsOptionsMenu();
    public void ~SGraphicsOptionsMenu();
    public void Create(bool );
    public void OnSize();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SAudioOptionsMenu : public SMenu
{
    private class STextButton Ok;
    private class STextButton Cancel;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool HaveToSave();
    private void UnactivateAll();
    private void CancelWidget();
    private class SSliderH SliderMusicVolume;
    private class SSliderH SliderSoundVolume;
    private class SSliderH SliderVoiceVolume;
    private class SCheckBox ReverseChannelsCheckBox;
    private class SCheckBox PlaySoundInBackgroundCheckBox;
    public void SAudioOptionsMenu(class SAudioOptionsMenu & );
    public void SAudioOptionsMenu();
    public void ~SAudioOptionsMenu();
    public void Create(bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SAudioOptionsMenu : public SMenu
{
    private class STextButton Ok;
    private class STextButton Cancel;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private bool HaveToSave();
    private void UnactivateAll();
    private void CancelWidget();
    private class SSliderH SliderMusicVolume;
    private class SSliderH SliderSoundVolume;
    private class SSliderH SliderVoiceVolume;
    private class SCheckBox ReverseChannelsCheckBox;
    private class SCheckBox PlaySoundInBackgroundCheckBox;
    public void SAudioOptionsMenu(class SAudioOptionsMenu & );
    public void SAudioOptionsMenu();
    public void ~SAudioOptionsMenu();
    public void Create(bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SLanguageOptionsMenu : public SMenu
{
    private class STextButton Ok;
    private class STextButton Cancel;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void UnactivateAll();
    private bool HaveToSave();
    private class SDropList LanguagesDroplist;
    public void SLanguageOptionsMenu(class SLanguageOptionsMenu & );
    public void SLanguageOptionsMenu();
    public void ~SLanguageOptionsMenu();
    public void Create(bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SLoadMenu : public SMenu
{
    private class STextButton Load;
    private class STextButton Delete;
    private class STextButton Cancel;
    private class SSaveLoadListBox ListBox;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void LoadGame();
    public void SLoadMenu(class SLoadMenu & );
    public void SLoadMenu();
    public void ~SLoadMenu();
    public void Create(bool );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class STitleRoom : public SDXWidget
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnChar(int );
    private bool OnKeyDown(int );
    private bool OnKeyUp(int );
    private bool CtrlPressed;
    private int MenuFont;
    private class STextButton CancelButton;
    private void CreateGame();
    private void JoinGame();
    private void Refresh();
    private void BackToStagingRoom();
    private void Cancel();
    private void OnUserEvent(unsigned long ,unsigned int ,long );
    private bool isJoinGameInProgress;
    public void STitleRoom(class STitleRoom & );
    public void STitleRoom();
    public void ~STitleRoom();
    public void Create(class SMulti * );
    public void EnableJoinButtonIfSelectedGame();
    public void OnUpdateUsers(int ,struct UserInfo * );
    public void OnUpdateMatches(int ,struct MatchInfo * );
    public void OnChatMessage(char * ,unsigned long );
    public class SMulti * m_pMulti;
    public class SEditBox EditBox;
    public class SListBox ChatListBox;
    public class SPlayerListBox PlayersListBox;
    public class SMatchListBox RunningGamesListBox;
    public class SDropList SQLDrop_Stage;
    public class SDropList SQLDrop_Players;
    public class SDropList SQLDrop_GameType;
    public class SDropList SQLDrop_Version;
    public int TotalNumberOfGamesText;
    public int NumberOfPlayersText;
    public int NumberOfPlayers;
    public class STextButton JoinButton;
    public class STextButton RefreshButton;
    public class STextButton CreateButton;
    public class SMessageBoxWithoutButtons Message;
    public class STextButton BackToStagingRoomButton;
    private void TESTSERVERS();
    private void TESTPLAYERS(int );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SIntroduction : public SSkippableDXWidget
{
    public void SIntroduction(class SIntroduction & );
    public void SIntroduction();
    public void ~SIntroduction();
    public void Create(int );
    public void Update();
    public void OnSize();
    private class SProperties * IntroTextsIni;
    private class SListBox TextListBox;
    private int TextHeight;
    private int BottomGradientFont;
    private int TopGradientFont;
    private int BottomGradientBackground;
    private int TopGradientBackground;
    private int BottomFillBackground;
    private int TopFillBackground;
    private float AudioDuration;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSplash : public SDXWidget
{
    public void SSplash(class SSplash & );
    public void SSplash();
    public void ~SSplash();
    public void Create(enum SplashType );
    public void Update();
    public void OnSize();
    public bool OnKeyDown(int );
    public void OnMouseDown(int ,int ,int ,int );
    private enum SplashType Type;
    private int ImageFont;
    private int FadeFrame;
    private int Duration;
    private int FadeDuration;
    private int StartTick;
    private int EndAction;
    private int SkipAction;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum SplashType
{
    Assemble=0,
    SwineHD=1
};

class SSplash : public SDXWidget
{
    public void SSplash(class SSplash & );
    public void SSplash();
    public void ~SSplash();
    public void Create(enum SplashType );
    public void Update();
    public void OnSize();
    public bool OnKeyDown(int );
    public void OnMouseDown(int ,int ,int ,int );
    private enum SplashType Type;
    private int ImageFont;
    private int FadeFrame;
    private int Duration;
    private int FadeDuration;
    private int StartTick;
    private int EndAction;
    private int SkipAction;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SBriefingMenu : public SDXWidget
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void OnTimer(int ,unsigned long );
    private void OnTimerDisplayNextPicture(bool );
    private void StartBriefingSpeech(bool );
    private void PlayNextBriefing(bool );
    private class STextButton Done;
    private class STextButton Replay;
    private class STextButton Exit;
    private class SListBox BriefingListBox;
    private class SListBox LeftUpperListBox;
    private int EnemyUnitPictureFonts[13];
    private int NewUnitPictureFonts[13];
    private int MenuFont;
    private int MapPictureFont;
    private int TypePictureFont;
    private int WeatherPictureFont;
    private int HeaderFont;
    private int MapPictureBackgroundFont;
    private int MapPictureFrame;
    private int MapEndOfBriefingFrame;
    private int MapPictureBackgroundFrame;
    private int TimerDisplayNextPicture;
    private int PictureNumber;
    private class SDXWidget UnitDXWidget[11];
    public void SBriefingMenu(class SBriefingMenu & );
    public void SBriefingMenu();
    public void ~SBriefingMenu();
    public void Create(bool );
    private void UnactivateAll();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SResultsMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private int CarFont;
    private class STextButton DoneButton;
    private class STextButton LoadButton;
    private class STextButton RestartButton;
    private class STextButton QuitButton;
    private class SListBox ListBox;
    private class SDXWidget CarPicture;
    private void UnactivateAll();
    public void SResultsMenu(class SResultsMenu & );
    public void SResultsMenu();
    public void ~SResultsMenu();
    public void Create();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SGameView : public SDXWidget
{
    private class SGameWorld * World;
    private bool OnKeyDown(int );
    private bool OnKeyUp(int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseWheel(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnSize(int ,int );
    private unsigned long KeyTime[256];
    private unsigned long LastUpdate;
    private unsigned long LastServerUpdate;
    private void UpdateKey(unsigned long ,int );
    private int ControlType;
    private int DragMode;
    private int DragMX;
    private int DragMY;
    private float DragX;
    private float DragY;
    private float DragZ;
    private float DragTX;
    private float DragTZ;
    private int DragTarget;
    private bool DragStarted;
    private unsigned long LastClickTime;
    private int LastClickUnit;
    private int MouseX;
    private int MouseY;
    private bool MouseOver;
    private void MouseUpdate(int ,int ,int );
    private int CommandMode;
    private void StartCommand(int );
    private void ExecuteCommand(int ,int ,int ,int );
    private class SScaler MenuBackgroundScaler;
    private class SScaler PanelBackgroundScaler;
    private int PanelFont;
    private int PanelTextFont;
    private int PanelAIFont;
    private int PanelSpecFont;
    private int MapGroupFont;
    private int MinimapFont;
    private int StatusFont;
    private class SDXWidget Panel;
    private class SMinimap Map;
    private class SStatusPanel Status;
    private class SButton Pause;
    private class SButton Play;
    private class SButton FastForward;
    private class SButton Buy;
    private class SButton Attack;
    private class SButton Move;
    private class SButton Spec;
    private class SButton DriverStop;
    private class SButton DriverChase;
    private class SButton DriverRetreat;
    private class SButton GunnerFireAtWill;
    private class SButton GunnerReturnFire;
    private class SButton GunnerHoldFire;
    private class SButton GroupCreate;
    private class SLabel _SPLabel;
    private class SGroupIcon GroupIcons[9];
    private int TimeFrame;
    private int CountdownFrame;
    private int PauseFrame;
    private int SPFrame;
    private bool PauseFeedbackEnabled;
    private int ScoreFrames[8];
    private int EventBorderFrame;
    private int EventAnimFrame[3];
    private int EventTextFrame[3];
    private void SetPlaySpeed(int );
    private bool MessageOnScreen;
    private class SMulti * Multi;
    private class SInGameMenu * InGameMenu;
    private class SSaveMenu * SaveGameMenu;
    private class SLoadMenu * LoadGameMenu;
    private class SHelpMenu * HelpMenu;
    private class SInGameBriefingMenu * InGameBriefingMenu;
    private class SOptionsMenu * OptionsMenu;
    private class SAudioOptionsMenu * AudioOptionsMenu;
    private class SGraphicsOptionsMenu * GraphicsOptionsMenu;
    private class SGameOptionsMenu * GameOptionsMenu;
    private class SLanguageOptionsMenu * LanguageOptionsMenu;
    private class SQuickMarket * QuickMarket;
    private class SEditBox ChatEditBox;
    private class SCheckBox ChatCheckBox;
    private bool bChat;
    private int ChatTextFrame;
    private bool IsMouseRestrictionNeeded();
    private bool IsInGame();
    private void SetScalerPosition();
    private void LoadInGameMenu();
    private void LoadSaveGameMenu();
    private void LoadLoadGameMenu();
    private void LoadHelpMenu();
    private void LoadInGameBriefingMenu();
    private void LoadOptionsMenu();
    private void LoadAudioOptionsMenu();
    private void LoadGraphicsOptionsMenu();
    private void LoadGameOptionsMenu();
    private void LoadLanguageOptionsMenu();
    private void LoadQuickMarket();
    private int MessageBoxA(char * ,int );
    private struct SUnitDescription UnitToBuy;
    private class STipDialog * TipDialog;
    private bool bHotKeyPressed;
    private float RotateCollector;
    private float ZoomCollector;
    private class SListBox TutorialTextListBox;
    private class SMessageBoxWithoutButtons WaitingMessageBox;
    public void SGameView(class SGameView & );
    public void SGameView();
    public void ~SGameView();
    public void Create();
    public void SetPosition(int ,int ,int ,int );
    public void LoadMap(class SMulti * );
    public void LoadGame(char * );
    public void Update();
    public bool MinimapLeftClick(float ,float );
    public void MinimapRightClick(float ,float );
    public void MinimapLeftDrag(float ,float );
    public void OnChatMessage(char * ,unsigned long );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMenuBackGroundView : public SDXWidget
{
    private class SWorld * World;
    private void OnSize(int ,int );
    private unsigned long LastUpdate;
    private unsigned long LastServerUpdate;
    private class SScaler MenuBackgroundScaler;
    private class SScaler PanelBackgroundScaler;
    private void SetScalerPosition();
    public void SMenuBackGroundView(class SMenuBackGroundView & );
    public void SMenuBackGroundView();
    public void ~SMenuBackGroundView();
    public void Create();
    public void SetPosition(int ,int ,int ,int );
    public void LoadMap();
    public void Update();
    public bool MinimapLeftClick(float ,float );
    public void MinimapRightClick(float ,float );
    public void MinimapLeftDrag(float ,float );
    public void OnChatMessage(char * ,unsigned long );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMenuBackGroundView : public SDXWidget
{
    private class SWorld * World;
    private void OnSize(int ,int );
    private unsigned long LastUpdate;
    private unsigned long LastServerUpdate;
    private class SScaler MenuBackgroundScaler;
    private class SScaler PanelBackgroundScaler;
    private void SetScalerPosition();
    public void SMenuBackGroundView(class SMenuBackGroundView & );
    public void SMenuBackGroundView();
    public void ~SMenuBackGroundView();
    public void Create();
    public void SetPosition(int ,int ,int ,int );
    public void LoadMap();
    public void Update();
    public bool MinimapLeftClick(float ,float );
    public void MinimapRightClick(float ,float );
    public void MinimapLeftDrag(float ,float );
    public void OnChatMessage(char * ,unsigned long );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMarket : public SDXWidget
{
    private class SProperties * UnitsIni;
    private class SProperties * UnitsIniColor;
    private class SProperties * UnitsIniLocale;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private int MenuFont;
    private int ScrollButtonFont;
    private class SButton ScrollLeft_MyUnits;
    private class SButton ScrollRight_MyUnits;
    private class SButton ScrollLeft_ShopUnits;
    private class SButton ScrollRight_ShopUnits;
    private class STextButton Buy;
    private class STextButton Sell;
    private class STextButton Add_Upgrade;
    private class STextButton Drop_Upgrade;
    private class STextButton Done;
    private class STextButton Cancel;
    private int fightingUnitsTextFrame;
    private class SListBox UnitPropertiesText;
    private class SListBox UnitPropertiesValue;
    private class SListBox UnitDescriptionListBox;
    private class SListBox UpgradeDescriptionListBox;
    private int UnitPropertiesBackFrame;
    private int UnitSPFrame;
    private int UpgradeSPFrame;
    private int SPTextFrame;
    private char * UnitClass;
    private char * UnitName;
    private char * UnitNick;
    private char * UnitDesc;
    private char * UnitAnim;
    private int UnitPrice;
    private int UnitAmmo;
    private int UnitFuel;
    private int UnitSpeed;
    private int NextLevelXP;
    private int Level2XP;
    private int Level3XP;
    private float UnitHP;
    private float UnitFrontArmor;
    private float UnitBackArmor;
    private float UnitTopArmor;
    private float UnitSideArmor;
    private float UnitBottomArmor;
    private float UnitDamage;
    private float UnitReloadTime;
    private float UnitSight;
    private float UnitRange;
    private float UnitConsume;
    private int UnitLevel;
    private int UnitXP;
    private unsigned int Race;
    private char * UpgradeName;
    private char * UpgradeDesc;
    private int UpgradePrice;
    private int ExtraSight;
    private int ExtraArmor;
    private int ExtraAmmo;
    private int ExtraFuel;
    private int ExtraSpeed;
    private float ExtraReloadTime;
    private void LoadUnitInfo();
    private bool LoadUpgradeInfo(char * );
    private int UnitPictureFonts[13][3];
    private int UpgradePictureGlyphs[9];
    private int SelectionFont;
    private int UpgradeFont;
    private class SMarketButton NewUnitButtons[10];
    private class SMarketButton MyUnitButtons[10];
    private class SMarketButton NewUpgradeButtons[9];
    private class SMarketButton MyUpgradeButtons[3];
    private int FirstMyUnit;
    private int SelMyUnit;
    private int FirstNewUnit;
    private int NumNewUnits;
    private int SelNewUnit;
    private int SelMyUpgrade;
    private int SelNewUpgrade;
    private int UpgradeMask;
    private void StartAnim();
    private void ShowMyUnits();
    private void ShowNewUnits();
    private void SelectMyUnit(int );
    private void SelectNewUnit(int );
    private void SelectMyUpgrade(int );
    private void SelectNewUpgrade(int );
    private int GetClassIndex(char * );
    private int MyUpgrades[3];
    private int AnimFrame;
    private char * AnimUnitClass;
    private int AnimUnitLevel;
    private unsigned long LastUpdate;
    private class SDArray<SUnitDescription> MyUnits;
    private class SDArray<SUnitDescription> OldUnits;
    private int NewUnits[13];
    private int CurrentSP;
    private int SaveSP;
    private bool SaveArmy(char * );
    private int ChatListBoxbackgroundFrame;
    private bool HasFightingUnit();
    private void UnactivateAll();
    public void SMarket(class SMarket & );
    public void SMarket();
    public void ~SMarket();
    public void Create();
    public void BuyUnits(class SDArray<SUnitDescription> & );
    public void Update();
    public void OnChatMessage(char * ,unsigned long );
    public class SListBox ChatListBox;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SCredits : public SSkippableDXWidget
{
    public void SCredits(class SCredits & );
    public void SCredits();
    public void ~SCredits();
    public void Create();
    public void Update();
    public bool OnKeyDown(int );
    public bool OnKeyUp(int );
    public void OnSize();
    private class SProperties * CreditsIni;
    private class SDXWidget ContentParent;
    private class SDArray<SDXWidget *> Widgets;
    private class SDArray<int> ImageFonts;
    private int BottomGradientFont;
    private int TopGradientFont;
    private int BottomGradientBackground;
    private int TopGradientBackground;
    private int BottomFillBackground;
    private int TopFillBackground;
    private float ContentHeight;
    private bool AutoScroll;
    private class SDArray<char *> SpeechPaths;
    private const int SpeechBeginDelay;
    private const int SpeechEndDelay;
    private const float MusicDuration;
    private int SpeechInterval;
    private int NextSpeechTime;
    private int NextSpeechIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMulti : public IMatchMakingEventHandler, public IConnectionManagerEventHandler
{
    public bool InitMatchMaking();
    public void Update();
    public class MatchMaking * matchMaking;
    public class STitleRoom * pTitleRoom;
    public int m_NumInternetPlayers;
    public char m_strGameName[260];
    public bool m_bEnableStateChanged;
    public HRESULT CreateGame();
    public void SendFrameData(int ,class SStream * );
    public bool GetFrameData(int ,int ,class SStream * );
    public bool HasFrameData(int ,int );
    public bool IsDisconnected(int ,int );
    private int CalculateConfirmedLastFrame(int );
    private void AssembleDataPacket(int ,int ,struct APP_MSG_PACKET_DATA &** ,int & );
    private void StoreFrameData(int ,int ,unsigned int * ,int );
    public void SendMeThePacketsOfThisPlayer(int ,int );
    public bool GetSlots(int );
    public unsigned int GetTeam(int );
    public int GetLocalPlayerSlotNumber();
    public unsigned int GetPlayerColor(int );
    public unsigned int GetPlayerRace(int );
    public class SString GetPlayerName(int );
    public HRESULT MessageHandler(void * ,unsigned long ,void * );
    public char m_strLocalPlayerName[260];
    public int m_bHostPlayer;
    public long m_lNumberOfActivePlayers;
    public void SMulti(class SMulti & );
    public void SMulti(struct HWND__ * );
    public void ~SMulti();
    public class SMulti * instance;
    public struct HWND__ * m_hwndSW;
    protected bool m_bMapLoadingError;
    protected HRESULT hr;
    protected struct SFrameHistory frameHistory[8];
    protected int nextFrameToProcess;
    protected int numSentFrames;
    protected int m_ConnectionType;
    public HRESULT ChatRoom_Start(class SChatRoomMenu * ,bool );
    public void ChatRoom_End();
    public class SChatRoomMenu * m_pChatRoomMenu;
    public class SMarket * m_pMarket;
    public class SGameView * gameView;
    private void InitializeConnectionInfo(struct PLAYER_CONNECTION_INFO & );
    private int GetFreePlayerSlot();
    private void AddPlayerInfo(int ,struct PLAYER_CONNECTION_INFO & ,unsigned int ,char * );
    private int GetNextColorIndex(int );
    private int GetPrevColorIndex(int );
    private enum MessageType GetMessageType(enum MessageId );
    private int GetRoute(enum MessageType ,int );
    private void SendMessageInternal(struct MSG_GENERIC * ,int ,unsigned int );
    private void SendMessageA(int ,struct MSG_GENERIC * ,int );
    private void SendBroadcastMessage(bool ,struct MSG_GENERIC * ,int );
    private void SendIntroductionMessage();
    private void OnIntroductionMessage(enum ConnectionId ,struct STAGEMSG_INTRODUCTION & );
    private void SendRequestMapDownloading();
    private void OnRequestMapDownloading(int ,struct STAGEMSG_REQUEST_MAP_DOWNLOAD & );
    public void SendPlayerChangeReady();
    private void OnPlayerChangeReady(int ,struct STAGEMSG_PLAYER_READY & );
    public void SendPlayerChangeBuying(bool );
    private void OnPlayerChangeBuying(int ,struct STAGEMSG_PLAYER_CHANGE & );
    public void SendPlayerChangeRace(int );
    private void OnPlayerChangeRace(int ,struct STAGEMSG_PLAYER_CHANGE & );
    public void SendPlayerChangeTeam();
    private void OnPlayerChangeTeam(int ,struct STAGEMSG_PLAYER_CHANGE & );
    public void SendPlayerChangeColor(int );
    private void OnPlayerChangeColor(int ,struct STAGEMSG_PLAYER_CHANGE & );
    private void SendRejectMessage(enum ConnectionId );
    private void SendSlotNumberMessage(int );
    private void OnSlotNumberMessage(int );
    public void SendGameSettingsMessage(int );
    private void SendSlotDataMessage(int ,int );
    private void OnSlotDataMessage(struct STAGEMSG_STAGEDATA & );
    private void UpdateConnectivity();
    private void SendConnectivityUpdateMessage();
    private void OnConnectivityUpdateMessage(int ,struct PEER_MSG_CONNECTIVITY_UPDATE * );
    public int GetPing(int );
    public void SetPingToolTips();
    public void HandleChatMessage(char * ,char * ,enum ChatMessageType ,bool );
    public void SendChatCommand(char * ,enum ActiveChatRoom );
    public void SendChatMessage(char * ,char * ,enum ChatMessageType ,enum ActiveChatRoom );
    public void CancelGame();
    public void StartGame();
    public int GetFullSlots();
    public int GetFullAndOpenSlots();
    public void UpdateMatchOnMatchMakingServer();
    public enum ConnectionId connections[8];
    public struct SLOT_INFO m_Slots[8];
    public int MapLoading[8];
    public int localSlotNumber;
    public void DisplaySlotData();
    public void ClearReadyForAllPlayers();
    public int m_bSettingsLocked;
    public HRESULT ChangePlayerSlotStatus(unsigned long ,int );
    public struct GAME_SETTINGS m_GameSettings;
    public int m_bGameStarted;
    protected void ClearSlotArray();
    protected void SendMapLoadingDataToPlayers(int );
    protected HRESULT RemovePlayerFromStage(unsigned int );
    protected int GetSlotFromRaknetGuid(unsigned int );
    private int GetMapLoadingData(int );
    private void ZeroMapLoadingData();
    private void ClearMapLoading();
    private int m_bAllowPlayerJoin;
    private int m_bInitOk;
    private int m_bFirstDisplayData;
    private void OnAccept(char * );
    private void OnUpdateUsers(int ,struct UserInfo * );
    private void OnUpdateMatches(int ,struct MatchInfo * );
    private void OnUpdateChat(char * ,char * ,enum ChatMessageType );
    private void OnConnectionSuccessful(enum ConnectionId ,unsigned int );
    private void OnConnectionFailed(enum ConnectionFailedReason );
    private void OnPeerConnected(enum ConnectionId ,unsigned int );
    private void OnDisconnected(unsigned int );
    private void OnMessage(enum ConnectionId ,unsigned int * ,int );
    private void OnFileDownloaded(char * ,unsigned int * ,int );
    private void OnFileProgress(int );
    private const int hostSlotId=0;
    private int lastFramesRecievedByOthers[8][8];
    private bool disconnecting[8];
    private unsigned int receiverId;
    public unsigned long lastReceivedFrameTime[8];
    public unsigned long lastPacketResendRequest[8];
    private bool IsHostPlayerConnection(unsigned int );
    private void StartSyncAfterDisconnect(int );
    private void HandleLastReceivedFrameMessage(int ,int ,int );
    public void CreateLanGame();
    public void CreateInternetGame();
    public void JoinGame(struct MatchInfo * );
    public void JoinGame(struct RakNet::SystemAddress );
    public void Disconnect();
    private class ConnectionManager * connectionManager;
    private class ConnectivityGraph * connectivityGraph;
    private unsigned long lastConnectivityGraphUpdate;
    private void Initialize();
    public class SMulti & operator=(class SMulti & );
    public void * __vecDelDtor(unsigned int );
};

struct PLAYER_CONNECTION_INFO
{
    char internalIpAddress[16];
    char externalIpAddress[16];
    int listenPort;
};

enum MessageId
{
    STAGE_MSGID_INTRODUCTION=135,
    STAGE_MSGID_SETSLOTID=136,
    STAGE_MSGID_REJECTPLAYER=137,
    STAGE_MSGID_SETSTAGEDATA=138,
    STAGE_MSGID_STARTGAME=139,
    STAGE_MSGID_CANCELGAME=140,
    STAGE_MSGID_CHAT=141,
    STAGE_MSGID_GAMESETTINGS=142,
    STAGE_MSGID_REQUEST_MAP_DOWNLOAD=143,
    STAGE_MSGID_SETMAPLOADINGDATA=144,
    STAGE_MSGID_PLAYER_CHANGEREADY=145,
    STAGE_MSGID_PLAYER_CHANGEBUYING=146,
    STAGE_MSGID_PLAYER_CHANGERACE=147,
    STAGE_MSGID_PLAYER_CHANGETEAM=148,
    STAGE_MSGID_PLAYER_CHANGECOLOR=149,
    APP_MSGID_PACKET_DATA=150,
    APP_MSGID_RESEND_REQUEST=151,
    PEER_MSGID_LAST_RECEIVED_FRAMES=152,
    PEER_MSGID_CONNECTIVITY_UPDATE=153
};

struct STAGEMSG_INTRODUCTION : public MSG_GENERIC
{
    struct PLAYER_CONNECTION_INFO connectionInfo;
    char strPlayerName[51];
};

struct STAGEMSG_REQUEST_MAP_DOWNLOAD : public MSG_GENERIC
{
    unsigned int receiverId;
};

struct STAGEMSG_PLAYER_READY : public MSG_GENERIC
{
    int param;
};

struct STAGEMSG_PLAYER_CHANGE : public MSG_GENERIC
{
    int param;
};

struct STAGEMSG_STAGEDATA : public MSG_GENERIC
{
    int slotNumber;
    struct SLOT_INFO slotInfo;
};

struct PEER_MSG_CONNECTIVITY_UPDATE : public MSG_GENERIC
{
    struct PeerConnectivity connectivity;
    unsigned int worstPing;
};

enum ActiveChatRoom
{
    TitleRoom=0,
    ChatRoom=1,
    InGameGlobal=2,
    InGameAllies=3
};

class SMulti : public IMatchMakingEventHandler, public IConnectionManagerEventHandler
{
    public bool InitMatchMaking();
    public void Update();
    public class MatchMaking * matchMaking;
    public class STitleRoom * pTitleRoom;
    public int m_NumInternetPlayers;
    public char m_strGameName[260];
    public bool m_bEnableStateChanged;
    public HRESULT CreateGame();
    public void SendFrameData(int ,class SStream * );
    public bool GetFrameData(int ,int ,class SStream * );
    public bool HasFrameData(int ,int );
    public bool IsDisconnected(int ,int );
    private int CalculateConfirmedLastFrame(int );
    private void AssembleDataPacket(int ,int ,struct APP_MSG_PACKET_DATA &** ,int & );
    private void StoreFrameData(int ,int ,unsigned int * ,int );
    public void SendMeThePacketsOfThisPlayer(int ,int );
    public bool GetSlots(int );
    public unsigned int GetTeam(int );
    public int GetLocalPlayerSlotNumber();
    public unsigned int GetPlayerColor(int );
    public unsigned int GetPlayerRace(int );
    public class SString GetPlayerName(int );
    public HRESULT MessageHandler(void * ,unsigned long ,void * );
    public char m_strLocalPlayerName[260];
    public int m_bHostPlayer;
    public long m_lNumberOfActivePlayers;
    public void SMulti(class SMulti & );
    public void SMulti(struct HWND__ * );
    public void ~SMulti();
    public class SMulti * instance;
    public struct HWND__ * m_hwndSW;
    protected bool m_bMapLoadingError;
    protected HRESULT hr;
    protected struct SFrameHistory frameHistory[8];
    protected int nextFrameToProcess;
    protected int numSentFrames;
    protected int m_ConnectionType;
    public HRESULT ChatRoom_Start(class SChatRoomMenu * ,bool );
    public void ChatRoom_End();
    public class SChatRoomMenu * m_pChatRoomMenu;
    public class SMarket * m_pMarket;
    public class SGameView * gameView;
    private void InitializeConnectionInfo(struct PLAYER_CONNECTION_INFO & );
    private int GetFreePlayerSlot();
    private void AddPlayerInfo(int ,struct PLAYER_CONNECTION_INFO & ,unsigned int ,char * );
    private int GetNextColorIndex(int );
    private int GetPrevColorIndex(int );
    private enum MessageType GetMessageType(enum MessageId );
    private int GetRoute(enum MessageType ,int );
    private void SendMessageInternal(struct MSG_GENERIC * ,int ,unsigned int );
    private void SendMessageA(int ,struct MSG_GENERIC * ,int );
    private void SendBroadcastMessage(bool ,struct MSG_GENERIC * ,int );
    private void SendIntroductionMessage();
    private void OnIntroductionMessage(enum ConnectionId ,struct STAGEMSG_INTRODUCTION & );
    private void SendRequestMapDownloading();
    private void OnRequestMapDownloading(int ,struct STAGEMSG_REQUEST_MAP_DOWNLOAD & );
    public void SendPlayerChangeReady();
    private void OnPlayerChangeReady(int ,struct STAGEMSG_PLAYER_READY & );
    public void SendPlayerChangeBuying(bool );
    private void OnPlayerChangeBuying(int ,struct STAGEMSG_PLAYER_CHANGE & );
    public void SendPlayerChangeRace(int );
    private void OnPlayerChangeRace(int ,struct STAGEMSG_PLAYER_CHANGE & );
    public void SendPlayerChangeTeam();
    private void OnPlayerChangeTeam(int ,struct STAGEMSG_PLAYER_CHANGE & );
    public void SendPlayerChangeColor(int );
    private void OnPlayerChangeColor(int ,struct STAGEMSG_PLAYER_CHANGE & );
    private void SendRejectMessage(enum ConnectionId );
    private void SendSlotNumberMessage(int );
    private void OnSlotNumberMessage(int );
    public void SendGameSettingsMessage(int );
    private void SendSlotDataMessage(int ,int );
    private void OnSlotDataMessage(struct STAGEMSG_STAGEDATA & );
    private void UpdateConnectivity();
    private void SendConnectivityUpdateMessage();
    private void OnConnectivityUpdateMessage(int ,struct PEER_MSG_CONNECTIVITY_UPDATE * );
    public int GetPing(int );
    public void SetPingToolTips();
    public void HandleChatMessage(char * ,char * ,enum ChatMessageType ,bool );
    public void SendChatCommand(char * ,enum ActiveChatRoom );
    public void SendChatMessage(char * ,char * ,enum ChatMessageType ,enum ActiveChatRoom );
    public void CancelGame();
    public void StartGame();
    public int GetFullSlots();
    public int GetFullAndOpenSlots();
    public void UpdateMatchOnMatchMakingServer();
    public enum ConnectionId connections[8];
    public struct SLOT_INFO m_Slots[8];
    public int MapLoading[8];
    public int localSlotNumber;
    public void DisplaySlotData();
    public void ClearReadyForAllPlayers();
    public int m_bSettingsLocked;
    public HRESULT ChangePlayerSlotStatus(unsigned long ,int );
    public struct GAME_SETTINGS m_GameSettings;
    public int m_bGameStarted;
    protected void ClearSlotArray();
    protected void SendMapLoadingDataToPlayers(int );
    protected HRESULT RemovePlayerFromStage(unsigned int );
    protected int GetSlotFromRaknetGuid(unsigned int );
    private int GetMapLoadingData(int );
    private void ZeroMapLoadingData();
    private void ClearMapLoading();
    private int m_bAllowPlayerJoin;
    private int m_bInitOk;
    private int m_bFirstDisplayData;
    private void OnAccept(char * );
    private void OnUpdateUsers(int ,struct UserInfo * );
    private void OnUpdateMatches(int ,struct MatchInfo * );
    private void OnUpdateChat(char * ,char * ,enum ChatMessageType );
    private void OnConnectionSuccessful(enum ConnectionId ,unsigned int );
    private void OnConnectionFailed(enum ConnectionFailedReason );
    private void OnPeerConnected(enum ConnectionId ,unsigned int );
    private void OnDisconnected(unsigned int );
    private void OnMessage(enum ConnectionId ,unsigned int * ,int );
    private void OnFileDownloaded(char * ,unsigned int * ,int );
    private void OnFileProgress(int );
    private const int hostSlotId=0;
    private int lastFramesRecievedByOthers[8][8];
    private bool disconnecting[8];
    private unsigned int receiverId;
    public unsigned long lastReceivedFrameTime[8];
    public unsigned long lastPacketResendRequest[8];
    private bool IsHostPlayerConnection(unsigned int );
    private void StartSyncAfterDisconnect(int );
    private void HandleLastReceivedFrameMessage(int ,int ,int );
    public void CreateLanGame();
    public void CreateInternetGame();
    public void JoinGame(struct MatchInfo * );
    public void JoinGame(struct RakNet::SystemAddress );
    public void Disconnect();
    private class ConnectionManager * connectionManager;
    private class ConnectivityGraph * connectivityGraph;
    private unsigned long lastConnectivityGraphUpdate;
    private void Initialize();
    public class SMulti & operator=(class SMulti & );
    public void * __vecDelDtor(unsigned int );
};

class SButton : public SDXWidget
{
    private int Font;
    private int NormalGlyph;
    private int ActiveGlyph;
    private int PressedGlyph;
    private int SpecialGlyph;
    private int SpriteFrame;
    private bool Active;
    private bool Pressed;
    private bool Stuck;
    private bool Special;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void SetState();
    public void SButton(class SButton * );
    public void SButton(class SButton & );
    public void SButton();
    public void Create(int ,int ,int ,int ,int );
    public void SetGlyphs(int ,int ,int ,int ,int );
    public void SetStuck(bool );
    public void SetActive(bool );
    public void SetSpecial(bool );
    public void ~SButton();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SButton : public SDXWidget
{
    private int Font;
    private int NormalGlyph;
    private int ActiveGlyph;
    private int PressedGlyph;
    private int SpecialGlyph;
    private int SpriteFrame;
    private bool Active;
    private bool Pressed;
    private bool Stuck;
    private bool Special;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void SetState();
    public void SButton(class SButton * );
    public void SButton(class SButton & );
    public void SButton();
    public void Create(int ,int ,int ,int ,int );
    public void SetGlyphs(int ,int ,int ,int ,int );
    public void SetStuck(bool );
    public void SetActive(bool );
    public void SetSpecial(bool );
    public void ~SButton();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SLabel : public SDXWidget
{
    private int Font;
    private int TextFrame;
    private class SString Text;
    private unsigned long Color;
    private void Update();
    public void SLabel(class SLabel * );
    public void SLabel(class SLabel & );
    public void SLabel();
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public void Create(int );
    public void SetText(char * );
    public void SetTextF(char * ,<btNoType> );
    public void SetTextV(char * ,char * );
    public void SetTextColor(unsigned long );
    public char * GetText();
    public void ~SLabel();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SLabel : public SDXWidget
{
    private int Font;
    private int TextFrame;
    private class SString Text;
    private unsigned long Color;
    private void Update();
    public void SLabel(class SLabel * );
    public void SLabel(class SLabel & );
    public void SLabel();
    public void SetPosition(int ,int ,int ,int );
    public void Resize(int ,int );
    public void Create(int );
    public void SetText(char * );
    public void SetTextF(char * ,<btNoType> );
    public void SetTextV(char * ,char * );
    public void SetTextColor(unsigned long );
    public char * GetText();
    public void ~SLabel();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SRadioButton : public SDXWidget
{
    private int Font;
    private int RadioFont;
    private int RadioHLFont;
    private int RadioDisabledFont;
    private int TextFrame;
    private int RadioFrame;
    private class SString Text;
    private unsigned long NormalColor;
    private unsigned long ActiveColor;
    private unsigned long DisabledColor;
    private bool Active;
    private bool Pressed;
    private bool bChecked;
    private bool OnKeyDown(int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void Update();
    public void SRadioButton(class SRadioButton & );
    public void SRadioButton();
    public void ~SRadioButton();
    public void Create(int ,unsigned long ,unsigned long ,unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetCheck(bool );
    public bool GetCheck();
    public void SetVisible(bool );
    public void SetActive(bool );
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SRadioButton : public SDXWidget
{
    private int Font;
    private int RadioFont;
    private int RadioHLFont;
    private int RadioDisabledFont;
    private int TextFrame;
    private int RadioFrame;
    private class SString Text;
    private unsigned long NormalColor;
    private unsigned long ActiveColor;
    private unsigned long DisabledColor;
    private bool Active;
    private bool Pressed;
    private bool bChecked;
    private bool OnKeyDown(int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void Update();
    public void SRadioButton(class SRadioButton & );
    public void SRadioButton();
    public void ~SRadioButton();
    public void Create(int ,unsigned long ,unsigned long ,unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetCheck(bool );
    public bool GetCheck();
    public void SetVisible(bool );
    public void SetActive(bool );
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDialog : public SDXWidget
{
    protected int ModalResult;
    protected void Cancel();
    public void SDialog(class SDialog * );
    public void SDialog(class SDialog & );
    public void SDialog();
    public void Create();
    public int DoModal();
    public void ~SDialog();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDialog : public SDXWidget
{
    protected int ModalResult;
    protected void Cancel();
    public void SDialog(class SDialog * );
    public void SDialog(class SDialog & );
    public void SDialog();
    public void Create();
    public int DoModal();
    public void ~SDialog();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMessageBoxWithoutButtons : public SDialog
{
    private class SListBox ListBox;
    private bool bInGame;
    public void Create(bool );
    public void SetText(char * );
    public void SetVisible(bool );
    protected void Cancel();
    public void SMessageBoxWithoutButtons(class SMessageBoxWithoutButtons * );
    public void SMessageBoxWithoutButtons(class SMessageBoxWithoutButtons & );
    public void SMessageBoxWithoutButtons();
    public void ~SMessageBoxWithoutButtons();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SEditBox : public SDXWidget
{
    private int Font;
    private int TextFrame;
    private int CaretFrame;
    private int CaretTimer;
    private bool CaretVisible;
    private char Utf8Text[766];
    private wchar_t Text[256];
    private int CaretPos;
    private bool CtrlPressed;
    private void Update();
    private bool OnKeyDown(int );
    private bool OnKeyUp(int );
    private bool OnChar(int );
    private void OnTimer(int ,unsigned long );
    private void OnMouseDown(int ,int ,int ,int );
    public void SEditBox(class SEditBox * );
    public void SEditBox(class SEditBox & );
    public void SEditBox();
    public void Create(int ,bool ,bool );
    public void SetText(char * );
    public char * GetText();
    public void ~SEditBox();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SEditBox : public SDXWidget
{
    private int Font;
    private int TextFrame;
    private int CaretFrame;
    private int CaretTimer;
    private bool CaretVisible;
    private char Utf8Text[766];
    private wchar_t Text[256];
    private int CaretPos;
    private bool CtrlPressed;
    private void Update();
    private bool OnKeyDown(int );
    private bool OnKeyUp(int );
    private bool OnChar(int );
    private void OnTimer(int ,unsigned long );
    private void OnMouseDown(int ,int ,int ,int );
    public void SEditBox(class SEditBox * );
    public void SEditBox(class SEditBox & );
    public void SEditBox();
    public void Create(int ,bool ,bool );
    public void SetText(char * );
    public char * GetText();
    public void ~SEditBox();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SEditBoxWithText : public SDXWidget
{
    private int Font;
    private int Prompt;
    private class SEditBox EditBox;
    public void SEditBoxWithText(class SEditBoxWithText & );
    public void SEditBoxWithText();
    public void ~SEditBoxWithText();
    public void Create(int ,int ,char * );
    public void SetBackgroundColor(unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetFocusToInnerEditBox();
    public void SetTooltipText(char * );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SEditBoxWithText : public SDXWidget
{
    private int Font;
    private int Prompt;
    private class SEditBox EditBox;
    public void SEditBoxWithText(class SEditBoxWithText & );
    public void SEditBoxWithText();
    public void ~SEditBoxWithText();
    public void Create(int ,int ,char * );
    public void SetBackgroundColor(unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetFocusToInnerEditBox();
    public void SetTooltipText(char * );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSliderH : public SDXWidget
{
    private int SliderFont;
    private int ButtonFont;
    private int SliderFrame;
    private int SliderBox;
    private int ButtonLeftFrame;
    private int ButtonRightFrame;
    private int FirstKlikkTimer;
    private int TickTimer;
    private int NumberOfFixPos;
    private int SliderPos;
    private int * SliderRovatka;
    private bool PressedLeft;
    private bool PressedRight;
    private bool ActiveLeft;
    private bool ActiveRight;
    private bool RedBigyoDown;
    private int XPosOfLittleRedBigyo;
    private int DeltaXOfLRB;
    private int XDownPosOfLRB;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void OnTimer(int ,unsigned long );
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void Update();
    public void SSliderH(class SSliderH & );
    public void SSliderH();
    public void ~SSliderH();
    public int GetSliderPos();
    public int GetNumberOfFixPos();
    public void Create(int ,int ,int ,int ,int );
    public void SetActive(bool );
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSliderH : public SDXWidget
{
    private int SliderFont;
    private int ButtonFont;
    private int SliderFrame;
    private int SliderBox;
    private int ButtonLeftFrame;
    private int ButtonRightFrame;
    private int FirstKlikkTimer;
    private int TickTimer;
    private int NumberOfFixPos;
    private int SliderPos;
    private int * SliderRovatka;
    private bool PressedLeft;
    private bool PressedRight;
    private bool ActiveLeft;
    private bool ActiveRight;
    private bool RedBigyoDown;
    private int XPosOfLittleRedBigyo;
    private int DeltaXOfLRB;
    private int XDownPosOfLRB;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void OnTimer(int ,unsigned long );
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private void Update();
    public void SSliderH(class SSliderH & );
    public void SSliderH();
    public void ~SSliderH();
    public int GetSliderPos();
    public int GetNumberOfFixPos();
    public void Create(int ,int ,int ,int ,int );
    public void SetActive(bool );
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SCheckBox : public SDXWidget
{
    private int Font;
    private int CheckFont;
    private int UnCheckFont;
    private int CheckFontGrey;
    private int UnCheckFontGrey;
    private int TextFrame;
    private int CheckFrame;
    private class SString Text;
    private unsigned long NormalColor;
    private unsigned long ActiveColor;
    private unsigned long DisabledColor;
    private bool Active;
    private bool Pressed;
    private bool bChecked;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private bool OnKeyDown(int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void Update();
    public void SCheckBox(class SCheckBox & );
    public void SCheckBox();
    public void ~SCheckBox();
    public void Create(int ,unsigned long ,unsigned long ,unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetCheck(bool );
    public bool GetCheck();
    public void SetActive(bool );
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SCheckBox : public SDXWidget
{
    private int Font;
    private int CheckFont;
    private int UnCheckFont;
    private int CheckFontGrey;
    private int UnCheckFontGrey;
    private int TextFrame;
    private int CheckFrame;
    private class SString Text;
    private unsigned long NormalColor;
    private unsigned long ActiveColor;
    private unsigned long DisabledColor;
    private bool Active;
    private bool Pressed;
    private bool bChecked;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private bool OnKeyDown(int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void Update();
    public void SCheckBox(class SCheckBox & );
    public void SCheckBox();
    public void ~SCheckBox();
    public void Create(int ,unsigned long ,unsigned long ,unsigned long );
    public void SetText(char * );
    public char * GetText();
    public void SetCheck(bool );
    public bool GetCheck();
    public void SetActive(bool );
    public void SetFocus();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct SDropList::SDropListItem
{
    char ItemText[261];
    unsigned long ItemData;
    bool ItemEnabled;
};

class SDArray<SDropList::SDropListItem>
{
    private int size;
    private int maxsize;
    public struct SDropList::SDropListItem * array;
    public void SDArray<SDropList::SDropListItem>(class SDArray<SDropList::SDropListItem> & );
    public void SDArray<SDropList::SDropListItem>();
    public void ~SDArray<SDropList::SDropListItem>();
    public int Add(struct SDropList::SDropListItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SDropList::SDropListItem & operator[](int );
    public void operator=(class SDArray<SDropList::SDropListItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SDropList::SDropListItem>
{
    private int size;
    private int maxsize;
    public struct SDropList::SDropListItem * array;
    public void SDArray<SDropList::SDropListItem>(class SDArray<SDropList::SDropListItem> & );
    public void SDArray<SDropList::SDropListItem>();
    public void ~SDArray<SDropList::SDropListItem>();
    public int Add(struct SDropList::SDropListItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SDropList::SDropListItem & operator[](int );
    public void operator=(class SDArray<SDropList::SDropListItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDropList : public SDXWidget
{
    struct SDropListItem
    {
        char ItemText[261];
        unsigned long ItemData;
        bool ItemEnabled;
    };
    private int Font;
    private int ButtonFont;
    private int * DropLineFrames;
    private int DropFrame;
    private int DropBoxFrame;
    private int DropBlackFrame;
    private bool Dropped;
    private bool Dropable;
    private unsigned long DroppedBackgroundColor;
    private int ButtonFrame;
    private int TextFrame;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private bool OnKeyDown(int );
    private void Update();
    private void Drop();
    private int SetCurActive(int );
    private int FontHeight;
    private bool Active;
    private bool Pressed;
    public void SDropList(class SDropList & );
    public void SDropList();
    public void ~SDropList();
    public void Create(int ,bool ,unsigned long );
    public int DeleteItem(int );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public unsigned long GetItemData(int );
    public int SetItemData(int ,unsigned long );
    public int SetItemEnabled(int ,bool );
    public bool IsItemEnabled(int );
    public int GetText(int ,char * ,int );
    public int SetText(int ,char * );
    public int GetTextLen(int );
    public int AddItem(char * ,bool ,unsigned long );
    public void ResetContent();
    public void SetDropable(bool );
    public void SetActive(bool );
    public void SetFocus();
    protected struct SDropList::SDropListItem m_ListBoxItem;
    protected class SDArray<SDropList::SDropListItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nCurActive;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDropList : public SDXWidget
{
    struct SDropListItem
    {
        char ItemText[261];
        unsigned long ItemData;
        bool ItemEnabled;
    };
    private int Font;
    private int ButtonFont;
    private int * DropLineFrames;
    private int DropFrame;
    private int DropBoxFrame;
    private int DropBlackFrame;
    private bool Dropped;
    private bool Dropable;
    private unsigned long DroppedBackgroundColor;
    private int ButtonFrame;
    private int TextFrame;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private bool OnKeyDown(int );
    private void Update();
    private void Drop();
    private int SetCurActive(int );
    private int FontHeight;
    private bool Active;
    private bool Pressed;
    public void SDropList(class SDropList & );
    public void SDropList();
    public void ~SDropList();
    public void Create(int ,bool ,unsigned long );
    public int DeleteItem(int );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public unsigned long GetItemData(int );
    public int SetItemData(int ,unsigned long );
    public int SetItemEnabled(int ,bool );
    public bool IsItemEnabled(int );
    public int GetText(int ,char * ,int );
    public int SetText(int ,char * );
    public int GetTextLen(int );
    public int AddItem(char * ,bool ,unsigned long );
    public void ResetContent();
    public void SetDropable(bool );
    public void SetActive(bool );
    public void SetFocus();
    protected struct SDropList::SDropListItem m_ListBoxItem;
    protected class SDArray<SDropList::SDropListItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nCurActive;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct SDropList::SDropListItem
{
    char ItemText[261];
    unsigned long ItemData;
    bool ItemEnabled;
};

struct SFileListBoxItem
{
    char VisibleText[261];
    char Filename[261];
    unsigned long ItemData;
    unsigned long Color;
};

struct SFileListBoxItem
{
    char VisibleText[261];
    char Filename[261];
    unsigned long ItemData;
    unsigned long Color;
};

class SDArray<SFileListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SFileListBoxItem * array;
    public void SDArray<SFileListBoxItem>(class SDArray<SFileListBoxItem> & );
    public void SDArray<SFileListBoxItem>();
    public void ~SDArray<SFileListBoxItem>();
    public int Add(struct SFileListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SFileListBoxItem & operator[](int );
    public void operator=(class SDArray<SFileListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SFileListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SFileListBoxItem * array;
    public void SDArray<SFileListBoxItem>(class SDArray<SFileListBoxItem> & );
    public void SDArray<SFileListBoxItem>();
    public void ~SDArray<SFileListBoxItem>();
    public int Add(struct SFileListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SFileListBoxItem & operator[](int );
    public void operator=(class SDArray<SFileListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SFileListBox : public SDXWidget
{
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private int SliderMarginLeft;
    private int SliderMarginRight;
    private int SliderMarginTop;
    private int SliderMarginBottom;
    private int * TextLineFrames;
    private int * TextLineBackFrames;
    private bool scrollbars;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private class SSliderV Slider;
    private int CurActive;
    private int RowHeight;
    public void SFileListBox(class SFileListBox & );
    public void SFileListBox();
    public void ~SFileListBox();
    public void Create(int ,unsigned int ,bool ,bool ,bool );
    public void QSort(int );
    public int DeleteItem(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public unsigned long GetItemData(int );
    public int SetItemData(int ,unsigned long );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int GetText(int ,char * ,int );
    public int SetText(int ,char * );
    public int GetTextLen(int );
    public int GetFileName(int ,char * ,int );
    public int SetFileName(int ,char * );
    public int GetFileNameLen(int );
    public int AddItem(char * ,char * ,unsigned long ,unsigned long );
    public void SetMargin(int ,int ,int ,int );
    public void SetSliderMargin(int ,int ,int ,int );
    public void ResetContent();
    protected struct SFileListBoxItem m_ListBoxItem;
    protected class SDArray<SFileListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SFileListBox : public SDXWidget
{
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private int SliderMarginLeft;
    private int SliderMarginRight;
    private int SliderMarginTop;
    private int SliderMarginBottom;
    private int * TextLineFrames;
    private int * TextLineBackFrames;
    private bool scrollbars;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private class SSliderV Slider;
    private int CurActive;
    private int RowHeight;
    public void SFileListBox(class SFileListBox & );
    public void SFileListBox();
    public void ~SFileListBox();
    public void Create(int ,unsigned int ,bool ,bool ,bool );
    public void QSort(int );
    public int DeleteItem(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public unsigned long GetItemData(int );
    public int SetItemData(int ,unsigned long );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int GetText(int ,char * ,int );
    public int SetText(int ,char * );
    public int GetTextLen(int );
    public int GetFileName(int ,char * ,int );
    public int SetFileName(int ,char * );
    public int GetFileNameLen(int );
    public int AddItem(char * ,char * ,unsigned long ,unsigned long );
    public void SetMargin(int ,int ,int ,int );
    public void SetSliderMargin(int ,int ,int ,int );
    public void ResetContent();
    protected struct SFileListBoxItem m_ListBoxItem;
    protected class SDArray<SFileListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SColorButton : public SDXWidget
{
    private int ColorFrame;
    private int ColorButtonBackGroundFont;
    private int ColorButtonBackGroundFrame;
    private bool Active;
    private bool Pressed;
    private int ColorIndex;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void Update();
    public void SColorButton(class SColorButton & );
    public void SColorButton();
    public void ~SColorButton();
    public void Create();
    public void SetColor(unsigned int );
    public unsigned int GetColorIndex();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SColorButton : public SDXWidget
{
    private int ColorFrame;
    private int ColorButtonBackGroundFont;
    private int ColorButtonBackGroundFrame;
    private bool Active;
    private bool Pressed;
    private int ColorIndex;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void Update();
    public void SColorButton(class SColorButton & );
    public void SColorButton();
    public void ~SColorButton();
    public void Create();
    public void SetColor(unsigned int );
    public unsigned int GetColorIndex();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct UserInfo
{
    class SString name;
    enum UserStatus status;
    void UserInfo(struct UserInfo * );
    void UserInfo(struct UserInfo & );
    void UserInfo();
    void ~UserInfo();
    struct UserInfo & operator=(struct UserInfo * );
    struct UserInfo & operator=(struct UserInfo & );
    void * __vecDelDtor(unsigned int );
};

struct SPlayerListBoxItem
{
    enum UserStatus status;
    char PlayerName[261];
    unsigned long Color;
};

struct SPlayerListBoxItem
{
    enum UserStatus status;
    char PlayerName[261];
    unsigned long Color;
};

class SDArray<SPlayerListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SPlayerListBoxItem * array;
    public void SDArray<SPlayerListBoxItem>(class SDArray<SPlayerListBoxItem> & );
    public void SDArray<SPlayerListBoxItem>();
    public void ~SDArray<SPlayerListBoxItem>();
    public int Add(struct SPlayerListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SPlayerListBoxItem & operator[](int );
    public void operator=(class SDArray<SPlayerListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SPlayerListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SPlayerListBoxItem * array;
    public void SDArray<SPlayerListBoxItem>(class SDArray<SPlayerListBoxItem> & );
    public void SDArray<SPlayerListBoxItem>();
    public void ~SDArray<SPlayerListBoxItem>();
    public int Add(struct SPlayerListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SPlayerListBoxItem & operator[](int );
    public void operator=(class SDArray<SPlayerListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SPlayerListBox : public SDXWidget
{
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int * TextLineBackFrames;
    private int * StatusFrame;
    private int * ReadyFrame;
    private int * PlayerNameFrame;
    private int RowHeight;
    private class SSliderV Slider;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private int StateFont;
    private int CurActive;
    private int LastClickTime;
    public void SPlayerListBox(class SPlayerListBox & );
    public void SPlayerListBox();
    public void ~SPlayerListBox();
    public void Create(int ,int ,int );
    public void QSort(int );
    public int DeleteItem(int );
    public int DeletePlayer(char * );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public enum UserStatus GetStatus(int );
    public int SetPlayerName(char * ,char * );
    public char * GetPlayerName(int );
    public int GetPlayerIndex(char * );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int AddItem(enum UserStatus ,char * ,unsigned long );
    public int UpdateItem(int ,enum UserStatus ,char * ,unsigned long );
    public void ResetContent();
    protected struct SPlayerListBoxItem m_ListBoxItem;
    protected class SDArray<SPlayerListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SPlayerListBox : public SDXWidget
{
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int * TextLineBackFrames;
    private int * StatusFrame;
    private int * ReadyFrame;
    private int * PlayerNameFrame;
    private int RowHeight;
    private class SSliderV Slider;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private int StateFont;
    private int CurActive;
    private int LastClickTime;
    public void SPlayerListBox(class SPlayerListBox & );
    public void SPlayerListBox();
    public void ~SPlayerListBox();
    public void Create(int ,int ,int );
    public void QSort(int );
    public int DeleteItem(int );
    public int DeletePlayer(char * );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public enum UserStatus GetStatus(int );
    public int SetPlayerName(char * ,char * );
    public char * GetPlayerName(int );
    public int GetPlayerIndex(char * );
    public unsigned long GetColor(int );
    public int SetColor(int ,unsigned long );
    public int AddItem(enum UserStatus ,char * ,unsigned long );
    public int UpdateItem(int ,enum UserStatus ,char * ,unsigned long );
    public void ResetContent();
    protected struct SPlayerListBoxItem m_ListBoxItem;
    protected class SDArray<SPlayerListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMatchListBox : public SDXWidget
{
    struct SMatchListBoxItem
    {
        bool Status;
        char GameName[261];
        char Map[261];
        int NumPlayers;
        int MaxPlayers;
        char GameType[261];
        class SVersion Version;
        unsigned long ServerCode;
        struct MatchInfo matchInfo;
        unsigned long Color;
        void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem * );
        void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem & );
        void SMatchListBoxItem();
        void ~SMatchListBoxItem();
        struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem * );
        struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem & );
        void * __vecDelDtor(unsigned int );
    };
    struct SFilter
    {
        int Status;
        int ActPlayers;
        int GameType;
        class SVersion Version;
        int On;
        bool Changed;
        void SFilter();
    };
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int * TextLineBackFrames;
    private int * StatusFrame;
    private int * GameNameFrame;
    private int * PlayerFrame;
    private int * GameTypeFrame;
    private int * MapFrame;
    private int * VersionFrame;
    private class SSliderV Slider;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private bool GoodWhenFiltered(int );
    private void SetGoodWhenFilteredItems();
    private struct SMatchListBox::SFilter Filter;
    private int StateFont;
    private int CurActive;
    private int LastClickTime;
    private int RowHeight;
    public void SMatchListBox(class SMatchListBox & );
    public void SMatchListBox();
    public void ~SMatchListBox();
    public void Create();
    public int DeleteItem(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public char * GetGameName(int );
    public unsigned long GetServerCode(int );
    public struct MatchInfo * GetMatchInfo(int );
    public int GetMaxPlayers(int );
    public bool GetStatus(int );
    public class SVersion GetVersion(int );
    public int AddItem(bool ,char * ,char * ,int ,int ,char * ,class SVersion ,unsigned long ,struct MatchInfo & ,unsigned long );
    public void ResetContent();
    public void SetFilter(bool ,int ,int ,class SVersion );
    public void ResetFilter();
    public int GetCountWithoutFiltering();
    protected struct SMatchListBox::SMatchListBoxItem m_ListBoxItem;
    protected class SDArray<int> m_GoodWhenFilteredItems;
    protected class SDArray<SMatchListBox::SMatchListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SMatchListBox : public SDXWidget
{
    struct SMatchListBoxItem
    {
        bool Status;
        char GameName[261];
        char Map[261];
        int NumPlayers;
        int MaxPlayers;
        char GameType[261];
        class SVersion Version;
        unsigned long ServerCode;
        struct MatchInfo matchInfo;
        unsigned long Color;
        void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem * );
        void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem & );
        void SMatchListBoxItem();
        void ~SMatchListBoxItem();
        struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem * );
        struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem & );
        void * __vecDelDtor(unsigned int );
    };
    struct SFilter
    {
        int Status;
        int ActPlayers;
        int GameType;
        class SVersion Version;
        int On;
        bool Changed;
        void SFilter();
    };
    private int Font;
    private int VisibleTextLines;
    private int MaxInnerTextLines;
    private int * TextLineBackFrames;
    private int * StatusFrame;
    private int * GameNameFrame;
    private int * PlayerFrame;
    private int * GameTypeFrame;
    private int * MapFrame;
    private int * VersionFrame;
    private class SSliderV Slider;
    private bool SelectAble;
    private void Update();
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOut();
    private void OnMouseWheel(int ,int ,int ,int );
    private bool GoodWhenFiltered(int );
    private void SetGoodWhenFilteredItems();
    private struct SMatchListBox::SFilter Filter;
    private int StateFont;
    private int CurActive;
    private int LastClickTime;
    private int RowHeight;
    public void SMatchListBox(class SMatchListBox & );
    public void SMatchListBox();
    public void ~SMatchListBox();
    public void Create();
    public int DeleteItem(int );
    public int EnsureIndexIsVisible(int ,bool );
    public int SetTopIndex(int );
    public int GetTopIndex();
    public int GetCount();
    public int GetCurSel();
    public int SetCurSel(int );
    public char * GetGameName(int );
    public unsigned long GetServerCode(int );
    public struct MatchInfo * GetMatchInfo(int );
    public int GetMaxPlayers(int );
    public bool GetStatus(int );
    public class SVersion GetVersion(int );
    public int AddItem(bool ,char * ,char * ,int ,int ,char * ,class SVersion ,unsigned long ,struct MatchInfo & ,unsigned long );
    public void ResetContent();
    public void SetFilter(bool ,int ,int ,class SVersion );
    public void ResetFilter();
    public int GetCountWithoutFiltering();
    protected struct SMatchListBox::SMatchListBoxItem m_ListBoxItem;
    protected class SDArray<int> m_GoodWhenFilteredItems;
    protected class SDArray<SMatchListBox::SMatchListBoxItem> m_ListBoxItems;
    protected int m_nCurSel;
    protected int m_nTopIndex;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SStatusPanel : public SDXWidget
{
    private int Font;
    private int OverlayFrame;
    private int AmmoIcon;
    private int FuelIcon;
    private int XPIcon;
    private int CargoIcon;
    private int AtomIcon;
    private int TextFont;
    private int NameFrame;
    private int HPFrame;
    private int AmmoFrame;
    private int FuelFrame;
    private int XPFrame;
    private int HPStripe;
    private int AmmoStripe;
    private int FuelStripe;
    private int XPStripe;
    private int CargoStripe;
    private int LevelFrame1;
    private int LevelFrame2;
    private int CargoFrame;
    private int UpgradeFont;
    private int UpgradeFrames[3];
    public void SStatusPanel(class SStatusPanel & );
    public void SStatusPanel();
    public void ~SStatusPanel();
    public void Create(int ,int );
    public void SetStatus(struct SPanelStatus & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SStatusPanel : public SDXWidget
{
    private int Font;
    private int OverlayFrame;
    private int AmmoIcon;
    private int FuelIcon;
    private int XPIcon;
    private int CargoIcon;
    private int AtomIcon;
    private int TextFont;
    private int NameFrame;
    private int HPFrame;
    private int AmmoFrame;
    private int FuelFrame;
    private int XPFrame;
    private int HPStripe;
    private int AmmoStripe;
    private int FuelStripe;
    private int XPStripe;
    private int CargoStripe;
    private int LevelFrame1;
    private int LevelFrame2;
    private int CargoFrame;
    private int UpgradeFont;
    private int UpgradeFrames[3];
    public void SStatusPanel(class SStatusPanel & );
    public void SStatusPanel();
    public void ~SStatusPanel();
    public void Create(int ,int );
    public void SetStatus(struct SPanelStatus & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SGroupIcon : public SDXWidget
{
    private int Font;
    private int NormalWheelGlyph;
    private int PressedWheelGlyph;
    private int NormalNumberGlyph;
    private int PressedNumberGlyph;
    private int WheelFrame;
    private int NumberFrame;
    private bool Pressed;
    private bool Drag;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void SetState();
    public void SGroupIcon(class SGroupIcon * );
    public void SGroupIcon(class SGroupIcon & );
    public void SGroupIcon();
    public void Create(int ,int ,int ,int ,int );
    public void SetPressed(bool );
    public void ~SGroupIcon();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SGroupIcon : public SDXWidget
{
    private int Font;
    private int NormalWheelGlyph;
    private int PressedWheelGlyph;
    private int NormalNumberGlyph;
    private int PressedNumberGlyph;
    private int WheelFrame;
    private int NumberFrame;
    private bool Pressed;
    private bool Drag;
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void SetState();
    public void SGroupIcon(class SGroupIcon * );
    public void SGroupIcon(class SGroupIcon & );
    public void SGroupIcon();
    public void Create(int ,int ,int ,int ,int );
    public void SetPressed(bool );
    public void ~SGroupIcon();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SInGameMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private class STextButton SaveGame;
    private class STextButton LoadGame;
    private class STextButton OptionsButton;
    private class STextButton Help;
    private class STextButton ShowBriefing;
    private class STextButton EndGame;
    private class STextButton ReturnGame;
    private void UnactivateAll();
    public void SInGameMenu(class SInGameMenu * );
    public void SInGameMenu(class SInGameMenu & );
    public void SInGameMenu();
    public void Create();
    public void ~SInGameMenu();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SInGameMenu : public SMenu
{
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private class STextButton SaveGame;
    private class STextButton LoadGame;
    private class STextButton OptionsButton;
    private class STextButton Help;
    private class STextButton ShowBriefing;
    private class STextButton EndGame;
    private class STextButton ReturnGame;
    private void UnactivateAll();
    public void SInGameMenu(class SInGameMenu * );
    public void SInGameMenu(class SInGameMenu & );
    public void SInGameMenu();
    public void Create();
    public void ~SInGameMenu();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSaveMenu : public SMenu
{
    private class STextButton Save;
    private class STextButton Delete;
    private class STextButton Cancel;
    private class SSaveLoadListBox ListBox;
    private class SEditBox EditBox[14];
    private bool OnAction(class SWidget * ,int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private bool OnKeyDown(int );
    private void HideEditBox();
    private void SaveGame();
    public void SSaveMenu(class SSaveMenu & );
    public void SSaveMenu();
    public void ~SSaveMenu();
    public void Create();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SHelpMenu : public SMenu
{
    private class STextButton Back;
    private class SListBox ListBox;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    public void SHelpMenu(class SHelpMenu & );
    public void SHelpMenu();
    public void ~SHelpMenu();
    public void Create();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SInGameBriefingMenu : public SMenu
{
    private class STextButton Back;
    private class SListBox BriefingListBox;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    public void SInGameBriefingMenu(class SInGameBriefingMenu & );
    public void SInGameBriefingMenu();
    public void ~SInGameBriefingMenu();
    public void Create();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SDXWidget *>
{
    private int size;
    private int maxsize;
    public class SDXWidget ** array;
    public void SDArray<SDXWidget *>(class SDArray<SDXWidget *> & );
    public void SDArray<SDXWidget *>();
    public void ~SDArray<SDXWidget *>();
    public int Add(class SDXWidget &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SDXWidget &** operator[](int );
    public void operator=(class SDArray<SDXWidget *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SDXWidget *>
{
    private int size;
    private int maxsize;
    public class SDXWidget ** array;
    public void SDArray<SDXWidget *>(class SDArray<SDXWidget *> & );
    public void SDArray<SDXWidget *>();
    public void ~SDArray<SDXWidget *>();
    public int Add(class SDXWidget &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SDXWidget &** operator[](int );
    public void operator=(class SDArray<SDXWidget *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<int>
{
    private int size;
    private int maxsize;
    public int * array;
    public void SDArray<int>(class SDArray<int> & );
    public void SDArray<int>();
    public void ~SDArray<int>();
    public int Add(int & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public int & operator[](int );
    public void operator=(class SDArray<int> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<int>
{
    private int size;
    private int maxsize;
    public int * array;
    public void SDArray<int>(class SDArray<int> & );
    public void SDArray<int>();
    public void ~SDArray<int>();
    public int Add(int & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public int & operator[](int );
    public void operator=(class SDArray<int> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<char *>
{
    private int size;
    private int maxsize;
    public char ** array;
    public void SDArray<char *>(class SDArray<char *> & );
    public void SDArray<char *>();
    public void ~SDArray<char *>();
    public int Add(char &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public char &** operator[](int );
    public void operator=(class SDArray<char *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<char *>
{
    private int size;
    private int maxsize;
    public char ** array;
    public void SDArray<char *>(class SDArray<char *> & );
    public void SDArray<char *>();
    public void ~SDArray<char *>();
    public int Add(char &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public char &** operator[](int );
    public void operator=(class SDArray<char *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct APP_MSG_PACKET_DATA : public MSG_GENERIC
{
    unsigned int playerSlot;
    int frameCount;
    unsigned int lengthFirst;
    unsigned int lengthSecond;
};

struct SFrameHistory
{
    struct SFrameData frames[83];
    void SFrameHistory();
    void ~SFrameHistory();
    void * __vecDelDtor(unsigned int );
};

struct PLAYER_CONNECTION_INFO
{
    char internalIpAddress[16];
    char externalIpAddress[16];
    int listenPort;
};

struct MSG_GENERIC
{
    enum MessageId messageId;
    unsigned int originalSender:4;
    unsigned int ttl:4;
    unsigned int targetPlayerMask;
};

struct STAGEMSG_INTRODUCTION : public MSG_GENERIC
{
    struct PLAYER_CONNECTION_INFO connectionInfo;
    char strPlayerName[51];
};

struct STAGEMSG_REQUEST_MAP_DOWNLOAD : public MSG_GENERIC
{
    unsigned int receiverId;
};

struct STAGEMSG_PLAYER_READY : public MSG_GENERIC
{
    int param;
};

struct STAGEMSG_PLAYER_CHANGE : public MSG_GENERIC
{
    int param;
};

struct STAGEMSG_STAGEDATA : public MSG_GENERIC
{
    int slotNumber;
    struct SLOT_INFO slotInfo;
};

struct PEER_MSG_CONNECTIVITY_UPDATE : public MSG_GENERIC
{
    struct PeerConnectivity connectivity;
    unsigned int worstPing;
};

struct SLOT_INFO
{
    unsigned long dwSlotStatus;
    char strSlotName[50];
    struct PLAYER_CONNECTION_INFO connectionInfo;
    unsigned int raknetGuid;
    unsigned int Race;
    unsigned int Color;
    unsigned int Team;
};

struct GAME_SETTINGS
{
    int bSettingsLocked;
    int SPStartLimit;
    int SPPeriodicLimit;
    unsigned int GameType;
    char MapName[260];
    char MapFileName[260];
    unsigned long MapFileCRC;
    unsigned int CountMinute;
    int bEquipment;
    int bLimitedAmmo;
    int bLimitedFuel;
    int bMovingForce;
    int bBomber;
    int bNewUnit;
    int bRandomStartPosition;
    int bDomination;
    int StartRandomseed;
};

struct Peer2PeerConnectivity
{
    unsigned int distance:3;
    unsigned int ping:13;
};

struct PeerConnectivity
{
    struct Peer2PeerConnectivity targets[8];
};

class ConnectivityGraph
{
    public void ConnectivityGraph();
    public void ~ConnectivityGraph();
    public struct PeerConnectivity peers[8];
    public int guaranteedMessageRouting[8];
    public int nonSequentialMessageRouting[8];
    public unsigned int worstPings[8];
    public void ClearPeerInfo(int );
    public void * __vecDelDtor(unsigned int );
};

struct SMatchListBox::SMatchListBoxItem
{
    bool Status;
    char GameName[261];
    char Map[261];
    int NumPlayers;
    int MaxPlayers;
    char GameType[261];
    class SVersion Version;
    unsigned long ServerCode;
    struct MatchInfo matchInfo;
    unsigned long Color;
    void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem * );
    void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem & );
    void SMatchListBoxItem();
    void ~SMatchListBoxItem();
    struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem * );
    struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem & );
    void * __vecDelDtor(unsigned int );
};

struct SMatchListBox::SMatchListBoxItem
{
    bool Status;
    char GameName[261];
    char Map[261];
    int NumPlayers;
    int MaxPlayers;
    char GameType[261];
    class SVersion Version;
    unsigned long ServerCode;
    struct MatchInfo matchInfo;
    unsigned long Color;
    void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem * );
    void SMatchListBoxItem(struct SMatchListBox::SMatchListBoxItem & );
    void SMatchListBoxItem();
    void ~SMatchListBoxItem();
    struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem * );
    struct SMatchListBox::SMatchListBoxItem & operator=(struct SMatchListBox::SMatchListBoxItem & );
    void * __vecDelDtor(unsigned int );
};

struct SMatchListBox::SFilter
{
    int Status;
    int ActPlayers;
    int GameType;
    class SVersion Version;
    int On;
    bool Changed;
    void SFilter();
};

class SSliderV : public SDXWidget
{
    private int SliderFont;
    private int ButtonFont;
    private int SliderUp;
    private int SliderMiddle;
    private int SliderDown;
    private int SliderBox;
    private int ButtonUpFrame;
    private int ButtonDownFrame;
    private int FirstKlikkTimer;
    private int TickTimer;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private bool PressedUp;
    private bool PressedDown;
    private bool ActiveUp;
    private bool ActiveDown;
    private bool RedBigyoDown;
    private int VisibleRows;
    private int TopIndex;
    private int TopIndexInListBox;
    private int NumberOfRows;
    private int YSizeOfLittleRedBigyo;
    private int YPosOfLittleRedBigyo;
    private int XPosRed;
    private int XPosLine;
    private int DeltaYOfLRB;
    private int YDownPosOfLRB;
    private bool IsOverUpButton(int ,int );
    private bool IsOverDownButton(int ,int );
    private bool IsOverRed(int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void OnTimer(int ,unsigned long );
    private void Update();
    public void SSliderV(class SSliderV & );
    public void SSliderV();
    public void ~SSliderV();
    public void SetMargin(int ,int ,int ,int );
    public void Create(int ,int ,int );
    public void SetRows(int ,int );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SSliderV : public SDXWidget
{
    private int SliderFont;
    private int ButtonFont;
    private int SliderUp;
    private int SliderMiddle;
    private int SliderDown;
    private int SliderBox;
    private int ButtonUpFrame;
    private int ButtonDownFrame;
    private int FirstKlikkTimer;
    private int TickTimer;
    private int MarginLeft;
    private int MarginRight;
    private int MarginTop;
    private int MarginBottom;
    private bool PressedUp;
    private bool PressedDown;
    private bool ActiveUp;
    private bool ActiveDown;
    private bool RedBigyoDown;
    private int VisibleRows;
    private int TopIndex;
    private int TopIndexInListBox;
    private int NumberOfRows;
    private int YSizeOfLittleRedBigyo;
    private int YPosOfLittleRedBigyo;
    private int XPosRed;
    private int XPosLine;
    private int DeltaYOfLRB;
    private int YDownPosOfLRB;
    private bool IsOverUpButton(int ,int );
    private bool IsOverDownButton(int ,int );
    private bool IsOverRed(int ,int );
    private void OnMouseDown(int ,int ,int ,int );
    private void OnMouseUp(int ,int ,int ,int );
    private void OnMouseMove(int ,int ,int );
    private void OnMouseOver();
    private void OnMouseOut();
    private void OnTimer(int ,unsigned long );
    private void Update();
    public void SSliderV(class SSliderV & );
    public void SSliderV();
    public void ~SSliderV();
    public void SetMargin(int ,int ,int ,int );
    public void Create(int ,int ,int );
    public void SetRows(int ,int );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SMatchListBox::SMatchListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SMatchListBox::SMatchListBoxItem * array;
    public void SDArray<SMatchListBox::SMatchListBoxItem>(class SDArray<SMatchListBox::SMatchListBoxItem> & );
    public void SDArray<SMatchListBox::SMatchListBoxItem>();
    public void ~SDArray<SMatchListBox::SMatchListBoxItem>();
    public int Add(struct SMatchListBox::SMatchListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SMatchListBox::SMatchListBoxItem & operator[](int );
    public void operator=(class SDArray<SMatchListBox::SMatchListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SMatchListBox::SMatchListBoxItem>
{
    private int size;
    private int maxsize;
    public struct SMatchListBox::SMatchListBoxItem * array;
    public void SDArray<SMatchListBox::SMatchListBoxItem>(class SDArray<SMatchListBox::SMatchListBoxItem> & );
    public void SDArray<SMatchListBox::SMatchListBoxItem>();
    public void ~SDArray<SMatchListBox::SMatchListBoxItem>();
    public int Add(struct SMatchListBox::SMatchListBoxItem & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SMatchListBox::SMatchListBoxItem & operator[](int );
    public void operator=(class SDArray<SMatchListBox::SMatchListBoxItem> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SPlatform
{
    public void SPlatform(class SPlatform & );
    public void SPlatform();
    public void ~SPlatform();
    public void Initialize();
    public void Update();
    public char * GetPlayerName();
    public void UnlockAchievement(enum SAchievementID );
    public void SetStat(enum SStatID ,int ,bool ,bool );
    public int IncrementStat(enum SStatID ,int ,int ,bool );
    public void StoreStats();
    public void ResetStatsAndAchievements();
    public void OnGameOverlayActivated(bool );
    public void OnStatsReceived();
    private class SSteamManager * SteamManager;
    private char * PlayerName;
    private class Array<SStat> Stats;
    private class Array<SAchievement> Achievements;
    private void InitPlayerName();
    private void InitStats();
    private void InitAchievements();
    private struct SStat * GetLocalStatById(enum SStatID );
    private struct SAchievement * GetLocalAchievementById(enum SAchievementID );
    private void SetStatToPlatform(struct SStat * ,bool );
    private void UnlockStatBasedAchievementIfNeeded(struct SStat * );
    public class SPlatform & operator=(class SPlatform & );
    public void * __vecDelDtor(unsigned int );
};

enum SStatID
{
    STAT_PIG_UNITS_DESTROYED=0,
    STAT_RABBIT_UNITS_DESTROYED=1,
    STAT_UNITS_DESTROYED_WITH_MINES=2,
    STAT_MAX_UNITS_DESTROYED_BY_ONE_UNIT=3
};

class SPlatform
{
    public void SPlatform(class SPlatform & );
    public void SPlatform();
    public void ~SPlatform();
    public void Initialize();
    public void Update();
    public char * GetPlayerName();
    public void UnlockAchievement(enum SAchievementID );
    public void SetStat(enum SStatID ,int ,bool ,bool );
    public int IncrementStat(enum SStatID ,int ,int ,bool );
    public void StoreStats();
    public void ResetStatsAndAchievements();
    public void OnGameOverlayActivated(bool );
    public void OnStatsReceived();
    private class SSteamManager * SteamManager;
    private char * PlayerName;
    private class Array<SStat> Stats;
    private class Array<SAchievement> Achievements;
    private void InitPlayerName();
    private void InitStats();
    private void InitAchievements();
    private struct SStat * GetLocalStatById(enum SStatID );
    private struct SAchievement * GetLocalAchievementById(enum SAchievementID );
    private void SetStatToPlatform(struct SStat * ,bool );
    private void UnlockStatBasedAchievementIfNeeded(struct SStat * );
    public class SPlatform & operator=(class SPlatform & );
    public void * __vecDelDtor(unsigned int );
};

class Array<SStat>
{
    public void Array<SStat>(class Array<SStat> * );
    public void Array<SStat>(class Array<SStat> & );
    public void Array<SStat>();
    public void ~Array<SStat>();
    public void operator=(class ArrayRef<SStat> & );
    public void operator=(class Array<SStat> * );
    public void operator=(class Array<SStat> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SStat & operator[](unsigned int );
    public struct SStat & operator[](unsigned int );
    public struct SStat & GetLast();
    public struct SStat & GetLast();
    public void Add(struct SStat * );
    public void Add(struct SStat & );
    public void Insert(unsigned int ,struct SStat * );
    public void Insert(unsigned int ,struct SStat & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SStat & );
    public void RemoveLast();
    public struct SStat * begin();
    public struct SStat * begin();
    public struct SStat * end();
    public struct SStat * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SStat> operator class ArrayRef<struct SStat>();
    private struct SStat * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SStat * Allocate(unsigned int );
    private void Deallocate(struct SStat * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ArrayRef<SStat>
{
};

struct SStat
{
    enum SStatID Id;
    int Value;
};

class Array<SStat>
{
    public void Array<SStat>(class Array<SStat> * );
    public void Array<SStat>(class Array<SStat> & );
    public void Array<SStat>();
    public void ~Array<SStat>();
    public void operator=(class ArrayRef<SStat> & );
    public void operator=(class Array<SStat> * );
    public void operator=(class Array<SStat> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SStat & operator[](unsigned int );
    public struct SStat & operator[](unsigned int );
    public struct SStat & GetLast();
    public struct SStat & GetLast();
    public void Add(struct SStat * );
    public void Add(struct SStat & );
    public void Insert(unsigned int ,struct SStat * );
    public void Insert(unsigned int ,struct SStat & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SStat & );
    public void RemoveLast();
    public struct SStat * begin();
    public struct SStat * begin();
    public struct SStat * end();
    public struct SStat * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SStat> operator class ArrayRef<struct SStat>();
    private struct SStat * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SStat * Allocate(unsigned int );
    private void Deallocate(struct SStat * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class Array<SAchievement>
{
    public void Array<SAchievement>(class Array<SAchievement> * );
    public void Array<SAchievement>(class Array<SAchievement> & );
    public void Array<SAchievement>();
    public void ~Array<SAchievement>();
    public void operator=(class ArrayRef<SAchievement> & );
    public void operator=(class Array<SAchievement> * );
    public void operator=(class Array<SAchievement> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SAchievement & operator[](unsigned int );
    public struct SAchievement & operator[](unsigned int );
    public struct SAchievement & GetLast();
    public struct SAchievement & GetLast();
    public void Add(struct SAchievement * );
    public void Add(struct SAchievement & );
    public void Insert(unsigned int ,struct SAchievement * );
    public void Insert(unsigned int ,struct SAchievement & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SAchievement & );
    public void RemoveLast();
    public struct SAchievement * begin();
    public struct SAchievement * begin();
    public struct SAchievement * end();
    public struct SAchievement * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SAchievement> operator class ArrayRef<struct SAchievement>();
    private struct SAchievement * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SAchievement * Allocate(unsigned int );
    private void Deallocate(struct SAchievement * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ArrayRef<SAchievement>
{
};

struct SAchievement
{
    enum SAchievementID Id;
    bool Achieved;
};

class Array<SAchievement>
{
    public void Array<SAchievement>(class Array<SAchievement> * );
    public void Array<SAchievement>(class Array<SAchievement> & );
    public void Array<SAchievement>();
    public void ~Array<SAchievement>();
    public void operator=(class ArrayRef<SAchievement> & );
    public void operator=(class Array<SAchievement> * );
    public void operator=(class Array<SAchievement> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SAchievement & operator[](unsigned int );
    public struct SAchievement & operator[](unsigned int );
    public struct SAchievement & GetLast();
    public struct SAchievement & GetLast();
    public void Add(struct SAchievement * );
    public void Add(struct SAchievement & );
    public void Insert(unsigned int ,struct SAchievement * );
    public void Insert(unsigned int ,struct SAchievement & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SAchievement & );
    public void RemoveLast();
    public struct SAchievement * begin();
    public struct SAchievement * begin();
    public struct SAchievement * end();
    public struct SAchievement * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SAchievement> operator class ArrayRef<struct SAchievement>();
    private struct SAchievement * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SAchievement * Allocate(unsigned int );
    private void Deallocate(struct SAchievement * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

struct SStat
{
    enum SStatID Id;
    int Value;
};

struct SAchievement
{
    enum SAchievementID Id;
    bool Achieved;
};

enum UPnPGateway::InitStatus
{
    Initializing=0,
    Failed=1,
    Success=2
};

class UPnPGateway
{
    public class UPnPGateway * instance;
    public void Create();
    public void Destroy();
    public bool AddPortMapping(char * ,char * );
    private void UPnPGateway();
    private void ~UPnPGateway();
    private unsigned long InitThreadProc(void * );
    enum InitStatus
    {
        Initializing=0,
        Failed=1,
        Success=2
    };
    private enum UPnPGateway::InitStatus initStatus;
    struct GatewayData
    {
        char lanaddr[64];
        struct UPNPUrls urls;
        struct IGDdatas data;
        void GatewayData();
    };
    private struct UPnPGateway::GatewayData * gatewayData;
    private void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode
{
    void MapNode(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    void MapNode(unsigned int ,struct RakNet::FileListReceiver * );
    void MapNode();
    struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator=(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    unsigned int mapNodeKey;
    struct RakNet::FileListReceiver * mapNodeData;
};

class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
        void MapNode(unsigned int ,struct RakNet::FileListReceiver * );
        void MapNode();
        struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator=(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
        unsigned int mapNodeKey;
        struct RakNet::FileListReceiver * mapNodeData;
    };
    public int NodeComparisonFunc(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    public void Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >(class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > & );
    public void Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >();
    public void ~Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >();
    public class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > & operator=(class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > & );
    public struct RakNet::FileListReceiver &** Get(unsigned int & );
    public struct RakNet::FileListReceiver * Pop(unsigned int & );
    public void Set(unsigned int & ,struct RakNet::FileListReceiver &** );
    public void SetExisting(unsigned int & ,struct RakNet::FileListReceiver &** );
    public void SetNew(unsigned int & ,struct RakNet::FileListReceiver &** );
    public bool Has(unsigned int & );
    public bool Delete(unsigned int & );
    public struct RakNet::FileListReceiver &** operator[](const unsigned int );
    public unsigned int GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(unsigned int & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(unsigned int & ,unsigned int );
    protected bool HasSavedSearchResult(unsigned int & );
    protected unsigned int lastSearchIndex;
    protected unsigned int lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
        void MapNode(unsigned int ,struct RakNet::FileListReceiver * );
        void MapNode();
        struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator=(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
        unsigned int mapNodeKey;
        struct RakNet::FileListReceiver * mapNodeData;
    };
    public int NodeComparisonFunc(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    public void Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >(class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > & );
    public void Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >();
    public void ~Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >();
    public class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > & operator=(class DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> > & );
    public struct RakNet::FileListReceiver &** Get(unsigned int & );
    public struct RakNet::FileListReceiver * Pop(unsigned int & );
    public void Set(unsigned int & ,struct RakNet::FileListReceiver &** );
    public void SetExisting(unsigned int & ,struct RakNet::FileListReceiver &** );
    public void SetNew(unsigned int & ,struct RakNet::FileListReceiver &** );
    public bool Has(unsigned int & );
    public bool Delete(unsigned int & );
    public struct RakNet::FileListReceiver &** operator[](const unsigned int );
    public unsigned int GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(unsigned int & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(unsigned int & ,unsigned int );
    protected bool HasSavedSearchResult(unsigned int & );
    protected unsigned int lastSearchIndex;
    protected unsigned int lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode
{
    void MapNode(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    void MapNode(unsigned int ,struct RakNet::FileListReceiver * );
    void MapNode();
    struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator=(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    unsigned int mapNodeKey;
    struct RakNet::FileListReceiver * mapNodeData;
};

class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>
{
    public void List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>(class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> & );
    public void List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>();
    public void ~List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> & );
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    public void Replace(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,const struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>
{
    public void List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>(class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> & );
    public void List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>();
    public void ~List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> & );
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    public void Replace(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,const struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyCompar(class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> & );
    public void OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyCompar();
    public void ~OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyCompa();
    public class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> & );
    public bool HasData(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int GetIndexFromKey(unsigned int & ,bool * ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public bool GetElementFromKey(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode GetElementFromKey(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int Insert(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int Remove(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int RemoveIfExists(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyCompar(class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> & );
    public void OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyCompar();
    public void ~OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyCompa();
    public class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<unsigned short,DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode,&DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::NodeComparisonFunc> & );
    public bool HasData(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int GetIndexFromKey(unsigned int & ,bool * ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public bool GetElementFromKey(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode GetElementFromKey(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int Insert(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int Remove(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public unsigned int RemoveIfExists(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ));
    public struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<unsigned short,RakNet::FileListReceiver *,&DataStructures::defaultMapKeyComparison<unsigned short> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class SProperties
{
    public void SProperties(char * ,bool ,bool );
    public void ~SProperties();
    public char * GetString(char * ,char * ,char * );
    public float GetFloat(char * ,char * ,float );
    public int GetInt(char * ,char * ,int );
    public void EnumPropertyClasses();
    public char * GetNextPropertyClass();
    public void EnumProperties(char * );
    public char * GetNextProperty();
    private struct SPropertyClass * chain;
    private struct SPropertyClass * pc_enum;
    private struct SProperty * p_enum;
    private void ParseFileData(char * ,char * ,bool );
    private struct SPropertyClass * LookupClass(char * );
    private struct SProperty * LookupVariable(struct SPropertyClass * ,char * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SString
{
    private char * buf;
    private int size;
    public void SString(class SStream * );
    public void SString(char );
    public void SString(char * ,int );
    public void SString(char * );
    public void SString(class SString & );
    public void SString();
    private void SString(char * ,int );
    public void ~SString();
    public void operator=(char * );
    public void operator=(class SString & );
    public class SString operator+(char * );
    public class SString operator+(class SString & );
    public void operator+=(char * );
    public void operator+=(class SString & );
    public int GetLength();
    public bool IsEmpty();
    public char * operator const char *();
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void Empty();
    public void Format(char * ,<btNoType> );
    public void Crop(int ,int );
    public const int IndexOf(char & );
    public void ReplaceChars(class SString & ,char & );
    public class SString Copy(int ,int );
    public class SString Dirname();
    public class SString Basename();
    public bool operator==(char * );
    public bool operator==(class SString & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SString
{
    private char * buf;
    private int size;
    public void SString(class SStream * );
    public void SString(char );
    public void SString(char * ,int );
    public void SString(char * );
    public void SString(class SString & );
    public void SString();
    private void SString(char * ,int );
    public void ~SString();
    public void operator=(char * );
    public void operator=(class SString & );
    public class SString operator+(char * );
    public class SString operator+(class SString & );
    public void operator+=(char * );
    public void operator+=(class SString & );
    public int GetLength();
    public bool IsEmpty();
    public char * operator const char *();
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void Empty();
    public void Format(char * ,<btNoType> );
    public void Crop(int ,int );
    public const int IndexOf(char & );
    public void ReplaceChars(class SString & ,char & );
    public class SString Copy(int ,int );
    public class SString Dirname();
    public class SString Basename();
    public bool operator==(char * );
    public bool operator==(class SString & );
    public void * __vecDelDtor(unsigned int );
};

struct tagRECT
{
    long left;
    long top;
    long right;
    long bottom;
};

enum _ACL_INFORMATION_CLASS
{
    AclRevisionInformation=1,
    AclSizeInformation=2
};

enum _AUDIT_EVENT_TYPE
{
    AuditEventObjectAccess=0,
    AuditEventDirectoryServiceAccess=1
};

enum _ACCESS_REASON_TYPE
{
    AccessReasonNone=0,
    AccessReasonAllowedAce=65536,
    AccessReasonDeniedAce=131072,
    AccessReasonAllowedParentAce=196608,
    AccessReasonDeniedParentAce=262144,
    AccessReasonMissingPrivilege=1048576,
    AccessReasonFromPrivilege=2097152,
    AccessReasonIntegrityLevel=3145728,
    AccessReasonOwnership=4194304,
    AccessReasonNullDacl=5242880,
    AccessReasonEmptyDacl=6291456,
    AccessReasonNoSD=7340032,
    AccessReasonNoGrant=8388608
};

enum _SECURITY_IMPERSONATION_LEVEL
{
    SecurityAnonymous=0,
    SecurityIdentification=1,
    SecurityImpersonation=2,
    SecurityDelegation=3
};

enum _TOKEN_TYPE
{
    TokenPrimary=1,
    TokenImpersonation=2
};

enum _TOKEN_ELEVATION_TYPE
{
    TokenElevationTypeDefault=1,
    TokenElevationTypeFull=2,
    TokenElevationTypeLimited=3
};

enum _TOKEN_INFORMATION_CLASS
{
    TokenUser=1,
    TokenGroups=2,
    TokenPrivileges=3,
    TokenOwner=4,
    TokenPrimaryGroup=5,
    TokenDefaultDacl=6,
    TokenSource=7,
    TokenType=8,
    TokenImpersonationLevel=9,
    TokenStatistics=10,
    TokenRestrictedSids=11,
    TokenSessionId=12,
    TokenGroupsAndPrivileges=13,
    TokenSessionReference=14,
    TokenSandBoxInert=15,
    TokenAuditPolicy=16,
    TokenOrigin=17,
    TokenElevationType=18,
    TokenLinkedToken=19,
    TokenElevation=20,
    TokenHasRestrictions=21,
    TokenAccessInformation=22,
    TokenVirtualizationAllowed=23,
    TokenVirtualizationEnabled=24,
    TokenIntegrityLevel=25,
    TokenUIAccess=26,
    TokenMandatoryPolicy=27,
    TokenLogonSid=28,
    MaxTokenInfoClass=29
};

enum std::_Uninitialized
{
    _Noinit=0
};

enum _MANDATORY_LEVEL
{
    MandatoryLevelUntrusted=0,
    MandatoryLevelLow=1,
    MandatoryLevelMedium=2,
    MandatoryLevelHigh=3,
    MandatoryLevelSystem=4,
    MandatoryLevelSecureProcess=5,
    MandatoryLevelCount=6
};

enum _HARDWARE_COUNTER_TYPE
{
    PMCCounter=0,
    MaxHardwareCounterType=1
};

enum _JOBOBJECTINFOCLASS
{
    JobObjectBasicAccountingInformation=1,
    JobObjectBasicLimitInformation=2,
    JobObjectBasicProcessIdList=3,
    JobObjectBasicUIRestrictions=4,
    JobObjectSecurityLimitInformation=5,
    JobObjectEndOfJobTimeInformation=6,
    JobObjectAssociateCompletionPortInformation=7,
    JobObjectBasicAndIoAccountingInformation=8,
    JobObjectExtendedLimitInformation=9,
    JobObjectJobSetInformation=10,
    JobObjectGroupInformation=11,
    MaxJobObjectInfoClass=12
};

enum _LOGICAL_PROCESSOR_RELATIONSHIP
{
    RelationProcessorCore=0,
    RelationNumaNode=1,
    RelationCache=2,
    RelationProcessorPackage=3,
    RelationGroup=4,
    RelationAll=65535
};

enum _PROCESSOR_CACHE_TYPE
{
    CacheUnified=0,
    CacheInstruction=1,
    CacheData=2,
    CacheTrace=3
};

enum std::memory_order
{
    memory_order_relaxed=0,
    memory_order_consume=1,
    memory_order_acquire=2,
    memory_order_release=3,
    memory_order_acq_rel=4,
    memory_order_seq_cst=5
};

enum std::_Iosb<int>::_Fmtflags
{
    _Fmtmask=65535,
    _Fmtzero=0
};

enum std::_Iosb<int>::_Iostate
{
    _Statmask=23
};

enum std::_Iosb<int>::_Openmode
{
    _Openmask=255
};

enum std::_Iosb<int>::_Seekdir
{
    _Seekbeg=0,
    _Seekcur=1,
    _Seekend=2
};

enum _DEP_SYSTEM_POLICY_TYPE
{
    DEPPolicyAlwaysOff=0,
    DEPPolicyAlwaysOn=1,
    DEPPolicyOptIn=2,
    DEPPolicyOptOut=3,
    DEPTotalPolicyCount=4
};

enum _SYSTEM_POWER_STATE
{
    PowerSystemUnspecified=0,
    PowerSystemWorking=1,
    PowerSystemSleeping1=2,
    PowerSystemSleeping2=3,
    PowerSystemSleeping3=4,
    PowerSystemHibernate=5,
    PowerSystemShutdown=6,
    PowerSystemMaximum=7
};

enum POWER_ACTION
{
    PowerActionNone=0,
    PowerActionReserved=1,
    PowerActionSleep=2,
    PowerActionHibernate=3,
    PowerActionShutdown=4,
    PowerActionShutdownReset=5,
    PowerActionShutdownOff=6,
    PowerActionWarmEject=7
};

enum _DEVICE_POWER_STATE
{
    PowerDeviceUnspecified=0,
    PowerDeviceD0=1,
    PowerDeviceD1=2,
    PowerDeviceD2=3,
    PowerDeviceD3=4,
    PowerDeviceMaximum=5
};

enum _MONITOR_DISPLAY_STATE
{
    PowerMonitorOff=0,
    PowerMonitorOn=1,
    PowerMonitorDim=2
};

enum LATENCY_TIME
{
    LT_DONT_CARE=0,
    LT_LOWEST_LATENCY=1
};

enum _POWER_REQUEST_TYPE
{
    PowerRequestDisplayRequired=0,
    PowerRequestSystemRequired=1,
    PowerRequestAwayModeRequired=2
};

enum POWER_INFORMATION_LEVEL
{
    SystemPowerPolicyAc=0,
    SystemPowerPolicyDc=1,
    VerifySystemPolicyAc=2,
    VerifySystemPolicyDc=3,
    SystemPowerCapabilities=4,
    SystemBatteryState=5,
    SystemPowerStateHandler=6,
    ProcessorStateHandler=7,
    SystemPowerPolicyCurrent=8,
    AdministratorPowerPolicy=9,
    SystemReserveHiberFile=10,
    ProcessorInformation=11,
    SystemPowerInformation=12,
    ProcessorStateHandler2=13,
    LastWakeTime=14,
    LastSleepTime=15,
    SystemExecutionState=16,
    SystemPowerStateNotifyHandler=17,
    ProcessorPowerPolicyAc=18,
    ProcessorPowerPolicyDc=19,
    VerifyProcessorPowerPolicyAc=20,
    VerifyProcessorPowerPolicyDc=21,
    ProcessorPowerPolicyCurrent=22,
    SystemPowerStateLogging=23,
    SystemPowerLoggingEntry=24,
    SetPowerSettingValue=25,
    NotifyUserPowerSetting=26,
    PowerInformationLevelUnused0=27,
    PowerInformationLevelUnused1=28,
    SystemVideoState=29,
    TraceApplicationPowerMessage=30,
    TraceApplicationPowerMessageEnd=31,
    ProcessorPerfStates=32,
    ProcessorIdleStates=33,
    ProcessorCap=34,
    SystemWakeSource=35,
    SystemHiberFileInformation=36,
    TraceServicePowerMessage=37,
    ProcessorLoad=38,
    PowerShutdownNotification=39,
    MonitorCapabilities=40,
    SessionPowerInit=41,
    SessionDisplayState=42,
    PowerRequestCreate=43,
    PowerRequestAction=44,
    GetPowerRequestList=45,
    ProcessorInformationEx=46,
    NotifyUserModeLegacyPowerEvent=47,
    GroupPark=48,
    ProcessorIdleDomains=49,
    WakeTimerList=50,
    SystemHiberFileSize=51,
    PowerInformationLevelMaximum=52
};

enum SYSTEM_POWER_CONDITION
{
    PoAc=0,
    PoDc=1,
    PoHot=2,
    PoConditionMaximum=3
};

enum POWER_PLATFORM_ROLE
{
    PlatformRoleUnspecified=0,
    PlatformRoleDesktop=1,
    PlatformRoleMobile=2,
    PlatformRoleWorkstation=3,
    PlatformRoleEnterpriseServer=4,
    PlatformRoleSOHOServer=5,
    PlatformRoleAppliancePC=6,
    PlatformRolePerformanceServer=7,
    PlatformRoleMaximum=8
};

enum SYSNLS_FUNCTION
{
    COMPARE_STRING=1
};

enum SYSGEOTYPE
{
    GEO_NATION=1,
    GEO_LATITUDE=2,
    GEO_LONGITUDE=3,
    GEO_ISO2=4,
    GEO_ISO3=5,
    GEO_RFC1766=6,
    GEO_LCID=7,
    GEO_FRIENDLYNAME=8,
    GEO_OFFICIALNAME=9,
    GEO_TIMEZONES=10,
    GEO_OFFICIALLANGUAGES=11
};

enum SYSGEOCLASS
{
    GEOCLASS_NATION=16,
    GEOCLASS_REGION=14
};

enum _NORM_FORM
{
    NormalizationOther=0,
    NormalizationC=1,
    NormalizationD=2,
    NormalizationKC=5,
    NormalizationKD=6
};

enum _FILE_INFO_BY_HANDLE_CLASS
{
    FileBasicInfo=0,
    FileStandardInfo=1,
    FileNameInfo=2,
    FileRenameInfo=3,
    FileDispositionInfo=4,
    FileAllocationInfo=5,
    FileEndOfFileInfo=6,
    FileStreamInfo=7,
    FileCompressionInfo=8,
    FileAttributeTagInfo=9,
    FileIdBothDirectoryInfo=10,
    FileIdBothDirectoryRestartInfo=11,
    FileIoPriorityHintInfo=12,
    FileRemoteProtocolInfo=13,
    MaximumFileInfoByHandleClass=14
};

enum _MEMORY_RESOURCE_NOTIFICATION_TYPE
{
    LowMemoryResourceNotification=0,
    HighMemoryResourceNotification=1
};

enum _PROC_THREAD_ATTRIBUTE_NUM
{
    ProcThreadAttributeParentProcess=0,
    ProcThreadAttributeExtendedFlags=1,
    ProcThreadAttributeHandleList=2,
    ProcThreadAttributeGroupAffinity=3,
    ProcThreadAttributePreferredNode=4,
    ProcThreadAttributeIdealProcessor=5,
    ProcThreadAttributeUmsThread=6,
    ProcThreadAttributeMitigationPolicy=7,
    ProcThreadAttributeMax=8
};

enum _PRIORITY_HINT
{
    IoPriorityHintVeryLow=0,
    IoPriorityHintLow=1,
    IoPriorityHintNormal=2,
    MaximumIoPriorityHintType=3
};

enum _FILE_ID_TYPE
{
    FileIdType=0,
    ObjectIdType=1,
    MaximumFileIdType=2
};

enum _GET_FILEEX_INFO_LEVELS
{
    GetFileExInfoStandard=0,
    GetFileExMaxInfoLevel=1
};

enum _FINDEX_INFO_LEVELS
{
    FindExInfoStandard=0,
    FindExInfoBasic=1,
    FindExInfoMaxInfoLevel=2
};

enum _FINDEX_SEARCH_OPS
{
    FindExSearchNameMatch=0,
    FindExSearchLimitToDirectories=1,
    FindExSearchLimitToDevices=2,
    FindExSearchMaxSearchOp=3
};

enum _EXCEPTION_DISPOSITION
{
    ExceptionContinueExecution=0,
    ExceptionContinueSearch=1,
    ExceptionNestedException=2,
    ExceptionCollidedUnwind=3
};

enum _STREAM_INFO_LEVELS
{
    FindStreamInfoStandard=0,
    FindStreamInfoMaxInfoLevel=1
};

enum IMAGE_AUX_SYMBOL_TYPE
{
    IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF=1
};

enum PIPE_ATTRIBUTE_TYPE
{
    PipeAttribute=0,
    PipeConnectionAttribute=1,
    PipeHandleAttribute=2
};

enum std::float_denorm_style
{
    denorm_indeterminate=-1,
    denorm_absent=0,
    denorm_present=1
};

enum std::float_round_style
{
    round_indeterminate=-1,
    round_toward_zero=0,
    round_to_nearest=1,
    round_toward_infinity=2,
    round_toward_neg_infinity=3
};

enum _COMPUTER_NAME_FORMAT
{
    ComputerNameNetBIOS=0,
    ComputerNameDnsHostname=1,
    ComputerNameDnsDomain=2,
    ComputerNameDnsFullyQualified=3,
    ComputerNamePhysicalNetBIOS=4,
    ComputerNamePhysicalDnsHostname=5,
    ComputerNamePhysicalDnsDomain=6,
    ComputerNamePhysicalDnsFullyQualified=7,
    ComputerNameMax=8
};

enum IMPORT_OBJECT_TYPE
{
    IMPORT_OBJECT_CODE=0,
    IMPORT_OBJECT_DATA=1,
    IMPORT_OBJECT_CONST=2
};

enum IMPORT_OBJECT_NAME_TYPE
{
    IMPORT_OBJECT_ORDINAL=0,
    IMPORT_OBJECT_NAME=1,
    IMPORT_OBJECT_NAME_NO_PREFIX=2,
    IMPORT_OBJECT_NAME_UNDECORATE=3
};

enum _RTL_UMS_THREAD_INFO_CLASS
{
    UmsThreadInvalidInfoClass=0,
    UmsThreadUserContext=1,
    UmsThreadPriority=2,
    UmsThreadAffinity=3,
    UmsThreadTeb=4,
    UmsThreadIsSuspended=5,
    UmsThreadIsTerminated=6,
    UmsThreadMaxInfoClass=7
};

enum _RTL_UMS_SCHEDULER_REASON
{
    UmsSchedulerStartup=0,
    UmsSchedulerThreadBlocked=1,
    UmsSchedulerThreadYield=2
};

enum _HEAP_INFORMATION_CLASS
{
    HeapCompatibilityInformation=0,
    HeapEnableTerminationOnCorruption=1
};

enum _ACTIVATION_CONTEXT_INFO_CLASS
{
    ActivationContextBasicInformation=1,
    ActivationContextDetailedInformation=2,
    AssemblyDetailedInformationInActivationContext=3,
    FileInformationInAssemblyOfAssemblyInActivationContext=4,
    RunlevelInformationInActivationContext=5,
    CompatibilityInformationInActivationContext=6,
    ActivationContextManifestResourceName=7,
    MaxActivationContextInfoClass=8,
    AssemblyDetailedInformationInActivationContxt=3,
    FileInformationInAssemblyOfAssemblyInActivationContxt=4
};

enum DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY
{
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER=-1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15=0,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO=1,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO=2,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO=3,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI=4,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI=5,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS=6,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN=8,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI=9,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL=10,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED=11,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL=12,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED=13,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE=14,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL=-2147483648,
    DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32=-1
};

enum DISPLAYCONFIG_SCALING
{
    DISPLAYCONFIG_SCALING_IDENTITY=1,
    DISPLAYCONFIG_SCALING_CENTERED=2,
    DISPLAYCONFIG_SCALING_STRETCHED=3,
    DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX=4,
    DISPLAYCONFIG_SCALING_CUSTOM=5,
    DISPLAYCONFIG_SCALING_PREFERRED=128,
    DISPLAYCONFIG_SCALING_FORCE_UINT32=-1
};

enum DISPLAYCONFIG_ROTATION
{
    DISPLAYCONFIG_ROTATION_IDENTITY=1,
    DISPLAYCONFIG_ROTATION_ROTATE90=2,
    DISPLAYCONFIG_ROTATION_ROTATE180=3,
    DISPLAYCONFIG_ROTATION_ROTATE270=4,
    DISPLAYCONFIG_ROTATION_FORCE_UINT32=-1
};

enum DISPLAYCONFIG_MODE_INFO_TYPE
{
    DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE=1,
    DISPLAYCONFIG_MODE_INFO_TYPE_TARGET=2,
    DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32=-1
};

enum ACTCTX_REQUESTED_RUN_LEVEL
{
    ACTCTX_RUN_LEVEL_UNSPECIFIED=0,
    ACTCTX_RUN_LEVEL_AS_INVOKER=1,
    ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE=2,
    ACTCTX_RUN_LEVEL_REQUIRE_ADMIN=3,
    ACTCTX_RUN_LEVEL_NUMBERS=4
};

enum DISPLAYCONFIG_PIXELFORMAT
{
    DISPLAYCONFIG_PIXELFORMAT_8BPP=1,
    DISPLAYCONFIG_PIXELFORMAT_16BPP=2,
    DISPLAYCONFIG_PIXELFORMAT_24BPP=3,
    DISPLAYCONFIG_PIXELFORMAT_32BPP=4,
    DISPLAYCONFIG_PIXELFORMAT_NONGDI=5,
    DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32=-1
};

enum _SC_ACTION_TYPE
{
    SC_ACTION_NONE=0,
    SC_ACTION_RESTART=1,
    SC_ACTION_REBOOT=2,
    SC_ACTION_RUN_COMMAND=3
};

enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE
{
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN=0,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS=1,
    ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION=2
};

enum DISPLAYCONFIG_TOPOLOGY_ID
{
    DISPLAYCONFIG_TOPOLOGY_INTERNAL=1,
    DISPLAYCONFIG_TOPOLOGY_CLONE=2,
    DISPLAYCONFIG_TOPOLOGY_EXTEND=4,
    DISPLAYCONFIG_TOPOLOGY_EXTERNAL=8,
    DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32=-1
};

enum DISPLAYCONFIG_DEVICE_INFO_TYPE
{
    DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME=1,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME=2,
    DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE=3,
    DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME=4,
    DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE=5,
    DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32=-1
};

enum _SC_STATUS_TYPE
{
    SC_STATUS_PROCESS_INFO=0
};

enum _SC_ENUM_TYPE
{
    SC_ENUM_PROCESS_INFO=0
};

enum _CM_SERVICE_NODE_TYPE
{
    DriverType=1,
    FileSystemType=2,
    Win32ServiceOwnProcess=16,
    Win32ServiceShareProcess=32,
    AdapterType=4,
    RecognizerType=8
};

enum _CM_SERVICE_LOAD_TYPE
{
    BootLoad=0,
    SystemLoad=1,
    AutoLoad=2,
    DemandLoad=3,
    DisableLoad=4
};

enum _CM_ERROR_CONTROL_TYPE
{
    IgnoreError=0,
    NormalError=1,
    SevereError=2,
    CriticalError=3
};

enum _TAPE_DRIVE_PROBLEM_TYPE
{
    TapeDriveProblemNone=0,
    TapeDriveReadWriteWarning=1,
    TapeDriveReadWriteError=2,
    TapeDriveReadWarning=3,
    TapeDriveWriteWarning=4,
    TapeDriveReadError=5,
    TapeDriveWriteError=6,
    TapeDriveHardwareError=7,
    TapeDriveUnsupportedMedia=8,
    TapeDriveScsiConnectionError=9,
    TapeDriveTimetoClean=10,
    TapeDriveCleanDriveNow=11,
    TapeDriveMediaLifeExpired=12,
    TapeDriveSnappedTape=13
};

enum _TRANSACTION_OUTCOME
{
    TransactionOutcomeUndetermined=1,
    TransactionOutcomeCommitted=2,
    TransactionOutcomeAborted=3
};

enum _TRANSACTION_STATE
{
    TransactionStateNormal=1,
    TransactionStateIndoubt=2,
    TransactionStateCommittedNotify=3
};

enum _TRANSACTION_INFORMATION_CLASS
{
    TransactionBasicInformation=0,
    TransactionPropertiesInformation=1,
    TransactionEnlistmentInformation=2,
    TransactionSuperiorEnlistmentInformation=3,
    TransactionBindInformation=4,
    TransactionDTCPrivateInformation=5
};

enum _TRANSACTIONMANAGER_INFORMATION_CLASS
{
    TransactionManagerBasicInformation=0,
    TransactionManagerLogInformation=1,
    TransactionManagerLogPathInformation=2,
    TransactionManagerRecoveryInformation=4,
    TransactionManagerOnlineProbeInformation=3,
    TransactionManagerOldestTransactionInformation=5
};

enum _RESOURCEMANAGER_INFORMATION_CLASS
{
    ResourceManagerBasicInformation=0,
    ResourceManagerCompletionInformation=1
};

enum _ENLISTMENT_INFORMATION_CLASS
{
    EnlistmentBasicInformation=0,
    EnlistmentRecoveryInformation=1,
    EnlistmentCrmInformation=2
};

enum _KTMOBJECT_TYPE
{
    KTMOBJECT_TRANSACTION=0,
    KTMOBJECT_TRANSACTION_MANAGER=1,
    KTMOBJECT_RESOURCE_MANAGER=2,
    KTMOBJECT_ENLISTMENT=3,
    KTMOBJECT_INVALID=4
};

enum std::_Codecvt_mode
{
    _Consume_header=4,
    _Generate_header=2
};

enum EUtf8
{
    Utf8_Len2Start=192,
    Utf8_Len2End=223,
    Utf8_Len3Start=224,
    Utf8_Len3End=239,
    Utf8_Len4Start=240,
    Utf8_Len4End=247,
    Utf8_Len2Mask=31,
    Utf8_Len3Mask=15,
    Utf8_Len4Mask=7,
    Utf8_TailStart=128,
    Utf8_TailMask=63,
    Utf8_TailEnd=191
};

enum EUtf16
{
    Utf16_HighSurrogateStart=55296,
    Utf16_HighSurrogateEnd=56319,
    Utf16_LowSurrogateStart=56320,
    Utf16_LowSurrogateEnd=57343,
    Utf16_SurrogateMask=1023
};

enum _SID_NAME_USE
{
    SidTypeUser=1,
    SidTypeGroup=2,
    SidTypeDomain=3,
    SidTypeAlias=4,
    SidTypeWellKnownGroup=5,
    SidTypeDeletedAccount=6,
    SidTypeInvalid=7,
    SidTypeUnknown=8,
    SidTypeComputer=9,
    SidTypeLabel=10
};

enum WELL_KNOWN_SID_TYPE
{
    WinNullSid=0,
    WinWorldSid=1,
    WinLocalSid=2,
    WinCreatorOwnerSid=3,
    WinCreatorGroupSid=4,
    WinCreatorOwnerServerSid=5,
    WinCreatorGroupServerSid=6,
    WinNtAuthoritySid=7,
    WinDialupSid=8,
    WinNetworkSid=9,
    WinBatchSid=10,
    WinInteractiveSid=11,
    WinServiceSid=12,
    WinAnonymousSid=13,
    WinProxySid=14,
    WinEnterpriseControllersSid=15,
    WinSelfSid=16,
    WinAuthenticatedUserSid=17,
    WinRestrictedCodeSid=18,
    WinTerminalServerSid=19,
    WinRemoteLogonIdSid=20,
    WinLogonIdsSid=21,
    WinLocalSystemSid=22,
    WinLocalServiceSid=23,
    WinNetworkServiceSid=24,
    WinBuiltinDomainSid=25,
    WinBuiltinAdministratorsSid=26,
    WinBuiltinUsersSid=27,
    WinBuiltinGuestsSid=28,
    WinBuiltinPowerUsersSid=29,
    WinBuiltinAccountOperatorsSid=30,
    WinBuiltinSystemOperatorsSid=31,
    WinBuiltinPrintOperatorsSid=32,
    WinBuiltinBackupOperatorsSid=33,
    WinBuiltinReplicatorSid=34,
    WinBuiltinPreWindows2000CompatibleAccessSid=35,
    WinBuiltinRemoteDesktopUsersSid=36,
    WinBuiltinNetworkConfigurationOperatorsSid=37,
    WinAccountAdministratorSid=38,
    WinAccountGuestSid=39,
    WinAccountKrbtgtSid=40,
    WinAccountDomainAdminsSid=41,
    WinAccountDomainUsersSid=42,
    WinAccountDomainGuestsSid=43,
    WinAccountComputersSid=44,
    WinAccountControllersSid=45,
    WinAccountCertAdminsSid=46,
    WinAccountSchemaAdminsSid=47,
    WinAccountEnterpriseAdminsSid=48,
    WinAccountPolicyAdminsSid=49,
    WinAccountRasAndIasServersSid=50,
    WinNTLMAuthenticationSid=51,
    WinDigestAuthenticationSid=52,
    WinSChannelAuthenticationSid=53,
    WinThisOrganizationSid=54,
    WinOtherOrganizationSid=55,
    WinBuiltinIncomingForestTrustBuildersSid=56,
    WinBuiltinPerfMonitoringUsersSid=57,
    WinBuiltinPerfLoggingUsersSid=58,
    WinBuiltinAuthorizationAccessSid=59,
    WinBuiltinTerminalServerLicenseServersSid=60,
    WinBuiltinDCOMUsersSid=61,
    WinBuiltinIUsersSid=62,
    WinIUserSid=63,
    WinBuiltinCryptoOperatorsSid=64,
    WinUntrustedLabelSid=65,
    WinLowLabelSid=66,
    WinMediumLabelSid=67,
    WinHighLabelSid=68,
    WinSystemLabelSid=69,
    WinWriteRestrictedCodeSid=70,
    WinCreatorOwnerRightsSid=71,
    WinCacheablePrincipalsGroupSid=72,
    WinNonCacheablePrincipalsGroupSid=73,
    WinEnterpriseReadonlyControllersSid=74,
    WinAccountReadonlyControllersSid=75,
    WinBuiltinEventLogReadersGroup=76,
    WinNewEnterpriseReadonlyControllersSid=77,
    WinBuiltinCertSvcDComAccessGroup=78,
    WinMediumPlusLabelSid=79,
    WinLocalLogonSid=80,
    WinConsoleLogonSid=81,
    WinThisOrganizationCertificateSid=82
};

struct _ACTIVATION_CONTEXT_QUERY_INDEX
{
    unsigned long ulAssemblyIndex;
    unsigned long ulFileIndexInAssembly;
};

struct tagMENUITEMINFOA
{
    unsigned int cbSize;
    unsigned int fMask;
    unsigned int fType;
    unsigned int fState;
    unsigned int wID;
    struct HMENU__ * hSubMenu;
    struct HBITMAP__ * hbmpChecked;
    struct HBITMAP__ * hbmpUnchecked;
    unsigned long dwItemData;
    char * dwTypeData;
    unsigned int cch;
    struct HBITMAP__ * hbmpItem;
};

struct tagALTTABINFO
{
    unsigned long cbSize;
    int cItems;
    int cColumns;
    int cRows;
    int iColFocus;
    int iRowFocus;
    int cxItem;
    int cyItem;
    struct tagPOINT ptStart;
};

struct _ENUM_SERVICE_STATUSW
{
    wchar_t * lpServiceName;
    wchar_t * lpDisplayName;
    struct _SERVICE_STATUS ServiceStatus;
};

struct _HARDWARE_COUNTER_DATA
{
    enum _HARDWARE_COUNTER_TYPE Type;
    unsigned long Reserved;
    unsigned int Value;
};

struct ANON_OBJECT_HEADER_BIGOBJ
{
    unsigned int Sig1;
    unsigned int Sig2;
    unsigned int Version;
    unsigned int Machine;
    unsigned long TimeDateStamp;
    struct _GUID ClassID;
    unsigned long SizeOfData;
    unsigned long Flags;
    unsigned long MetaDataSize;
    unsigned long MetaDataOffset;
    unsigned long NumberOfSections;
    unsigned long PointerToSymbolTable;
    unsigned long NumberOfSymbols;
};

struct DLGTEMPLATE
{
    unsigned long style;
    unsigned long dwExtendedStyle;
    unsigned int cdit;
    int x;
    int y;
    int cx;
    int cy;
};

struct tagWCRANGE
{
    wchar_t wcLow;
    unsigned int cGlyphs;
};

struct tagMOUSEMOVEPOINT
{
    int x;
    int y;
    unsigned long time;
    unsigned long dwExtraInfo;
};

struct _QUOTA_LIMITS
{
    unsigned long PagedPoolLimit;
    unsigned long NonPagedPoolLimit;
    unsigned long MinimumWorkingSetSize;
    unsigned long MaximumWorkingSetSize;
    unsigned long PagefileLimit;
    union _LARGE_INTEGER TimeLimit;
};

struct tagDESIGNVECTOR
{
    unsigned long dvReserved;
    unsigned long dvNumAxes;
    long dvValues[16];
};

struct DISPLAYCONFIG_RATIONAL
{
    unsigned int Numerator;
    unsigned int Denominator;
};

struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
{
    unsigned long ElementCount;
    struct _COMPATIBILITY_CONTEXT_ELEMENT Elements[0];
};

struct tagMETAHEADER
{
    unsigned int mtType;
    unsigned int mtHeaderSize;
    unsigned int mtVersion;
    unsigned long mtSize;
    unsigned int mtNoObjects;
    unsigned long mtMaxRecord;
    unsigned int mtNoParameters;
};

struct _TRIVERTEX
{
    long x;
    long y;
    unsigned int Red;
    unsigned int Green;
    unsigned int Blue;
    unsigned int Alpha;
};

struct tagMENUBARINFO
{
    unsigned long cbSize;
    struct tagRECT rcBar;
    struct HMENU__ * hMenu;
    struct HWND__ * hwndMenu;
    int fBarFocused:1;
    int fFocused:1;
};

struct _PROCESS_INFORMATION
{
    void * hProcess;
    void * hThread;
    unsigned long dwProcessId;
    unsigned long dwThreadId;
};

struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION
{
    struct _JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
    struct _IO_COUNTERS IoInfo;
    unsigned long ProcessMemoryLimit;
    unsigned long JobMemoryLimit;
    unsigned long PeakProcessMemoryUsed;
    unsigned long PeakJobMemoryUsed;
};

struct PPM_WMI_LEGACY_PERFSTATE
{
    unsigned long Frequency;
    unsigned long Flags;
    unsigned long PercentFrequency;
};

struct _OSVERSIONINFOA
{
    unsigned long dwOSVersionInfoSize;
    unsigned long dwMajorVersion;
    unsigned long dwMinorVersion;
    unsigned long dwBuildNumber;
    unsigned long dwPlatformId;
    char szCSDVersion[128];
};

struct _PROC_THREAD_ATTRIBUTE_LIST
{
};

struct _TP_WAIT
{
};

struct _IMAGE_OS2_HEADER
{
    unsigned int ne_magic;
    char ne_ver;
    char ne_rev;
    unsigned int ne_enttab;
    unsigned int ne_cbenttab;
    long ne_crc;
    unsigned int ne_flags;
    unsigned int ne_autodata;
    unsigned int ne_heap;
    unsigned int ne_stack;
    long ne_csip;
    long ne_sssp;
    unsigned int ne_cseg;
    unsigned int ne_cmod;
    unsigned int ne_cbnrestab;
    unsigned int ne_segtab;
    unsigned int ne_rsrctab;
    unsigned int ne_restab;
    unsigned int ne_modtab;
    unsigned int ne_imptab;
    long ne_nrestab;
    unsigned int ne_cmovent;
    unsigned int ne_align;
    unsigned int ne_cres;
    unsigned int ne_exetyp;
    unsigned int ne_flagsothers;
    unsigned int ne_pretthunks;
    unsigned int ne_psegrefbytes;
    unsigned int ne_swaparea;
    unsigned int ne_expver;
};

struct tagEMRFILLPATH
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
};

struct PPM_WMI_IDLE_STATES
{
    unsigned long Type;
    unsigned long Count;
    unsigned long TargetState;
    unsigned long OldState;
    unsigned int TargetProcessors;
    struct PPM_WMI_IDLE_STATE State[1];
};

struct tagICONMETRICSW
{
    unsigned int cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    struct tagLOGFONTW lfFont;
};

struct tagMCI_RECORD_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrom;
    unsigned long dwTo;
};

struct tagMIXERLINECONTROLSA
{
    unsigned long cbStruct;
    unsigned long dwLineID;
    unsigned long dwControlID;
    unsigned long dwControlType;
    unsigned long cControls;
    unsigned long cbmxctrl;
    struct tagMIXERCONTROLA * pamxctrl;
};

struct _OUTLINETEXTMETRICA
{
    unsigned int otmSize;
    struct tagTEXTMETRICA otmTextMetrics;
    unsigned int otmFiller;
    struct tagPANOSE otmPanoseNumber;
    unsigned int otmfsSelection;
    unsigned int otmfsType;
    int otmsCharSlopeRise;
    int otmsCharSlopeRun;
    int otmItalicAngle;
    unsigned int otmEMSquare;
    int otmAscent;
    int otmDescent;
    unsigned int otmLineGap;
    unsigned int otmsCapEmHeight;
    unsigned int otmsXHeight;
    struct tagRECT otmrcFontBox;
    int otmMacAscent;
    int otmMacDescent;
    unsigned int otmMacLineGap;
    unsigned int otmusMinimumPPEM;
    struct tagPOINT otmptSubscriptSize;
    struct tagPOINT otmptSubscriptOffset;
    struct tagPOINT otmptSuperscriptSize;
    struct tagPOINT otmptSuperscriptOffset;
    unsigned int otmsStrikeoutSize;
    int otmsStrikeoutPosition;
    int otmsUnderscoreSize;
    int otmsUnderscorePosition;
    char * otmpFamilyName;
    char * otmpFaceName;
    char * otmpStyleName;
    char * otmpFullName;
};

struct _TAPE_WRITE_MARKS
{
    unsigned long Type;
    unsigned long Count;
    unsigned int Immediate;
};

struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
{
    unsigned long BeginAddress;
    unsigned long EndAddress;
    unsigned long ExceptionHandler;
    unsigned long HandlerData;
    unsigned long PrologEndAddress;
};

struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA
{
    unsigned long dwReason;
    char * pszComment;
    struct _SERVICE_STATUS_PROCESS ServiceStatus;
};

struct _cpinfoexA
{
    unsigned int MaxCharSize;
    unsigned int DefaultChar[2];
    unsigned int LeadByte[12];
    wchar_t UnicodeDefaultChar;
    unsigned int CodePage;
    char CodePageName[260];
};

struct tagMIDIOUTCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned int wTechnology;
    unsigned int wVoices;
    unsigned int wNotes;
    unsigned int wChannelMask;
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct tagSTYLEBUFA
{
    unsigned long dwStyle;
    char szDescription[32];
};

struct _s__RTTIClassHierarchyDescriptor
{
    unsigned long signature;
    unsigned long attributes;
    unsigned long numBaseClasses;
    struct _s__RTTIBaseClassArray * pBaseClassArray;
};

struct _s__RTTIBaseClassDescriptor
{
    struct _TypeDescriptor * pTypeDescriptor;
    unsigned long numContainedBases;
    struct _PMD where;
    unsigned long attributes;
    struct _s__RTTIClassHierarchyDescriptor * pClassDescriptor;
};

struct _OBJECT_TYPE_LIST
{
    unsigned int Level;
    unsigned int Sbz;
    struct _GUID * ObjectType;
};

struct tagTITLEBARINFO
{
    unsigned long cbSize;
    struct tagRECT rcTitleBar;
    unsigned long rgstate[6];
};

struct _SECURITY_DESCRIPTOR
{
    unsigned int Revision;
    unsigned int Sbz1;
    unsigned int Control;
    void * Owner;
    void * Group;
    struct _ACL * Sacl;
    struct _ACL * Dacl;
};

struct _KTMOBJECT_CURSOR
{
    struct _GUID LastQuery;
    unsigned long ObjectIdCount;
    struct _GUID ObjectIds[1];
};

struct _CONSOLE_CURSOR_INFO
{
    unsigned long dwSize;
    int bVisible;
};

struct tagHW_PROFILE_INFOA
{
    unsigned long dwDockInfo;
    char szHwProfileGuid[39];
    char szHwProfileName[80];
};

struct _SYSTEMTIME
{
    unsigned int wYear;
    unsigned int wMonth;
    unsigned int wDayOfWeek;
    unsigned int wDay;
    unsigned int wHour;
    unsigned int wMinute;
    unsigned int wSecond;
    unsigned int wMilliseconds;
};

struct _RTL_CRITICAL_SECTION_DEBUG
{
    unsigned int Type;
    unsigned int CreatorBackTraceIndex;
    struct _RTL_CRITICAL_SECTION * CriticalSection;
    struct _LIST_ENTRY ProcessLocksList;
    unsigned long EntryCount;
    unsigned long ContentionCount;
    unsigned long Flags;
    unsigned int CreatorBackTraceIndexHigh;
    unsigned int SpareWORD;
};

struct _WIN32_FIND_DATAA
{
    unsigned long dwFileAttributes;
    struct _FILETIME ftCreationTime;
    struct _FILETIME ftLastAccessTime;
    struct _FILETIME ftLastWriteTime;
    unsigned long nFileSizeHigh;
    unsigned long nFileSizeLow;
    unsigned long dwReserved0;
    unsigned long dwReserved1;
    char cFileName[260];
    char cAlternateFileName[14];
};

struct tagMCI_INFO_PARMSA
{
    unsigned long dwCallback;
    char * lpstrReturn;
    unsigned long dwRetSize;
};

struct _TAPE_CREATE_PARTITION
{
    unsigned long Method;
    unsigned long Count;
    unsigned long Size;
};

struct $_TypeDescriptor$_extraBytes_24
{
    void * pVFTable;
    void * spare;
    char name[24];
};

struct tagACTCTXA
{
    unsigned long cbSize;
    unsigned long dwFlags;
    char * lpSource;
    unsigned int wProcessorArchitecture;
    unsigned int wLangId;
    char * lpAssemblyDirectory;
    char * lpResourceName;
    char * lpApplicationName;
    struct HINSTANCE__ * hModule;
};

struct tagEMRPOLYLINE16
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cpts;
    struct tagPOINTS apts[1];
};

struct _ADMINISTRATOR_POWER_POLICY
{
    enum _SYSTEM_POWER_STATE MinSleep;
    enum _SYSTEM_POWER_STATE MaxSleep;
    unsigned long MinVideoTimeout;
    unsigned long MaxVideoTimeout;
    unsigned long MinSpindownTimeout;
    unsigned long MaxSpindownTimeout;
};

struct _COMMTIMEOUTS
{
    unsigned long ReadIntervalTimeout;
    unsigned long ReadTotalTimeoutMultiplier;
    unsigned long ReadTotalTimeoutConstant;
    unsigned long WriteTotalTimeoutMultiplier;
    unsigned long WriteTotalTimeoutConstant;
};

struct _STARTUPINFOEXA
{
    struct _STARTUPINFOA StartupInfo;
    struct _PROC_THREAD_ATTRIBUTE_LIST * lpAttributeList;
};

struct HPALETTE__
{
    int unused;
};

struct value_entW
{
    wchar_t * ve_valuename;
    unsigned long ve_valuelen;
    unsigned long ve_valueptr;
    unsigned long ve_type;
};

struct PPM_THERMAL_POLICY_EVENT
{
    unsigned int Mode;
    unsigned int Processors;
};

union _IMAGE_AUX_SYMBOL_EX
{
    struct <unnamed-type-Sym>
    {
        unsigned long WeakDefaultSymIndex;
        unsigned long WeakSearchType;
        unsigned int rgbReserved[12];
    };
    struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-Sym> Sym;
    struct <unnamed-type-File>
    {
        unsigned int Name[20];
    };
    struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-File> File;
    struct <unnamed-type-Section>
    {
        unsigned long Length;
        unsigned int NumberOfRelocations;
        unsigned int NumberOfLinenumbers;
        unsigned long CheckSum;
        int Number;
        unsigned int Selection;
        unsigned int bReserved;
        int HighNumber;
        unsigned int rgbReserved[2];
    };
    struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-Section> Section;
    struct IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    unsigned int rgbReserved[2];
    struct <unnamed-type-CRC>
    {
        unsigned long crc;
        unsigned int rgbReserved[16];
    };
    struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-CRC> CRC;
};

struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-CRC>
{
    unsigned long crc;
    unsigned int rgbReserved[16];
};

struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-Section>
{
    unsigned long Length;
    unsigned int NumberOfRelocations;
    unsigned int NumberOfLinenumbers;
    unsigned long CheckSum;
    int Number;
    unsigned int Selection;
    unsigned int bReserved;
    int HighNumber;
    unsigned int rgbReserved[2];
};

struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-File>
{
    unsigned int Name[20];
};

struct _IMAGE_AUX_SYMBOL_EX::<unnamed-type-Sym>
{
    unsigned long WeakDefaultSymIndex;
    unsigned long WeakSearchType;
    unsigned int rgbReserved[12];
};

struct _REPARSE_GUID_DATA_BUFFER
{
    unsigned long ReparseTag;
    unsigned int ReparseDataLength;
    unsigned int Reserved;
    struct _GUID ReparseGuid;
    struct <unnamed-type-GenericReparseBuffer>
    {
        unsigned int DataBuffer[1];
    };
    struct _REPARSE_GUID_DATA_BUFFER::<unnamed-type-GenericReparseBuffer> GenericReparseBuffer;
};

struct tagMIDIOUTCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned int wTechnology;
    unsigned int wVoices;
    unsigned int wNotes;
    unsigned int wChannelMask;
    unsigned long dwSupport;
};

struct tagACTCTX_SECTION_KEYED_DATA
{
    unsigned long cbSize;
    unsigned long ulDataFormatVersion;
    void * lpData;
    unsigned long ulLength;
    void * lpSectionGlobalData;
    unsigned long ulSectionGlobalDataLength;
    void * lpSectionBase;
    unsigned long ulSectionTotalLength;
    void * hActCtx;
    unsigned long ulAssemblyRosterIndex;
    unsigned long ulFlags;
    struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
};

struct tWAVEFORMATEX
{
    unsigned int wFormatTag;
    unsigned int nChannels;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
    unsigned int wBitsPerSample;
    unsigned int cbSize;
};

struct joyinfo_tag
{
    unsigned int wXpos;
    unsigned int wYpos;
    unsigned int wZpos;
    unsigned int wButtons;
};

struct tagMDINEXTMENU
{
    struct HMENU__ * hmenuIn;
    struct HMENU__ * hmenuNext;
    struct HWND__ * hwndNext;
};

struct tagACTCTXW
{
    unsigned long cbSize;
    unsigned long dwFlags;
    wchar_t * lpSource;
    unsigned int wProcessorArchitecture;
    unsigned int wLangId;
    wchar_t * lpAssemblyDirectory;
    wchar_t * lpResourceName;
    wchar_t * lpApplicationName;
    struct HINSTANCE__ * hModule;
};

struct _OFSTRUCT
{
    unsigned int cBytes;
    unsigned int fFixedDisk;
    unsigned int nErrCode;
    unsigned int Reserved1;
    unsigned int Reserved2;
    char szPathName[128];
};

struct _OVERLAPPED_ENTRY
{
    unsigned long lpCompletionKey;
    struct _OVERLAPPED * lpOverlapped;
    unsigned long Internal;
    unsigned long dwNumberOfBytesTransferred;
};

struct tagHELPWININFOW
{
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    wchar_t rgchMember[2];
};

struct _ACTIVATION_CONTEXT_QUERY_INDEX
{
    unsigned long ulAssemblyIndex;
    unsigned long ulFileIndexInAssembly;
};

struct $_TypeDescriptor$_extraBytes_5
{
    void * pVFTable;
    void * spare;
    char name[5];
};

struct tagEMRTRANSPARENTBLT
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long cxDest;
    long cyDest;
    unsigned long dwRop;
    long xSrc;
    long ySrc;
    struct tagXFORM xformSrc;
    unsigned long crBkColorSrc;
    unsigned long iUsageSrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    long cxSrc;
    long cySrc;
};

struct __vcrt_assert_va_start_is_not_reference<__crt_locale_pointers * const>
{
};

struct tagMEASUREITEMSTRUCT
{
    unsigned int CtlType;
    unsigned int CtlID;
    unsigned int itemID;
    unsigned int itemWidth;
    unsigned int itemHeight;
    unsigned long itemData;
};

struct _SUPPORTED_OS_INFO
{
    unsigned int OsCount;
    unsigned int MitigationExist;
    unsigned int OsList[4];
};

struct tagENUMLOGFONTW
{
    struct tagLOGFONTW elfLogFont;
    wchar_t elfFullName[64];
    wchar_t elfStyle[32];
};

struct tagMIDIOUTCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned int wTechnology;
    unsigned int wVoices;
    unsigned int wNotes;
    unsigned int wChannelMask;
    unsigned long dwSupport;
};

struct tagLOCALESIGNATURE
{
    unsigned long lsUsb[4];
    unsigned long lsCsbDefault[2];
    unsigned long lsCsbSupported[2];
};

struct tagMINMAXINFO
{
    struct tagPOINT ptReserved;
    struct tagPOINT ptMaxSize;
    struct tagPOINT ptMaxPosition;
    struct tagPOINT ptMinTrackSize;
    struct tagPOINT ptMaxTrackSize;
};

struct tagIMEMENUITEMINFOA
{
    unsigned int cbSize;
    unsigned int fType;
    unsigned int fState;
    unsigned int wID;
    struct HBITMAP__ * hbmpChecked;
    struct HBITMAP__ * hbmpUnchecked;
    unsigned long dwItemData;
    char szString[80];
    struct HBITMAP__ * hbmpItem;
};

struct midistrmbuffver_tag
{
    unsigned long dwVersion;
    unsigned long dwMid;
    unsigned long dwOEMVersion;
};

struct tagEMRFILLRGN
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cbRgnData;
    unsigned long ihBrush;
    unsigned int RgnData[1];
};

struct _TAPE_SET_MEDIA_PARAMETERS
{
    unsigned long BlockSize;
};

struct _RTL_CRITICAL_SECTION
{
    struct _RTL_CRITICAL_SECTION_DEBUG * DebugInfo;
    long LockCount;
    long RecursionCount;
    void * OwningThread;
    void * LockSemaphore;
    unsigned long SpinCount;
};

struct _BY_HANDLE_FILE_INFORMATION
{
    unsigned long dwFileAttributes;
    struct _FILETIME ftCreationTime;
    struct _FILETIME ftLastAccessTime;
    struct _FILETIME ftLastWriteTime;
    unsigned long dwVolumeSerialNumber;
    unsigned long nFileSizeHigh;
    unsigned long nFileSizeLow;
    unsigned long nNumberOfLinks;
    unsigned long nFileIndexHigh;
    unsigned long nFileIndexLow;
};

struct _BLENDFUNCTION
{
    unsigned int BlendOp;
    unsigned int BlendFlags;
    unsigned int SourceConstantAlpha;
    unsigned int AlphaFormat;
};

struct tagENHMETAHEADER
{
    unsigned long iType;
    unsigned long nSize;
    struct _RECTL rclBounds;
    struct _RECTL rclFrame;
    unsigned long dSignature;
    unsigned long nVersion;
    unsigned long nBytes;
    unsigned long nRecords;
    unsigned int nHandles;
    unsigned int sReserved;
    unsigned long nDescription;
    unsigned long offDescription;
    unsigned long nPalEntries;
    struct tagSIZE szlDevice;
    struct tagSIZE szlMillimeters;
    unsigned long cbPixelFormat;
    unsigned long offPixelFormat;
    unsigned long bOpenGL;
    struct tagSIZE szlMicrometers;
};

enum __vcrt_va_list_is_reference<char const * const>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<char const * const>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct tagACTCTX_SECTION_KEYED_DATA_2600
{
    unsigned long cbSize;
    unsigned long ulDataFormatVersion;
    void * lpData;
    unsigned long ulLength;
    void * lpSectionGlobalData;
    unsigned long ulSectionGlobalDataLength;
    void * lpSectionBase;
    unsigned long ulSectionTotalLength;
    void * hActCtx;
    unsigned long ulAssemblyRosterIndex;
};

struct waveformat_tag
{
    unsigned int wFormatTag;
    unsigned int nChannels;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
};

struct tagDIBSECTION
{
    struct tagBITMAP dsBm;
    struct tagBITMAPINFOHEADER dsBmih;
    unsigned long dsBitfields[3];
    void * dshSection;
    unsigned long dsOffset;
};

struct tagMONITORINFOEXW : public tagMONITORINFO
{
    wchar_t szDevice[32];
};

struct tagMIXERLINECONTROLSW
{
    unsigned long cbStruct;
    unsigned long dwLineID;
    unsigned long dwControlID;
    unsigned long dwControlType;
    unsigned long cControls;
    unsigned long cbmxctrl;
    struct tagMIXERCONTROLW * pamxctrl;
};

struct _TRANSACTION_BASIC_INFORMATION
{
    struct _GUID TransactionId;
    unsigned long State;
    unsigned long Outcome;
};

struct tagBITMAP
{
    long bmType;
    long bmWidth;
    long bmHeight;
    long bmWidthBytes;
    unsigned int bmPlanes;
    unsigned int bmBitsPixel;
    void * bmBits;
};

struct tagTRACKMOUSEEVENT
{
    unsigned long cbSize;
    unsigned long dwFlags;
    struct HWND__ * hwndTrack;
    unsigned long dwHoverTime;
};

struct _ACL
{
    unsigned int AclRevision;
    unsigned int Sbz1;
    unsigned int AclSize;
    unsigned int AceCount;
    unsigned int Sbz2;
};

struct tagMIDIOUTCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned int wTechnology;
    unsigned int wVoices;
    unsigned int wNotes;
    unsigned int wChannelMask;
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct FLASHWINFO
{
    unsigned int cbSize;
    struct HWND__ * hwnd;
    unsigned long dwFlags;
    unsigned int uCount;
    unsigned long dwTimeout;
};

struct tagAUXCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned int wTechnology;
    unsigned int wReserved1;
    unsigned long dwSupport;
};

struct tagHW_PROFILE_INFOW
{
    unsigned long dwDockInfo;
    wchar_t szHwProfileGuid[39];
    wchar_t szHwProfileName[80];
};

class SStack<int>
{
    private int * array;
    private int size;
    private int maxsize;
    public float userdata;
    public void SStack<int>();
    public void ~SStack<int>();
    public void Push(int );
    public int & Pop();
    public int & GetFirst();
    public int & Peek();
    public void SetData(int * ,int ,int );
    public int GetSize();
    public bool IsEmpty();
    public void * __vecDelDtor(unsigned int );
};

struct _SYSTEM_ALARM_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct tagENUMLOGFONTEXDVW
{
    struct tagENUMLOGFONTEXW elfEnumLogfontEx;
    struct tagDESIGNVECTOR elfDesignVector;
};

struct _ICONINFOEXW
{
    unsigned long cbSize;
    int fIcon;
    unsigned long xHotspot;
    unsigned long yHotspot;
    struct HBITMAP__ * hbmMask;
    struct HBITMAP__ * hbmColor;
    unsigned int wResID;
    wchar_t szModName[260];
    wchar_t szResName[260];
};

struct tagENUMTEXTMETRICW
{
    struct tagNEWTEXTMETRICEXW etmNewTextMetricEx;
    struct tagAXESLISTW etmAxesList;
};

struct tagMENUITEMINFOA
{
    unsigned int cbSize;
    unsigned int fMask;
    unsigned int fType;
    unsigned int fState;
    unsigned int wID;
    struct HMENU__ * hSubMenu;
    struct HBITMAP__ * hbmpChecked;
    struct HBITMAP__ * hbmpUnchecked;
    unsigned long dwItemData;
    char * dwTypeData;
    unsigned int cch;
    struct HBITMAP__ * hbmpItem;
};

struct HDRVR__
{
    int unused;
};

struct tagGESTURENOTIFYSTRUCT
{
    unsigned int cbSize;
    unsigned long dwFlags;
    struct HWND__ * hwndTarget;
    struct tagPOINTS ptsLocation;
    unsigned long dwInstanceID;
};

struct _IMAGE_IMPORT_BY_NAME
{
    unsigned int Hint;
    unsigned int Name[1];
};

struct _NON_PAGED_DEBUG_INFO
{
    unsigned int Signature;
    unsigned int Flags;
    unsigned long Size;
    unsigned int Machine;
    unsigned int Characteristics;
    unsigned long TimeDateStamp;
    unsigned long CheckSum;
    unsigned long SizeOfImage;
    unsigned int ImageBase;
};

struct tagRAWMOUSE
{
    unsigned int usFlags;
    unsigned long ulButtons;
    unsigned int usButtonFlags;
    unsigned int usButtonData;
    unsigned long ulRawButtons;
    long lLastX;
    long lLastY;
    unsigned long ulExtraInformation;
};

struct _Ctypevec
{
    unsigned int _Page;
    int * _Table;
    int _Delfl;
    wchar_t * _LocaleName;
};

struct tagNCCALCSIZE_PARAMS
{
    struct tagRECT rgrc[3];
    struct tagWINDOWPOS * lppos;
};

struct _WIN32_FIND_DATAW
{
    unsigned long dwFileAttributes;
    struct _FILETIME ftCreationTime;
    struct _FILETIME ftLastAccessTime;
    struct _FILETIME ftLastWriteTime;
    unsigned long nFileSizeHigh;
    unsigned long nFileSizeLow;
    unsigned long dwReserved0;
    unsigned long dwReserved1;
    wchar_t cFileName[260];
    wchar_t cAlternateFileName[14];
};

struct _TOKEN_LINKED_TOKEN
{
    void * LinkedToken;
};

struct _TOKEN_PRIVILEGES
{
    unsigned long PrivilegeCount;
    struct _LUID_AND_ATTRIBUTES Privileges[1];
};

struct _POINTFLOAT
{
    float x;
    float y;
};

struct tagDRAWITEMSTRUCT
{
    unsigned int CtlType;
    unsigned int CtlID;
    unsigned int itemID;
    unsigned int itemAction;
    unsigned int itemState;
    struct HWND__ * hwndItem;
    struct HDC__ * hDC;
    struct tagRECT rcItem;
    unsigned long itemData;
};

struct tagMCI_OPEN_PARMSW
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    wchar_t * lpstrDeviceType;
    wchar_t * lpstrElementName;
    wchar_t * lpstrAlias;
};

struct PPM_IDLE_STATE_ACCOUNTING
{
    unsigned long IdleTransitions;
    unsigned long FailedTransitions;
    unsigned long InvalidBucketIndex;
    unsigned int TotalTime;
    unsigned long IdleTimeBuckets[6];
};

struct _RGNDATAHEADER
{
    unsigned long dwSize;
    unsigned long iType;
    unsigned long nCount;
    unsigned long nRgnSize;
    struct tagRECT rcBound;
};

struct _WIN32_FILE_ATTRIBUTE_DATA
{
    unsigned long dwFileAttributes;
    struct _FILETIME ftCreationTime;
    struct _FILETIME ftLastAccessTime;
    struct _FILETIME ftLastWriteTime;
    unsigned long nFileSizeHigh;
    unsigned long nFileSizeLow;
};

struct _TOKEN_CONTROL
{
    struct _LUID TokenId;
    struct _LUID AuthenticationId;
    struct _LUID ModifiedId;
    struct _TOKEN_SOURCE TokenSource;
};

struct _ACCESS_ALLOWED_CALLBACK_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct _TOKEN_PRIMARY_GROUP
{
    void * PrimaryGroup;
};

struct _SYSTEM_POWER_POLICY
{
    unsigned long Revision;
    struct POWER_ACTION_POLICY PowerButton;
    struct POWER_ACTION_POLICY SleepButton;
    struct POWER_ACTION_POLICY LidClose;
    enum _SYSTEM_POWER_STATE LidOpenWake;
    unsigned long Reserved;
    struct POWER_ACTION_POLICY Idle;
    unsigned long IdleTimeout;
    unsigned int IdleSensitivity;
    unsigned int DynamicThrottle;
    unsigned int Spare2[2];
    enum _SYSTEM_POWER_STATE MinSleep;
    enum _SYSTEM_POWER_STATE MaxSleep;
    enum _SYSTEM_POWER_STATE ReducedLatencySleep;
    unsigned long WinLogonFlags;
    unsigned long Spare3;
    unsigned long DozeS4Timeout;
    unsigned long BroadcastCapacityResolution;
    struct SYSTEM_POWER_LEVEL DischargePolicy[4];
    unsigned long VideoTimeout;
    unsigned int VideoDimDisplay;
    unsigned long VideoReserved[3];
    unsigned long SpindownTimeout;
    unsigned int OptimizeForPower;
    unsigned int FanThrottleTolerance;
    unsigned int ForcedThrottle;
    unsigned int MinThrottle;
    struct POWER_ACTION_POLICY OverThrottled;
};

struct tagEMRRESIZEPALETTE
{
    struct tagEMR emr;
    unsigned long ihPal;
    unsigned long cEntries;
};

struct _ACTIVATION_CONTEXT_BASIC_INFORMATION
{
    void * hActCtx;
    unsigned long dwFlags;
};

struct tagCBT_CREATEWNDA
{
    struct tagCREATESTRUCTA * lpcs;
    struct HWND__ * hwndInsertAfter;
};

struct tagMOUSEHOOKSTRUCT
{
    struct tagPOINT pt;
    struct HWND__ * hwnd;
    unsigned int wHitTestCode;
    unsigned long dwExtraInfo;
};

struct _IMAGE_FUNCTION_ENTRY64
{
    unsigned int StartingAddress;
    unsigned int EndingAddress;
    unsigned int EndOfPrologue;
    unsigned int UnwindInfoAddress;
};

struct _KCRM_PROTOCOL_BLOB
{
    struct _GUID ProtocolId;
    unsigned long StaticInfoLength;
    unsigned long TransactionIdInfoLength;
    unsigned long Unused1;
    unsigned long Unused2;
};

struct tagENUMLOGFONTEXDVA
{
    struct tagENUMLOGFONTEXA elfEnumLogfontEx;
    struct tagDESIGNVECTOR elfDesignVector;
};

struct tagEMREXTCREATEPEN
{
    struct tagEMR emr;
    unsigned long ihPen;
    unsigned long offBmi;
    unsigned long cbBmi;
    unsigned long offBits;
    unsigned long cbBits;
    struct tagEXTLOGPEN32 elp;
};

struct _Real_widened<double,float>
{
};

struct tagMIDIINCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long dwSupport;
};

struct tagCIEXYZ
{
    long ciexyzX;
    long ciexyzY;
    long ciexyzZ;
};

struct tagPOLYTEXTW
{
    int x;
    int y;
    unsigned int n;
    wchar_t * lpstr;
    unsigned int uiFlags;
    struct tagRECT rcl;
    int * pdx;
};

struct _GROUP_RELATIONSHIP
{
    unsigned int MaximumGroupCount;
    unsigned int ActiveGroupCount;
    unsigned int Reserved[20];
    struct _PROCESSOR_GROUP_INFO GroupInfo[1];
};

struct $_TypeDescriptor$_extraBytes_28
{
    void * pVFTable;
    void * spare;
    char name[28];
};

struct tagCBT_CREATEWNDW
{
    struct tagCREATESTRUCTW * lpcs;
    struct HWND__ * hwndInsertAfter;
};

struct _XSTATE_FEATURE
{
    unsigned long Offset;
    unsigned long Size;
};

struct _CREATE_THREAD_DEBUG_INFO
{
    void * hThread;
    void * lpThreadLocalBase;
    unsigned long  ( * lpStartAddress)(void * );
};

struct HENHMETAFILE__
{
    int unused;
};

struct _IMAGE_ARCHIVE_MEMBER_HEADER
{
    unsigned int Name[16];
    unsigned int Date[12];
    unsigned int UserID[6];
    unsigned int GroupID[6];
    unsigned int Mode[8];
    unsigned int Size[10];
    unsigned int EndHeader[2];
};

struct tagEMRSELECTCLIPPATH
{
    struct tagEMR emr;
    unsigned long iMode;
};

struct _XSAVE_FORMAT
{
    unsigned int ControlWord;
    unsigned int StatusWord;
    unsigned int TagWord;
    unsigned int Reserved1;
    unsigned int ErrorOpcode;
    unsigned long ErrorOffset;
    unsigned int ErrorSelector;
    unsigned int Reserved2;
    unsigned long DataOffset;
    unsigned int DataSelector;
    unsigned int Reserved3;
    unsigned long MxCsr;
    unsigned long MxCsr_Mask;
    struct _M128A FloatRegisters[8];
    struct _M128A XmmRegisters[8];
    unsigned int Reserved4[192];
    unsigned long StackControl[7];
    unsigned long Cr0NpxState;
};

struct tagEMRALPHABLEND
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long cxDest;
    long cyDest;
    unsigned long dwRop;
    long xSrc;
    long ySrc;
    struct tagXFORM xformSrc;
    unsigned long crBkColorSrc;
    unsigned long iUsageSrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    long cxSrc;
    long cySrc;
};

struct _MEMORY_BASIC_INFORMATION
{
    void * BaseAddress;
    void * AllocationBase;
    unsigned long AllocationProtect;
    unsigned long RegionSize;
    unsigned long State;
    unsigned long Protect;
    unsigned long Type;
};

struct _SERVICE_NOTIFY_2A
{
    unsigned long dwVersion;
    void  ( * pfnNotifyCallback)(void * );
    void * pContext;
    unsigned long dwNotificationStatus;
    struct _SERVICE_STATUS_PROCESS ServiceStatus;
    unsigned long dwNotificationTriggered;
    char * pszServiceNames;
};

struct tagWAVEINCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
};

struct timecaps_tag
{
    unsigned int wPeriodMin;
    unsigned int wPeriodMax;
};

struct _GENERIC_MAPPING
{
    unsigned long GenericRead;
    unsigned long GenericWrite;
    unsigned long GenericExecute;
    unsigned long GenericAll;
};

struct _IMAGE_FILE_HEADER
{
    unsigned int Machine;
    unsigned int NumberOfSections;
    unsigned long TimeDateStamp;
    unsigned long PointerToSymbolTable;
    unsigned long NumberOfSymbols;
    unsigned int SizeOfOptionalHeader;
    unsigned int Characteristics;
};

struct _GLYPHMETRICS
{
    unsigned int gmBlackBoxX;
    unsigned int gmBlackBoxY;
    struct tagPOINT gmptGlyphOrigin;
    int gmCellIncX;
    int gmCellIncY;
};

struct tagDEBUGHOOKINFO
{
    unsigned long idThread;
    unsigned long idThreadInstaller;
    long lParam;
    unsigned int wParam;
    int code;
};

struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
{
    struct _GUID TmIdentity;
    unsigned long Flags;
};

struct tagMCI_OVLY_LOAD_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpfilename;
    struct tagRECT rc;
};

struct _PSFEATURE_OUTPUT
{
    int bPageIndependent;
    int bSetPageDevice;
};

struct tagCREATESTRUCTW
{
    void * lpCreateParams;
    struct HINSTANCE__ * hInstance;
    struct HMENU__ * hMenu;
    struct HWND__ * hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    long style;
    wchar_t * lpszName;
    wchar_t * lpszClass;
    unsigned long dwExStyle;
};

struct tagTTPOLYCURVE
{
    unsigned int wType;
    unsigned int cpfx;
    struct tagPOINTFX apfx[1];
};

struct tagMCI_ANIM_STEP_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrames;
};

struct tagKBDLLHOOKSTRUCT
{
    unsigned long vkCode;
    unsigned long scanCode;
    unsigned long flags;
    unsigned long time;
    unsigned long dwExtraInfo;
};

struct tagEMRCREATEDIBPATTERNBRUSHPT
{
    struct tagEMR emr;
    unsigned long ihBrush;
    unsigned long iUsage;
    unsigned long offBmi;
    unsigned long cbBmi;
    unsigned long offBits;
    unsigned long cbBits;
};

struct _RGNDATA
{
    struct _RGNDATAHEADER rdh;
    char Buffer[1];
};

struct _DISCDLGSTRUCTA
{
    unsigned long cbStructure;
    struct HWND__ * hwndOwner;
    char * lpLocalName;
    char * lpRemoteName;
    unsigned long dwFlags;
};

struct _DCB
{
    unsigned long DCBlength;
    unsigned long BaudRate;
    unsigned long fBinary:1;
    unsigned long fParity:1;
    unsigned long fOutxCtsFlow:1;
    unsigned long fOutxDsrFlow:1;
    unsigned long fDtrControl:2;
    unsigned long fDsrSensitivity:1;
    unsigned long fTXContinueOnXoff:1;
    unsigned long fOutX:1;
    unsigned long fInX:1;
    unsigned long fErrorChar:1;
    unsigned long fNull:1;
    unsigned long fRtsControl:2;
    unsigned long fAbortOnError:1;
    unsigned long fDummy2:17;
    unsigned int wReserved;
    unsigned int XonLim;
    unsigned int XoffLim;
    unsigned int ByteSize;
    unsigned int Parity;
    unsigned int StopBits;
    char XonChar;
    char XoffChar;
    char ErrorChar;
    char EofChar;
    char EvtChar;
    unsigned int wReserved1;
};

struct tagENUMLOGFONTEXA
{
    struct tagLOGFONTA elfLogFont;
    unsigned int elfFullName[64];
    unsigned int elfStyle[32];
    unsigned int elfScript[32];
};

struct _NETRESOURCEW
{
    unsigned long dwScope;
    unsigned long dwType;
    unsigned long dwDisplayType;
    unsigned long dwUsage;
    wchar_t * lpLocalName;
    wchar_t * lpRemoteName;
    wchar_t * lpComment;
    wchar_t * lpProvider;
};

struct _SMALL_RECT
{
    int Left;
    int Top;
    int Right;
    int Bottom;
};

struct _IMAGE_DATA_DIRECTORY
{
    unsigned long VirtualAddress;
    unsigned long Size;
};

struct _heapinfo
{
    int * _pentry;
    unsigned int _size;
    int _useflag;
};

struct _FILE_ID_BOTH_DIR_INFO
{
    unsigned long NextEntryOffset;
    unsigned long FileIndex;
    union _LARGE_INTEGER CreationTime;
    union _LARGE_INTEGER LastAccessTime;
    union _LARGE_INTEGER LastWriteTime;
    union _LARGE_INTEGER ChangeTime;
    union _LARGE_INTEGER EndOfFile;
    union _LARGE_INTEGER AllocationSize;
    unsigned long FileAttributes;
    unsigned long FileNameLength;
    unsigned long EaSize;
    char ShortNameLength;
    wchar_t ShortName[12];
    union _LARGE_INTEGER FileId;
    wchar_t FileName[1];
};

struct tagMCI_LOAD_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpfilename;
};

struct tagMULTIKEYHELPA
{
    unsigned long mkSize;
    char mkKeylist;
    char szKeyphrase[1];
};

struct tMIXERCONTROLDETAILS_BOOLEAN
{
    long fValue;
};

struct tagJOYCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    wchar_t szPname[32];
    unsigned int wXmin;
    unsigned int wXmax;
    unsigned int wYmin;
    unsigned int wYmax;
    unsigned int wZmin;
    unsigned int wZmax;
    unsigned int wNumButtons;
    unsigned int wPeriodMin;
    unsigned int wPeriodMax;
    unsigned int wRmin;
    unsigned int wRmax;
    unsigned int wUmin;
    unsigned int wUmax;
    unsigned int wVmin;
    unsigned int wVmax;
    unsigned int wCaps;
    unsigned int wMaxAxes;
    unsigned int wNumAxes;
    unsigned int wMaxButtons;
    wchar_t szRegKey[32];
    wchar_t szOEMVxD[260];
};

struct IMAGE_LOAD_CONFIG_DIRECTORY64
{
    unsigned long Size;
    unsigned long TimeDateStamp;
    unsigned int MajorVersion;
    unsigned int MinorVersion;
    unsigned long GlobalFlagsClear;
    unsigned long GlobalFlagsSet;
    unsigned long CriticalSectionDefaultTimeout;
    unsigned int DeCommitFreeBlockThreshold;
    unsigned int DeCommitTotalFreeThreshold;
    unsigned int LockPrefixTable;
    unsigned int MaximumAllocationSize;
    unsigned int VirtualMemoryThreshold;
    unsigned int ProcessAffinityMask;
    unsigned long ProcessHeapFlags;
    unsigned int CSDVersion;
    unsigned int Reserved1;
    unsigned int EditList;
    unsigned int SecurityCookie;
    unsigned int SEHandlerTable;
    unsigned int SEHandlerCount;
};

struct _PERFORMANCE_DATA
{
    unsigned int Size;
    unsigned int Version;
    unsigned int HwCountersCount;
    unsigned long ContextSwitchCount;
    unsigned int WaitReasonBitMap;
    unsigned int CycleTime;
    unsigned long RetryCount;
    unsigned long Reserved;
    struct _HARDWARE_COUNTER_DATA HwCounters[16];
};

struct tagEMRMODIFYWORLDTRANSFORM
{
    struct tagEMR emr;
    struct tagXFORM xform;
    unsigned long iMode;
};

struct _PACKEDEVENTINFO
{
    unsigned long ulSize;
    unsigned long ulNumEventsForLogFile;
    unsigned long ulOffsets[0];
};

struct _QUERY_SERVICE_LOCK_STATUSA
{
    unsigned long fIsLocked;
    char * lpLockOwner;
    unsigned long dwLockDuration;
};

struct _Combined_type<float,double>
{
};

struct tagWAVEINCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct tagAUXCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned int wTechnology;
    unsigned int wReserved1;
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct _REASON_CONTEXT
{
    unsigned long Version;
    unsigned long Flags;
    union <unnamed-type-Reason>
    {
        struct <unnamed-type-Detailed>
        {
            struct HINSTANCE__ * LocalizedReasonModule;
            unsigned long LocalizedReasonId;
            unsigned long ReasonStringCount;
            wchar_t ** ReasonStrings;
        };
        struct _REASON_CONTEXT::<unnamed-type-Reason>::<unnamed-type-Detailed> Detailed;
        wchar_t * SimpleReasonString;
    };
    union _REASON_CONTEXT::<unnamed-type-Reason> Reason;
};

struct tagEMRGLSBOUNDEDRECORD
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cbData;
    unsigned int Data[1];
};

struct tagNEWTEXTMETRICEXW
{
    struct tagNEWTEXTMETRICW ntmTm;
    struct tagFONTSIGNATURE ntmFontSig;
};

struct _EXCEPTION_RECORD32
{
    unsigned long ExceptionCode;
    unsigned long ExceptionFlags;
    unsigned long ExceptionRecord;
    unsigned long ExceptionAddress;
    unsigned long NumberParameters;
    unsigned long ExceptionInformation[15];
};

struct _ACCESS_REASONS
{
    unsigned long Data[32];
};

struct _ACCESS_DENIED_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct _COMSTAT
{
    unsigned long fCtsHold:1;
    unsigned long fDsrHold:1;
    unsigned long fRlsdHold:1;
    unsigned long fXoffHold:1;
    unsigned long fXoffSent:1;
    unsigned long fEof:1;
    unsigned long fTxim:1;
    unsigned long fReserved:25;
    unsigned long cbInQue;
    unsigned long cbOutQue;
};

struct tagPOLYTEXTA
{
    int x;
    int y;
    unsigned int n;
    char * lpstr;
    unsigned int uiFlags;
    struct tagRECT rcl;
    int * pdx;
};

struct _SE_ACCESS_REPLY
{
    unsigned long Size;
    unsigned long ResultListCount;
    unsigned long * GrantedAccess;
    unsigned long * AccessStatus;
    struct _ACCESS_REASONS * AccessReason;
    struct _PRIVILEGE_SET ** Privileges;
};

struct tagMCI_SYSINFO_PARMSA
{
    unsigned long dwCallback;
    char * lpstrReturn;
    unsigned long dwRetSize;
    unsigned long dwNumber;
    unsigned int wDeviceType;
};

struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT
{
    void * CompletionKey;
    void * CompletionPort;
};

struct _MESSAGE_RESOURCE_BLOCK
{
    unsigned long LowId;
    unsigned long HighId;
    unsigned long OffsetToEntries;
};

struct _JOBOBJECT_JOBSET_INFORMATION
{
    unsigned long MemberLevel;
};

struct tagHELPINFO
{
    unsigned int cbSize;
    int iContextType;
    int iCtrlId;
    void * hItemHandle;
    unsigned long dwContextId;
    struct tagPOINT MousePos;
};

struct _TAPE_PREPARE
{
    unsigned long Operation;
    unsigned int Immediate;
};

struct __vc_attributes::iid_isAttribute
{
    void iid_isAttribute(char * );
    char * limited_expression;
};

struct __vc_attributes::defaultAttribute
{
    void defaultAttribute(char * );
    void defaultAttribute();
    char * value;
};

struct __vc_attributes::defaultbindAttribute
{
    void defaultbindAttribute();
};

struct __vc_attributes::no_injected_textAttribute
{
    void no_injected_textAttribute(bool );
    void no_injected_textAttribute();
    bool value;
};

struct __vc_attributes::ptrAttribute
{
    void ptrAttribute();
};

struct __vc_attributes::cpp_quoteAttribute
{
    void cpp_quoteAttribute(char * );
    char * string;
};

struct __vc_attributes::controlAttribute
{
    void controlAttribute();
};

struct __vc_attributes::propputAttribute
{
    void propputAttribute();
};

struct __vc_attributes::satypeAttribute
{
    void satypeAttribute(char * );
    void satypeAttribute();
    char * type;
};

struct __vc_attributes::coclassAttribute
{
    void coclassAttribute();
};

struct __vc_attributes::lcidAttribute
{
    void lcidAttribute();
};

struct __vc_attributes::library_blockAttribute
{
    void library_blockAttribute();
};

struct __vc_attributes::nonbrowsableAttribute
{
    void nonbrowsableAttribute();
};

struct __vc_attributes::ms_unionAttribute
{
    void ms_unionAttribute();
};

struct __vc_attributes::importidlAttribute
{
    void importidlAttribute(char * );
    char * value;
};

struct __vc_attributes::customAttribute
{
    void customAttribute(char * );
    char * value;
};

struct __vc_attributes::propputrefAttribute
{
    void propputrefAttribute();
};

struct __vc_attributes::uidefaultAttribute
{
    void uidefaultAttribute();
};

struct __vc_attributes::readonlyAttribute
{
    void readonlyAttribute();
};

enum __vc_attributes::event_sourceAttribute::type_e
{
    native=0,
    com=1,
    managed=2
};

enum __vc_attributes::event_sourceAttribute::optimize_e
{
    speed=0,
    size=1
};

struct __vc_attributes::event_sourceAttribute
{
    enum type_e
    {
        native=0,
        com=1,
        managed=2
    };
    enum optimize_e
    {
        speed=0,
        size=1
    };
    void event_sourceAttribute(enum __vc_attributes::event_sourceAttribute::type_e );
    void event_sourceAttribute();
    enum __vc_attributes::event_sourceAttribute::type_e type;
    enum __vc_attributes::event_sourceAttribute::optimize_e optimize;
    bool decorate;
};

struct __vc_attributes::publicAttribute
{
    void publicAttribute();
};

struct __vc_attributes::helper_attributes::notify_atlprovAttribute
{
    void notify_atlprovAttribute();
};

struct __vc_attributes::helper_attributes::help_stringAttribute
{
    void help_stringAttribute(char * );
    char * value;
};

struct __vc_attributes::helper_attributes::requires_valueAttribute
{
    void requires_valueAttribute();
};

struct __vc_attributes::helper_attributes::as_stringAttribute
{
    void as_stringAttribute();
};

enum __vc_attributes::helper_attributes::v1_alttypeAttribute::type_e
{
    eBoolean=0,
    eInteger=1,
    eFloat=2,
    eDouble=3
};

struct __vc_attributes::helper_attributes::v1_alttypeAttribute
{
    enum type_e
    {
        eBoolean=0,
        eInteger=1,
        eFloat=2,
        eDouble=3
    };
    void v1_alttypeAttribute(enum __vc_attributes::helper_attributes::v1_alttypeAttribute::type_e );
    enum __vc_attributes::helper_attributes::v1_alttypeAttribute::type_e type;
};

struct __vc_attributes::helper_attributes::source_annotation_attributeAttribute
{
    const int All;
    const int Assembly;
    const int Class;
    const int Constructor;
    const int Delegate;
    const int Enum;
    const int Event;
    const int Field;
    const int GenericParameter;
    const int Interface;
    const int Method;
    const int Module;
    const int Parameter;
    const int Property;
    const int ReturnValue;
    const int Struct;
    const int Typedef;
    void source_annotation_attributeAttribute(int );
    void source_annotation_attributeAttribute();
    int ValidOn;
    bool AllowMultiple;
};

struct __vc_attributes::helper_attributes::process_earlyAttribute
{
    void process_earlyAttribute();
};

struct __vc_attributes::helper_attributes::multi_valueAttribute
{
    void multi_valueAttribute();
};

struct __vc_attributes::helper_attributes::attributeAttribute
{
    const int All;
    const int Assembly;
    const int Class;
    const int Constructor;
    const int Delegate;
    const int Enum;
    const int Event;
    const int Field;
    const int GenericParameter;
    const int Interface;
    const int Method;
    const int Module;
    const int Parameter;
    const int Property;
    const int ReturnValue;
    const int Struct;
    void attributeAttribute(int );
    void attributeAttribute();
    int ValidOn;
    bool AllowMultiple;
    bool Inherited;
};

enum __vc_attributes::helper_attributes::usageAttribute::usage_e
{
    eAnyUsage=0,
    eCoClassUsage=1,
    eCOMInterfaceUsage=2,
    eInterfaceUsage=6,
    eMemberUsage=8,
    eMethodUsage=16,
    eInterfaceMethodUsage=32,
    eInterfaceMemberUsage=64,
    eCoClassMemberUsage=128,
    eCoClassMethodUsage=256,
    eGlobalMethodUsage=768,
    eGlobalDataUsage=1024,
    eClassUsage=2048,
    eInterfaceParameterUsage=4096,
    eMethodParameterUsage=12288,
    eIDLModuleUsage=16384,
    eAnonymousUsage=32768,
    eTypedefUsage=65536,
    eUnionUsage=131072,
    eEnumUsage=262144,
    eDefineTagUsage=524288,
    eStructUsage=1048576,
    eLocalUsage=2097152,
    ePropertyUsage=4194304,
    eEventUsage=8388608,
    eTemplateUsage=16777216,
    eModuleUsage=16777216,
    eIllegalUsage=33554432,
    eAsynchronousUsage=67108864,
    eAnyIDLUsage=4161535
};

struct __vc_attributes::helper_attributes::usageAttribute
{
    enum usage_e
    {
        eAnyUsage=0,
        eCoClassUsage=1,
        eCOMInterfaceUsage=2,
        eInterfaceUsage=6,
        eMemberUsage=8,
        eMethodUsage=16,
        eInterfaceMethodUsage=32,
        eInterfaceMemberUsage=64,
        eCoClassMemberUsage=128,
        eCoClassMethodUsage=256,
        eGlobalMethodUsage=768,
        eGlobalDataUsage=1024,
        eClassUsage=2048,
        eInterfaceParameterUsage=4096,
        eMethodParameterUsage=12288,
        eIDLModuleUsage=16384,
        eAnonymousUsage=32768,
        eTypedefUsage=65536,
        eUnionUsage=131072,
        eEnumUsage=262144,
        eDefineTagUsage=524288,
        eStructUsage=1048576,
        eLocalUsage=2097152,
        ePropertyUsage=4194304,
        eEventUsage=8388608,
        eTemplateUsage=16777216,
        eModuleUsage=16777216,
        eIllegalUsage=33554432,
        eAsynchronousUsage=67108864,
        eAnyIDLUsage=4161535
    };
    void usageAttribute(unsigned int );
    unsigned int value;
};

struct __vc_attributes::helper_attributes::default_valueAttribute
{
    void default_valueAttribute(<btNoType> );
    void * value;
};

struct __vc_attributes::helper_attributes::repeatableAttribute
{
    void repeatableAttribute();
};

struct __vc_attributes::helper_attributes::v1_earlyAttribute
{
    void v1_earlyAttribute();
};

struct __vc_attributes::helper_attributes::v1_nameAttribute
{
    void v1_nameAttribute(char * );
    char * name;
};

struct __vc_attributes::idl_moduleAttribute
{
    void idl_moduleAttribute(char * ,char * ,char * ,char * ,char * ,int ,int ,bool ,bool );
    void idl_moduleAttribute();
    char * name;
    char * dllname;
    char * version;
    char * uuid;
    char * helpstring;
    int helpstringcontext;
    int helpcontext;
    bool hidden;
    bool restricted;
};

struct __vc_attributes::last_isAttribute
{
    void last_isAttribute(char * );
    char * expression;
};

struct __vc_attributes::transmit_asAttribute
{
    void transmit_asAttribute(char * );
    char * xmit_type;
};

struct __vc_attributes::importlibAttribute
{
    void importlibAttribute(char * );
    char * tlb_file;
};

struct __vc_attributes::inAttribute
{
    void inAttribute();
};

struct __vc_attributes::immediatebindAttribute
{
    void immediatebindAttribute();
};

struct __vc_attributes::switch_typeAttribute
{
    void switch_typeAttribute(char * );
    char * switch_type_specifier;
};

struct __vc_attributes::helpcontextAttribute
{
    void helpcontextAttribute(char * );
    char * helpcontext_value;
};

struct __vc_attributes::stringAttribute
{
    void stringAttribute();
};

struct __vc_attributes::rangeAttribute
{
    void rangeAttribute(int ,int );
    int low_val;
    int high_val;
};

struct __vc_attributes::includelibAttribute
{
    void includelibAttribute(char * );
    char * value;
};

struct __vc_attributes::helpstringdllAttribute
{
    void helpstringdllAttribute(char * );
    char * dllname;
};

struct __vc_attributes::idAttribute
{
    void idAttribute(int );
    int id_num;
};

struct __vc_attributes::hiddenAttribute
{
    void hiddenAttribute();
};

enum __vc_attributes::threadingAttribute::threading_e
{
    apartment=1,
    single=2,
    free=3,
    neutral=4,
    both=5
};

struct __vc_attributes::threadingAttribute
{
    enum threading_e
    {
        apartment=1,
        single=2,
        free=3,
        neutral=4,
        both=5
    };
    void threadingAttribute(enum __vc_attributes::threadingAttribute::threading_e );
    void threadingAttribute();
    enum __vc_attributes::threadingAttribute::threading_e value;
};

struct __vc_attributes::objectAttribute
{
    void objectAttribute();
};

struct __vc_attributes::includeAttribute
{
    void includeAttribute(char * );
    char * include_file;
};

struct __vc_attributes::restrictedAttribute
{
    void restrictedAttribute(char * );
    void restrictedAttribute();
    char * value;
};

struct __vc_attributes::wire_marshalAttribute
{
    void wire_marshalAttribute(char * );
    char * wire_type;
};

struct __vc_attributes::emitidlAttribute
{
    const int restricted;
    const int forced;
    const int push;
    const int pop;
    void emitidlAttribute(int ,bool );
    void emitidlAttribute(int );
    void emitidlAttribute();
    int value;
    bool defaultimports;
};

struct __vc_attributes::optionalAttribute
{
    void optionalAttribute();
};

struct __vc_attributes::first_isAttribute
{
    void first_isAttribute(char * );
    char * value;
};

struct __vc_attributes::max_isAttribute
{
    void max_isAttribute(char * );
    char * expression;
};

struct __vc_attributes::oleautomationAttribute
{
    void oleautomationAttribute();
};

struct __vc_attributes::v1_enumAttribute
{
    void v1_enumAttribute();
};

struct __vc_attributes::nonextensibleAttribute
{
    void nonextensibleAttribute();
};

enum __vc_attributes::aggregatableAttribute::type_e
{
    never=0,
    allowed=1,
    always=2
};

struct __vc_attributes::aggregatableAttribute
{
    enum type_e
    {
        never=0,
        allowed=1,
        always=2
    };
    void aggregatableAttribute(enum __vc_attributes::aggregatableAttribute::type_e );
    void aggregatableAttribute();
    enum __vc_attributes::aggregatableAttribute::type_e type;
};

struct __vc_attributes::defaultvalueAttribute
{
    void defaultvalueAttribute(char * );
    char * value;
};

struct __vc_attributes::propgetAttribute
{
    void propgetAttribute();
};

struct __vc_attributes::defaultvtableAttribute
{
    void defaultvtableAttribute(char * );
    char * value;
};

struct __vc_attributes::call_asAttribute
{
    void call_asAttribute(void * );
    void * local_proc;
};

struct __vc_attributes::dispinterfaceAttribute
{
    void dispinterfaceAttribute();
};

struct __vc_attributes::exportAttribute
{
    void exportAttribute();
};

struct __vc_attributes::hookAttribute
{
    void hookAttribute(char * ,char * ,char * ,char * );
    void hookAttribute(char * ,char * ,char * );
    void hookAttribute(char * ,char * );
    void hookAttribute();
    char * event;
    char * source;
    char * handler;
    char * receiver;
};

struct __vc_attributes::atl::synchronizeAttribute
{
    void synchronizeAttribute();
};

struct __vc_attributes::atl::db_columnAttribute
{
    void db_columnAttribute(char * ,char * ,char * ,char * ,char * ,char * );
    void db_columnAttribute(char * );
    void db_columnAttribute();
    char * ordinal;
    char * dbtype;
    char * precision;
    char * scale;
    char * status;
    char * length;
};

struct __vc_attributes::atl::db_paramAttribute
{
    void db_paramAttribute(char * ,char * ,char * ,char * ,char * ,char * ,char * );
    void db_paramAttribute(char * );
    void db_paramAttribute();
    char * ordinal;
    char * paramtype;
    char * dbtype;
    char * precision;
    char * scale;
    char * status;
    char * length;
};

struct __vc_attributes::atl::db_accessorAttribute
{
    void db_accessorAttribute(int ,bool );
    void db_accessorAttribute();
    int id;
    bool auto_;
};

struct __vc_attributes::atl::soap_handlerAttribute
{
    void soap_handlerAttribute(char * ,char * ,char * ,char * ,char * );
    void soap_handlerAttribute();
    char * name;
    char * namespace;
    char * protocol;
    char * style;
    char * use;
};

struct __vc_attributes::atl::support_error_infoAttribute
{
    void support_error_infoAttribute(char * );
    char * error_interface;
};

struct __vc_attributes::atl::com_interface_entryAttribute
{
    void com_interface_entryAttribute(char * );
    void com_interface_entryAttribute();
    char * value;
};

struct __vc_attributes::atl::request_handlerAttribute
{
    void request_handlerAttribute(char * ,char * );
    void request_handlerAttribute(char * );
    void request_handlerAttribute();
    char * name;
    char * sdl;
};

struct __vc_attributes::atl::perfmonAttribute
{
    void perfmonAttribute(char * ,bool );
    void perfmonAttribute(char * );
    void perfmonAttribute();
    char * name;
    bool register;
};

struct __vc_attributes::atl::implements_categoryAttribute
{
    void implements_categoryAttribute(char * );
    char * value;
};

struct __vc_attributes::atl::db_sourceAttribute
{
    void db_sourceAttribute(wchar_t * ,wchar_t * ,wchar_t * );
    void db_sourceAttribute(wchar_t * );
    void db_sourceAttribute(char * ,char * ,char * );
    void db_sourceAttribute(char * );
    void db_sourceAttribute();
    char * source;
    char * name;
    char * hresult;
};

struct __vc_attributes::atl::aggregatesAttribute
{
    void aggregatesAttribute(char * );
    void aggregatesAttribute();
    char * clsid;
};

struct __vc_attributes::atl::db_tableAttribute
{
    void db_tableAttribute(wchar_t * ,wchar_t * ,wchar_t * ,wchar_t * ,wchar_t * );
    void db_tableAttribute(wchar_t * );
    void db_tableAttribute(char * ,char * ,char * ,char * ,char * );
    void db_tableAttribute(char * );
    void db_tableAttribute();
    char * table;
    char * name;
    char * source_name;
    char * hresult;
    char * bulk_fetch;
};

struct __vc_attributes::atl::soap_headerAttribute
{
    void soap_headerAttribute(char * ,bool ,bool ,bool );
    void soap_headerAttribute(char * );
    void soap_headerAttribute();
    char * value;
    bool required;
    bool in;
    bool out;
};

struct __vc_attributes::atl::db_commandAttribute
{
    void db_commandAttribute(wchar_t * ,wchar_t * ,wchar_t * ,wchar_t * ,wchar_t * ,wchar_t * );
    void db_commandAttribute(wchar_t * );
    void db_commandAttribute(char * ,char * ,char * ,char * ,char * ,char * );
    void db_commandAttribute(char * );
    void db_commandAttribute();
    char * command;
    char * name;
    char * source_name;
    char * hresult;
    char * bindings;
    char * bulk_fetch;
};

struct __vc_attributes::atl::tag_nameAttribute
{
    void tag_nameAttribute(char * ,char * );
    void tag_nameAttribute(char * );
    void tag_nameAttribute();
    char * name;
    char * parse_func;
};

struct __vc_attributes::atl::soap_namespaceAttribute
{
    void soap_namespaceAttribute(char * );
    void soap_namespaceAttribute();
    char * value;
};

struct __vc_attributes::atl::perf_objectAttribute
{
    void perf_objectAttribute(int ,int ,char * ,char * ,int ,bool ,char * ,int );
    void perf_objectAttribute();
    int name_res;
    int help_res;
    char * namestring;
    char * helpstring;
    int detail;
    bool no_instances;
    char * class_;
    int maxinstnamelen;
};

struct __vc_attributes::atl::rdxAttribute
{
    void rdxAttribute(char * ,char * ,char * );
    void rdxAttribute(char * ,char * );
    void rdxAttribute();
    char * key;
    char * valuename;
    char * regtype;
};

struct __vc_attributes::atl::perf_counterAttribute
{
    void perf_counterAttribute(char * ,char * ,int ,int ,int ,int ,bool ,int ,int ,char * );
    void perf_counterAttribute();
    char * namestring;
    char * helpstring;
    int name_res;
    int help_res;
    int countertype;
    int defscale;
    bool default_counter;
    int detail;
    int max_counter_size;
    char * countertype_string;
};

struct __vc_attributes::atl::soap_methodAttribute
{
    void soap_methodAttribute(char * );
    void soap_methodAttribute();
    char * name;
};

struct __vc_attributes::atl::requires_categoryAttribute
{
    void requires_categoryAttribute(char * );
    char * value;
};

struct __vc_attributes::atl::registration_scriptAttribute
{
    void registration_scriptAttribute(char * );
    void registration_scriptAttribute();
    char * script;
};

struct __vc_attributes::noncreatableAttribute
{
    void noncreatableAttribute();
};

struct __vc_attributes::defaultcollelemAttribute
{
    void defaultcollelemAttribute();
};

struct __vc_attributes::odlAttribute
{
    void odlAttribute();
};

struct __vc_attributes::switch_isAttribute
{
    void switch_isAttribute(char * );
    char * limited_expression;
};

struct __vc_attributes::idl_quoteAttribute
{
    void idl_quoteAttribute(char * );
    void idl_quoteAttribute();
    char * text;
};

struct __vc_attributes::displaybindAttribute
{
    void displaybindAttribute();
};

struct __vc_attributes::helpstringAttribute
{
    void helpstringAttribute(char * );
    char * help_text_string;
};

struct __vc_attributes::helpstringcontextAttribute
{
    void helpstringcontextAttribute(int );
    int contextid;
};

struct __vc_attributes::unhookAttribute
{
    void unhookAttribute(char * ,char * ,char * ,char * );
    void unhookAttribute(char * ,char * ,char * );
    void unhookAttribute(char * ,char * );
    void unhookAttribute();
    char * event;
    char * source;
    char * handler;
    char * receiver;
};

struct __vc_attributes::progidAttribute
{
    void progidAttribute(char * );
    char * name;
};

struct __vc_attributes::versionAttribute
{
    void versionAttribute(char * );
    char * value;
};

struct __vc_attributes::size_isAttribute
{
    void size_isAttribute(char * );
    char * expression;
};

struct __vc_attributes::dualAttribute
{
    void dualAttribute();
};

struct __vc_attributes::implementsAttribute
{
    void implementsAttribute(char * );
    void implementsAttribute();
    char * interfaces;
    char * dispinterfaces;
};

enum __vc_attributes::event_receiverAttribute::type_e
{
    native=0,
    com=1,
    managed=2
};

struct __vc_attributes::event_receiverAttribute
{
    enum type_e
    {
        native=0,
        com=1,
        managed=2
    };
    void event_receiverAttribute(enum __vc_attributes::event_receiverAttribute::type_e ,bool );
    void event_receiverAttribute(enum __vc_attributes::event_receiverAttribute::type_e );
    void event_receiverAttribute();
    enum __vc_attributes::event_receiverAttribute::type_e type;
    bool layout_dependent;
};

struct __vc_attributes::localAttribute
{
    void localAttribute();
};

enum __vc_attributes::pointer_defaultAttribute::type_e
{
    ptr=0,
    ref=1,
    unique=2
};

struct __vc_attributes::pointer_defaultAttribute
{
    enum type_e
    {
        ptr=0,
        ref=1,
        unique=2
    };
    void pointer_defaultAttribute(enum __vc_attributes::pointer_defaultAttribute::type_e );
    enum __vc_attributes::pointer_defaultAttribute::type_e type;
};

struct __vc_attributes::requesteditAttribute
{
    void requesteditAttribute();
};

struct __vc_attributes::bindableAttribute
{
    void bindableAttribute();
};

struct __vc_attributes::pragmaAttribute
{
    void pragmaAttribute(char * );
    char * token_sequence;
};

struct __vc_attributes::appobjectAttribute
{
    void appobjectAttribute();
};

struct __vc_attributes::retvalAttribute
{
    void retvalAttribute();
};

struct __vc_attributes::caseAttribute
{
    void caseAttribute(int );
    int value;
};

struct __vc_attributes::uuidAttribute
{
    void uuidAttribute(char * );
    char * value;
};

struct __vc_attributes::entryAttribute
{
    void entryAttribute(char * );
    char * entry_id;
};

struct __vc_attributes::sourceAttribute
{
    void sourceAttribute(char * );
    void sourceAttribute();
    char * value;
};

struct __vc_attributes::helpfileAttribute
{
    void helpfileAttribute(char * );
    char * filename;
};

struct __vc_attributes::licensedAttribute
{
    void licensedAttribute();
};

struct __vc_attributes::async_uuidAttribute
{
    void async_uuidAttribute(char * );
    char * uuid;
};

struct __vc_attributes::uniqueAttribute
{
    void uniqueAttribute();
};

struct __vc_attributes::length_isAttribute
{
    void length_isAttribute(char * );
    char * expression;
};

struct __vc_attributes::varargAttribute
{
    void varargAttribute();
};

struct __vc_attributes::vi_progidAttribute
{
    void vi_progidAttribute(char * );
    char * value;
};

struct __vc_attributes::providerAttribute
{
    void providerAttribute(char * ,char * ,int );
    void providerAttribute();
    char * name;
    char * uuid;
    int cookies;
};

struct __vc_attributes::refAttribute
{
    void refAttribute();
};

struct __vc_attributes::usesgetlasterrorAttribute
{
    void usesgetlasterrorAttribute();
};

struct __vc_attributes::importAttribute
{
    void importAttribute(char * );
    char * idl_file;
};

struct __vc_attributes::outAttribute
{
    void outAttribute();
};

enum __vc_attributes::moduleAttribute::type_e
{
    dll=1,
    exe=2,
    service=3,
    unspecified=4,
    EXE=2,
    SERVICE=3
};

struct __vc_attributes::moduleAttribute
{
    enum type_e
    {
        dll=1,
        exe=2,
        service=3,
        unspecified=4,
        EXE=2,
        SERVICE=3
    };
    void moduleAttribute(enum __vc_attributes::moduleAttribute::type_e ,char * ,char * ,char * ,int ,bool ,char * ,int ,char * ,char * ,int ,bool ,bool ,char * ,char * );
    void moduleAttribute(enum __vc_attributes::moduleAttribute::type_e );
    void moduleAttribute();
    enum __vc_attributes::moduleAttribute::type_e type;
    char * name;
    char * version;
    char * uuid;
    int lcid;
    bool control;
    char * helpstring;
    int helpstringcontext;
    char * helpstringdll;
    char * helpfile;
    int helpcontext;
    bool hidden;
    bool restricted;
    char * custom;
    char * resource_name;
};

struct DISPLAYCONFIG_SOURCE_MODE
{
    unsigned int width;
    unsigned int height;
    enum DISPLAYCONFIG_PIXELFORMAT pixelFormat;
    struct _POINTL position;
};

struct _CRT_FLOAT
{
    float f;
};

struct tagCBTACTIVATESTRUCT
{
    int fMouse;
    struct HWND__ * hWndActive;
};

struct tagDRAWTEXTPARAMS
{
    unsigned int cbSize;
    int iTabLength;
    int iLeftMargin;
    int iRightMargin;
    unsigned int uiLengthDrawn;
};

struct _RIP_INFO
{
    unsigned long dwError;
    unsigned long dwType;
};

struct $_TypeDescriptor$_extraBytes_23
{
    void * pVFTable;
    void * spare;
    char name[23];
};

struct tagPOINT
{
    long x;
    long y;
};

struct tagSIZE
{
    long cx;
    long cy;
};

struct _BLENDFUNCTION
{
    unsigned int BlendOp;
    unsigned int BlendFlags;
    unsigned int SourceConstantAlpha;
    unsigned int AlphaFormat;
};

struct tagUPDATELAYEREDWINDOWINFO
{
    unsigned long cbSize;
    struct HDC__ * hdcDst;
    struct tagPOINT * pptDst;
    struct tagSIZE * psize;
    struct HDC__ * hdcSrc;
    struct tagPOINT * pptSrc;
    unsigned long crKey;
    struct _BLENDFUNCTION * pblend;
    unsigned long dwFlags;
    struct tagRECT * prcDirty;
};

struct _ICONINFOEXA
{
    unsigned long cbSize;
    int fIcon;
    unsigned long xHotspot;
    unsigned long yHotspot;
    struct HBITMAP__ * hbmMask;
    struct HBITMAP__ * hbmColor;
    unsigned int wResID;
    char szModName[260];
    char szResName[260];
};

struct tagAUDIODESCRIPTION
{
    unsigned int cbSize;
    int Enabled;
    unsigned long Locale;
};

struct _SERVICE_FAILURE_ACTIONSA
{
    unsigned long dwResetPeriod;
    char * lpRebootMsg;
    char * lpCommand;
    unsigned long cActions;
    struct _SC_ACTION * lpsaActions;
};

struct _IMAGE_RESOURCE_DIR_STRING_U
{
    unsigned int Length;
    wchar_t NameString[1];
};

struct tagPOINTS
{
    int x;
    int y;
};

struct _EVENTLOG_FULL_INFORMATION
{
    unsigned long dwFull;
};

struct tagENUMLOGFONTA
{
    struct tagLOGFONTA elfLogFont;
    unsigned int elfFullName[64];
    unsigned int elfStyle[32];
};

struct _SERVICE_REQUIRED_PRIVILEGES_INFOA
{
    char * pmszRequiredPrivileges;
};

struct tagHARDWAREHOOKSTRUCT
{
    struct HWND__ * hwnd;
    unsigned int message;
    unsigned int wParam;
    long lParam;
};

struct _SYSTEM_AUDIT_CALLBACK_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct _TRANSACTIONMANAGER_BASIC_INFORMATION
{
    struct _GUID TmIdentity;
    union _LARGE_INTEGER VirtualClock;
};

struct _INPUT_RECORD
{
    unsigned int EventType;
    union <unnamed-type-Event>
    {
        struct _KEY_EVENT_RECORD KeyEvent;
        struct _MOUSE_EVENT_RECORD MouseEvent;
        struct _WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
        struct _MENU_EVENT_RECORD MenuEvent;
        struct _FOCUS_EVENT_RECORD FocusEvent;
    };
    union _INPUT_RECORD::<unnamed-type-Event> Event;
};

struct _OSVERSIONINFOEXW
{
    unsigned long dwOSVersionInfoSize;
    unsigned long dwMajorVersion;
    unsigned long dwMinorVersion;
    unsigned long dwBuildNumber;
    unsigned long dwPlatformId;
    wchar_t szCSDVersion[128];
    unsigned int wServicePackMajor;
    unsigned int wServicePackMinor;
    unsigned int wSuiteMask;
    unsigned int wProductType;
    unsigned int wReserved;
};

struct _IMAGE_BOUND_IMPORT_DESCRIPTOR
{
    unsigned long TimeDateStamp;
    unsigned int OffsetModuleName;
    unsigned int NumberOfModuleForwarderRefs;
};

struct _SYSTEM_MANDATORY_LABEL_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct tagWAVEOUTCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
    unsigned long dwSupport;
};

struct _complex
{
    float x;
    float y;
};

struct tagMIXERCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long fdwSupport;
    unsigned long cDestinations;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct _TAPE_SET_DRIVE_PARAMETERS
{
    unsigned int ECC;
    unsigned int Compression;
    unsigned int DataPadding;
    unsigned int ReportSetmarks;
    unsigned long EOTWarningZoneSize;
};

struct _CACHE_DESCRIPTOR
{
    unsigned int Level;
    unsigned int Associativity;
    unsigned int LineSize;
    unsigned long Size;
    enum _PROCESSOR_CACHE_TYPE Type;
};

struct _CONNECTDLGSTRUCTA
{
    unsigned long cbStructure;
    struct HWND__ * hwndOwner;
    struct _NETRESOURCEA * lpConnRes;
    unsigned long dwFlags;
    unsigned long dwDevNum;
};

struct LIST_ENTRY32
{
    unsigned long Flink;
    unsigned long Blink;
};

struct ANON_OBJECT_HEADER
{
    unsigned int Sig1;
    unsigned int Sig2;
    unsigned int Version;
    unsigned int Machine;
    unsigned long TimeDateStamp;
    struct _GUID ClassID;
    unsigned long SizeOfData;
};

struct tagLOGFONTA
{
    long lfHeight;
    long lfWidth;
    long lfEscapement;
    long lfOrientation;
    long lfWeight;
    unsigned int lfItalic;
    unsigned int lfUnderline;
    unsigned int lfStrikeOut;
    unsigned int lfCharSet;
    unsigned int lfOutPrecision;
    unsigned int lfClipPrecision;
    unsigned int lfQuality;
    unsigned int lfPitchAndFamily;
    char lfFaceName[32];
};

struct tagTEXTMETRICA
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    unsigned int tmFirstChar;
    unsigned int tmLastChar;
    unsigned int tmDefaultChar;
    unsigned int tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
};

struct _IMAGE_NT_HEADERS64
{
    unsigned long Signature;
    struct _IMAGE_FILE_HEADER FileHeader;
    struct _IMAGE_OPTIONAL_HEADER64 OptionalHeader;
};

struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
{
    union _LARGE_INTEGER TotalUserTime;
    union _LARGE_INTEGER TotalKernelTime;
    union _LARGE_INTEGER ThisPeriodTotalUserTime;
    union _LARGE_INTEGER ThisPeriodTotalKernelTime;
    unsigned long TotalPageFaultCount;
    unsigned long TotalProcesses;
    unsigned long ActiveProcesses;
    unsigned long TotalTerminatedProcesses;
};

struct tagCOLORADJUSTMENT
{
    unsigned int caSize;
    unsigned int caFlags;
    unsigned int caIlluminantIndex;
    unsigned int caRedGamma;
    unsigned int caGreenGamma;
    unsigned int caBlueGamma;
    unsigned int caReferenceBlack;
    unsigned int caReferenceWhite;
    int caContrast;
    int caBrightness;
    int caColorfulness;
    int caRedGreenTint;
};

struct tagLOGBRUSH
{
    unsigned int lbStyle;
    unsigned long lbColor;
    unsigned long lbHatch;
};

struct _NT_TIB32
{
    unsigned long ExceptionList;
    unsigned long StackBase;
    unsigned long StackLimit;
    unsigned long SubSystemTib;
    unsigned long FiberData;
    unsigned long Version;
    unsigned long ArbitraryUserPointer;
    unsigned long Self;
};

struct tagMENUGETOBJECTINFO
{
    unsigned long dwFlags;
    unsigned int uPos;
    struct HMENU__ * hmenu;
    void * riid;
    void * pvObj;
};

struct _ENUM_SERVICE_STATUS_PROCESSA
{
    char * lpServiceName;
    char * lpDisplayName;
    struct _SERVICE_STATUS_PROCESS ServiceStatusProcess;
};

struct _IMAGE_SYMBOL
{
    union <unnamed-type-N>
    {
        unsigned int ShortName[8];
        struct <unnamed-type-Name>
        {
            unsigned long Short;
            unsigned long Long;
        };
        struct _IMAGE_SYMBOL::<unnamed-type-N>::<unnamed-type-Name> Name;
        unsigned long LongName[2];
    };
    union _IMAGE_SYMBOL::<unnamed-type-N> N;
    unsigned long Value;
    int SectionNumber;
    unsigned int Type;
    unsigned int StorageClass;
    unsigned int NumberOfAuxSymbols;
};

struct _SYSTEM_ALARM_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

class Utf8ReadIterator
{
    public void Utf8ReadIterator(char * ,int );
    public bool IsAtEnd();
    public unsigned long GetCodepoint();
    private unsigned int * p;
    private unsigned int * end;
};

struct tagRAWINPUTHEADER
{
    unsigned long dwType;
    unsigned long dwSize;
    void * hDevice;
    unsigned int wParam;
};

struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
{
    unsigned int BeginAddress;
    unsigned int EndAddress;
    unsigned int ExceptionHandler;
    unsigned int HandlerData;
    unsigned int PrologEndAddress;
};

struct tagLOGPALETTE
{
    unsigned int palVersion;
    unsigned int palNumEntries;
    struct tagPALETTEENTRY palPalEntry[1];
};

struct midihdr_tag
{
    char * lpData;
    unsigned long dwBufferLength;
    unsigned long dwBytesRecorded;
    unsigned long dwUser;
    unsigned long dwFlags;
    struct midihdr_tag * lpNext;
    unsigned long reserved;
    unsigned long dwOffset;
    unsigned long dwReserved[8];
};

struct _VIDEOPARAMETERS
{
    struct _GUID Guid;
    unsigned long dwOffset;
    unsigned long dwCommand;
    unsigned long dwFlags;
    unsigned long dwMode;
    unsigned long dwTVStandard;
    unsigned long dwAvailableModes;
    unsigned long dwAvailableTVStandard;
    unsigned long dwFlickerFilter;
    unsigned long dwOverScanX;
    unsigned long dwOverScanY;
    unsigned long dwMaxUnscaledX;
    unsigned long dwMaxUnscaledY;
    unsigned long dwPositionX;
    unsigned long dwPositionY;
    unsigned long dwBrightness;
    unsigned long dwContrast;
    unsigned long dwCPType;
    unsigned long dwCPCommand;
    unsigned long dwCPStandard;
    unsigned long dwCPKey;
    unsigned long bCP_APSTriggerBits;
    unsigned int bOEMCopyProtection[256];
};

struct _ENUM_SERVICE_STATUSA
{
    char * lpServiceName;
    char * lpDisplayName;
    struct _SERVICE_STATUS ServiceStatus;
};

struct _TypeDescriptor
{
    void * pVFTable;
    void * spare;
    char name[0];
};

struct _NETRESOURCEA
{
    unsigned long dwScope;
    unsigned long dwType;
    unsigned long dwDisplayType;
    unsigned long dwUsage;
    char * lpLocalName;
    char * lpRemoteName;
    char * lpComment;
    char * lpProvider;
};

struct $_TypeDescriptor$_extraBytes_34
{
    void * pVFTable;
    void * spare;
    char name[34];
};

struct _NUMA_NODE_RELATIONSHIP
{
    unsigned long NodeNumber;
    unsigned int Reserved[20];
    struct _GROUP_AFFINITY GroupMask;
};

struct _IMAGE_TLS_DIRECTORY64
{
    unsigned int StartAddressOfRawData;
    unsigned int EndAddressOfRawData;
    unsigned int AddressOfIndex;
    unsigned int AddressOfCallBacks;
    unsigned long SizeOfZeroFill;
    unsigned long Characteristics;
};

struct tagRAWINPUTDEVICE
{
    unsigned int usUsagePage;
    unsigned int usUsage;
    unsigned long dwFlags;
    struct HWND__ * hwndTarget;
};

struct _XSTATE_CONTEXT
{
    unsigned int Mask;
    unsigned long Length;
    unsigned long Reserved1;
    struct _XSAVE_AREA * Area;
    unsigned long Reserved2;
    void * Buffer;
    unsigned long Reserved3;
};

struct PPM_PERFSTATE_EVENT
{
    unsigned long State;
    unsigned long Status;
    unsigned long Latency;
    unsigned long Speed;
    unsigned long Processor;
};

struct _FILE_END_OF_FILE_INFO
{
    union _LARGE_INTEGER EndOfFile;
};

struct tagMCI_SEQ_SET_PARMS
{
    unsigned long dwCallback;
    unsigned long dwTimeFormat;
    unsigned long dwAudio;
    unsigned long dwTempo;
    unsigned long dwPort;
    unsigned long dwSlave;
    unsigned long dwMaster;
    unsigned long dwOffset;
};

struct tagEMRSELECTPALETTE
{
    struct tagEMR emr;
    unsigned long ihPal;
};

struct _KEY_EVENT_RECORD
{
    int bKeyDown;
    unsigned int wRepeatCount;
    unsigned int wVirtualKeyCode;
    unsigned int wVirtualScanCode;
    union <unnamed-type-uChar>
    {
        wchar_t UnicodeChar;
        char AsciiChar;
    };
    union _KEY_EVENT_RECORD::<unnamed-type-uChar> uChar;
    unsigned long dwControlKeyState;
};

union _KEY_EVENT_RECORD::<unnamed-type-uChar>
{
    wchar_t UnicodeChar;
    char AsciiChar;
};

struct pvalueW
{
    wchar_t * pv_valuename;
    int pv_valuelen;
    void * pv_value_context;
    unsigned long pv_type;
};

struct _SERVICE_DELAYED_AUTO_START_INFO
{
    int fDelayedAutostart;
};

struct _ENLISTMENT_BASIC_INFORMATION
{
    struct _GUID EnlistmentId;
    struct _GUID TransactionId;
    struct _GUID ResourceManagerId;
};

struct tagDROPSTRUCT
{
    struct HWND__ * hwndSource;
    struct HWND__ * hwndSink;
    unsigned long wFmt;
    unsigned long dwData;
    struct tagPOINT ptDrop;
    unsigned long dwControlData;
};

struct PPM_IDLE_ACCOUNTING_EX
{
    unsigned long StateCount;
    unsigned long TotalTransitions;
    unsigned long ResetCount;
    unsigned int StartTime;
    struct PPM_IDLE_STATE_ACCOUNTING_EX State[1];
};

struct _PRIVILEGE_SET
{
    unsigned long PrivilegeCount;
    unsigned long Control;
    struct _LUID_AND_ATTRIBUTES Privilege[1];
};

struct tagMCI_OVLY_WINDOW_PARMSA
{
    unsigned long dwCallback;
    struct HWND__ * hWnd;
    unsigned int nCmdShow;
    char * lpstrText;
};

struct tagRECONVERTSTRING
{
    unsigned long dwSize;
    unsigned long dwVersion;
    unsigned long dwStrLen;
    unsigned long dwStrOffset;
    unsigned long dwCompStrLen;
    unsigned long dwCompStrOffset;
    unsigned long dwTargetStrLen;
    unsigned long dwTargetStrOffset;
};

struct tagEMRPOLYTEXTOUTA
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long iGraphicsMode;
    float exScale;
    float eyScale;
    long cStrings;
    struct tagEMRTEXT aemrtext[1];
};

struct tagNEWTEXTMETRICEXA
{
    struct tagNEWTEXTMETRICA ntmTm;
    struct tagFONTSIGNATURE ntmFontSig;
};

struct tagHIGHCONTRASTW
{
    unsigned int cbSize;
    unsigned long dwFlags;
    wchar_t * lpszDefaultScheme;
};

struct _TIME_DYNAMIC_ZONE_INFORMATION
{
    long Bias;
    wchar_t StandardName[32];
    struct _SYSTEMTIME StandardDate;
    long StandardBias;
    wchar_t DaylightName[32];
    struct _SYSTEMTIME DaylightDate;
    long DaylightBias;
    wchar_t TimeZoneKeyName[128];
    unsigned int DynamicDaylightTimeDisabled;
};

struct DISPLAYCONFIG_ADAPTER_NAME
{
    struct DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    wchar_t adapterDevicePath[128];
};

enum __vcrt_va_list_is_reference<char const *>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<char const *>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct _ACL_REVISION_INFORMATION
{
    unsigned long AclRevision;
};

struct tagNONCLIENTMETRICSW
{
    unsigned int cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    struct tagLOGFONTW lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    struct tagLOGFONTW lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    struct tagLOGFONTW lfMenuFont;
    struct tagLOGFONTW lfStatusFont;
    struct tagLOGFONTW lfMessageFont;
    int iPaddedBorderWidth;
};

struct _FILE_ALLOCATION_INFO
{
    union _LARGE_INTEGER AllocationSize;
};

struct _WINDOW_BUFFER_SIZE_RECORD
{
    struct _COORD dwSize;
};

struct _UNIVERSAL_NAME_INFOW
{
    wchar_t * lpUniversalName;
};

struct tagEXTLOGPEN32
{
    unsigned long elpPenStyle;
    unsigned long elpWidth;
    unsigned int elpBrushStyle;
    unsigned long elpColor;
    unsigned long elpHatch;
    unsigned long elpNumEntries;
    unsigned long elpStyleEntry[1];
};

struct _CONSOLE_SCREEN_BUFFER_INFOEX
{
    unsigned long cbSize;
    struct _COORD dwSize;
    struct _COORD dwCursorPosition;
    unsigned int wAttributes;
    struct _SMALL_RECT srWindow;
    struct _COORD dwMaximumWindowSize;
    unsigned int wPopupAttributes;
    int bFullscreenSupported;
    unsigned long ColorTable[16];
};

struct _div_t
{
    int quot;
    int rem;
};

struct _TRANSACTION_ENLISTMENTS_INFORMATION
{
    unsigned long NumberOfEnlistments;
    struct _TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
};

struct _TP_IO
{
};

struct _QUERY_SERVICE_LOCK_STATUSW
{
    unsigned long fIsLocked;
    wchar_t * lpLockOwner;
    unsigned long dwLockDuration;
};

struct _SERVICE_NOTIFY_2W
{
    unsigned long dwVersion;
    void  ( * pfnNotifyCallback)(void * );
    void * pContext;
    unsigned long dwNotificationStatus;
    struct _SERVICE_STATUS_PROCESS ServiceStatus;
    unsigned long dwNotificationTriggered;
    wchar_t * pszServiceNames;
};

struct _LDBL12
{
    unsigned int ld12[12];
};

struct _MENU_EVENT_RECORD
{
    unsigned int dwCommandId;
};

struct _IMAGE_RELOCATION
{
    unsigned long VirtualAddress;
    unsigned long RelocCount;
    unsigned long SymbolTableIndex;
    unsigned int Type;
};

struct _SID
{
    unsigned int Revision;
    unsigned int SubAuthorityCount;
    struct _SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    unsigned long SubAuthority[1];
};

struct _FIXED
{
    unsigned int fract;
    int value;
};

struct tagCOMBOBOXINFO
{
    unsigned long cbSize;
    struct tagRECT rcItem;
    struct tagRECT rcButton;
    unsigned long stateButton;
    struct HWND__ * hwndCombo;
    struct HWND__ * hwndItem;
    struct HWND__ * hwndList;
};

struct tagWINDOWPLACEMENT
{
    unsigned int length;
    unsigned int flags;
    unsigned int showCmd;
    struct tagPOINT ptMinPosition;
    struct tagPOINT ptMaxPosition;
    struct tagRECT rcNormalPosition;
};

struct tagENUMLOGFONTEXW
{
    struct tagLOGFONTW elfLogFont;
    wchar_t elfFullName[64];
    wchar_t elfStyle[32];
    wchar_t elfScript[32];
};

struct tagJOYCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    char szPname[32];
    unsigned int wXmin;
    unsigned int wXmax;
    unsigned int wYmin;
    unsigned int wYmax;
    unsigned int wZmin;
    unsigned int wZmax;
    unsigned int wNumButtons;
    unsigned int wPeriodMin;
    unsigned int wPeriodMax;
    unsigned int wRmin;
    unsigned int wRmax;
    unsigned int wUmin;
    unsigned int wUmax;
    unsigned int wVmin;
    unsigned int wVmax;
    unsigned int wCaps;
    unsigned int wMaxAxes;
    unsigned int wNumAxes;
    unsigned int wMaxButtons;
    char szRegKey[32];
    char szOEMVxD[260];
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct _CRT_DOUBLE
{
    float x;
};

struct tagMCI_ANIM_OPEN_PARMSW
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    wchar_t * lpstrDeviceType;
    wchar_t * lpstrElementName;
    wchar_t * lpstrAlias;
    unsigned long dwStyle;
    struct HWND__ * hWndParent;
};

struct tagTTPOLYGONHEADER
{
    unsigned long cb;
    unsigned long dwType;
    struct tagPOINTFX pfxStart;
};

struct tagFONTSIGNATURE
{
    unsigned long fsUsb[4];
    unsigned long fsCsb[2];
};

struct tagSCROLLINFO
{
    unsigned int cbSize;
    unsigned int fMask;
    int nMin;
    int nMax;
    unsigned int nPage;
    int nPos;
    int nTrackPos;
};

struct tagEMREXTFLOODFILL
{
    struct tagEMR emr;
    struct _POINTL ptlStart;
    unsigned long crColor;
    unsigned long iMode;
};

struct PPM_IDLESTATE_EVENT
{
    unsigned long NewState;
    unsigned long OldState;
    unsigned int Processors;
};

struct _IMAGE_FUNCTION_ENTRY
{
    unsigned long StartingAddress;
    unsigned long EndingAddress;
    unsigned long EndOfPrologue;
};

struct tagWAVEOUTCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
    unsigned long dwSupport;
};

struct HTOUCHINPUT__
{
    int unused;
};

struct tagABORTPATH
{
    struct tagEMR emr;
};

struct tagRGBQUAD
{
    unsigned int rgbBlue;
    unsigned int rgbGreen;
    unsigned int rgbRed;
    unsigned int rgbReserved;
};

struct tagCREATESTRUCTA
{
    void * lpCreateParams;
    struct HINSTANCE__ * hInstance;
    struct HMENU__ * hMenu;
    struct HWND__ * hwndParent;
    int cy;
    int cx;
    int y;
    int x;
    long style;
    char * lpszName;
    char * lpszClass;
    unsigned long dwExStyle;
};

struct _TP_TIMER
{
};

struct SVector3
{
    float x;
    float y;
    float z;
    void SVector3(float ,float ,float );
    void SVector3();
    struct SVector3 operator-(struct SVector3 & );
    struct SVector3 operator-();
    struct SVector3 operator+(struct SVector3 & );
    struct SVector3 operator*(float );
    struct SVector3 & operator+=(struct SVector3 & );
    struct SVector3 & operator-=(struct SVector3 & );
    struct SVector3 & operator*=(float );
    float LengthSqr();
    float Length();
    struct SVector3 & Normalize();
    struct SVector3 GetNormalized();
};

struct SVector3
{
    float x;
    float y;
    float z;
    void SVector3(float ,float ,float );
    void SVector3();
    struct SVector3 operator-(struct SVector3 & );
    struct SVector3 operator-();
    struct SVector3 operator+(struct SVector3 & );
    struct SVector3 operator*(float );
    struct SVector3 & operator+=(struct SVector3 & );
    struct SVector3 & operator-=(struct SVector3 & );
    struct SVector3 & operator*=(float );
    float LengthSqr();
    float Length();
    struct SVector3 & Normalize();
    struct SVector3 GetNormalized();
};

struct _FILE_BASIC_INFO
{
    union _LARGE_INTEGER CreationTime;
    union _LARGE_INTEGER LastAccessTime;
    union _LARGE_INTEGER LastWriteTime;
    union _LARGE_INTEGER ChangeTime;
    unsigned long FileAttributes;
};

struct tagMCI_SYSINFO_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpstrReturn;
    unsigned long dwRetSize;
    unsigned long dwNumber;
    unsigned int wDeviceType;
};

struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
{
    unsigned long ulFlags;
    unsigned long ulEncodedAssemblyIdentityLength;
    unsigned long ulManifestPathType;
    unsigned long ulManifestPathLength;
    union _LARGE_INTEGER liManifestLastWriteTime;
    unsigned long ulPolicyPathType;
    unsigned long ulPolicyPathLength;
    union _LARGE_INTEGER liPolicyLastWriteTime;
    unsigned long ulMetadataSatelliteRosterIndex;
    unsigned long ulManifestVersionMajor;
    unsigned long ulManifestVersionMinor;
    unsigned long ulPolicyVersionMajor;
    unsigned long ulPolicyVersionMinor;
    unsigned long ulAssemblyDirectoryNameLength;
    wchar_t * lpAssemblyEncodedAssemblyIdentity;
    wchar_t * lpAssemblyManifestPath;
    wchar_t * lpAssemblyPolicyPath;
    wchar_t * lpAssemblyDirectoryName;
    unsigned long ulFileCount;
};

struct tagEMRFRAMERGN
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cbRgnData;
    unsigned long ihBrush;
    struct tagSIZE szlStroke;
    unsigned int RgnData[1];
};

struct _EVENTSFORLOGFILE
{
    unsigned long ulSize;
    wchar_t szLogicalLogFile[256];
    unsigned long ulNumRecords;
    struct _EVENTLOGRECORD pEventLogRecords[0];
};

struct _GUID
{
    unsigned long Data1;
    unsigned int Data2;
    unsigned int Data3;
    unsigned int Data4[8];
};

struct tagMIXERCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long fdwSupport;
    unsigned long cDestinations;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

union _RTL_RUN_ONCE
{
    void * Ptr;
};

struct tagBITMAPINFO
{
    struct tagBITMAPINFOHEADER bmiHeader;
    struct tagRGBQUAD bmiColors[1];
};

struct _PROCESS_HEAP_ENTRY
{
    void * lpData;
    unsigned long cbData;
    unsigned int cbOverhead;
    unsigned int iRegionIndex;
    unsigned int wFlags;
    struct _PROCESS_HEAP_ENTRY::_anonymous_2277::<unnamed-type-Block> Block;
    struct _PROCESS_HEAP_ENTRY::_anonymous_2276::<unnamed-type-Region> Region;
};

struct _STARTUPINFOA
{
    unsigned long cb;
    char * lpReserved;
    char * lpDesktop;
    char * lpTitle;
    unsigned long dwX;
    unsigned long dwY;
    unsigned long dwXSize;
    unsigned long dwYSize;
    unsigned long dwXCountChars;
    unsigned long dwYCountChars;
    unsigned long dwFillAttribute;
    unsigned long dwFlags;
    unsigned int wShowWindow;
    unsigned int cbReserved2;
    unsigned int * lpReserved2;
    void * hStdInput;
    void * hStdOutput;
    void * hStdError;
};

struct tagMDICREATESTRUCTA
{
    char * szClass;
    char * szTitle;
    void * hOwner;
    int x;
    int y;
    int cx;
    int cy;
    unsigned long style;
    long lParam;
};

struct _SID_AND_ATTRIBUTES_HASH
{
    unsigned long SidCount;
    struct _SID_AND_ATTRIBUTES * SidAttr;
    unsigned long Hash[32];
};

struct _TP_POOL_STACK_INFORMATION
{
    unsigned long StackReserve;
    unsigned long StackCommit;
};

struct _NETCONNECTINFOSTRUCT
{
    unsigned long cbStructure;
    unsigned long dwFlags;
    unsigned long dwSpeed;
    unsigned long dwDelay;
    unsigned long dwOptDataSize;
};

struct HTASK__
{
    int unused;
};

struct tagEMRMASKBLT
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long cxDest;
    long cyDest;
    unsigned long dwRop;
    long xSrc;
    long ySrc;
    struct tagXFORM xformSrc;
    unsigned long crBkColorSrc;
    unsigned long iUsageSrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    long xMask;
    long yMask;
    unsigned long iUsageMask;
    unsigned long offBmiMask;
    unsigned long cbBmiMask;
    unsigned long offBitsMask;
    unsigned long cbBitsMask;
};

union _LARGE_INTEGER
{
    unsigned long LowPart;
    long HighPart;
    struct <unnamed-type-u>
    {
        unsigned long LowPart;
        long HighPart;
    };
    struct _LARGE_INTEGER::<unnamed-type-u> u;
    int QuadPart;
};

struct _LARGE_INTEGER::<unnamed-type-u>
{
    unsigned long LowPart;
    long HighPart;
};

struct __vcrt_assert_va_start_is_not_reference<wchar_t const * const>
{
};

struct tagWAVEOUTCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct tagCOLORCORRECTPALETTE
{
    struct tagEMR emr;
    unsigned long ihPalette;
    unsigned long nFirstEntry;
    unsigned long nPalEntries;
    unsigned long nReserved;
};

struct _exception
{
    int type;
    char * name;
    float arg1;
    float arg2;
    float retval;
};

struct _FOCUS_EVENT_RECORD
{
    int bSetFocus;
};

struct HKEY__
{
    int unused;
};

struct tagDRVCONFIGINFO
{
    unsigned long dwDCISize;
    wchar_t * lpszDCISectionName;
    wchar_t * lpszDCIAliasName;
};

struct HPEN__
{
    int unused;
};

struct tagLAYERPLANEDESCRIPTOR
{
    unsigned int nSize;
    unsigned int nVersion;
    unsigned long dwFlags;
    unsigned int iPixelType;
    unsigned int cColorBits;
    unsigned int cRedBits;
    unsigned int cRedShift;
    unsigned int cGreenBits;
    unsigned int cGreenShift;
    unsigned int cBlueBits;
    unsigned int cBlueShift;
    unsigned int cAlphaBits;
    unsigned int cAlphaShift;
    unsigned int cAccumBits;
    unsigned int cAccumRedBits;
    unsigned int cAccumGreenBits;
    unsigned int cAccumBlueBits;
    unsigned int cAccumAlphaBits;
    unsigned int cDepthBits;
    unsigned int cStencilBits;
    unsigned int cAuxBuffers;
    unsigned int iLayerPlane;
    unsigned int bReserved;
    unsigned long crTransparent;
};

struct tagSCROLLBARINFO
{
    unsigned long cbSize;
    struct tagRECT rcScrollBar;
    int dxyLineButton;
    int xyThumbTop;
    int xyThumbBottom;
    int reserved;
    unsigned long rgstate[6];
};

struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct tagCHANGEFILTERSTRUCT
{
    unsigned long cbSize;
    unsigned long ExtStatus;
};

struct HRGN__
{
    int unused;
};

struct _FILE_NAME_INFO
{
    unsigned long FileNameLength;
    wchar_t FileName[1];
};

struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
{
    struct _GUID EnlistmentId;
    struct _GUID UOW;
};

struct _WIN32_STREAM_ID
{
    unsigned long dwStreamId;
    unsigned long dwStreamAttributes;
    union _LARGE_INTEGER Size;
    unsigned long dwStreamNameSize;
    wchar_t cStreamName[1];
};

struct tagMENUITEMINFOW
{
    unsigned int cbSize;
    unsigned int fMask;
    unsigned int fType;
    unsigned int fState;
    unsigned int wID;
    struct HMENU__ * hSubMenu;
    struct HBITMAP__ * hbmpChecked;
    struct HBITMAP__ * hbmpUnchecked;
    unsigned long dwItemData;
    wchar_t * dwTypeData;
    unsigned int cch;
    struct HBITMAP__ * hbmpItem;
};

struct _SERVICE_TIMECHANGE_INFO
{
    union _LARGE_INTEGER liNewTime;
    union _LARGE_INTEGER liOldTime;
};

struct HACCEL__
{
    int unused;
};

struct tagEMRANGLEARC
{
    struct tagEMR emr;
    struct _POINTL ptlCenter;
    unsigned long nRadius;
    float eStartAngle;
    float eSweepAngle;
};

struct HRSRC__
{
    int unused;
};

class SProperties
{
    public void SProperties(char * ,bool ,bool );
    public void ~SProperties();
    public char * GetString(char * ,char * ,char * );
    public float GetFloat(char * ,char * ,float );
    public int GetInt(char * ,char * ,int );
    public void EnumPropertyClasses();
    public char * GetNextPropertyClass();
    public void EnumProperties(char * );
    public char * GetNextProperty();
    private struct SPropertyClass * chain;
    private struct SPropertyClass * pc_enum;
    private struct SProperty * p_enum;
    private void ParseFileData(char * ,char * ,bool );
    private struct SPropertyClass * LookupClass(char * );
    private struct SProperty * LookupVariable(struct SPropertyClass * ,char * );
    public void * __vecDelDtor(unsigned int );
};

struct tagWINDOWINFO
{
    unsigned long cbSize;
    struct tagRECT rcWindow;
    struct tagRECT rcClient;
    unsigned long dwStyle;
    unsigned long dwExStyle;
    unsigned long dwWindowStatus;
    unsigned int cxWindowBorders;
    unsigned int cyWindowBorders;
    unsigned int atomWindowType;
    unsigned int wCreatorVersion;
};

struct tagEMREXCLUDECLIPRECT
{
    struct tagEMR emr;
    struct _RECTL rclClip;
};

struct _COMMCONFIG
{
    unsigned long dwSize;
    unsigned int wVersion;
    unsigned int wReserved;
    struct _DCB dcb;
    unsigned long dwProviderSubType;
    unsigned long dwProviderOffset;
    unsigned long dwProviderSize;
    wchar_t wcProviderData[1];
};

struct tagMCI_WAVE_OPEN_PARMSA
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    char * lpstrDeviceType;
    char * lpstrElementName;
    char * lpstrAlias;
    unsigned long dwBufferSeconds;
};

struct tagICONMETRICSA
{
    unsigned int cbSize;
    int iHorzSpacing;
    int iVertSpacing;
    int iTitleWrap;
    struct tagLOGFONTA lfFont;
};

struct tagMCI_ANIM_PLAY_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrom;
    unsigned long dwTo;
    unsigned long dwSpeed;
};

struct _IMAGE_COFF_SYMBOLS_HEADER
{
    unsigned long NumberOfSymbols;
    unsigned long LvaToFirstSymbol;
    unsigned long NumberOfLinenumbers;
    unsigned long LvaToFirstLinenumber;
    unsigned long RvaToFirstByteOfCode;
    unsigned long RvaToLastByteOfCode;
    unsigned long RvaToFirstByteOfData;
    unsigned long RvaToLastByteOfData;
};

struct _DISPLAY_DEVICEW
{
    unsigned long cb;
    wchar_t DeviceName[32];
    wchar_t DeviceString[128];
    unsigned long StateFlags;
    wchar_t DeviceID[128];
    wchar_t DeviceKey[128];
};

struct tagEMRLINETO
{
    struct tagEMR emr;
    struct _POINTL ptl;
};

struct _IMAGE_OPTIONAL_HEADER64
{
    unsigned int Magic;
    unsigned int MajorLinkerVersion;
    unsigned int MinorLinkerVersion;
    unsigned long SizeOfCode;
    unsigned long SizeOfInitializedData;
    unsigned long SizeOfUninitializedData;
    unsigned long AddressOfEntryPoint;
    unsigned long BaseOfCode;
    unsigned int ImageBase;
    unsigned long SectionAlignment;
    unsigned long FileAlignment;
    unsigned int MajorOperatingSystemVersion;
    unsigned int MinorOperatingSystemVersion;
    unsigned int MajorImageVersion;
    unsigned int MinorImageVersion;
    unsigned int MajorSubsystemVersion;
    unsigned int MinorSubsystemVersion;
    unsigned long Win32VersionValue;
    unsigned long SizeOfImage;
    unsigned long SizeOfHeaders;
    unsigned long CheckSum;
    unsigned int Subsystem;
    unsigned int DllCharacteristics;
    unsigned int SizeOfStackReserve;
    unsigned int SizeOfStackCommit;
    unsigned int SizeOfHeapReserve;
    unsigned int SizeOfHeapCommit;
    unsigned long LoaderFlags;
    unsigned long NumberOfRvaAndSizes;
    struct _IMAGE_DATA_DIRECTORY DataDirectory[16];
};

enum SwineVersionType
{
    Developer=0,
    Gold=1
};

struct _COMPATIBILITY_CONTEXT_ELEMENT
{
    struct _GUID Id;
    enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
};

struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
{
    unsigned long ulFlags;
    enum ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    unsigned long UiAccess;
};

struct _cpinfo
{
    unsigned int MaxCharSize;
    unsigned int DefaultChar[2];
    unsigned int LeadByte[12];
};

struct provider_info
{
    unsigned long  ( * pi_R0_1val)(void * ,struct val_context * ,unsigned long ,void * ,unsigned long * ,unsigned long );
    unsigned long  ( * pi_R0_allvals)(void * ,struct val_context * ,unsigned long ,void * ,unsigned long * ,unsigned long );
    unsigned long  ( * pi_R3_1val)(void * ,struct val_context * ,unsigned long ,void * ,unsigned long * ,unsigned long );
    unsigned long  ( * pi_R3_allvals)(void * ,struct val_context * ,unsigned long ,void * ,unsigned long * ,unsigned long );
    unsigned long pi_flags;
    void * pi_key_context;
};

struct _TIME_ZONE_INFORMATION
{
    long Bias;
    wchar_t StandardName[32];
    struct _SYSTEMTIME StandardDate;
    long StandardBias;
    wchar_t DaylightName[32];
    struct _SYSTEMTIME DaylightDate;
    long DaylightBias;
};

struct _TAPE_GET_DRIVE_PARAMETERS
{
    unsigned int ECC;
    unsigned int Compression;
    unsigned int DataPadding;
    unsigned int ReportSetmarks;
    unsigned long DefaultBlockSize;
    unsigned long MaximumBlockSize;
    unsigned long MinimumBlockSize;
    unsigned long MaximumPartitionCount;
    unsigned long FeaturesLow;
    unsigned long FeaturesHigh;
    unsigned long EOTWarningZoneSize;
};

struct tagLOGFONTW
{
    long lfHeight;
    long lfWidth;
    long lfEscapement;
    long lfOrientation;
    long lfWeight;
    unsigned int lfItalic;
    unsigned int lfUnderline;
    unsigned int lfStrikeOut;
    unsigned int lfCharSet;
    unsigned int lfOutPrecision;
    unsigned int lfClipPrecision;
    unsigned int lfQuality;
    unsigned int lfPitchAndFamily;
    wchar_t lfFaceName[32];
};

struct tagTEXTMETRICW
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    wchar_t tmFirstChar;
    wchar_t tmLastChar;
    wchar_t tmDefaultChar;
    wchar_t tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
};

struct midiproptimediv_tag
{
    unsigned long cbStruct;
    unsigned long dwTimeDiv;
};

struct tagNEWTEXTMETRICA
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    unsigned int tmFirstChar;
    unsigned int tmLastChar;
    unsigned int tmDefaultChar;
    unsigned int tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
    unsigned long ntmFlags;
    unsigned int ntmSizeEM;
    unsigned int ntmCellHeight;
    unsigned int ntmAvgWidth;
};

struct tagMSGBOXPARAMSW
{
    unsigned int cbSize;
    struct HWND__ * hwndOwner;
    struct HINSTANCE__ * hInstance;
    wchar_t * lpszText;
    wchar_t * lpszCaption;
    unsigned long dwStyle;
    wchar_t * lpszIcon;
    unsigned long dwContextHelpId;
    void  ( * lpfnMsgBoxCallback)(struct tagHELPINFO * );
    unsigned long dwLanguageId;
};

class SStream
{
    private class SStack<int> Chunks;
    public void SStream(class SStream * );
    public void SStream(class SStream & );
    protected void SStream();
    protected bool NewTypeStrings;
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public unsigned int ReadByte();
    public unsigned int ReadWord();
    public int ReadInt();
    public float ReadFloat();
    public char * ReadString();
    public void WriteByte(unsigned int );
    public void WriteWord(unsigned int );
    public void WriteInt(int );
    public void WriteFloat(float );
    public void WriteString(char * );
    public int ReadChunkHeader();
    public void ReadChunkSkip();
    public void ReadChunkValidate();
    public bool ReadChunkIsEnd();
    public int ReadChunkRemain();
    public void WriteChunkStart(int );
    public void WriteChunkEnd();
    public void ReadSignature();
    public void WriteSignature();
    public void ~SStream();
    public class SStream & operator=(class SStream * );
    public class SStream & operator=(class SStream & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SStream
{
    private class SStack<int> Chunks;
    public void SStream(class SStream * );
    public void SStream(class SStream & );
    protected void SStream();
    protected bool NewTypeStrings;
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public unsigned int ReadByte();
    public unsigned int ReadWord();
    public int ReadInt();
    public float ReadFloat();
    public char * ReadString();
    public void WriteByte(unsigned int );
    public void WriteWord(unsigned int );
    public void WriteInt(int );
    public void WriteFloat(float );
    public void WriteString(char * );
    public int ReadChunkHeader();
    public void ReadChunkSkip();
    public void ReadChunkValidate();
    public bool ReadChunkIsEnd();
    public int ReadChunkRemain();
    public void WriteChunkStart(int );
    public void WriteChunkEnd();
    public void ReadSignature();
    public void WriteSignature();
    public void ~SStream();
    public class SStream & operator=(class SStream * );
    public class SStream & operator=(class SStream & );
    public void * __vecDelDtor(unsigned int );
};

struct _KCRM_MARSHAL_HEADER
{
    unsigned long VersionMajor;
    unsigned long VersionMinor;
    unsigned long NumProtocols;
    unsigned long Unused;
};

struct _CONSOLE_FONT_INFO
{
    unsigned long nFont;
    struct _COORD dwFontSize;
};

struct _SERVICE_DESCRIPTIONA
{
    char * lpDescription;
};

class Utf16ReadIterator
{
    public void Utf16ReadIterator(wchar_t * ,int );
    public bool IsAtEnd();
    public unsigned long GetCodepoint();
    private unsigned int * p;
    private unsigned int * end;
};

struct BATTERY_REPORTING_SCALE
{
    unsigned long Granularity;
    unsigned long Capacity;
};

struct _MEMORY_BASIC_INFORMATION32
{
    unsigned long BaseAddress;
    unsigned long AllocationBase;
    unsigned long AllocationProtect;
    unsigned long RegionSize;
    unsigned long State;
    unsigned long Protect;
    unsigned long Type;
};

struct tagLOGCOLORSPACEA
{
    unsigned long lcsSignature;
    unsigned long lcsVersion;
    unsigned long lcsSize;
    long lcsCSType;
    long lcsIntent;
    struct tagICEXYZTRIPLE lcsEndpoints;
    unsigned long lcsGammaRed;
    unsigned long lcsGammaGreen;
    unsigned long lcsGammaBlue;
    char lcsFilename[260];
};

class Utf8WriteIterator
{
    public void Utf8WriteIterator(char * ,int );
    public unsigned long GetCodepointSize(unsigned long );
    public void AppendCodepoint(unsigned long );
    private unsigned int * p;
    private unsigned int * end;
};

struct tagGCP_RESULTSA
{
    unsigned long lStructSize;
    char * lpOutString;
    unsigned int * lpOrder;
    int * lpDx;
    int * lpCaretPos;
    char * lpClass;
    wchar_t * lpGlyphs;
    unsigned int nGlyphs;
    int nMaxFit;
};

enum __vcrt_va_list_is_reference<__crt_locale_pointers *>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<__crt_locale_pointers *>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct tagLOGPEN
{
    unsigned int lopnStyle;
    struct tagPOINT lopnWidth;
    unsigned long lopnColor;
};

struct _TOKEN_MANDATORY_LABEL
{
    struct _SID_AND_ATTRIBUTES Label;
};

struct tagEMREXTCREATEFONTINDIRECTW
{
    struct tagEMR emr;
    unsigned long ihFont;
    struct tagEXTLOGFONTW elfw;
};

struct _LIST_ENTRY
{
    struct _LIST_ENTRY * Flink;
    struct _LIST_ENTRY * Blink;
};

struct tagEMRSETVIEWPORTORGEX
{
    struct tagEMR emr;
    struct _POINTL ptlOrigin;
};

struct tagIMECHARPOSITION
{
    unsigned long dwSize;
    unsigned long dwCharPos;
    struct tagPOINT pt;
    unsigned int cLineHeight;
    struct tagRECT rcDocument;
};

struct tagMCI_SAVE_PARMSA
{
    unsigned long dwCallback;
    char * lpfilename;
};

struct _MAT2
{
    struct _FIXED eM11;
    struct _FIXED eM12;
    struct _FIXED eM21;
    struct _FIXED eM22;
};

struct _s__CatchableType
{
    unsigned int properties;
    struct _TypeDescriptor * pType;
    struct _PMD thisDisplacement;
    int sizeOrOffset;
    void  ( * copyFunction)(void * );
};

struct tagEMRCREATEPALETTE
{
    struct tagEMR emr;
    unsigned long ihPal;
    struct tagLOGPALETTE lgpl;
};

struct _LOAD_DLL_DEBUG_INFO
{
    void * hFile;
    void * lpBaseOfDll;
    unsigned long dwDebugInfoFileOffset;
    unsigned long nDebugInfoSize;
    void * lpImageName;
    unsigned int fUnicode;
};

struct tagEMRSETCOLORADJUSTMENT
{
    struct tagEMR emr;
    struct tagCOLORADJUSTMENT ColorAdjustment;
};

struct tagUSEROBJECTFLAGS
{
    int fInherit;
    int fReserved;
    unsigned long dwFlags;
};

struct _IMAGE_RESOURCE_DIRECTORY_ENTRY
{
    unsigned long NameOffset:31;
    unsigned long NameIsString:1;
    unsigned long Name;
    unsigned int Id;
    unsigned long OffsetToData;
    unsigned long OffsetToDirectory:31;
    unsigned long DataIsDirectory:1;
};

struct tMIXERCONTROLDETAILS_UNSIGNED
{
    unsigned long dwValue;
};

struct tagMIDIINCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct tagHELPWININFOA
{
    int wStructSize;
    int x;
    int y;
    int dx;
    int dy;
    int wMax;
    char rgchMember[2];
};

struct tagNEWTEXTMETRICW
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    wchar_t tmFirstChar;
    wchar_t tmLastChar;
    wchar_t tmDefaultChar;
    wchar_t tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
    unsigned long ntmFlags;
    unsigned int ntmSizeEM;
    unsigned int ntmCellHeight;
    unsigned int ntmAvgWidth;
};

struct tagMSG
{
    struct HWND__ * hwnd;
    unsigned int message;
    unsigned int wParam;
    long lParam;
    unsigned long time;
    struct tagPOINT pt;
};

struct _WOW64_DESCRIPTOR_TABLE_ENTRY
{
    unsigned long Selector;
    struct _WOW64_LDT_ENTRY Descriptor;
};

struct _TOKEN_SOURCE
{
    char SourceName[8];
    struct _LUID SourceIdentifier;
};

struct _QUOTA_LIMITS_EX
{
    unsigned long PagedPoolLimit;
    unsigned long NonPagedPoolLimit;
    unsigned long MinimumWorkingSetSize;
    unsigned long MaximumWorkingSetSize;
    unsigned long PagefileLimit;
    union _LARGE_INTEGER TimeLimit;
    unsigned long WorkingSetLimit;
    unsigned long Reserved2;
    unsigned long Reserved3;
    unsigned long Reserved4;
    unsigned long Flags;
    union _RATE_QUOTA_LIMIT CpuRateLimit;
};

union _SLIST_HEADER
{
    unsigned int Alignment;
    struct _SINGLE_LIST_ENTRY Next;
    unsigned int Depth;
    unsigned int Sequence;
};

struct _GROUP_AFFINITY
{
    unsigned long Mask;
    unsigned int Group;
    unsigned int Reserved[3];
};

struct _TOKEN_STATISTICS
{
    struct _LUID TokenId;
    struct _LUID AuthenticationId;
    union _LARGE_INTEGER ExpirationTime;
    enum _TOKEN_TYPE TokenType;
    enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    unsigned long DynamicCharged;
    unsigned long DynamicAvailable;
    unsigned long GroupCount;
    unsigned long PrivilegeCount;
    struct _LUID ModifiedId;
};

struct _IMAGE_SECTION_HEADER
{
    unsigned int Name[8];
    union <unnamed-type-Misc>
    {
        unsigned long PhysicalAddress;
        unsigned long VirtualSize;
    };
    union _IMAGE_SECTION_HEADER::<unnamed-type-Misc> Misc;
    unsigned long VirtualAddress;
    unsigned long SizeOfRawData;
    unsigned long PointerToRawData;
    unsigned long PointerToRelocations;
    unsigned long PointerToLinenumbers;
    unsigned int NumberOfRelocations;
    unsigned int NumberOfLinenumbers;
    unsigned long Characteristics;
};

struct _RASTERIZER_STATUS
{
    int nSize;
    int wFlags;
    int nLanguageID;
};

struct HUMPD__
{
    int unused;
};

struct _PROCESSOR_POWER_POLICY_INFO
{
    unsigned long TimeCheck;
    unsigned long DemoteLimit;
    unsigned long PromoteLimit;
    unsigned int DemotePercent;
    unsigned int PromotePercent;
    unsigned int Spare[2];
    unsigned long AllowDemotion:1;
    unsigned long AllowPromotion:1;
    unsigned long Reserved:30;
};

struct tagJOYCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    wchar_t szPname[32];
    unsigned int wXmin;
    unsigned int wXmax;
    unsigned int wYmin;
    unsigned int wYmax;
    unsigned int wZmin;
    unsigned int wZmax;
    unsigned int wNumButtons;
    unsigned int wPeriodMin;
    unsigned int wPeriodMax;
    unsigned int wRmin;
    unsigned int wRmax;
    unsigned int wUmin;
    unsigned int wUmax;
    unsigned int wVmin;
    unsigned int wVmax;
    unsigned int wCaps;
    unsigned int wMaxAxes;
    unsigned int wNumAxes;
    unsigned int wMaxButtons;
    wchar_t szRegKey[32];
    wchar_t szOEMVxD[260];
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct SHELLHOOKINFO
{
    struct HWND__ * hwnd;
    struct tagRECT rc;
};

struct _SID_AND_ATTRIBUTES
{
    void * Sid;
    unsigned long Attributes;
};

struct _IMAGE_DEBUG_DIRECTORY
{
    unsigned long Characteristics;
    unsigned long TimeDateStamp;
    unsigned int MajorVersion;
    unsigned int MinorVersion;
    unsigned long Type;
    unsigned long SizeOfData;
    unsigned long AddressOfRawData;
    unsigned long PointerToRawData;
};

struct _currencyfmtA
{
    unsigned int NumDigits;
    unsigned int LeadingZero;
    unsigned int Grouping;
    char * lpDecimalSep;
    char * lpThousandSep;
    unsigned int NegativeOrder;
    unsigned int PositiveOrder;
    char * lpCurrencySymbol;
};

struct _OUTLINETEXTMETRICW
{
    unsigned int otmSize;
    struct tagTEXTMETRICW otmTextMetrics;
    unsigned int otmFiller;
    struct tagPANOSE otmPanoseNumber;
    unsigned int otmfsSelection;
    unsigned int otmfsType;
    int otmsCharSlopeRise;
    int otmsCharSlopeRun;
    int otmItalicAngle;
    unsigned int otmEMSquare;
    int otmAscent;
    int otmDescent;
    unsigned int otmLineGap;
    unsigned int otmsCapEmHeight;
    unsigned int otmsXHeight;
    struct tagRECT otmrcFontBox;
    int otmMacAscent;
    int otmMacDescent;
    unsigned int otmMacLineGap;
    unsigned int otmusMinimumPPEM;
    struct tagPOINT otmptSubscriptSize;
    struct tagPOINT otmptSubscriptOffset;
    struct tagPOINT otmptSuperscriptSize;
    struct tagPOINT otmptSuperscriptOffset;
    unsigned int otmsStrikeoutSize;
    int otmsStrikeoutPosition;
    int otmsUnderscoreSize;
    int otmsUnderscorePosition;
    char * otmpFamilyName;
    char * otmpFaceName;
    char * otmpStyleName;
    char * otmpFullName;
};

struct tagMCI_GETDEVCAPS_PARMS
{
    unsigned long dwCallback;
    unsigned long dwReturn;
    unsigned long dwItem;
};

struct _IMAGE_DEBUG_MISC
{
    unsigned long DataType;
    unsigned long Length;
    unsigned int Unicode;
    unsigned int Reserved[3];
    unsigned int Data[1];
};

struct HIMC__
{
    int unused;
};

struct tagPIXELFORMATDESCRIPTOR
{
    unsigned int nSize;
    unsigned int nVersion;
    unsigned long dwFlags;
    unsigned int iPixelType;
    unsigned int cColorBits;
    unsigned int cRedBits;
    unsigned int cRedShift;
    unsigned int cGreenBits;
    unsigned int cGreenShift;
    unsigned int cBlueBits;
    unsigned int cBlueShift;
    unsigned int cAlphaBits;
    unsigned int cAlphaShift;
    unsigned int cAccumBits;
    unsigned int cAccumRedBits;
    unsigned int cAccumGreenBits;
    unsigned int cAccumBlueBits;
    unsigned int cAccumAlphaBits;
    unsigned int cDepthBits;
    unsigned int cStencilBits;
    unsigned int cAuxBuffers;
    unsigned int iLayerType;
    unsigned int bReserved;
    unsigned long dwLayerMask;
    unsigned long dwVisibleMask;
    unsigned long dwDamageMask;
};

struct _REMOTE_NAME_INFOW
{
    wchar_t * lpUniversalName;
    wchar_t * lpConnectionName;
    wchar_t * lpRemainingPath;
};

struct _OBJECTID
{
    struct _GUID Lineage;
    unsigned long Uniquifier;
};

struct PPM_IDLE_ACCOUNTING
{
    unsigned long StateCount;
    unsigned long TotalTransitions;
    unsigned long ResetCount;
    unsigned int StartTime;
    struct PPM_IDLE_STATE_ACCOUNTING State[1];
};

struct mmtime_tag
{
    unsigned int wType;
    union <unnamed-type-u>
    {
        unsigned long ms;
        unsigned long sample;
        unsigned long cb;
        unsigned long ticks;
        struct <unnamed-type-smpte>
        {
            unsigned int hour;
            unsigned int min;
            unsigned int sec;
            unsigned int frame;
            unsigned int fps;
            unsigned int dummy;
            unsigned int pad[2];
        };
        struct mmtime_tag::<unnamed-type-u>::<unnamed-type-smpte> smpte;
        struct <unnamed-type-midi>
        {
            unsigned long songptrpos;
        };
        struct mmtime_tag::<unnamed-type-u>::<unnamed-type-midi> midi;
    };
    union mmtime_tag::<unnamed-type-u> u;
};

struct tagMIXERCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long fdwSupport;
    unsigned long cDestinations;
};

struct _TAPE_WMI_OPERATIONS
{
    unsigned long Method;
    unsigned long DataBufferSize;
    void * DataBuffer;
};

struct _CHAR_INFO
{
    union <unnamed-type-Char>
    {
        wchar_t UnicodeChar;
        char AsciiChar;
    };
    union _CHAR_INFO::<unnamed-type-Char> Char;
    unsigned int Attributes;
};

union _CHAR_INFO::<unnamed-type-Char>
{
    wchar_t UnicodeChar;
    char AsciiChar;
};

struct SERVICE_STATUS_HANDLE__
{
    int unused;
};

struct $_TypeDescriptor$_extraBytes_19
{
    void * pVFTable;
    void * spare;
    char name[19];
};

union _RATE_QUOTA_LIMIT
{
    unsigned long RateData;
    unsigned long RatePercent:7;
    unsigned long Reserved0:25;
};

struct $_TypeDescriptor$_extraBytes_21
{
    void * pVFTable;
    void * spare;
    char name[21];
};

struct _IMAGE_VXD_HEADER
{
    unsigned int e32_magic;
    unsigned int e32_border;
    unsigned int e32_worder;
    unsigned long e32_level;
    unsigned int e32_cpu;
    unsigned int e32_os;
    unsigned long e32_ver;
    unsigned long e32_mflags;
    unsigned long e32_mpages;
    unsigned long e32_startobj;
    unsigned long e32_eip;
    unsigned long e32_stackobj;
    unsigned long e32_esp;
    unsigned long e32_pagesize;
    unsigned long e32_lastpagesize;
    unsigned long e32_fixupsize;
    unsigned long e32_fixupsum;
    unsigned long e32_ldrsize;
    unsigned long e32_ldrsum;
    unsigned long e32_objtab;
    unsigned long e32_objcnt;
    unsigned long e32_objmap;
    unsigned long e32_itermap;
    unsigned long e32_rsrctab;
    unsigned long e32_rsrccnt;
    unsigned long e32_restab;
    unsigned long e32_enttab;
    unsigned long e32_dirtab;
    unsigned long e32_dircnt;
    unsigned long e32_fpagetab;
    unsigned long e32_frectab;
    unsigned long e32_impmod;
    unsigned long e32_impmodcnt;
    unsigned long e32_impproc;
    unsigned long e32_pagesum;
    unsigned long e32_datapage;
    unsigned long e32_preload;
    unsigned long e32_nrestab;
    unsigned long e32_cbnrestab;
    unsigned long e32_nressum;
    unsigned long e32_autodata;
    unsigned long e32_debuginfo;
    unsigned long e32_debuglen;
    unsigned long e32_instpreload;
    unsigned long e32_instdemand;
    unsigned long e32_heapsize;
    unsigned int e32_res3[12];
    unsigned long e32_winresoff;
    unsigned long e32_winreslen;
    unsigned int e32_devid;
    unsigned int e32_ddkver;
};

struct tagEMRTEXT
{
    struct _POINTL ptlReference;
    unsigned long nChars;
    unsigned long offString;
    unsigned long fOptions;
    struct _RECTL rcl;
    unsigned long offDx;
};

struct tagACTCTXW
{
    unsigned long cbSize;
    unsigned long dwFlags;
    wchar_t * lpSource;
    unsigned int wProcessorArchitecture;
    unsigned int wLangId;
    wchar_t * lpAssemblyDirectory;
    wchar_t * lpResourceName;
    wchar_t * lpApplicationName;
    struct HINSTANCE__ * hModule;
};

struct tagMCI_ANIM_UPDATE_PARMS
{
    unsigned long dwCallback;
    struct tagRECT rc;
    struct HDC__ * hDC;
};

struct tagEMROFFSETCLIPRGN
{
    struct tagEMR emr;
    struct _POINTL ptlOffset;
};

struct tagEMRPOLYLINE
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cptl;
    struct _POINTL aptl[1];
};

struct tagMCI_OVLY_LOAD_PARMSA
{
    unsigned long dwCallback;
    char * lpfilename;
    struct tagRECT rc;
};

struct tagCHARSETINFO
{
    unsigned int ciCharset;
    unsigned int ciACP;
    struct tagFONTSIGNATURE fs;
};

struct tagEMRCREATECOLORSPACEW
{
    struct tagEMR emr;
    unsigned long ihCS;
    struct tagLOGCOLORSPACEW lcs;
    unsigned long dwFlags;
    unsigned long cbData;
    unsigned int Data[1];
};

struct tagIMEMENUITEMINFOW
{
    unsigned int cbSize;
    unsigned int fType;
    unsigned int fState;
    unsigned int wID;
    struct HBITMAP__ * hbmpChecked;
    struct HBITMAP__ * hbmpUnchecked;
    unsigned long dwItemData;
    wchar_t szString[80];
    struct HBITMAP__ * hbmpItem;
};

struct $_TypeDescriptor$_extraBytes_20
{
    void * pVFTable;
    void * spare;
    char name[20];
};

struct tagACCESSTIMEOUT
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long iTimeOutMSec;
};

struct tagGCP_RESULTSW
{
    unsigned long lStructSize;
    wchar_t * lpOutString;
    unsigned int * lpOrder;
    int * lpDx;
    int * lpCaretPos;
    char * lpClass;
    wchar_t * lpGlyphs;
    unsigned int nGlyphs;
    int nMaxFit;
};

struct _IMAGE_LINENUMBER
{
    union <unnamed-type-Type>
    {
        unsigned long SymbolTableIndex;
        unsigned long VirtualAddress;
    };
    union _IMAGE_LINENUMBER::<unnamed-type-Type> Type;
    unsigned int Linenumber;
};

struct tagMCI_STATUS_PARMS
{
    unsigned long dwCallback;
    unsigned long dwReturn;
    unsigned long dwItem;
    unsigned long dwTrack;
};

struct tagEMRSETTEXTCOLOR
{
    struct tagEMR emr;
    unsigned long crColor;
};

struct tagBITMAPFILEHEADER
{
    unsigned int bfType;
    unsigned long bfSize;
    unsigned int bfReserved1;
    unsigned int bfReserved2;
    unsigned long bfOffBits;
};

struct _IMAGE_THUNK_DATA32
{
    union <unnamed-type-u1>
    {
        unsigned long ForwarderString;
        unsigned long Function;
        unsigned long Ordinal;
        unsigned long AddressOfData;
    };
    union _IMAGE_THUNK_DATA32::<unnamed-type-u1> u1;
};

struct tagTEXTMETRICA
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    unsigned int tmFirstChar;
    unsigned int tmLastChar;
    unsigned int tmDefaultChar;
    unsigned int tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
};

struct value_entA
{
    char * ve_valuename;
    unsigned long ve_valuelen;
    unsigned long ve_valueptr;
    unsigned long ve_type;
};

struct _IMAGE_ROM_HEADERS
{
    struct _IMAGE_FILE_HEADER FileHeader;
    struct _IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
};

struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION
{
    unsigned int CycleTime;
};

struct tagXFORM
{
    float eM11;
    float eM12;
    float eM21;
    float eM22;
    float eDx;
    float eDy;
};

struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
{
    unsigned long dwDataType;
    unsigned long cbData;
    unsigned int * pData;
};

struct _s__RTTICompleteObjectLocator
{
    unsigned long signature;
    unsigned long offset;
    unsigned long cdOffset;
    struct _TypeDescriptor * pTypeDescriptor;
    struct _s__RTTIClassHierarchyDescriptor * pClassDescriptor;
};

struct _FILETIME
{
    unsigned long dwLowDateTime;
    unsigned long dwHighDateTime;
};

struct _QUERY_SERVICE_CONFIGW
{
    unsigned long dwServiceType;
    unsigned long dwStartType;
    unsigned long dwErrorControl;
    wchar_t * lpBinaryPathName;
    wchar_t * lpLoadOrderGroup;
    unsigned long dwTagId;
    wchar_t * lpDependencies;
    wchar_t * lpServiceStartName;
    wchar_t * lpDisplayName;
};

struct _PROCESSOR_NUMBER
{
    unsigned int Group;
    unsigned int Number;
    unsigned int Reserved;
};

struct _SINGLE_LIST_ENTRY
{
    struct _SINGLE_LIST_ENTRY * Next;
};

struct pvalueA
{
    char * pv_valuename;
    int pv_valuelen;
    void * pv_value_context;
    unsigned long pv_type;
};

struct _wfinddata64_t
{
    unsigned int attrib;
    int time_create;
    int time_access;
    int time_write;
    int size;
    wchar_t name[260];
};

struct tagEMRSETDIBITSTODEVICE
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long xSrc;
    long ySrc;
    long cxSrc;
    long cySrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    unsigned long iUsageSrc;
    unsigned long iStartScan;
    unsigned long cScans;
};

struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
{
    unsigned long PropagationCookie;
    struct _GUID UOW;
    struct _GUID TmIdentity;
    unsigned long BufferLength;
};

struct _CONNECTDLGSTRUCTW
{
    unsigned long cbStructure;
    struct HWND__ * hwndOwner;
    struct _NETRESOURCEW * lpConnRes;
    unsigned long dwFlags;
    unsigned long dwDevNum;
};

struct POWER_ACTION_POLICY
{
    enum POWER_ACTION Action;
    unsigned long Flags;
    unsigned long EventCode;
};

struct _IMAGE_DOS_HEADER
{
    unsigned int e_magic;
    unsigned int e_cblp;
    unsigned int e_cp;
    unsigned int e_crlc;
    unsigned int e_cparhdr;
    unsigned int e_minalloc;
    unsigned int e_maxalloc;
    unsigned int e_ss;
    unsigned int e_sp;
    unsigned int e_csum;
    unsigned int e_ip;
    unsigned int e_cs;
    unsigned int e_lfarlc;
    unsigned int e_ovno;
    unsigned int e_res[4];
    unsigned int e_oemid;
    unsigned int e_oeminfo;
    unsigned int e_res2[10];
    long e_lfanew;
};

struct tagMCI_OVLY_OPEN_PARMSA
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    char * lpstrDeviceType;
    char * lpstrElementName;
    char * lpstrAlias;
    unsigned long dwStyle;
    struct HWND__ * hWndParent;
};

struct tagTOUCHINPUT
{
    long x;
    long y;
    void * hSource;
    unsigned long dwID;
    unsigned long dwFlags;
    unsigned long dwMask;
    unsigned long dwTime;
    unsigned long dwExtraInfo;
    unsigned long cxContact;
    unsigned long cyContact;
};

struct _devicemodeW
{
    wchar_t dmDeviceName[32];
    unsigned int dmSpecVersion;
    unsigned int dmDriverVersion;
    unsigned int dmSize;
    unsigned int dmDriverExtra;
    unsigned long dmFields;
    int dmOrientation;
    int dmPaperSize;
    int dmPaperLength;
    int dmPaperWidth;
    int dmScale;
    int dmCopies;
    int dmDefaultSource;
    int dmPrintQuality;
    struct _POINTL dmPosition;
    unsigned long dmDisplayOrientation;
    unsigned long dmDisplayFixedOutput;
    int dmColor;
    int dmDuplex;
    int dmYResolution;
    int dmTTOption;
    int dmCollate;
    wchar_t dmFormName[32];
    unsigned int dmLogPixels;
    unsigned long dmBitsPerPel;
    unsigned long dmPelsWidth;
    unsigned long dmPelsHeight;
    unsigned long dmDisplayFlags;
    unsigned long dmNup;
    unsigned long dmDisplayFrequency;
    unsigned long dmICMMethod;
    unsigned long dmICMIntent;
    unsigned long dmMediaType;
    unsigned long dmDitherType;
    unsigned long dmReserved1;
    unsigned long dmReserved2;
    unsigned long dmPanningWidth;
    unsigned long dmPanningHeight;
};

struct tagPOINTFX
{
    struct _FIXED x;
    struct _FIXED y;
};

struct SQuaternion
{
    float x;
    float y;
    float z;
    float w;
    void SQuaternion(struct SVector3 & ,float );
    void SQuaternion(float ,float ,float ,float );
    void SQuaternion();
    struct SQuaternion RotationX(float );
    struct SQuaternion RotationY(float );
    struct SQuaternion RotationZ(float );
    struct SQuaternion operator*(struct SQuaternion & );
    struct SVector3 GetRight();
    struct SVector3 GetForward();
    struct SVector3 GetUp();
    float LengthSqr();
    float Length();
    struct SQuaternion & Normalize();
    struct SQuaternion & Flip();
    void ToAxisAngle(struct SVector3 & ,float & );
    struct SVector3 Log();
    struct SQuaternion Exp(struct SVector3 & );
    struct SQuaternion GetConjugate();
    struct SVector3 Rotate(struct SVector3 & );
    struct SVector3 RotateBack(struct SVector3 & );
    struct SQuaternion NLerp(struct SQuaternion & ,struct SQuaternion & ,float );
    struct SQuaternion FromDir(struct SVector3 ,struct SVector3 );
    struct SVector2 GetYawPitchFromDirection(const struct SVector3 );
};

struct SQuaternion
{
    float x;
    float y;
    float z;
    float w;
    void SQuaternion(struct SVector3 & ,float );
    void SQuaternion(float ,float ,float ,float );
    void SQuaternion();
    struct SQuaternion RotationX(float );
    struct SQuaternion RotationY(float );
    struct SQuaternion RotationZ(float );
    struct SQuaternion operator*(struct SQuaternion & );
    struct SVector3 GetRight();
    struct SVector3 GetForward();
    struct SVector3 GetUp();
    float LengthSqr();
    float Length();
    struct SQuaternion & Normalize();
    struct SQuaternion & Flip();
    void ToAxisAngle(struct SVector3 & ,float & );
    struct SVector3 Log();
    struct SQuaternion Exp(struct SVector3 & );
    struct SQuaternion GetConjugate();
    struct SVector3 Rotate(struct SVector3 & );
    struct SVector3 RotateBack(struct SVector3 & );
    struct SQuaternion NLerp(struct SQuaternion & ,struct SQuaternion & ,float );
    struct SQuaternion FromDir(struct SVector3 ,struct SVector3 );
    struct SVector2 GetYawPitchFromDirection(const struct SVector3 );
};

struct tagLOGFONTW
{
    long lfHeight;
    long lfWidth;
    long lfEscapement;
    long lfOrientation;
    long lfWeight;
    unsigned int lfItalic;
    unsigned int lfUnderline;
    unsigned int lfStrikeOut;
    unsigned int lfCharSet;
    unsigned int lfOutPrecision;
    unsigned int lfClipPrecision;
    unsigned int lfQuality;
    unsigned int lfPitchAndFamily;
    wchar_t lfFaceName[32];
};

struct _s__CatchableType
{
    unsigned int properties;
    struct _TypeDescriptor * pType;
    struct _PMD thisDisplacement;
    int sizeOrOffset;
    void  ( * copyFunction)(void * );
};

struct $_s__CatchableTypeArray$_extraBytes_20
{
    int nCatchableTypes;
    struct _s__CatchableType * arrayOfCatchableTypes[5];
};

struct tagEMRNAMEDESCAPE
{
    struct tagEMR emr;
    int iEscape;
    int cbDriver;
    int cbEscData;
    unsigned int EscData[1];
};

struct _TRANSACTIONMANAGER_LOG_INFORMATION
{
    struct _GUID LogIdentity;
};

struct _CONSOLE_SELECTION_INFO
{
    unsigned long dwFlags;
    struct _COORD dwSelectionAnchor;
    struct _SMALL_RECT srSelection;
};

struct tagCOMPAREITEMSTRUCT
{
    unsigned int CtlType;
    unsigned int CtlID;
    struct HWND__ * hwndItem;
    unsigned int itemID1;
    unsigned long itemData1;
    unsigned int itemID2;
    unsigned long itemData2;
    unsigned long dwLocaleId;
};

struct tagGESTURECONFIG
{
    unsigned long dwID;
    unsigned long dwWant;
    unsigned long dwBlock;
};

struct _SYSTEM_INFO
{
    unsigned long dwOemId;
    unsigned int wProcessorArchitecture;
    unsigned int wReserved;
    unsigned long dwPageSize;
    void * lpMinimumApplicationAddress;
    void * lpMaximumApplicationAddress;
    unsigned long dwActiveProcessorMask;
    unsigned long dwNumberOfProcessors;
    unsigned long dwProcessorType;
    unsigned long dwAllocationGranularity;
    unsigned int wProcessorLevel;
    unsigned int wProcessorRevision;
};

struct val_context
{
    int valuelen;
    void * value_context;
    void * val_buff_ptr;
};

struct tagMIXERLINEW
{
    unsigned long cbStruct;
    unsigned long dwDestination;
    unsigned long dwSource;
    unsigned long dwLineID;
    unsigned long fdwLine;
    unsigned long dwUser;
    unsigned long dwComponentType;
    unsigned long cChannels;
    unsigned long cConnections;
    unsigned long cControls;
    wchar_t szShortName[16];
    wchar_t szName[64];
    struct <unnamed-type-Target>
    {
        unsigned long dwType;
        unsigned long dwDeviceID;
        unsigned int wMid;
        unsigned int wPid;
        unsigned int vDriverVersion;
        wchar_t szPname[32];
    };
    struct tagMIXERLINEW::<unnamed-type-Target> Target;
};

struct tagMIDIINCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long dwSupport;
};

struct _CONTEXT_EX
{
    struct _CONTEXT_CHUNK All;
    struct _CONTEXT_CHUNK Legacy;
    struct _CONTEXT_CHUNK XState;
};

struct HGLRC__
{
    int unused;
};

struct tagMIXERLINEA
{
    unsigned long cbStruct;
    unsigned long dwDestination;
    unsigned long dwSource;
    unsigned long dwLineID;
    unsigned long fdwLine;
    unsigned long dwUser;
    unsigned long dwComponentType;
    unsigned long cChannels;
    unsigned long cConnections;
    unsigned long cControls;
    char szShortName[16];
    char szName[64];
    struct <unnamed-type-Target>
    {
        unsigned long dwType;
        unsigned long dwDeviceID;
        unsigned int wMid;
        unsigned int wPid;
        unsigned int vDriverVersion;
        char szPname[32];
    };
    struct tagMIXERLINEA::<unnamed-type-Target> Target;
};

struct tagMIXERLINEA::<unnamed-type-Target>
{
    unsigned long dwType;
    unsigned long dwDeviceID;
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
};

struct HMENU__
{
    int unused;
};

struct tagEMREXTESCAPE
{
    struct tagEMR emr;
    int iEscape;
    int cbEscData;
    unsigned int EscData[1];
};

struct _nlsversioninfoex
{
    unsigned long dwNLSVersionInfoSize;
    unsigned long dwNLSVersion;
    unsigned long dwDefinedVersion;
    unsigned long dwEffectiveId;
    struct _GUID guidCustomVersion;
};

struct std::is_arithmetic<double> : public std::integral_constant<bool,1>
{
};

struct std::_Conditionally_enabled_hash<int,1>
{
    unsigned int operator()(int & );
};

struct std::_Conditionally_enabled_hash<int,1>
{
    unsigned int operator()(int & );
};

struct std::_String_base_types<wchar_t,std::allocator<wchar_t> >
{
};

class std::allocator<wchar_t>
{
    public wchar_t * address(wchar_t & );
    public wchar_t * address(wchar_t & );
    public void allocator<wchar_t>();
    public void deallocate(const wchar_t * ,const unsigned int );
    public wchar_t * allocate(const unsigned int ,void * );
    public wchar_t * allocate(const unsigned int );
    public unsigned int max_size();
};

struct std::_Default_allocator_traits<std::allocator<wchar_t> >
{
    wchar_t * allocate(class std::allocator<wchar_t> & ,const unsigned int ,void * );
    wchar_t * allocate(class std::allocator<wchar_t> & ,const unsigned int );
    void deallocate(class std::allocator<wchar_t> & ,const wchar_t * ,const unsigned int );
    unsigned int max_size(class std::allocator<wchar_t> & );
    class std::allocator<wchar_t> select_on_container_copy_construction(class std::allocator<wchar_t> & );
};

struct std::output_iterator_tag
{
};

struct std::aligned_union<1,std::_Generic_error_category>
{
    const unsigned int _Max_len=8;
    const unsigned int alignment_value=4;
};

struct std::_Simple_types<char>
{
};

class std::_Lockit
{
    public void _Lockit(class std::_Lockit & );
    public void _Lockit(int );
    public void _Lockit();
    public void ~_Lockit();
    private void _Lockit_ctor(class std::_Lockit * ,int );
    private void _Lockit_ctor(class std::_Lockit * );
    public void _Lockit_ctor(int );
    private void _Lockit_dtor(class std::_Lockit * );
    public void _Lockit_dtor(int );
    public class std::_Lockit & operator=(class std::_Lockit & );
    private int _Locktype;
    public void * __vecDelDtor(unsigned int );
};

class std::_Lockit
{
    public void _Lockit(class std::_Lockit & );
    public void _Lockit(int );
    public void _Lockit();
    public void ~_Lockit();
    private void _Lockit_ctor(class std::_Lockit * ,int );
    private void _Lockit_ctor(class std::_Lockit * );
    public void _Lockit_ctor(int );
    private void _Lockit_dtor(class std::_Lockit * );
    public void _Lockit_dtor(int );
    public class std::_Lockit & operator=(class std::_Lockit & );
    private int _Locktype;
    public void * __vecDelDtor(unsigned int );
};

struct std::_Add_reference<unsigned short * const &,void>
{
};

class std::basic_filebuf<char,std::char_traits<char> >
{
};

struct std::_Invoker_pmf_refwrap
{
};

enum std::float_denorm_style
{
    denorm_indeterminate=-1,
    denorm_absent=0,
    denorm_present=1
};

enum std::float_round_style
{
    round_indeterminate=-1,
    round_toward_zero=0,
    round_to_nearest=1,
    round_toward_infinity=2,
    round_toward_neg_infinity=3
};

struct std::_Num_base
{
    const enum std::float_denorm_style has_denorm=0;
    const bool has_denorm_loss=0;
    const bool has_infinity=0;
    const bool has_quiet_NaN=0;
    const bool has_signaling_NaN=0;
    const bool is_bounded=0;
    const bool is_exact=0;
    const bool is_iec559=0;
    const bool is_integer=0;
    const bool is_modulo=0;
    const bool is_signed=0;
    const bool is_specialized=0;
    const bool tinyness_before=0;
    const bool traps=0;
    const enum std::float_round_style round_style=0;
    const int digits=0;
    const int digits10=0;
    const int max_digits10=0;
    const int max_exponent=0;
    const int max_exponent10=0;
    const int min_exponent=0;
    const int min_exponent10=0;
    const int radix=0;
};

struct std::hash<std::error_condition>
{
    unsigned int operator()(class std::error_condition & );
};

class std::error_condition
{
    public void error_condition(int ,class std::error_category & );
    public void error_condition();
    public void assign(int ,class std::error_category & );
    public void clear();
    public int value();
    public class std::error_category & category();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message();
    public bool operator bool();
    private int _Myval;
    private class std::error_category * _Mycat;
};

struct std::hash<std::error_condition>
{
    unsigned int operator()(class std::error_condition & );
};

class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > : public std::basic_ios<wchar_t,std::char_traits<wchar_t> >
{
    public void basic_ostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_ostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * );
    public void basic_ostream<wchar_t,std::char_traits<wchar_t> >(enum std::_Uninitialized ,bool );
    public void basic_ostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,bool );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    protected class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * );
    protected void swap(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_ostream<wchar_t,std::char_traits<wchar_t> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool opfx();
    public void osfx();
    public void _Osfx();
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(void * );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(float );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(float );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(float );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned long );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(long );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(bool );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & put(wchar_t );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & write(wchar_t * ,int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & flush();
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & seekp(int ,int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & seekp(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellp();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base
{
};

class std::basic_ostream<wchar_t,std::char_traits<wchar_t> >::sentry
{
};

class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > : public std::basic_ios<wchar_t,std::char_traits<wchar_t> >
{
    public void basic_ostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_ostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * );
    public void basic_ostream<wchar_t,std::char_traits<wchar_t> >(enum std::_Uninitialized ,bool );
    public void basic_ostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,bool );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    protected class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * );
    protected void swap(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_ostream<wchar_t,std::char_traits<wchar_t> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool opfx();
    public void osfx();
    public void _Osfx();
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(void * );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(float );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(float );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(float );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned long );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(long );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(unsigned int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(bool );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & operator<<(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & put(wchar_t );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & write(wchar_t * ,int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & flush();
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & seekp(int ,int );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & seekp(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellp();
    public void * __vecDelDtor(unsigned int );
};

struct std::is_object<char> : public std::integral_constant<bool,1>
{
};

struct std::is_error_condition_enum<enum std::errc> : public std::integral_constant<bool,1>
{
};

struct std::is_signed<char const > : public std::integral_constant<bool,1>
{
};

struct std::hash<float>
{
    unsigned int operator()(const float );
};

struct std::hash<float>
{
    unsigned int operator()(const float );
};

struct std::_Is_integral<unsigned long> : public std::integral_constant<bool,1>
{
};

class std::basic_ofstream<char,std::char_traits<char> >
{
};

struct std::_Get_deleter_pointer_type<std::_Facet_base,std::default_delete<std::_Facet_base>,void>
{
};

struct std::_Change_sign<long>
{
};

struct std::_Is_integral<wchar_t> : public std::integral_constant<bool,1>
{
};

struct std::less<void>
{
};

struct std::hash<int> : public std::_Conditionally_enabled_hash<int,1>
{
    unsigned int _Do_hash(int & );
};

struct std::_Is_integral<long> : public std::integral_constant<bool,1>
{
};

struct std::integral_constant<unsigned int,0>
{
    const unsigned int value=0;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

struct std::integral_constant<unsigned int,0>
{
    const unsigned int value=0;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

struct std::_Num_int_base : public std::_Num_base
{
    const bool is_bounded=1;
    const bool is_exact=1;
    const bool is_integer=1;
    const bool is_specialized=1;
    const int radix=2;
};

struct std::is_error_code_enum<unsigned int> : public std::integral_constant<bool,0>
{
};

class std::ctype<wchar_t> : public std::ctype_base
{
    public wchar_t * is(wchar_t * ,wchar_t * ,int * );
    public bool is(int ,wchar_t );
    public wchar_t * scan_is(int ,wchar_t * ,wchar_t * );
    public wchar_t * scan_not(int ,wchar_t * ,wchar_t * );
    public wchar_t * tolower(wchar_t * ,wchar_t * );
    public wchar_t tolower(wchar_t );
    public wchar_t * toupper(wchar_t * ,wchar_t * );
    public wchar_t toupper(wchar_t );
    public char * widen(char * ,char * ,wchar_t * );
    public wchar_t widen(char );
    public wchar_t * narrow(wchar_t * ,wchar_t * ,char ,char * );
    public char narrow(wchar_t ,char );
    public class std::locale::id id;
    public void ctype<wchar_t>(class std::_Locinfo & ,unsigned int );
    public void ctype<wchar_t>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~ctype<wchar_t>();
    protected void _Init(class std::_Locinfo & );
    protected wchar_t * do_is(wchar_t * ,wchar_t * ,int * );
    protected bool do_is(int ,wchar_t );
    protected wchar_t * do_scan_is(int ,wchar_t * ,wchar_t * );
    protected wchar_t * do_scan_not(int ,wchar_t * ,wchar_t * );
    protected wchar_t * do_tolower(wchar_t * ,wchar_t * );
    protected wchar_t do_tolower(wchar_t );
    protected wchar_t * do_toupper(wchar_t * ,wchar_t * );
    protected wchar_t do_toupper(wchar_t );
    protected wchar_t _Dowiden(char );
    protected char * do_widen(char * ,char * ,wchar_t * );
    protected wchar_t do_widen(char );
    protected char _Donarrow(wchar_t ,char );
    protected wchar_t * do_narrow(wchar_t * ,wchar_t * ,char ,char * );
    protected char do_narrow(wchar_t ,char );
    private struct _Ctypevec _Ctype;
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::_Locinfo
{
    public void _Locinfo_ctor(class std::_Locinfo * ,int ,char * );
    public void _Locinfo_ctor(class std::_Locinfo * ,char * );
    public void _Locinfo_dtor(class std::_Locinfo * );
    public class std::_Locinfo & _Locinfo_Addcats(class std::_Locinfo * ,int ,char * );
    public void _Locinfo(class std::_Locinfo & );
    public void _Locinfo(int ,char * );
    public void _Locinfo(char * );
    public void ~_Locinfo();
    public class std::_Locinfo & _Addcats(int ,char * );
    public char * _Getname();
    public struct _Collvec _Getcoll();
    public struct _Ctypevec _Getctype();
    public struct _Cvtvec _Getcvt();
    public struct lconv * _Getlconv();
    public class std::_Timevec _Gettnames();
    public char * _Getdays();
    public char * _Getmonths();
    public char * _Getfalse();
    public char * _Gettrue();
    public int _Getdateorder();
    public class std::_Timevec _W_Gettnames();
    public unsigned int * _W_Getdays();
    public unsigned int * _W_Getmonths();
    public class std::_Locinfo & operator=(class std::_Locinfo & );
    private class std::_Lockit _Lock;
    private class std::_Yarn<char> _Days;
    private class std::_Yarn<char> _Months;
    private class std::_Yarn<wchar_t> _W_Days;
    private class std::_Yarn<wchar_t> _W_Months;
    private class std::_Yarn<char> _Oldlocname;
    private class std::_Yarn<char> _Newlocname;
    public void __dflt_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::locale::facet : public std::_Facet_base, public std::_Crt_new_delete
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public void _Incref();
    public class std::_Facet_base * _Decref();
    private unsigned long _Myrefs;
    public void facet(class std::locale::facet & );
    protected void facet(unsigned int );
    protected void ~facet();
    public class std::locale::facet & operator=(class std::locale::facet & );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::locale : public std::_Locbase<int>, public std::_Crt_new_delete
{
    class id
    {
        public void id(class std::locale::id & );
        public void id(unsigned int );
        public unsigned int operator unsigned int();
        private unsigned int _Id;
        private int _Id_cnt;
        public class std::locale::id & operator=(class std::locale::id & );
        public void __dflt_ctor_closure();
    };
    class _Locimp : public std::locale::facet
    {
        protected void ~_Locimp();
        private class std::locale::_Locimp * _New_Locimp(class std::locale::_Locimp & );
        private class std::locale::_Locimp * _New_Locimp(bool );
        private void _Locimp_dtor(class std::locale::_Locimp * );
        private void _Locimp_Addfac(class std::locale::_Locimp * ,class std::locale::facet * ,unsigned int );
        private void _Locimp_ctor(class std::locale::_Locimp * ,class std::locale::_Locimp & );
        private void _Locimp(class std::locale::_Locimp & );
        private void _Locimp(bool );
        private void _Addfac(class std::locale::facet * ,unsigned int );
        private class std::locale::_Locimp * _Makeloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makewloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makeushloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makexloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private class std::locale::facet ** _Facetvec;
        private unsigned int _Facetcount;
        private int _Catmask;
        private bool _Xparent;
        private class std::_Yarn<char> _Name;
        private class std::locale::_Locimp * _Clocptr;
        public class std::locale::_Locimp & operator=(class std::locale::_Locimp & );
        protected void * __vecDelDtor(unsigned int );
    };
    class facet : public std::_Facet_base, public std::_Crt_new_delete
    {
        public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
        public void _Incref();
        public class std::_Facet_base * _Decref();
        private unsigned long _Myrefs;
        public void facet(class std::locale::facet & );
        protected void facet(unsigned int );
        protected void ~facet();
        public class std::locale::facet & operator=(class std::locale::facet & );
        public void __dflt_ctor_closure();
        public void __local_vftable_ctor_closure();
        protected void * __vecDelDtor(unsigned int );
    };
    private void locale(class std::locale::_Locimp * );
    public void locale(class std::locale & ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void locale(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void locale(class std::locale & ,char * ,int );
    public void locale(char * ,int );
    public void locale(class std::locale & ,class std::locale & ,int );
    public void locale();
    public void locale(class std::locale & );
    public void locale(enum std::_Uninitialized );
    private void _Construct(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void ~locale();
    public class std::locale & operator=(class std::locale & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > name();
    public char * c_str();
    public class std::locale::facet * _Getfacet(unsigned int );
    public bool operator==(class std::locale & );
    public bool operator!=(class std::locale & );
    public class std::locale & classic();
    public class std::locale global(class std::locale & );
    public class std::locale empty();
    private class std::locale::_Locimp * _Init(bool );
    private class std::locale::_Locimp * _Getgloballocale();
    private void _Setgloballocale(void * );
    private bool _Badname(class std::_Locinfo & );
    private class std::locale::_Locimp * _Ptr;
    public void * __vecDelDtor(unsigned int );
};

class std::ctype<wchar_t> : public std::ctype_base
{
    public wchar_t * is(wchar_t * ,wchar_t * ,int * );
    public bool is(int ,wchar_t );
    public wchar_t * scan_is(int ,wchar_t * ,wchar_t * );
    public wchar_t * scan_not(int ,wchar_t * ,wchar_t * );
    public wchar_t * tolower(wchar_t * ,wchar_t * );
    public wchar_t tolower(wchar_t );
    public wchar_t * toupper(wchar_t * ,wchar_t * );
    public wchar_t toupper(wchar_t );
    public char * widen(char * ,char * ,wchar_t * );
    public wchar_t widen(char );
    public wchar_t * narrow(wchar_t * ,wchar_t * ,char ,char * );
    public char narrow(wchar_t ,char );
    public class std::locale::id id;
    public void ctype<wchar_t>(class std::_Locinfo & ,unsigned int );
    public void ctype<wchar_t>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~ctype<wchar_t>();
    protected void _Init(class std::_Locinfo & );
    protected wchar_t * do_is(wchar_t * ,wchar_t * ,int * );
    protected bool do_is(int ,wchar_t );
    protected wchar_t * do_scan_is(int ,wchar_t * ,wchar_t * );
    protected wchar_t * do_scan_not(int ,wchar_t * ,wchar_t * );
    protected wchar_t * do_tolower(wchar_t * ,wchar_t * );
    protected wchar_t do_tolower(wchar_t );
    protected wchar_t * do_toupper(wchar_t * ,wchar_t * );
    protected wchar_t do_toupper(wchar_t );
    protected wchar_t _Dowiden(char );
    protected char * do_widen(char * ,char * ,wchar_t * );
    protected wchar_t do_widen(char );
    protected char _Donarrow(wchar_t ,char );
    protected wchar_t * do_narrow(wchar_t * ,wchar_t * ,char ,char * );
    protected char do_narrow(wchar_t ,char );
    private struct _Ctypevec _Ctype;
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::_System_error_category : public std::error_category
{
    public void _System_error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public class std::error_condition default_error_condition(int );
    public void ~_System_error_category();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_System_error_category : public std::error_category
{
    public void _System_error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public class std::error_condition default_error_condition(int );
    public void ~_System_error_category();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::make_unsigned<unsigned int>
{
};

class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
{
    protected void basic_streambuf<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_streambuf<wchar_t,std::char_traits<wchar_t> >(enum std::_Uninitialized );
    protected void basic_streambuf<wchar_t,std::char_traits<wchar_t> >();
    protected class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    protected void swap(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_streambuf<wchar_t,std::char_traits<wchar_t> >();
    public class std::fpos<_Mbstatet> pubseekoff(int ,unsigned int ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekoff(int ,int ,int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,int );
    public class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * pubsetbuf(wchar_t * ,int );
    public class std::locale pubimbue(class std::locale & );
    public class std::locale getloc();
    public int in_avail();
    public int pubsync();
    public unsigned int sbumpc();
    public unsigned int sgetc();
    public int sgetn(wchar_t * ,int );
    public unsigned int snextc();
    public unsigned int sputbackc(wchar_t );
    public void stossc();
    public unsigned int sungetc();
    public unsigned int sputc(wchar_t );
    public int sputn(wchar_t * ,int );
    public void _Lock();
    public void _Unlock();
    protected wchar_t * eback();
    protected wchar_t * gptr();
    protected wchar_t * pbase();
    protected wchar_t * pptr();
    protected wchar_t * egptr();
    protected void gbump(int );
    protected void setg(wchar_t * ,wchar_t * ,wchar_t * );
    protected wchar_t * epptr();
    protected wchar_t * _Gndec();
    protected wchar_t * _Gninc();
    protected wchar_t * _Gnpreinc();
    protected int _Gnavail();
    protected void pbump(int );
    protected void setp(wchar_t * ,wchar_t * ,wchar_t * );
    protected void setp(wchar_t * ,wchar_t * );
    protected wchar_t * _Pninc();
    protected int _Pnavail();
    protected void _Init(wchar_t ** ,wchar_t ** ,int * ,wchar_t ** ,wchar_t ** ,int * );
    protected void _Init();
    protected unsigned int overflow(unsigned int );
    protected unsigned int pbackfail(unsigned int );
    protected int showmanyc();
    protected unsigned int underflow();
    protected unsigned int uflow();
    protected int xsgetn(wchar_t * ,int );
    protected int xsputn(wchar_t * ,int );
    protected class std::fpos<_Mbstatet> seekoff(int ,int ,int );
    protected class std::fpos<_Mbstatet> seekpos(class std::fpos<_Mbstatet> ,int );
    protected class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * setbuf(wchar_t * ,int );
    protected int sync();
    protected void imbue(class std::locale & );
    private wchar_t * _Gfirst;
    private wchar_t * _Pfirst;
    private wchar_t ** _IGfirst;
    private wchar_t ** _IPfirst;
    private wchar_t * _Gnext;
    private wchar_t * _Pnext;
    private wchar_t ** _IGnext;
    private wchar_t ** _IPnext;
    private int _Gcount;
    private int _Pcount;
    private int * _IGcount;
    private int * _IPcount;
    protected class std::locale * _Plocale;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> >
{
    protected void basic_streambuf<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_streambuf<wchar_t,std::char_traits<wchar_t> >(enum std::_Uninitialized );
    protected void basic_streambuf<wchar_t,std::char_traits<wchar_t> >();
    protected class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    protected void swap(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_streambuf<wchar_t,std::char_traits<wchar_t> >();
    public class std::fpos<_Mbstatet> pubseekoff(int ,unsigned int ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekoff(int ,int ,int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,int );
    public class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * pubsetbuf(wchar_t * ,int );
    public class std::locale pubimbue(class std::locale & );
    public class std::locale getloc();
    public int in_avail();
    public int pubsync();
    public unsigned int sbumpc();
    public unsigned int sgetc();
    public int sgetn(wchar_t * ,int );
    public unsigned int snextc();
    public unsigned int sputbackc(wchar_t );
    public void stossc();
    public unsigned int sungetc();
    public unsigned int sputc(wchar_t );
    public int sputn(wchar_t * ,int );
    public void _Lock();
    public void _Unlock();
    protected wchar_t * eback();
    protected wchar_t * gptr();
    protected wchar_t * pbase();
    protected wchar_t * pptr();
    protected wchar_t * egptr();
    protected void gbump(int );
    protected void setg(wchar_t * ,wchar_t * ,wchar_t * );
    protected wchar_t * epptr();
    protected wchar_t * _Gndec();
    protected wchar_t * _Gninc();
    protected wchar_t * _Gnpreinc();
    protected int _Gnavail();
    protected void pbump(int );
    protected void setp(wchar_t * ,wchar_t * ,wchar_t * );
    protected void setp(wchar_t * ,wchar_t * );
    protected wchar_t * _Pninc();
    protected int _Pnavail();
    protected void _Init(wchar_t ** ,wchar_t ** ,int * ,wchar_t ** ,wchar_t ** ,int * );
    protected void _Init();
    protected unsigned int overflow(unsigned int );
    protected unsigned int pbackfail(unsigned int );
    protected int showmanyc();
    protected unsigned int underflow();
    protected unsigned int uflow();
    protected int xsgetn(wchar_t * ,int );
    protected int xsputn(wchar_t * ,int );
    protected class std::fpos<_Mbstatet> seekoff(int ,int ,int );
    protected class std::fpos<_Mbstatet> seekpos(class std::fpos<_Mbstatet> ,int );
    protected class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * setbuf(wchar_t * ,int );
    protected int sync();
    protected void imbue(class std::locale & );
    private wchar_t * _Gfirst;
    private wchar_t * _Pfirst;
    private wchar_t ** _IGfirst;
    private wchar_t ** _IPfirst;
    private wchar_t * _Gnext;
    private wchar_t * _Pnext;
    private wchar_t ** _IGnext;
    private wchar_t ** _IPnext;
    private int _Gcount;
    private int _Pcount;
    private int * _IGcount;
    private int * _IPcount;
    protected class std::locale * _Plocale;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Iterator_traits_pointer_base<char,1>
{
};

struct std::is_reference<char> : public std::integral_constant<bool,0>
{
};

class std::basic_filebuf<wchar_t,std::char_traits<wchar_t> >
{
};

struct std::piecewise_construct_t
{
};

struct std::_Is_character<char> : public std::integral_constant<bool,1>
{
};

struct std::allocator_traits<std::allocator<wchar_t> > : public std::_Default_allocator_traits<std::allocator<wchar_t> >
{
};

class std::basic_stringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
{
};

class std::bad_cast : public std::exception
{
    public void bad_cast(class std::bad_cast * );
    public void bad_cast(class std::bad_cast & );
    private void bad_cast(const char * ,int );
    public void bad_cast();
    public class std::bad_cast __construct_from_string_literal(const char * );
    public void ~bad_cast();
    public class std::bad_cast & operator=(class std::bad_cast * );
    public class std::bad_cast & operator=(class std::bad_cast & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_cast : public std::exception
{
    public void bad_cast(class std::bad_cast * );
    public void bad_cast(class std::bad_cast & );
    private void bad_cast(const char * ,int );
    public void bad_cast();
    public class std::bad_cast __construct_from_string_literal(const char * );
    public void ~bad_cast();
    public class std::bad_cast & operator=(class std::bad_cast * );
    public class std::bad_cast & operator=(class std::bad_cast & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::equal_to<void>
{
};

struct std::make_unsigned<__int64>
{
};

struct std::_Trivially_copyable_ptr_iterator_tag : public std::_General_ptr_iterator_tag
{
};

struct std::is_error_condition_enum<std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > : public std::integral_constant<bool,0>
{
};

class std::numeric_limits<double> : public std::_Num_float_base
{
    public float min();
    public float max();
    public float lowest();
    public float epsilon();
    public float round_error();
    public float denorm_min();
    public float infinity();
    public float quiet_NaN();
    public float signaling_NaN();
    public const int digits=53;
    public const int digits10=15;
    public const int max_digits10=17;
    public const int max_exponent=1024;
    public const int max_exponent10=308;
    public const int min_exponent=-1021;
    public const int min_exponent10=-307;
};

class std::basic_streambuf<char,std::char_traits<char> >
{
    protected void basic_streambuf<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > & );
    protected void basic_streambuf<char,std::char_traits<char> >(enum std::_Uninitialized );
    protected void basic_streambuf<char,std::char_traits<char> >();
    protected class std::basic_streambuf<char,std::char_traits<char> > & operator=(class std::basic_streambuf<char,std::char_traits<char> > & );
    protected void swap(class std::basic_streambuf<char,std::char_traits<char> > & );
    public void ~basic_streambuf<char,std::char_traits<char> >();
    public class std::fpos<_Mbstatet> pubseekoff(int ,unsigned int ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekoff(int ,int ,int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,int );
    public class std::basic_streambuf<char,std::char_traits<char> > * pubsetbuf(char * ,int );
    public class std::locale pubimbue(class std::locale & );
    public class std::locale getloc();
    public int in_avail();
    public int pubsync();
    public int sbumpc();
    public int sgetc();
    public int sgetn(char * ,int );
    public int snextc();
    public int sputbackc(char );
    public void stossc();
    public int sungetc();
    public int sputc(char );
    public int sputn(char * ,int );
    public void _Lock();
    public void _Unlock();
    protected char * eback();
    protected char * gptr();
    protected char * pbase();
    protected char * pptr();
    protected char * egptr();
    protected void gbump(int );
    protected void setg(char * ,char * ,char * );
    protected char * epptr();
    protected char * _Gndec();
    protected char * _Gninc();
    protected char * _Gnpreinc();
    protected int _Gnavail();
    protected void pbump(int );
    protected void setp(char * ,char * ,char * );
    protected void setp(char * ,char * );
    protected char * _Pninc();
    protected int _Pnavail();
    protected void _Init(char ** ,char ** ,int * ,char ** ,char ** ,int * );
    protected void _Init();
    protected int overflow(int );
    protected int pbackfail(int );
    protected int showmanyc();
    protected int underflow();
    protected int uflow();
    protected int xsgetn(char * ,int );
    protected int xsputn(char * ,int );
    protected class std::fpos<_Mbstatet> seekoff(int ,int ,int );
    protected class std::fpos<_Mbstatet> seekpos(class std::fpos<_Mbstatet> ,int );
    protected class std::basic_streambuf<char,std::char_traits<char> > * setbuf(char * ,int );
    protected int sync();
    protected void imbue(class std::locale & );
    private char * _Gfirst;
    private char * _Pfirst;
    private char ** _IGfirst;
    private char ** _IPfirst;
    private char * _Gnext;
    private char * _Pnext;
    private char ** _IGnext;
    private char ** _IPnext;
    private int _Gcount;
    private int _Pcount;
    private int * _IGcount;
    private int * _IPcount;
    protected class std::locale * _Plocale;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_streambuf<char,std::char_traits<char> >
{
    protected void basic_streambuf<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > & );
    protected void basic_streambuf<char,std::char_traits<char> >(enum std::_Uninitialized );
    protected void basic_streambuf<char,std::char_traits<char> >();
    protected class std::basic_streambuf<char,std::char_traits<char> > & operator=(class std::basic_streambuf<char,std::char_traits<char> > & );
    protected void swap(class std::basic_streambuf<char,std::char_traits<char> > & );
    public void ~basic_streambuf<char,std::char_traits<char> >();
    public class std::fpos<_Mbstatet> pubseekoff(int ,unsigned int ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekoff(int ,int ,int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,unsigned int );
    public class std::fpos<_Mbstatet> pubseekpos(class std::fpos<_Mbstatet> ,int );
    public class std::basic_streambuf<char,std::char_traits<char> > * pubsetbuf(char * ,int );
    public class std::locale pubimbue(class std::locale & );
    public class std::locale getloc();
    public int in_avail();
    public int pubsync();
    public int sbumpc();
    public int sgetc();
    public int sgetn(char * ,int );
    public int snextc();
    public int sputbackc(char );
    public void stossc();
    public int sungetc();
    public int sputc(char );
    public int sputn(char * ,int );
    public void _Lock();
    public void _Unlock();
    protected char * eback();
    protected char * gptr();
    protected char * pbase();
    protected char * pptr();
    protected char * egptr();
    protected void gbump(int );
    protected void setg(char * ,char * ,char * );
    protected char * epptr();
    protected char * _Gndec();
    protected char * _Gninc();
    protected char * _Gnpreinc();
    protected int _Gnavail();
    protected void pbump(int );
    protected void setp(char * ,char * ,char * );
    protected void setp(char * ,char * );
    protected char * _Pninc();
    protected int _Pnavail();
    protected void _Init(char ** ,char ** ,int * ,char ** ,char ** ,int * );
    protected void _Init();
    protected int overflow(int );
    protected int pbackfail(int );
    protected int showmanyc();
    protected int underflow();
    protected int uflow();
    protected int xsgetn(char * ,int );
    protected int xsputn(char * ,int );
    protected class std::fpos<_Mbstatet> seekoff(int ,int ,int );
    protected class std::fpos<_Mbstatet> seekpos(class std::fpos<_Mbstatet> ,int );
    protected class std::basic_streambuf<char,std::char_traits<char> > * setbuf(char * ,int );
    protected int sync();
    protected void imbue(class std::locale & );
    private char * _Gfirst;
    private char * _Pfirst;
    private char ** _IGfirst;
    private char ** _IPfirst;
    private char * _Gnext;
    private char * _Pnext;
    private char ** _IGnext;
    private char ** _IPnext;
    private int _Gcount;
    private int _Pcount;
    private int * _IGcount;
    private int * _IPcount;
    protected class std::locale * _Plocale;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ostringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
{
};

class std::__non_rtti_object : public std::bad_typeid
{
    public class std::__non_rtti_object __construct_from_string_literal(const char * );
    public void __non_rtti_object(class std::__non_rtti_object * );
    public void __non_rtti_object(class std::__non_rtti_object & );
    private void __non_rtti_object(const char * ,int );
    public void ~__non_rtti_object();
    public class std::__non_rtti_object & operator=(class std::__non_rtti_object * );
    public class std::__non_rtti_object & operator=(class std::__non_rtti_object & );
    public void * __vecDelDtor(unsigned int );
};

class std::__non_rtti_object : public std::bad_typeid
{
    public class std::__non_rtti_object __construct_from_string_literal(const char * );
    public void __non_rtti_object(class std::__non_rtti_object * );
    public void __non_rtti_object(class std::__non_rtti_object & );
    private void __non_rtti_object(const char * ,int );
    public void ~__non_rtti_object();
    public class std::__non_rtti_object & operator=(class std::__non_rtti_object * );
    public class std::__non_rtti_object & operator=(class std::__non_rtti_object & );
    public void * __vecDelDtor(unsigned int );
};

struct std::_Is_integral<char32_t> : public std::integral_constant<bool,1>
{
};

struct std::_Is_default_allocator<std::allocator<char>,void> : public std::integral_constant<bool,1>
{
};

class std::_Winit
{
    public void _Winit();
    public void ~_Winit();
    private int _Init_cnt;
    public void * __vecDelDtor(unsigned int );
};

struct std::is_error_condition_enum<int> : public std::integral_constant<bool,0>
{
};

class std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
{
};

struct std::_Sign_base<char,1>
{
};

struct std::_Num_float_base : public std::_Num_base
{
    const enum std::float_denorm_style has_denorm=1;
    const bool has_infinity=1;
    const bool has_quiet_NaN=1;
    const bool has_signaling_NaN=1;
    const bool is_bounded=1;
    const bool is_iec559=1;
    const bool is_signed=1;
    const bool is_specialized=1;
    const enum std::float_round_style round_style=1;
    const int radix=2;
};

class std::logic_error : public std::exception
{
    public void logic_error(class std::logic_error * );
    public void logic_error(class std::logic_error & );
    public void logic_error(char * );
    public void logic_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~logic_error();
    public class std::logic_error & operator=(class std::logic_error * );
    public class std::logic_error & operator=(class std::logic_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::basic_string<char,std::char_traits<char>,std::allocator<char> > : public std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::initializer_list<char> ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const unsigned int ,const char ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const unsigned int ,const char );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * ,const unsigned int ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * ,const unsigned int );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,const unsigned int ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >();
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void _Construct(const char * ,const char * ,struct std::random_access_iterator_tag );
    public void _Construct(const char * ,const char * ,struct std::random_access_iterator_tag );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * );
    public void _Assign_rv_contents(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(class std::initializer_list<char> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const unsigned int ,const char );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,const unsigned int ,const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,unsigned int ,const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::initializer_list<char> );
    public void ~basic_string<char,std::char_traits<char>,std::allocator<char> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > end();
    public char * _Unchecked_begin();
    public char * _Unchecked_begin();
    public char * _Unchecked_end();
    public char * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > crend();
    public void shrink_to_fit();
    public char & at(const unsigned int );
    public char & at(const unsigned int );
    public char & operator[](const unsigned int );
    public char & operator[](const unsigned int );
    public void push_back(const char );
    public void pop_back();
    public char & front();
    public char & front();
    public char & back();
    public char & back();
    public char * c_str();
    public char * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const char );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const char * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const char * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<char> > & ,class std::_String_val<std::_Simple_types<char> > & );
    public void swap(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public unsigned int find(const char ,const unsigned int );
    public unsigned int find(const char * ,const unsigned int );
    public unsigned int find(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int rfind(const char ,const unsigned int );
    public unsigned int rfind(const char * ,const unsigned int );
    public unsigned int rfind(const char * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int find_first_of(const char ,const unsigned int );
    public unsigned int find_first_of(const char * ,const unsigned int );
    public unsigned int find_first_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int find_last_of(const char ,const unsigned int );
    public unsigned int find_last_of(const char * ,const unsigned int );
    public unsigned int find_last_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,unsigned int );
    public unsigned int find_first_not_of(const char ,const unsigned int );
    public unsigned int find_first_not_of(const char * ,unsigned int );
    public unsigned int find_first_not_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int find_last_not_of(const char ,const unsigned int );
    public unsigned int find_last_not_of(const char * ,const unsigned int );
    public unsigned int find_last_not_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const char * );
    public bool _Equal(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public int compare(const unsigned int ,const unsigned int ,const char * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const char * );
    public int compare(const char * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public int compare(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::allocator<char> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

class std::logic_error : public std::exception
{
    public void logic_error(class std::logic_error * );
    public void logic_error(class std::logic_error & );
    public void logic_error(char * );
    public void logic_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~logic_error();
    public class std::logic_error & operator=(class std::logic_error * );
    public class std::logic_error & operator=(class std::logic_error & );
    public void * __vecDelDtor(unsigned int );
};

struct std::is_error_code_enum<std::istreambuf_iterator<char,std::char_traits<char> > > : public std::integral_constant<bool,0>
{
};

struct std::_Simple_types<wchar_t>
{
};

struct std::_Change_sign<int>
{
};

enum std::pointer_safety
{
    relaxed=0,
    preferred=1,
    strict=2
};

struct std::char_traits<char32_t> : public std::_Char_traits<char32_t,unsigned int>
{
};

class std::locale : public std::_Locbase<int>, public std::_Crt_new_delete
{
    class id
    {
        public void id(class std::locale::id & );
        public void id(unsigned int );
        public unsigned int operator unsigned int();
        private unsigned int _Id;
        private int _Id_cnt;
        public class std::locale::id & operator=(class std::locale::id & );
        public void __dflt_ctor_closure();
    };
    class _Locimp : public std::locale::facet
    {
        protected void ~_Locimp();
        private class std::locale::_Locimp * _New_Locimp(class std::locale::_Locimp & );
        private class std::locale::_Locimp * _New_Locimp(bool );
        private void _Locimp_dtor(class std::locale::_Locimp * );
        private void _Locimp_Addfac(class std::locale::_Locimp * ,class std::locale::facet * ,unsigned int );
        private void _Locimp_ctor(class std::locale::_Locimp * ,class std::locale::_Locimp & );
        private void _Locimp(class std::locale::_Locimp & );
        private void _Locimp(bool );
        private void _Addfac(class std::locale::facet * ,unsigned int );
        private class std::locale::_Locimp * _Makeloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makewloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makeushloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makexloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private class std::locale::facet ** _Facetvec;
        private unsigned int _Facetcount;
        private int _Catmask;
        private bool _Xparent;
        private class std::_Yarn<char> _Name;
        private class std::locale::_Locimp * _Clocptr;
        public class std::locale::_Locimp & operator=(class std::locale::_Locimp & );
        protected void * __vecDelDtor(unsigned int );
    };
    class facet : public std::_Facet_base, public std::_Crt_new_delete
    {
        public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
        public void _Incref();
        public class std::_Facet_base * _Decref();
        private unsigned long _Myrefs;
        public void facet(class std::locale::facet & );
        protected void facet(unsigned int );
        protected void ~facet();
        public class std::locale::facet & operator=(class std::locale::facet & );
        public void __dflt_ctor_closure();
        public void __local_vftable_ctor_closure();
        protected void * __vecDelDtor(unsigned int );
    };
    private void locale(class std::locale::_Locimp * );
    public void locale(class std::locale & ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void locale(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void locale(class std::locale & ,char * ,int );
    public void locale(char * ,int );
    public void locale(class std::locale & ,class std::locale & ,int );
    public void locale();
    public void locale(class std::locale & );
    public void locale(enum std::_Uninitialized );
    private void _Construct(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void ~locale();
    public class std::locale & operator=(class std::locale & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > name();
    public char * c_str();
    public class std::locale::facet * _Getfacet(unsigned int );
    public bool operator==(class std::locale & );
    public bool operator!=(class std::locale & );
    public class std::locale & classic();
    public class std::locale global(class std::locale & );
    public class std::locale empty();
    private class std::locale::_Locimp * _Init(bool );
    private class std::locale::_Locimp * _Getgloballocale();
    private void _Setgloballocale(void * );
    private bool _Badname(class std::_Locinfo & );
    private class std::locale::_Locimp * _Ptr;
    public void * __vecDelDtor(unsigned int );
};

class std::locale::facet : public std::_Facet_base, public std::_Crt_new_delete
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public void _Incref();
    public class std::_Facet_base * _Decref();
    private unsigned long _Myrefs;
    public void facet(class std::locale::facet & );
    protected void facet(unsigned int );
    protected void ~facet();
    public class std::locale::facet & operator=(class std::locale::facet & );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::locale::_Locimp : public std::locale::facet
{
    protected void ~_Locimp();
    private class std::locale::_Locimp * _New_Locimp(class std::locale::_Locimp & );
    private class std::locale::_Locimp * _New_Locimp(bool );
    private void _Locimp_dtor(class std::locale::_Locimp * );
    private void _Locimp_Addfac(class std::locale::_Locimp * ,class std::locale::facet * ,unsigned int );
    private void _Locimp_ctor(class std::locale::_Locimp * ,class std::locale::_Locimp & );
    private void _Locimp(class std::locale::_Locimp & );
    private void _Locimp(bool );
    private void _Addfac(class std::locale::facet * ,unsigned int );
    private class std::locale::_Locimp * _Makeloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private void _Makewloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private void _Makeushloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private void _Makexloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private class std::locale::facet ** _Facetvec;
    private unsigned int _Facetcount;
    private int _Catmask;
    private bool _Xparent;
    private class std::_Yarn<char> _Name;
    private class std::locale::_Locimp * _Clocptr;
    public class std::locale::_Locimp & operator=(class std::locale::_Locimp & );
    protected void * __vecDelDtor(unsigned int );
};

class std::locale::_Locimp : public std::locale::facet
{
    protected void ~_Locimp();
    private class std::locale::_Locimp * _New_Locimp(class std::locale::_Locimp & );
    private class std::locale::_Locimp * _New_Locimp(bool );
    private void _Locimp_dtor(class std::locale::_Locimp * );
    private void _Locimp_Addfac(class std::locale::_Locimp * ,class std::locale::facet * ,unsigned int );
    private void _Locimp_ctor(class std::locale::_Locimp * ,class std::locale::_Locimp & );
    private void _Locimp(class std::locale::_Locimp & );
    private void _Locimp(bool );
    private void _Addfac(class std::locale::facet * ,unsigned int );
    private class std::locale::_Locimp * _Makeloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private void _Makewloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private void _Makeushloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private void _Makexloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
    private class std::locale::facet ** _Facetvec;
    private unsigned int _Facetcount;
    private int _Catmask;
    private bool _Xparent;
    private class std::_Yarn<char> _Name;
    private class std::locale::_Locimp * _Clocptr;
    public class std::locale::_Locimp & operator=(class std::locale::_Locimp & );
    protected void * __vecDelDtor(unsigned int );
};

class std::locale::id
{
    public void id(class std::locale::id & );
    public void id(unsigned int );
    public unsigned int operator unsigned int();
    private unsigned int _Id;
    private int _Id_cnt;
    public class std::locale::id & operator=(class std::locale::id & );
    public void __dflt_ctor_closure();
};

class std::locale::id
{
    public void id(class std::locale::id & );
    public void id(unsigned int );
    public unsigned int operator unsigned int();
    private unsigned int _Id;
    private int _Id_cnt;
    public class std::locale::id & operator=(class std::locale::id & );
    public void __dflt_ctor_closure();
};

struct std::_Simple_types<char16_t>
{
};

class std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >(class std::_Locinfo & ,unsigned int );
    public void num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >(unsigned int );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,void &** );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned long & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,long & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,bool & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,void &** );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned long & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,long & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,bool & );
    private int _Getifld(char * ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,int ,class std::locale & );
    private int _Getffld(char * ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::ios_base & ,int * );
    private int _Getffldx(char * ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::ios_base & ,int * );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >(class std::_Locinfo & ,unsigned int );
    public void num_get<char,std::istreambuf_iterator<char,std::char_traits<char> > >(unsigned int );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,void &** );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned long & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,long & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<char,std::char_traits<char> > get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,bool & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,void &** );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned long & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,long & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<char,std::char_traits<char> > do_get(class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::istreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,int & ,bool & );
    private int _Getifld(char * ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,int ,class std::locale & );
    private int _Getffld(char * ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::ios_base & ,int * );
    private int _Getffldx(char * ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::istreambuf_iterator<char,std::char_traits<char> > & ,class std::ios_base & ,int * );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<bool> : public std::_Num_int_base
{
    public bool min();
    public bool max();
    public bool lowest();
    public bool epsilon();
    public bool round_error();
    public bool denorm_min();
    public bool infinity();
    public bool quiet_NaN();
    public bool signaling_NaN();
    public const int digits=1;
};

struct std::_Is_default_allocator<std::allocator<char32_t>,void> : public std::integral_constant<bool,1>
{
};

struct std::_WChar_traits<char16_t>
{
    int compare(const char16_t * ,const char16_t * ,const unsigned int );
    unsigned int length(char16_t * );
    char16_t * copy(const char16_t * ,const char16_t * ,const unsigned int );
    char16_t * _Copy_s(const char16_t * ,const unsigned int ,const char16_t * ,const unsigned int );
    char16_t * find(char16_t * ,const unsigned int ,char16_t & );
    char16_t * move(const char16_t * ,const char16_t * ,const unsigned int );
    void assign(char16_t & ,char16_t & );
    char16_t * assign(const char16_t * ,unsigned int ,char16_t );
    bool eq(char16_t & ,char16_t & );
    bool lt(char16_t & ,char16_t & );
    char16_t to_char_type(unsigned int & );
    unsigned int to_int_type(char16_t & );
    bool eq_int_type(unsigned int & ,unsigned int & );
    unsigned int not_eof(unsigned int & );
    unsigned int eof();
};

struct std::common_type<>
{
};

struct std::_Unwrappable<wchar_t *,void> : public std::integral_constant<bool,0>
{
};

class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > >
{
};

class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
{
};

class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > >
{
};

class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > : public std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::initializer_list<wchar_t> ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const unsigned int ,const wchar_t ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const unsigned int ,const wchar_t );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * ,const unsigned int ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * ,const unsigned int );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,const unsigned int ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >();
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public void _Construct(const wchar_t * ,const wchar_t * ,struct std::random_access_iterator_tag );
    public void _Construct(const wchar_t * ,const wchar_t * ,struct std::random_access_iterator_tag );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * );
    public void _Assign_rv_contents(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(class std::initializer_list<wchar_t> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const unsigned int ,const wchar_t );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,const unsigned int ,const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,unsigned int ,const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::initializer_list<wchar_t> );
    public void ~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > end();
    public wchar_t * _Unchecked_begin();
    public wchar_t * _Unchecked_begin();
    public wchar_t * _Unchecked_end();
    public wchar_t * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > crend();
    public void shrink_to_fit();
    public wchar_t & at(const unsigned int );
    public wchar_t & at(const unsigned int );
    public wchar_t & operator[](const unsigned int );
    public wchar_t & operator[](const unsigned int );
    public void push_back(const wchar_t );
    public void pop_back();
    public wchar_t & front();
    public wchar_t & front();
    public wchar_t & back();
    public wchar_t & back();
    public wchar_t * c_str();
    public wchar_t * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const wchar_t );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const wchar_t * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const wchar_t * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<wchar_t> > & ,class std::_String_val<std::_Simple_types<wchar_t> > & );
    public void swap(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public unsigned int find(const wchar_t ,const unsigned int );
    public unsigned int find(const wchar_t * ,const unsigned int );
    public unsigned int find(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int rfind(const wchar_t ,const unsigned int );
    public unsigned int rfind(const wchar_t * ,const unsigned int );
    public unsigned int rfind(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int find_first_of(const wchar_t ,const unsigned int );
    public unsigned int find_first_of(const wchar_t * ,const unsigned int );
    public unsigned int find_first_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int find_last_of(const wchar_t ,const unsigned int );
    public unsigned int find_last_of(const wchar_t * ,const unsigned int );
    public unsigned int find_last_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,unsigned int );
    public unsigned int find_first_not_of(const wchar_t ,const unsigned int );
    public unsigned int find_first_not_of(const wchar_t * ,unsigned int );
    public unsigned int find_first_not_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int find_last_not_of(const wchar_t ,const unsigned int );
    public unsigned int find_last_not_of(const wchar_t * ,const unsigned int );
    public unsigned int find_last_not_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const wchar_t * );
    public bool _Equal(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public int compare(const unsigned int ,const unsigned int ,const wchar_t * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const wchar_t * );
    public int compare(const wchar_t * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public int compare(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::allocator<wchar_t> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > : public std::_Iterator_base0
{
    public void _String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >(wchar_t * ,struct std::_Container_base0 * );
    public void _String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >();
    public wchar_t & operator*();
    public wchar_t * operator->();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator++(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator++();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator--(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator--();
    public void _Verify_offset(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator+=(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator+(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator-=(const int );
    public int operator-(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator-(const int );
    public wchar_t & operator[](const int );
    public bool operator==(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator!=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator<(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator>(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator<=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator>=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public void _Compat(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public wchar_t * _Unwrapped();
    public void _Seek_to(wchar_t * );
    public wchar_t * _Ptr;
};

class std::initializer_list<wchar_t>
{
    public void initializer_list<wchar_t>(wchar_t * ,wchar_t * );
    public void initializer_list<wchar_t>();
    public wchar_t * begin();
    public wchar_t * end();
    public unsigned int size();
    private wchar_t * _First;
    private wchar_t * _Last;
};

class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > : public std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::initializer_list<wchar_t> ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const unsigned int ,const wchar_t ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const unsigned int ,const wchar_t );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * ,const unsigned int ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(const wchar_t * ,const unsigned int );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,const unsigned int ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >();
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,class std::allocator<wchar_t> & );
    public void basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public void _Construct(const wchar_t * ,const wchar_t * ,struct std::random_access_iterator_tag );
    public void _Construct(const wchar_t * ,const wchar_t * ,struct std::random_access_iterator_tag );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator=(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & assign(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * );
    public void _Assign_rv_contents(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & operator+=(class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & append(class std::initializer_list<wchar_t> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const unsigned int ,const wchar_t );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & insert(const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::initializer_list<wchar_t> );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const wchar_t );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,const unsigned int ,const wchar_t * );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,unsigned int ,const wchar_t * ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::initializer_list<wchar_t> );
    public void ~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > end();
    public wchar_t * _Unchecked_begin();
    public wchar_t * _Unchecked_begin();
    public wchar_t * _Unchecked_end();
    public wchar_t * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > > crend();
    public void shrink_to_fit();
    public wchar_t & at(const unsigned int );
    public wchar_t & at(const unsigned int );
    public wchar_t & operator[](const unsigned int );
    public wchar_t & operator[](const unsigned int );
    public void push_back(const wchar_t );
    public void pop_back();
    public wchar_t & front();
    public wchar_t & front();
    public wchar_t & back();
    public wchar_t & back();
    public wchar_t * c_str();
    public wchar_t * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const wchar_t );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const wchar_t * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const wchar_t * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<wchar_t> > & ,class std::_String_val<std::_Simple_types<wchar_t> > & );
    public void swap(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public unsigned int find(const wchar_t ,const unsigned int );
    public unsigned int find(const wchar_t * ,const unsigned int );
    public unsigned int find(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int rfind(const wchar_t ,const unsigned int );
    public unsigned int rfind(const wchar_t * ,const unsigned int );
    public unsigned int rfind(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int find_first_of(const wchar_t ,const unsigned int );
    public unsigned int find_first_of(const wchar_t * ,const unsigned int );
    public unsigned int find_first_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int find_last_of(const wchar_t ,const unsigned int );
    public unsigned int find_last_of(const wchar_t * ,const unsigned int );
    public unsigned int find_last_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,unsigned int );
    public unsigned int find_first_not_of(const wchar_t ,const unsigned int );
    public unsigned int find_first_not_of(const wchar_t * ,unsigned int );
    public unsigned int find_first_not_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public unsigned int find_last_not_of(const wchar_t ,const unsigned int );
    public unsigned int find_last_not_of(const wchar_t * ,const unsigned int );
    public unsigned int find_last_not_of(const wchar_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int );
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const wchar_t * );
    public bool _Equal(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public int compare(const unsigned int ,const unsigned int ,const wchar_t * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const wchar_t * );
    public int compare(const wchar_t * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public int compare(class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > & );
    public class std::allocator<wchar_t> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<unsigned short> : public std::_Num_int_base
{
    public unsigned int min();
    public unsigned int max();
    public unsigned int lowest();
    public unsigned int epsilon();
    public unsigned int round_error();
    public unsigned int denorm_min();
    public unsigned int infinity();
    public unsigned int quiet_NaN();
    public unsigned int signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=16;
    public const int digits10=4;
};

struct std::_Range_verifiable<unsigned short const *,unsigned short const *,void> : public std::integral_constant<bool,0>
{
};

class std::basic_ostream<char,std::char_traits<char> > : public std::basic_ios<char,std::char_traits<char> >
{
    public void basic_ostream<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > & );
    protected void basic_ostream<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > * );
    public void basic_ostream<char,std::char_traits<char> >(enum std::_Uninitialized ,bool );
    public void basic_ostream<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * ,bool );
    public class std::basic_ostream<char,std::char_traits<char> > & operator=(class std::basic_ostream<char,std::char_traits<char> > & );
    protected class std::basic_ostream<char,std::char_traits<char> > & operator=(class std::basic_ostream<char,std::char_traits<char> > * );
    protected void swap(class std::basic_ostream<char,std::char_traits<char> > & );
    public void ~basic_ostream<char,std::char_traits<char> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool opfx();
    public void osfx();
    public void _Osfx();
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(void * );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(float );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(float );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(float );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned long );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(long );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(bool );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::basic_ios<char,std::char_traits<char> > &  ( * )(class std::basic_ios<char,std::char_traits<char> > & ));
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::basic_ostream<char,std::char_traits<char> > &  ( * )(class std::basic_ostream<char,std::char_traits<char> > & ));
    public class std::basic_ostream<char,std::char_traits<char> > & put(char );
    public class std::basic_ostream<char,std::char_traits<char> > & write(char * ,int );
    public class std::basic_ostream<char,std::char_traits<char> > & flush();
    public class std::basic_ostream<char,std::char_traits<char> > & seekp(int ,int );
    public class std::basic_ostream<char,std::char_traits<char> > & seekp(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellp();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ostream<char,std::char_traits<char> >::_Sentry_base
{
};

class std::basic_ostream<char,std::char_traits<char> >::sentry
{
};

class std::basic_ostream<char,std::char_traits<char> > : public std::basic_ios<char,std::char_traits<char> >
{
    public void basic_ostream<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > & );
    protected void basic_ostream<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > * );
    public void basic_ostream<char,std::char_traits<char> >(enum std::_Uninitialized ,bool );
    public void basic_ostream<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * ,bool );
    public class std::basic_ostream<char,std::char_traits<char> > & operator=(class std::basic_ostream<char,std::char_traits<char> > & );
    protected class std::basic_ostream<char,std::char_traits<char> > & operator=(class std::basic_ostream<char,std::char_traits<char> > * );
    protected void swap(class std::basic_ostream<char,std::char_traits<char> > & );
    public void ~basic_ostream<char,std::char_traits<char> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool opfx();
    public void osfx();
    public void _Osfx();
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(void * );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(float );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(float );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(float );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned long );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(long );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(unsigned int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(int );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(bool );
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::basic_ios<char,std::char_traits<char> > &  ( * )(class std::basic_ios<char,std::char_traits<char> > & ));
    public class std::basic_ostream<char,std::char_traits<char> > & operator<<(class std::basic_ostream<char,std::char_traits<char> > &  ( * )(class std::basic_ostream<char,std::char_traits<char> > & ));
    public class std::basic_ostream<char,std::char_traits<char> > & put(char );
    public class std::basic_ostream<char,std::char_traits<char> > & write(char * ,int );
    public class std::basic_ostream<char,std::char_traits<char> > & flush();
    public class std::basic_ostream<char,std::char_traits<char> > & seekp(int ,int );
    public class std::basic_ostream<char,std::char_traits<char> > & seekp(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellp();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Sign_base<unsigned __int64,1>
{
};

class std::overflow_error : public std::runtime_error
{
    public void overflow_error(class std::overflow_error * );
    public void overflow_error(class std::overflow_error & );
    public void overflow_error(char * );
    public void overflow_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~overflow_error();
    public class std::overflow_error & operator=(class std::overflow_error * );
    public class std::overflow_error & operator=(class std::overflow_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::overflow_error : public std::runtime_error
{
    public void overflow_error(class std::overflow_error * );
    public void overflow_error(class std::overflow_error & );
    public void overflow_error(char * );
    public void overflow_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~overflow_error();
    public class std::overflow_error & operator=(class std::overflow_error * );
    public class std::overflow_error & operator=(class std::overflow_error & );
    public void * __vecDelDtor(unsigned int );
};

struct std::is_void<void const volatile > : public std::integral_constant<bool,1>
{
};

struct std::is_error_condition_enum<std::istreambuf_iterator<char,std::char_traits<char> > > : public std::integral_constant<bool,0>
{
};

struct std::is_volatile<int> : public std::integral_constant<bool,0>
{
};

struct std::_Range_verifiable<char *,char *,void> : public std::integral_constant<bool,0>
{
};

struct std::_String_base_types<char,std::allocator<char> >
{
};

struct std::_One_then_variadic_args_t
{
};

struct std::is_error_code_enum<std::error_category> : public std::integral_constant<bool,0>
{
};

struct std::_Invoker_ret<std::_Unforced,0>
{
};

struct std::char_traits<wchar_t> : public std::_WChar_traits<wchar_t>
{
};

class std::basic_iostream<char,std::char_traits<char> > : public std::basic_istream<char,std::char_traits<char> >, public std::basic_ostream<char,std::char_traits<char> >, public std::basic_ios<char,std::char_traits<char> >
{
    public void basic_iostream<char,std::char_traits<char> >(class std::basic_iostream<char,std::char_traits<char> > & );
    protected void basic_iostream<char,std::char_traits<char> >(class std::basic_iostream<char,std::char_traits<char> > * );
    public void basic_iostream<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_iostream<char,std::char_traits<char> > & operator=(class std::basic_iostream<char,std::char_traits<char> > & );
    protected class std::basic_iostream<char,std::char_traits<char> > & operator=(class std::basic_iostream<char,std::char_traits<char> > * );
    protected void swap(class std::basic_iostream<char,std::char_traits<char> > & );
    public void ~basic_iostream<char,std::char_traits<char> >();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_iostream<char,std::char_traits<char> > : public std::basic_istream<char,std::char_traits<char> >, public std::basic_ostream<char,std::char_traits<char> >, public std::basic_ios<char,std::char_traits<char> >
{
    public void basic_iostream<char,std::char_traits<char> >(class std::basic_iostream<char,std::char_traits<char> > & );
    protected void basic_iostream<char,std::char_traits<char> >(class std::basic_iostream<char,std::char_traits<char> > * );
    public void basic_iostream<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_iostream<char,std::char_traits<char> > & operator=(class std::basic_iostream<char,std::char_traits<char> > & );
    protected class std::basic_iostream<char,std::char_traits<char> > & operator=(class std::basic_iostream<char,std::char_traits<char> > * );
    protected void swap(class std::basic_iostream<char,std::char_traits<char> > & );
    public void ~basic_iostream<char,std::char_traits<char> >();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ios<wchar_t,std::char_traits<wchar_t> > : public std::ios_base
{
    public void basic_ios<wchar_t,std::char_traits<wchar_t> >(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_ios<wchar_t,std::char_traits<wchar_t> >();
    public void basic_ios<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public void ~basic_ios<wchar_t,std::char_traits<wchar_t> >();
    public void clear(unsigned int );
    public void clear(int ,bool );
    public void setstate(unsigned int );
    public void setstate(int ,bool );
    public class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & copyfmt(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * tie(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * tie();
    public class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * rdbuf(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * rdbuf();
    public class std::locale imbue(class std::locale & );
    public wchar_t fill(wchar_t );
    public wchar_t fill();
    public char narrow(wchar_t ,char );
    public wchar_t widen(char );
    public void move(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > * );
    public void move(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public void swap(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public void set_rdbuf(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    protected void init(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,bool );
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Mystrbuf;
    private class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * _Tiestr;
    private wchar_t _Fillch;
    public class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ios<wchar_t,std::char_traits<wchar_t> > : public std::ios_base
{
    public void basic_ios<wchar_t,std::char_traits<wchar_t> >(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_ios<wchar_t,std::char_traits<wchar_t> >();
    public void basic_ios<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public void ~basic_ios<wchar_t,std::char_traits<wchar_t> >();
    public void clear(unsigned int );
    public void clear(int ,bool );
    public void setstate(unsigned int );
    public void setstate(int ,bool );
    public class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & copyfmt(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * tie(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * tie();
    public class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * rdbuf(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * rdbuf();
    public class std::locale imbue(class std::locale & );
    public wchar_t fill(wchar_t );
    public wchar_t fill();
    public char narrow(wchar_t ,char );
    public wchar_t widen(char );
    public void move(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > * );
    public void move(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public void swap(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public void set_rdbuf(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    protected void init(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,bool );
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Mystrbuf;
    private class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > * _Tiestr;
    private wchar_t _Fillch;
    public class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Is_integral<int> : public std::integral_constant<bool,1>
{
};

class std::ostreambuf_iterator<char,std::char_traits<char> >
{
    public void ostreambuf_iterator<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > & );
    public void ostreambuf_iterator<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator*();
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator++(int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator++();
    public bool failed();
    private bool _Failed;
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
};

class std::ostreambuf_iterator<char,std::char_traits<char> >
{
    public void ostreambuf_iterator<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > & );
    public void ostreambuf_iterator<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator*();
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator++(int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator++();
    public bool failed();
    private bool _Failed;
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
};

struct std::integral_constant<bool,0>
{
    const bool value=0;
    bool operator bool();
    bool operator()();
};

struct std::integral_constant<bool,0>
{
    const bool value=0;
    bool operator bool();
    bool operator()();
};

struct std::_Unique_tag_refwrap_has_ctor_from
{
};

struct std::is_floating_point<double> : public std::integral_constant<bool,1>
{
};

class std::_String_iterator<std::_String_val<std::_Simple_types<char> > >
{
};

class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
{
};

class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > >
{
};

class std::allocator<char>
{
    public char * address(char & );
    public char * address(char & );
    public void allocator<char>();
    public void deallocate(const char * ,const unsigned int );
    public char * allocate(const unsigned int ,void * );
    public char * allocate(const unsigned int );
    public unsigned int max_size();
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > : public std::_Iterator_base0
{
    public void _String_const_iterator<std::_String_val<std::_Simple_types<char> > >(char * ,struct std::_Container_base0 * );
    public void _String_const_iterator<std::_String_val<std::_Simple_types<char> > >();
    public char & operator*();
    public char * operator->();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator++(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator++();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator--(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator--();
    public void _Verify_offset(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator+=(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator+(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator-=(const int );
    public int operator-(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator-(const int );
    public char & operator[](const int );
    public bool operator==(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator!=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator<(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator>(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator<=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator>=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public void _Compat(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public char * _Unwrapped();
    public void _Seek_to(char * );
    public char * _Ptr;
};

class std::initializer_list<char>
{
    public void initializer_list<char>(char * ,char * );
    public void initializer_list<char>();
    public char * begin();
    public char * end();
    public unsigned int size();
    private char * _First;
    private char * _Last;
};

class std::basic_string<char,std::char_traits<char>,std::allocator<char> > : public std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::initializer_list<char> ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const unsigned int ,const char ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const unsigned int ,const char );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * ,const unsigned int ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(const char * ,const unsigned int );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,const unsigned int ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >();
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::allocator<char> & );
    public void basic_string<char,std::char_traits<char>,std::allocator<char> >(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void _Construct(const char * ,const char * ,struct std::random_access_iterator_tag );
    public void _Construct(const char * ,const char * ,struct std::random_access_iterator_tag );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & assign(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * );
    public void _Assign_rv_contents(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & operator+=(class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & append(class std::initializer_list<char> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const unsigned int ,const char );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & insert(const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::initializer_list<char> );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const char );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,const unsigned int ,const char * );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,unsigned int ,const char * ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::initializer_list<char> );
    public void ~basic_string<char,std::char_traits<char>,std::allocator<char> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char> > > end();
    public char * _Unchecked_begin();
    public char * _Unchecked_begin();
    public char * _Unchecked_end();
    public char * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > > crend();
    public void shrink_to_fit();
    public char & at(const unsigned int );
    public char & at(const unsigned int );
    public char & operator[](const unsigned int );
    public char & operator[](const unsigned int );
    public void push_back(const char );
    public void pop_back();
    public char & front();
    public char & front();
    public char & back();
    public char & back();
    public char * c_str();
    public char * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const char );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const char * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const char * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<char> > & ,class std::_String_val<std::_Simple_types<char> > & );
    public void swap(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public unsigned int find(const char ,const unsigned int );
    public unsigned int find(const char * ,const unsigned int );
    public unsigned int find(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int rfind(const char ,const unsigned int );
    public unsigned int rfind(const char * ,const unsigned int );
    public unsigned int rfind(const char * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int find_first_of(const char ,const unsigned int );
    public unsigned int find_first_of(const char * ,const unsigned int );
    public unsigned int find_first_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int find_last_of(const char ,const unsigned int );
    public unsigned int find_last_of(const char * ,const unsigned int );
    public unsigned int find_last_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,unsigned int );
    public unsigned int find_first_not_of(const char ,const unsigned int );
    public unsigned int find_first_not_of(const char * ,unsigned int );
    public unsigned int find_first_not_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public unsigned int find_last_not_of(const char ,const unsigned int );
    public unsigned int find_last_not_of(const char * ,const unsigned int );
    public unsigned int find_last_not_of(const char * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const char * );
    public bool _Equal(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public int compare(const unsigned int ,const unsigned int ,const char * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const char * );
    public int compare(const char * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public int compare(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public class std::allocator<char> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Range_verifiable<unsigned short *,unsigned short *,void> : public std::integral_constant<bool,0>
{
};

class std::fpos<_Mbstatet>
{
    public void fpos<_Mbstatet>(struct _Mbstatet ,int );
    public void fpos<_Mbstatet>(int );
    public void state(struct _Mbstatet );
    public struct _Mbstatet state();
    public int operator __int64();
    public int seekpos();
    public class std::fpos<_Mbstatet> operator-(int );
    public int operator-(class std::fpos<_Mbstatet> & );
    public class std::fpos<_Mbstatet> & operator+=(int );
    public class std::fpos<_Mbstatet> & operator-=(int );
    public class std::fpos<_Mbstatet> operator+(int );
    public bool operator==(class std::fpos<_Mbstatet> & );
    public bool operator!=(class std::fpos<_Mbstatet> & );
    private int _Myoff;
    private int _Fpos;
    private struct _Mbstatet _Mystate;
    public void __dflt_ctor_closure();
};

class std::fpos<_Mbstatet>
{
    public void fpos<_Mbstatet>(struct _Mbstatet ,int );
    public void fpos<_Mbstatet>(int );
    public void state(struct _Mbstatet );
    public struct _Mbstatet state();
    public int operator __int64();
    public int seekpos();
    public class std::fpos<_Mbstatet> operator-(int );
    public int operator-(class std::fpos<_Mbstatet> & );
    public class std::fpos<_Mbstatet> & operator+=(int );
    public class std::fpos<_Mbstatet> & operator-=(int );
    public class std::fpos<_Mbstatet> operator+(int );
    public bool operator==(class std::fpos<_Mbstatet> & );
    public bool operator!=(class std::fpos<_Mbstatet> & );
    private int _Myoff;
    private int _Fpos;
    private struct _Mbstatet _Mystate;
    public void __dflt_ctor_closure();
};

struct std::allocator_arg_t
{
};

class std::allocator<std::_Container_proxy>
{
};

struct std::allocator_traits<std::allocator<std::_Container_proxy> >
{
};

class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > >
{
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > >
{
};

enum std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=8
};

enum std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=7
};

class std::allocator<char16_t>
{
    public char16_t * address(char16_t & );
    public char16_t * address(char16_t & );
    public void allocator<char16_t>();
    public void deallocate(const char16_t * ,const unsigned int );
    public char16_t * allocate(const unsigned int ,void * );
    public char16_t * allocate(const unsigned int );
    public unsigned int max_size();
};

class std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char16_t _Buf[8];
        char16_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public void _String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >();
    public void _Copy_alloc(class std::allocator<char16_t> & );
    public void _Move_alloc(class std::allocator<char16_t> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > > & );
    public class std::allocator<char16_t> & _Getal();
    public class std::allocator<char16_t> & _Getal();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_data();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_val<std::_Simple_types<char16_t> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<char16_t> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public char16_t * _Myptr();
    public char16_t * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char16_t _Buf[8];
        char16_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<char16_t> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<char16_t> >();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char16_t _Buf[8];
        char16_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public void _String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >();
    public void _Copy_alloc(class std::allocator<char16_t> & );
    public void _Move_alloc(class std::allocator<char16_t> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > > & );
    public class std::allocator<char16_t> & _Getal();
    public class std::allocator<char16_t> & _Getal();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_data();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Aligned<8,4,short,0>
{
};

class std::numeric_limits<unsigned __int64> : public std::_Num_int_base
{
    public unsigned int min();
    public unsigned int max();
    public unsigned int lowest();
    public unsigned int epsilon();
    public unsigned int round_error();
    public unsigned int denorm_min();
    public unsigned int infinity();
    public unsigned int quiet_NaN();
    public unsigned int signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=64;
    public const int digits10=19;
};

struct std::owner_less<void>
{
};

struct lconv
{
    char * decimal_point;
    char * thousands_sep;
    char * grouping;
    char * int_curr_symbol;
    char * currency_symbol;
    char * mon_decimal_point;
    char * mon_thousands_sep;
    char * mon_grouping;
    char * positive_sign;
    char * negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t * _W_decimal_point;
    wchar_t * _W_thousands_sep;
    wchar_t * _W_int_curr_symbol;
    wchar_t * _W_currency_symbol;
    wchar_t * _W_mon_decimal_point;
    wchar_t * _W_mon_thousands_sep;
    wchar_t * _W_positive_sign;
    wchar_t * _W_negative_sign;
};

class std::_Locinfo
{
    public void _Locinfo_ctor(class std::_Locinfo * ,int ,char * );
    public void _Locinfo_ctor(class std::_Locinfo * ,char * );
    public void _Locinfo_dtor(class std::_Locinfo * );
    public class std::_Locinfo & _Locinfo_Addcats(class std::_Locinfo * ,int ,char * );
    public void _Locinfo(class std::_Locinfo & );
    public void _Locinfo(int ,char * );
    public void _Locinfo(char * );
    public void ~_Locinfo();
    public class std::_Locinfo & _Addcats(int ,char * );
    public char * _Getname();
    public struct _Collvec _Getcoll();
    public struct _Ctypevec _Getctype();
    public struct _Cvtvec _Getcvt();
    public struct lconv * _Getlconv();
    public class std::_Timevec _Gettnames();
    public char * _Getdays();
    public char * _Getmonths();
    public char * _Getfalse();
    public char * _Gettrue();
    public int _Getdateorder();
    public class std::_Timevec _W_Gettnames();
    public unsigned int * _W_Getdays();
    public unsigned int * _W_Getmonths();
    public class std::_Locinfo & operator=(class std::_Locinfo & );
    private class std::_Lockit _Lock;
    private class std::_Yarn<char> _Days;
    private class std::_Yarn<char> _Months;
    private class std::_Yarn<wchar_t> _W_Days;
    private class std::_Yarn<wchar_t> _W_Months;
    private class std::_Yarn<char> _Oldlocname;
    private class std::_Yarn<char> _Newlocname;
    public void __dflt_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_istream<char,std::char_traits<char> > : public std::basic_ios<char,std::char_traits<char> >
{
    public void basic_istream<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > & );
    protected void basic_istream<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > * );
    public void basic_istream<char,std::char_traits<char> >(enum std::_Uninitialized );
    public void basic_istream<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * ,bool );
    public class std::basic_istream<char,std::char_traits<char> > & operator=(class std::basic_istream<char,std::char_traits<char> > & );
    protected class std::basic_istream<char,std::char_traits<char> > & operator=(class std::basic_istream<char,std::char_traits<char> > * );
    protected void swap(class std::basic_istream<char,std::char_traits<char> > & );
    public void ~basic_istream<char,std::char_traits<char> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool _Ipfx(bool );
    public bool ipfx(bool );
    public void isfx();
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(void &** );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(float & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(float & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(float & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned long & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(long & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(bool & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::basic_ios<char,std::char_traits<char> > &  ( * )(class std::basic_ios<char,std::char_traits<char> > & ));
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::basic_istream<char,std::char_traits<char> > &  ( * )(class std::basic_istream<char,std::char_traits<char> > & ));
    public class std::basic_istream<char,std::char_traits<char> > & get(class std::basic_streambuf<char,std::char_traits<char> > & ,char );
    public class std::basic_istream<char,std::char_traits<char> > & get(class std::basic_streambuf<char,std::char_traits<char> > & );
    public class std::basic_istream<char,std::char_traits<char> > & get(char & );
    public class std::basic_istream<char,std::char_traits<char> > & get(char * ,int ,char );
    public class std::basic_istream<char,std::char_traits<char> > & get(char * ,int );
    public int get();
    public class std::basic_istream<char,std::char_traits<char> > & getline(char * ,int ,char );
    public class std::basic_istream<char,std::char_traits<char> > & getline(char * ,int );
    public class std::basic_istream<char,std::char_traits<char> > & ignore(int ,int );
    public class std::basic_istream<char,std::char_traits<char> > & read(char * ,int );
    public int readsome(char * ,int );
    public int peek();
    public class std::basic_istream<char,std::char_traits<char> > & putback(char );
    public class std::basic_istream<char,std::char_traits<char> > & unget();
    public int gcount();
    public int sync();
    public class std::basic_istream<char,std::char_traits<char> > & seekg(int ,int );
    public class std::basic_istream<char,std::char_traits<char> > & seekg(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellg();
    private int _Chcount;
    public void * __vecDelDtor(unsigned int );
};

class std::basic_istream<char,std::char_traits<char> >::_Sentry_base
{
};

class std::basic_istream<char,std::char_traits<char> >::sentry
{
};

class std::basic_istream<char,std::char_traits<char> > : public std::basic_ios<char,std::char_traits<char> >
{
    public void basic_istream<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > & );
    protected void basic_istream<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > * );
    public void basic_istream<char,std::char_traits<char> >(enum std::_Uninitialized );
    public void basic_istream<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * ,bool );
    public class std::basic_istream<char,std::char_traits<char> > & operator=(class std::basic_istream<char,std::char_traits<char> > & );
    protected class std::basic_istream<char,std::char_traits<char> > & operator=(class std::basic_istream<char,std::char_traits<char> > * );
    protected void swap(class std::basic_istream<char,std::char_traits<char> > & );
    public void ~basic_istream<char,std::char_traits<char> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool _Ipfx(bool );
    public bool ipfx(bool );
    public void isfx();
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(void &** );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(float & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(float & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(float & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned long & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(long & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(unsigned int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(int & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(bool & );
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::basic_ios<char,std::char_traits<char> > &  ( * )(class std::basic_ios<char,std::char_traits<char> > & ));
    public class std::basic_istream<char,std::char_traits<char> > & operator>>(class std::basic_istream<char,std::char_traits<char> > &  ( * )(class std::basic_istream<char,std::char_traits<char> > & ));
    public class std::basic_istream<char,std::char_traits<char> > & get(class std::basic_streambuf<char,std::char_traits<char> > & ,char );
    public class std::basic_istream<char,std::char_traits<char> > & get(class std::basic_streambuf<char,std::char_traits<char> > & );
    public class std::basic_istream<char,std::char_traits<char> > & get(char & );
    public class std::basic_istream<char,std::char_traits<char> > & get(char * ,int ,char );
    public class std::basic_istream<char,std::char_traits<char> > & get(char * ,int );
    public int get();
    public class std::basic_istream<char,std::char_traits<char> > & getline(char * ,int ,char );
    public class std::basic_istream<char,std::char_traits<char> > & getline(char * ,int );
    public class std::basic_istream<char,std::char_traits<char> > & ignore(int ,int );
    public class std::basic_istream<char,std::char_traits<char> > & read(char * ,int );
    public int readsome(char * ,int );
    public int peek();
    public class std::basic_istream<char,std::char_traits<char> > & putback(char );
    public class std::basic_istream<char,std::char_traits<char> > & unget();
    public int gcount();
    public int sync();
    public class std::basic_istream<char,std::char_traits<char> > & seekg(int ,int );
    public class std::basic_istream<char,std::char_traits<char> > & seekg(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellg();
    private int _Chcount;
    public void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<char16_t> : public std::_Num_int_base
{
    public char16_t min();
    public char16_t max();
    public char16_t lowest();
    public char16_t epsilon();
    public char16_t round_error();
    public char16_t denorm_min();
    public char16_t infinity();
    public char16_t quiet_NaN();
    public char16_t signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=16;
    public const int digits10=4;
};

struct std::integral_constant<bool,1>
{
    const bool value=1;
    bool operator bool();
    bool operator()();
};

struct std::integral_constant<bool,1>
{
    const bool value=1;
    bool operator bool();
    bool operator()();
};

class std::_Timevec
{
    public void _Timevec(class std::_Timevec & );
    public void _Timevec(void * );
    public void ~_Timevec();
    public class std::_Timevec & operator=(class std::_Timevec & );
    public void * _Getptr();
    private void * _Timeptr;
    public void __dflt_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_Timevec
{
    public void _Timevec(class std::_Timevec & );
    public void _Timevec(void * );
    public void ~_Timevec();
    public class std::_Timevec & operator=(class std::_Timevec & );
    public void * _Getptr();
    private void * _Timeptr;
    public void __dflt_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::is_reference<wchar_t> : public std::integral_constant<bool,0>
{
};

struct std::is_reference<std::default_delete<std::_Facet_base> > : public std::integral_constant<bool,0>
{
};

struct std::is_floating_point<float> : public std::integral_constant<bool,1>
{
};

struct std::_Aligned<8,4,char,0>
{
};

struct std::_Invoker_pmf_pointer
{
};

struct std::_Range_verifiable<char const *,char const *,void> : public std::integral_constant<bool,0>
{
};

struct std::_Container_base0
{
    void _Orphan_all();
    void _Swap_all(struct std::_Container_base0 & );
};

struct std::_Iterator_base0
{
    void _Adopt(void * );
    struct std::_Container_base0 * _Getcont();
    const bool _Unwrap_when_unverified=1;
};

struct std::_Iterator_base0
{
    void _Adopt(void * );
    struct std::_Container_base0 * _Getcont();
    const bool _Unwrap_when_unverified=1;
};

class std::codecvt<wchar_t,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,wchar_t * ,wchar_t * ,wchar_t &** );
    public int out(struct _Mbstatet & ,wchar_t * ,wchar_t * ,wchar_t &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<wchar_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<wchar_t,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<wchar_t,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,wchar_t * ,wchar_t * ,wchar_t &** );
    protected int do_out(struct _Mbstatet & ,wchar_t * ,wchar_t * ,wchar_t &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::codecvt<wchar_t,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,wchar_t * ,wchar_t * ,wchar_t &** );
    public int out(struct _Mbstatet & ,wchar_t * ,wchar_t * ,wchar_t &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<wchar_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<wchar_t,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<wchar_t,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,wchar_t * ,wchar_t * ,wchar_t &** );
    protected int do_out(struct _Mbstatet & ,wchar_t * ,wchar_t * ,wchar_t &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::allocator<char32_t>
{
    public char32_t * address(char32_t & );
    public char32_t * address(char32_t & );
    public void allocator<char32_t>();
    public void deallocate(const char32_t * ,const unsigned int );
    public char32_t * allocate(const unsigned int ,void * );
    public char32_t * allocate(const unsigned int );
    public unsigned int max_size();
};

class std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1> : private std::allocator<char32_t>
{
    private class std::_String_val<std::_Simple_types<char32_t> > _Myval2;
    public class std::allocator<char32_t> & _Get_first();
    public class std::allocator<char32_t> & _Get_first();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_second();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_val<std::_Simple_types<char32_t> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<char32_t> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=4
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=3
    };
    public char32_t * _Myptr();
    public char32_t * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char32_t _Buf[4];
        char32_t * _Ptr;
        char _Alias[4];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<char32_t> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<char32_t> >();
    public void * __vecDelDtor(unsigned int );
};

class std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1> : private std::allocator<char32_t>
{
    private class std::_String_val<std::_Simple_types<char32_t> > _Myval2;
    public class std::allocator<char32_t> & _Get_first();
    public class std::allocator<char32_t> & _Get_first();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_second();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1>();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Iterator_base12
{
    void _Iterator_base12(struct std::_Iterator_base12 & );
    void _Iterator_base12();
    struct std::_Iterator_base12 & operator=(struct std::_Iterator_base12 & );
    void ~_Iterator_base12();
    void _Adopt(struct std::_Container_base12 * );
    void _Clrcont();
    struct std::_Container_base12 * _Getcont();
    struct std::_Iterator_base12 ** _Getpnext();
    void _Orphan_me();
    const bool _Unwrap_when_unverified=1;
    struct std::_Container_proxy * _Myproxy;
    struct std::_Iterator_base12 * _Mynextiter;
    void * __vecDelDtor(unsigned int );
};

struct std::_Container_base12
{
    void _Container_base12(struct std::_Container_base12 & );
    void _Container_base12();
    struct std::_Container_base12 & operator=(struct std::_Container_base12 & );
    struct std::_Iterator_base12 ** _Getpfirst();
    void _Orphan_all();
    void _Swap_all(struct std::_Container_base12 & );
    struct std::_Container_proxy * _Myproxy;
};

struct std::_Iterator_base12
{
    void _Iterator_base12(struct std::_Iterator_base12 & );
    void _Iterator_base12();
    struct std::_Iterator_base12 & operator=(struct std::_Iterator_base12 & );
    void ~_Iterator_base12();
    void _Adopt(struct std::_Container_base12 * );
    void _Clrcont();
    struct std::_Container_base12 * _Getcont();
    struct std::_Iterator_base12 ** _Getpnext();
    void _Orphan_me();
    const bool _Unwrap_when_unverified=1;
    struct std::_Container_proxy * _Myproxy;
    struct std::_Iterator_base12 * _Mynextiter;
    void * __vecDelDtor(unsigned int );
};

class std::basic_istream<wchar_t,std::char_traits<wchar_t> > : public std::basic_ios<wchar_t,std::char_traits<wchar_t> >
{
    public void basic_istream<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_istream<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > * );
    public void basic_istream<wchar_t,std::char_traits<wchar_t> >(enum std::_Uninitialized );
    public void basic_istream<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,bool );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    protected class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > * );
    protected void swap(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_istream<wchar_t,std::char_traits<wchar_t> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool _Ipfx(bool );
    public bool ipfx(bool );
    public void isfx();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(void &** );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(float & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(float & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(float & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned long & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(long & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(bool & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & ,wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(wchar_t & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(wchar_t * ,int ,wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(wchar_t * ,int );
    public unsigned int get();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & getline(wchar_t * ,int ,wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & getline(wchar_t * ,int );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & ignore(int ,unsigned int );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & read(wchar_t * ,int );
    public int readsome(wchar_t * ,int );
    public unsigned int peek();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & putback(wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & unget();
    public int gcount();
    public int sync();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & seekg(int ,int );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & seekg(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellg();
    private int _Chcount;
    public void * __vecDelDtor(unsigned int );
};

class std::basic_istream<wchar_t,std::char_traits<wchar_t> >::_Sentry_base
{
};

class std::basic_istream<wchar_t,std::char_traits<wchar_t> >::sentry
{
};

class std::basic_istream<wchar_t,std::char_traits<wchar_t> > : public std::basic_ios<wchar_t,std::char_traits<wchar_t> >
{
    public void basic_istream<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_istream<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > * );
    public void basic_istream<wchar_t,std::char_traits<wchar_t> >(enum std::_Uninitialized );
    public void basic_istream<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,bool );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    protected class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > * );
    protected void swap(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_istream<wchar_t,std::char_traits<wchar_t> >();
    class _Sentry_base
    {
    };
    class sentry
    {
    };
    public bool _Ipfx(bool );
    public bool ipfx(bool );
    public void isfx();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(void &** );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(float & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(float & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(float & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned long & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(long & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(unsigned int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(int & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(bool & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::ios_base &  ( * )(class std::ios_base & ));
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_ios<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & operator>>(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > &  ( * )(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & ));
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & ,wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(wchar_t & );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(wchar_t * ,int ,wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & get(wchar_t * ,int );
    public unsigned int get();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & getline(wchar_t * ,int ,wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & getline(wchar_t * ,int );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & ignore(int ,unsigned int );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & read(wchar_t * ,int );
    public int readsome(wchar_t * ,int );
    public unsigned int peek();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & putback(wchar_t );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & unget();
    public int gcount();
    public int sync();
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & seekg(int ,int );
    public class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & seekg(class std::fpos<_Mbstatet> );
    public class std::fpos<_Mbstatet> tellg();
    private int _Chcount;
    public void * __vecDelDtor(unsigned int );
};

struct std::hash<std::error_code>
{
    unsigned int operator()(class std::error_code & );
};

class std::error_code
{
    public void error_code(int ,class std::error_category & );
    public void error_code();
    public void assign(int ,class std::error_category & );
    public void clear();
    public int value();
    public class std::error_category & category();
    public class std::error_condition default_error_condition();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message();
    public bool operator bool();
    private int _Myval;
    private class std::error_category * _Mycat;
};

struct std::hash<std::error_code>
{
    unsigned int operator()(class std::error_code & );
};

struct std::_Add_reference<wchar_t * const &,void>
{
};

struct std::_Default_allocator_traits<std::allocator<char32_t> >
{
    char32_t * allocate(class std::allocator<char32_t> & ,const unsigned int ,void * );
    char32_t * allocate(class std::allocator<char32_t> & ,const unsigned int );
    void deallocate(class std::allocator<char32_t> & ,const char32_t * ,const unsigned int );
    unsigned int max_size(class std::allocator<char32_t> & );
    class std::allocator<char32_t> select_on_container_copy_construction(class std::allocator<char32_t> & );
};

class std::allocator<char32_t>
{
    public char32_t * address(char32_t & );
    public char32_t * address(char32_t & );
    public void allocator<char32_t>();
    public void deallocate(const char32_t * ,const unsigned int );
    public char32_t * allocate(const unsigned int ,void * );
    public char32_t * allocate(const unsigned int );
    public unsigned int max_size();
};

struct std::_Change_sign<unsigned __int64>
{
};

struct std::_Add_reference<wchar_t * &,void>
{
};

struct std::_Is_integral<signed char> : public std::integral_constant<bool,1>
{
};

struct std::_Range_verifiable<std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >,void> : public std::integral_constant<bool,0>
{
};

struct std::char_traits<unsigned short> : public std::_WChar_traits<unsigned short>
{
};

struct std::_Really_trivial_ptr_iterator_tag : public std::_Trivially_copyable_ptr_iterator_tag
{
};

enum std::_String_val<std::_Simple_types<char32_t> >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=4
};

enum std::_String_val<std::_Simple_types<char32_t> >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=3
};

class std::_String_val<std::_Simple_types<char32_t> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<char32_t> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=4
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=3
    };
    public char32_t * _Myptr();
    public char32_t * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char32_t _Buf[4];
        char32_t * _Ptr;
        char _Alias[4];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<char32_t> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<char32_t> >();
    public void * __vecDelDtor(unsigned int );
};

union std::_String_val<std::_Simple_types<char32_t> >::_Bxty
{
    void _Bxty();
    void ~_Bxty();
    char32_t _Buf[4];
    char32_t * _Ptr;
    char _Alias[4];
    void * __vecDelDtor(unsigned int );
};

class std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1> : private std::allocator<char>
{
    private class std::_String_val<std::_Simple_types<char> > _Myval2;
    public class std::allocator<char> & _Get_first();
    public class std::allocator<char> & _Get_first();
    public class std::_String_val<std::_Simple_types<char> > & _Get_second();
    public class std::_String_val<std::_Simple_types<char> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_val<std::_Simple_types<char> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<char> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=16
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=15
    };
    public char * _Myptr();
    public char * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char _Buf[16];
        char * _Ptr;
        char _Alias[16];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<char> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<char> >();
    public void * __vecDelDtor(unsigned int );
};

class std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1> : private std::allocator<char>
{
    private class std::_String_val<std::_Simple_types<char> > _Myval2;
    public class std::allocator<char> & _Get_first();
    public class std::allocator<char> & _Get_first();
    public class std::_String_val<std::_Simple_types<char> > & _Get_second();
    public class std::_String_val<std::_Simple_types<char> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>();
    public void * __vecDelDtor(unsigned int );
};

struct std::plus<void>
{
};

struct std::_Change_sign<__int64>
{
};

struct std::hash<long double>
{
    unsigned int operator()(const float );
};

struct std::hash<long double>
{
    unsigned int operator()(const float );
};

class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > >
{
};

class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > >
{
};

class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > : public std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::initializer_list<char16_t> ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const unsigned int ,const char16_t ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const unsigned int ,const char16_t );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * ,const unsigned int ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * ,const unsigned int );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,const unsigned int ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >();
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public void _Construct(const char16_t * ,const char16_t * ,struct std::random_access_iterator_tag );
    public void _Construct(const char16_t * ,const char16_t * ,struct std::random_access_iterator_tag );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * );
    public void _Assign_rv_contents(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(class std::initializer_list<char16_t> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const unsigned int ,const char16_t );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,const unsigned int ,const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,unsigned int ,const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::initializer_list<char16_t> );
    public void ~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > end();
    public char16_t * _Unchecked_begin();
    public char16_t * _Unchecked_begin();
    public char16_t * _Unchecked_end();
    public char16_t * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > crend();
    public void shrink_to_fit();
    public char16_t & at(const unsigned int );
    public char16_t & at(const unsigned int );
    public char16_t & operator[](const unsigned int );
    public char16_t & operator[](const unsigned int );
    public void push_back(const char16_t );
    public void pop_back();
    public char16_t & front();
    public char16_t & front();
    public char16_t & back();
    public char16_t & back();
    public char16_t * c_str();
    public char16_t * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const char16_t );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const char16_t * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const char16_t * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<char16_t> > & ,class std::_String_val<std::_Simple_types<char16_t> > & );
    public void swap(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public unsigned int find(const char16_t ,const unsigned int );
    public unsigned int find(const char16_t * ,const unsigned int );
    public unsigned int find(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int rfind(const char16_t ,const unsigned int );
    public unsigned int rfind(const char16_t * ,const unsigned int );
    public unsigned int rfind(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int find_first_of(const char16_t ,const unsigned int );
    public unsigned int find_first_of(const char16_t * ,const unsigned int );
    public unsigned int find_first_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int find_last_of(const char16_t ,const unsigned int );
    public unsigned int find_last_of(const char16_t * ,const unsigned int );
    public unsigned int find_last_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,unsigned int );
    public unsigned int find_first_not_of(const char16_t ,const unsigned int );
    public unsigned int find_first_not_of(const char16_t * ,unsigned int );
    public unsigned int find_first_not_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int find_last_not_of(const char16_t ,const unsigned int );
    public unsigned int find_last_not_of(const char16_t * ,const unsigned int );
    public unsigned int find_last_not_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const char16_t * );
    public bool _Equal(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public int compare(const unsigned int ,const unsigned int ,const char16_t * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const char16_t * );
    public int compare(const char16_t * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public int compare(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::allocator<char16_t> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > >
{
};

class std::initializer_list<char16_t>
{
    public void initializer_list<char16_t>(char16_t * ,char16_t * );
    public void initializer_list<char16_t>();
    public char16_t * begin();
    public char16_t * end();
    public unsigned int size();
    private char16_t * _First;
    private char16_t * _Last;
};

class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > : public std::_String_alloc<std::_String_base_types<char16_t,std::allocator<char16_t> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::initializer_list<char16_t> ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const unsigned int ,const char16_t ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const unsigned int ,const char16_t );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * ,const unsigned int ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(const char16_t * ,const unsigned int );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,const unsigned int ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >();
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,class std::allocator<char16_t> & );
    public void basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public void _Construct(const char16_t * ,const char16_t * ,struct std::random_access_iterator_tag );
    public void _Construct(const char16_t * ,const char16_t * ,struct std::random_access_iterator_tag );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator=(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & assign(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * );
    public void _Assign_rv_contents(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & operator+=(class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & append(class std::initializer_list<char16_t> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const unsigned int ,const char16_t );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & insert(const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::initializer_list<char16_t> );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const char16_t );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,const unsigned int ,const char16_t * );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,unsigned int ,const char16_t * ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::initializer_list<char16_t> );
    public void ~basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > end();
    public char16_t * _Unchecked_begin();
    public char16_t * _Unchecked_begin();
    public char16_t * _Unchecked_end();
    public char16_t * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char16_t> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char16_t> > > > crend();
    public void shrink_to_fit();
    public char16_t & at(const unsigned int );
    public char16_t & at(const unsigned int );
    public char16_t & operator[](const unsigned int );
    public char16_t & operator[](const unsigned int );
    public void push_back(const char16_t );
    public void pop_back();
    public char16_t & front();
    public char16_t & front();
    public char16_t & back();
    public char16_t & back();
    public char16_t * c_str();
    public char16_t * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const char16_t );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const char16_t * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const char16_t * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<char16_t> > & ,class std::_String_val<std::_Simple_types<char16_t> > & );
    public void swap(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public unsigned int find(const char16_t ,const unsigned int );
    public unsigned int find(const char16_t * ,const unsigned int );
    public unsigned int find(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int rfind(const char16_t ,const unsigned int );
    public unsigned int rfind(const char16_t * ,const unsigned int );
    public unsigned int rfind(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int find_first_of(const char16_t ,const unsigned int );
    public unsigned int find_first_of(const char16_t * ,const unsigned int );
    public unsigned int find_first_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int find_last_of(const char16_t ,const unsigned int );
    public unsigned int find_last_of(const char16_t * ,const unsigned int );
    public unsigned int find_last_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,unsigned int );
    public unsigned int find_first_not_of(const char16_t ,const unsigned int );
    public unsigned int find_first_not_of(const char16_t * ,unsigned int );
    public unsigned int find_first_not_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public unsigned int find_last_not_of(const char16_t ,const unsigned int );
    public unsigned int find_last_not_of(const char16_t * ,const unsigned int );
    public unsigned int find_last_not_of(const char16_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int );
    public class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const char16_t * );
    public bool _Equal(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public int compare(const unsigned int ,const unsigned int ,const char16_t * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const char16_t * );
    public int compare(const char16_t * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public int compare(class std::basic_string<char16_t,std::char_traits<char16_t>,std::allocator<char16_t> > & );
    public class std::allocator<char16_t> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

struct std::not_equal_to<void>
{
};

class std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(class std::_Locinfo & ,unsigned int );
    public void num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(unsigned int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,void * );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned long );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,long );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,bool );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,void * );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned int );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,int );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned long );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,long );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,bool );
    private char * _Ffmt(char * ,char ,int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Fput(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,char * ,unsigned int );
    private char * _Ifmt(char * ,char * ,int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Iput(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,char * ,unsigned int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,wchar_t * ,unsigned int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Rep(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,wchar_t ,unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(class std::_Locinfo & ,unsigned int );
    public void num_put<wchar_t,std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(unsigned int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,void * );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned long );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,long );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,bool );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,void * );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,float );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned int );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,int );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,unsigned long );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,long );
    protected class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,bool );
    private char * _Ffmt(char * ,char ,int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Fput(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,char * ,unsigned int );
    private char * _Ifmt(char * ,char * ,int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Iput(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,wchar_t ,char * ,unsigned int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Put(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,wchar_t * ,unsigned int );
    private class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > _Rep(class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,wchar_t ,unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<wchar_t> : public std::_Num_int_base
{
    public wchar_t min();
    public wchar_t max();
    public wchar_t lowest();
    public wchar_t epsilon();
    public wchar_t round_error();
    public wchar_t denorm_min();
    public wchar_t infinity();
    public wchar_t quiet_NaN();
    public wchar_t signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=16;
    public const int digits10=4;
};

struct std::_Container_base0
{
    void _Orphan_all();
    void _Swap_all(struct std::_Container_base0 & );
};

struct std::hash<double>
{
    unsigned int operator()(const float );
};

struct std::hash<double>
{
    unsigned int operator()(const float );
};

struct std::make_unsigned<int>
{
};

class std::basic_ifstream<wchar_t,std::char_traits<wchar_t> >
{
};

struct std::bidirectional_iterator_tag : public std::forward_iterator_tag
{
};

class std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >(class std::_Locinfo & ,unsigned int );
    public void num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >(unsigned int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,void * );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned long );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,long );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,bool );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,void * );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned int );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,int );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned long );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,long );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,bool );
    private char * _Ffmt(char * ,char ,int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Fput(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,char * ,unsigned int );
    private char * _Ifmt(char * ,char * ,int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Iput(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,char * ,unsigned int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,char * ,unsigned int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Rep(class std::ostreambuf_iterator<char,std::char_traits<char> > ,char ,unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >(class std::_Locinfo & ,unsigned int );
    public void num_put<char,std::ostreambuf_iterator<char,std::char_traits<char> > >(unsigned int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,void * );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned long );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,long );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,bool );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,void * );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,float );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned int );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,int );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,unsigned long );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,long );
    protected class std::ostreambuf_iterator<char,std::char_traits<char> > do_put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,bool );
    private char * _Ffmt(char * ,char ,int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Fput(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,char * ,unsigned int );
    private char * _Ifmt(char * ,char * ,int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Iput(class std::ostreambuf_iterator<char,std::char_traits<char> > ,class std::ios_base & ,char ,char * ,unsigned int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Put(class std::ostreambuf_iterator<char,std::char_traits<char> > ,char * ,unsigned int );
    private class std::ostreambuf_iterator<char,std::char_traits<char> > _Rep(class std::ostreambuf_iterator<char,std::char_traits<char> > ,char ,unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::_Char_traits<char32_t,unsigned int>
{
    int compare(char32_t * ,char32_t * ,unsigned int );
    unsigned int length(char32_t * );
    char32_t * copy(const char32_t * ,char32_t * ,unsigned int );
    char32_t * _Copy_s(const char32_t * ,const unsigned int ,const char32_t * ,const unsigned int );
    char32_t * find(char32_t * ,unsigned int ,char32_t & );
    char32_t * move(const char32_t * ,char32_t * ,unsigned int );
    void assign(char32_t & ,char32_t & );
    char32_t * assign(const char32_t * ,unsigned int ,const char32_t );
    bool eq(char32_t & ,char32_t & );
    bool lt(char32_t & ,char32_t & );
    char32_t to_char_type(unsigned int & );
    unsigned int to_int_type(char32_t & );
    bool eq_int_type(unsigned int & ,unsigned int & );
    unsigned int not_eof(unsigned int & );
    unsigned int eof();
};

class std::_System_error : public std::runtime_error
{
    private class std::basic_string<char,std::char_traits<char>,std::allocator<char> > _Makestr(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > );
    public void _System_error(class std::_System_error * );
    public void _System_error(class std::_System_error & );
    protected void _System_error(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    protected class std::error_code _Mycode;
    public void ~_System_error();
    public class std::_System_error & operator=(class std::_System_error * );
    public class std::_System_error & operator=(class std::_System_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::_System_error : public std::runtime_error
{
    private class std::basic_string<char,std::char_traits<char>,std::allocator<char> > _Makestr(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > );
    public void _System_error(class std::_System_error * );
    public void _System_error(class std::_System_error & );
    protected void _System_error(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    protected class std::error_code _Mycode;
    public void ~_System_error();
    public class std::_System_error & operator=(class std::_System_error * );
    public class std::_System_error & operator=(class std::_System_error & );
    public void * __vecDelDtor(unsigned int );
};

struct std::_Invoker_pmf_object
{
};

struct std::is_error_code_enum<std::error_condition> : public std::integral_constant<bool,0>
{
};

class std::error_category
{
    public void error_category(class std::error_category & );
    public void error_category();
    public void ~error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public class std::error_condition default_error_condition(int );
    public bool equivalent(class std::error_code & ,int );
    public bool equivalent(int ,class std::error_condition & );
    public bool operator==(class std::error_category & );
    public bool operator!=(class std::error_category & );
    public bool operator<(class std::error_category & );
    public class std::error_category & operator=(class std::error_category & );
    protected unsigned int _Addr;
    enum <unnamed-enum-_Future_addr>
    {
        _Future_addr=1,
        _Generic_addr=3,
        _Iostream_addr=5,
        _System_addr=7
    };
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::error_condition
{
    public void error_condition(int ,class std::error_category & );
    public void error_condition();
    public void assign(int ,class std::error_category & );
    public void clear();
    public int value();
    public class std::error_category & category();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message();
    public bool operator bool();
    private int _Myval;
    private class std::error_category * _Mycat;
};

class std::bad_exception : public std::exception
{
    public void bad_exception(class std::bad_exception * );
    public void bad_exception(class std::bad_exception & );
    public void bad_exception();
    public void ~bad_exception();
    public class std::bad_exception & operator=(class std::bad_exception * );
    public class std::bad_exception & operator=(class std::bad_exception & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_exception : public std::exception
{
    public void bad_exception(class std::bad_exception * );
    public void bad_exception(class std::bad_exception & );
    public void bad_exception();
    public void ~bad_exception();
    public class std::bad_exception & operator=(class std::bad_exception * );
    public class std::bad_exception & operator=(class std::bad_exception & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Zero_then_variadic_args_t
{
};

struct std::is_void<void> : public std::integral_constant<bool,1>
{
};

struct std::_Change_sign<unsigned int>
{
};

class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > >
{
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > >
{
};

class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > >
{
};

class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > >
{
};

class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > : public std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::initializer_list<char32_t> ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const unsigned int ,const char32_t ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const unsigned int ,const char32_t );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * ,const unsigned int ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * ,const unsigned int );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,const unsigned int ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >();
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public void _Construct(const char32_t * ,const char32_t * ,struct std::random_access_iterator_tag );
    public void _Construct(const char32_t * ,const char32_t * ,struct std::random_access_iterator_tag );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * );
    public void _Assign_rv_contents(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(class std::initializer_list<char32_t> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const unsigned int ,const char32_t );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,const unsigned int ,const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,unsigned int ,const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::initializer_list<char32_t> );
    public void ~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > end();
    public char32_t * _Unchecked_begin();
    public char32_t * _Unchecked_begin();
    public char32_t * _Unchecked_end();
    public char32_t * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > crend();
    public void shrink_to_fit();
    public char32_t & at(const unsigned int );
    public char32_t & at(const unsigned int );
    public char32_t & operator[](const unsigned int );
    public char32_t & operator[](const unsigned int );
    public void push_back(const char32_t );
    public void pop_back();
    public char32_t & front();
    public char32_t & front();
    public char32_t & back();
    public char32_t & back();
    public char32_t * c_str();
    public char32_t * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const char32_t );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const char32_t * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const char32_t * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<char32_t> > & ,class std::_String_val<std::_Simple_types<char32_t> > & );
    public void swap(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public unsigned int find(const char32_t ,const unsigned int );
    public unsigned int find(const char32_t * ,const unsigned int );
    public unsigned int find(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int rfind(const char32_t ,const unsigned int );
    public unsigned int rfind(const char32_t * ,const unsigned int );
    public unsigned int rfind(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int find_first_of(const char32_t ,const unsigned int );
    public unsigned int find_first_of(const char32_t * ,const unsigned int );
    public unsigned int find_first_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int find_last_of(const char32_t ,const unsigned int );
    public unsigned int find_last_of(const char32_t * ,const unsigned int );
    public unsigned int find_last_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,unsigned int );
    public unsigned int find_first_not_of(const char32_t ,const unsigned int );
    public unsigned int find_first_not_of(const char32_t * ,unsigned int );
    public unsigned int find_first_not_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int find_last_not_of(const char32_t ,const unsigned int );
    public unsigned int find_last_not_of(const char32_t * ,const unsigned int );
    public unsigned int find_last_not_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const char32_t * );
    public bool _Equal(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public int compare(const unsigned int ,const unsigned int ,const char32_t * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const char32_t * );
    public int compare(const char32_t * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public int compare(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::allocator<char32_t> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > >
{
};

class std::initializer_list<char32_t>
{
    public void initializer_list<char32_t>(char32_t * ,char32_t * );
    public void initializer_list<char32_t>();
    public char32_t * begin();
    public char32_t * end();
    public unsigned int size();
    private char32_t * _First;
    private char32_t * _Last;
};

class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > : public std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >
{
    public const unsigned int _Memcpy_move_offset=0;
    public const unsigned int _Memcpy_move_size=24;
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::initializer_list<char32_t> ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const unsigned int ,const char32_t ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const unsigned int ,const char32_t );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * ,const unsigned int ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(const char32_t * ,const unsigned int );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,const unsigned int ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >();
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,class std::allocator<char32_t> & );
    public void basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public void _Construct(const char32_t * ,const char32_t * ,struct std::random_access_iterator_tag );
    public void _Construct(const char32_t * ,const char32_t * ,struct std::random_access_iterator_tag );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator=(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & assign(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * );
    public void _Assign_rv_contents(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,1> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,0> );
    public void _Assign_rv_contents_with_alloc_always_equal(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > * ,struct std::integral_constant<bool,1> );
    public void _Construct_lv_contents(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & operator+=(class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & append(class std::initializer_list<char32_t> );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const unsigned int ,const char32_t );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & insert(const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > insert(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::initializer_list<char32_t> );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,unsigned int ,const unsigned int ,const char32_t );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,const unsigned int ,const char32_t * );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,unsigned int ,const char32_t * ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const unsigned int ,const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & replace(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::initializer_list<char32_t> );
    public void ~basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> >();
    public const unsigned int npos=-1;
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > ,const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > );
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > erase(const class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & erase(const unsigned int ,unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & erase(const unsigned int );
    public void clear();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > begin();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > begin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > end();
    public class std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > end();
    public char32_t * _Unchecked_begin();
    public char32_t * _Unchecked_begin();
    public char32_t * _Unchecked_end();
    public char32_t * _Unchecked_end();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rend();
    public class std::reverse_iterator<std::_String_iterator<std::_String_val<std::_Simple_types<char32_t> > > > rend();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > cbegin();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > cend();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > crbegin();
    public class std::reverse_iterator<std::_String_const_iterator<std::_String_val<std::_Simple_types<char32_t> > > > crend();
    public void shrink_to_fit();
    public char32_t & at(const unsigned int );
    public char32_t & at(const unsigned int );
    public char32_t & operator[](const unsigned int );
    public char32_t & operator[](const unsigned int );
    public void push_back(const char32_t );
    public void pop_back();
    public char32_t & front();
    public char32_t & front();
    public char32_t & back();
    public char32_t & back();
    public char32_t * c_str();
    public char32_t * data();
    public unsigned int length();
    public unsigned int size();
    public unsigned int max_size();
    public void resize(const unsigned int ,const char32_t );
    public unsigned int capacity();
    public void reserve(const unsigned int );
    public bool empty();
    public unsigned int copy(const char32_t * ,unsigned int ,const unsigned int );
    public unsigned int _Copy_s(const char32_t * ,const unsigned int ,unsigned int ,const unsigned int );
    public void _Swap_data(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,struct std::integral_constant<bool,0> );
    public void _Swap_data(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,struct std::integral_constant<bool,1> );
    public void _Swap_bx_large_with_small(class std::_String_val<std::_Simple_types<char32_t> > & ,class std::_String_val<std::_Simple_types<char32_t> > & );
    public void swap(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public unsigned int find(const char32_t ,const unsigned int );
    public unsigned int find(const char32_t * ,const unsigned int );
    public unsigned int find(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int rfind(const char32_t ,const unsigned int );
    public unsigned int rfind(const char32_t * ,const unsigned int );
    public unsigned int rfind(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int rfind(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int find_first_of(const char32_t ,const unsigned int );
    public unsigned int find_first_of(const char32_t * ,const unsigned int );
    public unsigned int find_first_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int find_last_of(const char32_t ,const unsigned int );
    public unsigned int find_last_of(const char32_t * ,const unsigned int );
    public unsigned int find_last_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,unsigned int );
    public unsigned int find_first_not_of(const char32_t ,const unsigned int );
    public unsigned int find_first_not_of(const char32_t * ,unsigned int );
    public unsigned int find_first_not_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_first_not_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public unsigned int find_last_not_of(const char32_t ,const unsigned int );
    public unsigned int find_last_not_of(const char32_t * ,const unsigned int );
    public unsigned int find_last_not_of(const char32_t * ,const unsigned int ,const unsigned int );
    public unsigned int find_last_not_of(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int );
    public class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > substr(const unsigned int ,const unsigned int );
    public bool _Equal(const char32_t * );
    public bool _Equal(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public int compare(const unsigned int ,const unsigned int ,const char32_t * ,const unsigned int );
    public int compare(const unsigned int ,const unsigned int ,const char32_t * );
    public int compare(const char32_t * );
    public int compare(const unsigned int ,const unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & ,const unsigned int ,const unsigned int );
    public int compare(unsigned int ,unsigned int ,class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public int compare(class std::basic_string<char32_t,std::char_traits<char32_t>,std::allocator<char32_t> > & );
    public class std::allocator<char32_t> get_allocator();
    public unsigned int _Calculate_growth(const unsigned int );
    public void _Become_small();
    public void _Eos(const unsigned int );
    public void _Tidy_init();
    public void _Tidy_deallocate();
    public void _Xlen();
    public void * __vecDelDtor(unsigned int );
};

class std::invalid_argument : public std::logic_error
{
    public void invalid_argument(class std::invalid_argument * );
    public void invalid_argument(class std::invalid_argument & );
    public void invalid_argument(char * );
    public void invalid_argument(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~invalid_argument();
    public class std::invalid_argument & operator=(class std::invalid_argument * );
    public class std::invalid_argument & operator=(class std::invalid_argument & );
    public void * __vecDelDtor(unsigned int );
};

class std::invalid_argument : public std::logic_error
{
    public void invalid_argument(class std::invalid_argument * );
    public void invalid_argument(class std::invalid_argument & );
    public void invalid_argument(char * );
    public void invalid_argument(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~invalid_argument();
    public class std::invalid_argument & operator=(class std::invalid_argument * );
    public class std::invalid_argument & operator=(class std::invalid_argument & );
    public void * __vecDelDtor(unsigned int );
};

struct std::is_error_code_enum<int> : public std::integral_constant<bool,0>
{
};

class std::basic_ios<char,std::char_traits<char> > : public std::ios_base
{
    public void basic_ios<char,std::char_traits<char> >(class std::basic_ios<char,std::char_traits<char> > & );
    protected void basic_ios<char,std::char_traits<char> >();
    public void basic_ios<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public void ~basic_ios<char,std::char_traits<char> >();
    public void clear(unsigned int );
    public void clear(int ,bool );
    public void setstate(unsigned int );
    public void setstate(int ,bool );
    public class std::basic_ios<char,std::char_traits<char> > & copyfmt(class std::basic_ios<char,std::char_traits<char> > & );
    public class std::basic_ostream<char,std::char_traits<char> > * tie(class std::basic_ostream<char,std::char_traits<char> > * );
    public class std::basic_ostream<char,std::char_traits<char> > * tie();
    public class std::basic_streambuf<char,std::char_traits<char> > * rdbuf(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_streambuf<char,std::char_traits<char> > * rdbuf();
    public class std::locale imbue(class std::locale & );
    public char fill(char );
    public char fill();
    public char narrow(char ,char );
    public char widen(char );
    public void move(class std::basic_ios<char,std::char_traits<char> > * );
    public void move(class std::basic_ios<char,std::char_traits<char> > & );
    public void swap(class std::basic_ios<char,std::char_traits<char> > & );
    public void set_rdbuf(class std::basic_streambuf<char,std::char_traits<char> > * );
    protected void init(class std::basic_streambuf<char,std::char_traits<char> > * ,bool );
    private class std::basic_streambuf<char,std::char_traits<char> > * _Mystrbuf;
    private class std::basic_ostream<char,std::char_traits<char> > * _Tiestr;
    private char _Fillch;
    public class std::basic_ios<char,std::char_traits<char> > & operator=(class std::basic_ios<char,std::char_traits<char> > & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ios<char,std::char_traits<char> > : public std::ios_base
{
    public void basic_ios<char,std::char_traits<char> >(class std::basic_ios<char,std::char_traits<char> > & );
    protected void basic_ios<char,std::char_traits<char> >();
    public void basic_ios<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public void ~basic_ios<char,std::char_traits<char> >();
    public void clear(unsigned int );
    public void clear(int ,bool );
    public void setstate(unsigned int );
    public void setstate(int ,bool );
    public class std::basic_ios<char,std::char_traits<char> > & copyfmt(class std::basic_ios<char,std::char_traits<char> > & );
    public class std::basic_ostream<char,std::char_traits<char> > * tie(class std::basic_ostream<char,std::char_traits<char> > * );
    public class std::basic_ostream<char,std::char_traits<char> > * tie();
    public class std::basic_streambuf<char,std::char_traits<char> > * rdbuf(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::basic_streambuf<char,std::char_traits<char> > * rdbuf();
    public class std::locale imbue(class std::locale & );
    public char fill(char );
    public char fill();
    public char narrow(char ,char );
    public char widen(char );
    public void move(class std::basic_ios<char,std::char_traits<char> > * );
    public void move(class std::basic_ios<char,std::char_traits<char> > & );
    public void swap(class std::basic_ios<char,std::char_traits<char> > & );
    public void set_rdbuf(class std::basic_streambuf<char,std::char_traits<char> > * );
    protected void init(class std::basic_streambuf<char,std::char_traits<char> > * ,bool );
    private class std::basic_streambuf<char,std::char_traits<char> > * _Mystrbuf;
    private class std::basic_ostream<char,std::char_traits<char> > * _Tiestr;
    private char _Fillch;
    public class std::basic_ios<char,std::char_traits<char> > & operator=(class std::basic_ios<char,std::char_traits<char> > & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_Init_locks
{
    public void _Init_locks();
    public void ~_Init_locks();
    private void _Init_locks_ctor(class std::_Init_locks * );
    private void _Init_locks_dtor(class std::_Init_locks * );
    public void * __vecDelDtor(unsigned int );
};

struct std::multiplies<void>
{
};

struct std::_Iterator_traits_pointer_base<wchar_t,1>
{
};

class std::length_error : public std::logic_error
{
    public void length_error(class std::length_error * );
    public void length_error(class std::length_error & );
    public void length_error(char * );
    public void length_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~length_error();
    public class std::length_error & operator=(class std::length_error * );
    public class std::length_error & operator=(class std::length_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::length_error : public std::logic_error
{
    public void length_error(class std::length_error * );
    public void length_error(class std::length_error & );
    public void length_error(char * );
    public void length_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~length_error();
    public class std::length_error & operator=(class std::length_error * );
    public class std::length_error & operator=(class std::length_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > : public std::_Iterator_base0
{
    public void _String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >(wchar_t * ,struct std::_Container_base0 * );
    public void _String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >();
    public wchar_t & operator*();
    public wchar_t * operator->();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator++(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator++();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator--(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator--();
    public void _Verify_offset(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator+=(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator+(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator-=(const int );
    public int operator-(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator-(const int );
    public wchar_t & operator[](const int );
    public bool operator==(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator!=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator<(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator>(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator<=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator>=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public void _Compat(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public wchar_t * _Unwrapped();
    public void _Seek_to(wchar_t * );
    public wchar_t * _Ptr;
};

class std::numeric_limits<float> : public std::_Num_float_base
{
    public float min();
    public float max();
    public float lowest();
    public float epsilon();
    public float round_error();
    public float denorm_min();
    public float infinity();
    public float quiet_NaN();
    public float signaling_NaN();
    public const int digits=24;
    public const int digits10=6;
    public const int max_digits10=9;
    public const int max_exponent=128;
    public const int max_exponent10=38;
    public const int min_exponent=-125;
    public const int min_exponent10=-37;
};

struct std::make_unsigned<unsigned __int64>
{
};

class std::codecvt<char,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    public int out(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<char,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<char,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<char,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected bool do_always_noconv();
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    protected int do_out(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::codecvt<char,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    public int out(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<char,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<char,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<char,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected bool do_always_noconv();
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    protected int do_out(struct _Mbstatet & ,char * ,char * ,char &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::_Ref_count_base
{
    private void _Destroy();
    private void _Delete_this();
    private unsigned long _Uses;
    private unsigned long _Weaks;
    public void _Ref_count_base(class std::_Ref_count_base & );
    protected void _Ref_count_base();
    public void ~_Ref_count_base();
    public bool _Incref_nz();
    public void _Incref();
    public void _Incwref();
    public void _Decref();
    public void _Decwref();
    public long _Use_count();
    public void * _Get_deleter(class type_info & );
    public class std::_Ref_count_base & operator=(class std::_Ref_count_base & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class type_info
{
    public void type_info(class type_info & );
    public class type_info & operator=(class type_info & );
    public unsigned int hash_code();
    public bool operator==(class type_info & );
    public bool operator!=(class type_info & );
    public bool before(class type_info & );
    public char * name();
    public char * raw_name();
    public void ~type_info();
    private struct __std_type_info_data _Data;
    public void * __vecDelDtor(unsigned int );
};

class std::_Ref_count_base
{
    private void _Destroy();
    private void _Delete_this();
    private unsigned long _Uses;
    private unsigned long _Weaks;
    public void _Ref_count_base(class std::_Ref_count_base & );
    protected void _Ref_count_base();
    public void ~_Ref_count_base();
    public bool _Incref_nz();
    public void _Incref();
    public void _Incwref();
    public void _Decref();
    public void _Decwref();
    public long _Use_count();
    public void * _Get_deleter(class type_info & );
    public class std::_Ref_count_base & operator=(class std::_Ref_count_base & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_istringstream<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
{
};

struct std::_Is_integral<unsigned __int64> : public std::integral_constant<bool,1>
{
};

class std::exception_ptr
{
    public void exception_ptr(class std::exception_ptr & );
    public void exception_ptr(void * );
    public void exception_ptr();
    public void ~exception_ptr();
    public class std::exception_ptr & operator=(void * );
    public class std::exception_ptr & operator=(class std::exception_ptr & );
    public bool operator bool();
    public void _RethrowException();
    public class std::exception_ptr _Current_exception();
    public class std::exception_ptr _Copy_exception(void * ,void * );
    private void * _Data1;
    private void * _Data2;
    public void * __vecDelDtor(unsigned int );
};

class std::exception_ptr
{
    public void exception_ptr(class std::exception_ptr & );
    public void exception_ptr(void * );
    public void exception_ptr();
    public void ~exception_ptr();
    public class std::exception_ptr & operator=(void * );
    public class std::exception_ptr & operator=(class std::exception_ptr & );
    public bool operator bool();
    public void _RethrowException();
    public class std::exception_ptr _Current_exception();
    public class std::exception_ptr _Copy_exception(void * ,void * );
    private void * _Data1;
    private void * _Data2;
    public void * __vecDelDtor(unsigned int );
};

struct std::integral_constant<unsigned int,4>
{
    const unsigned int value=4;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

struct std::integral_constant<unsigned int,4>
{
    const unsigned int value=4;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

class std::basic_fstream<char,std::char_traits<char> >
{
};

struct std::less_equal<void>
{
};

class std::numpunct<wchar_t> : public std::locale::facet
{
    public class std::locale::id id;
    public wchar_t decimal_point();
    public wchar_t thousands_sep();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > grouping();
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > falsename();
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > truename();
    protected void numpunct<wchar_t>(char * ,unsigned int ,bool );
    public void numpunct<wchar_t>(class std::_Locinfo & ,unsigned int ,bool );
    public void numpunct<wchar_t>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~numpunct<wchar_t>();
    protected void _Getvals(wchar_t ,struct lconv * ,struct _Cvtvec );
    protected void _Init(class std::_Locinfo & ,bool );
    protected wchar_t do_decimal_point();
    protected wchar_t do_thousands_sep();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_grouping();
    protected class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > do_falsename();
    protected class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > do_truename();
    private void _Tidy();
    private char * _Grouping;
    private wchar_t _Dp;
    private wchar_t _Kseparator;
    private wchar_t * _Falsename;
    private wchar_t * _Truename;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::numpunct<wchar_t> : public std::locale::facet
{
    public class std::locale::id id;
    public wchar_t decimal_point();
    public wchar_t thousands_sep();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > grouping();
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > falsename();
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > truename();
    protected void numpunct<wchar_t>(char * ,unsigned int ,bool );
    public void numpunct<wchar_t>(class std::_Locinfo & ,unsigned int ,bool );
    public void numpunct<wchar_t>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~numpunct<wchar_t>();
    protected void _Getvals(wchar_t ,struct lconv * ,struct _Cvtvec );
    protected void _Init(class std::_Locinfo & ,bool );
    protected wchar_t do_decimal_point();
    protected wchar_t do_thousands_sep();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_grouping();
    protected class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > do_falsename();
    protected class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > do_truename();
    private void _Tidy();
    private char * _Grouping;
    private wchar_t _Dp;
    private wchar_t _Kseparator;
    private wchar_t * _Falsename;
    private wchar_t * _Truename;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<char32_t> : public std::_Num_int_base
{
    public char32_t min();
    public char32_t max();
    public char32_t lowest();
    public char32_t epsilon();
    public char32_t round_error();
    public char32_t denorm_min();
    public char32_t infinity();
    public char32_t quiet_NaN();
    public char32_t signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=32;
    public const int digits10=9;
};

struct std::once_flag
{
    void once_flag(struct std::once_flag & );
    void once_flag();
    struct std::once_flag & operator=(struct std::once_flag & );
    void * _Opaque;
};

struct std::once_flag
{
    void once_flag(struct std::once_flag & );
    void once_flag();
    struct std::once_flag & operator=(struct std::once_flag & );
    void * _Opaque;
};

class std::error_code
{
    public void error_code(int ,class std::error_category & );
    public void error_code();
    public void assign(int ,class std::error_category & );
    public void clear();
    public int value();
    public class std::error_category & category();
    public class std::error_condition default_error_condition();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message();
    public bool operator bool();
    private int _Myval;
    private class std::error_category * _Mycat;
};

class std::basic_ifstream<char,std::char_traits<char> >
{
};

class std::exception
{
    public void exception(class std::exception & );
    public void exception(const char * ,int );
    public void exception(const char * );
    public void exception();
    public class std::exception & operator=(class std::exception & );
    public void ~exception();
    public char * what();
    private struct __std_exception_data _Data;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::exception
{
    public void exception(class std::exception & );
    public void exception(const char * ,int );
    public void exception(const char * );
    public void exception();
    public class std::exception & operator=(class std::exception & );
    public void ~exception();
    public char * what();
    private struct __std_exception_data _Data;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Is_floating_point<long double> : public std::integral_constant<bool,1>
{
};

struct std::_Maximum<4> : public std::integral_constant<unsigned int,4>
{
};

enum std::_Iosb<int>::_Dummy_enum
{
    _Dummy_enum_val=1
};

enum std::_Iosb<int>::_Fmtflags
{
    _Fmtmask=65535,
    _Fmtzero=0
};

enum std::_Iosb<int>::_Iostate
{
    _Statmask=23
};

enum std::_Iosb<int>::_Openmode
{
    _Openmask=255
};

enum std::_Iosb<int>::_Seekdir
{
    _Seekbeg=0,
    _Seekcur=1,
    _Seekend=2
};

enum std::_Iosb<int>::<unnamed-enum-_Openprot>
{
    _Openprot=64
};

class std::_Iosb<int>
{
    enum _Dummy_enum
    {
        _Dummy_enum_val=1
    };
    enum _Fmtflags
    {
        _Fmtmask=65535,
        _Fmtzero=0
    };
    public const enum std::_Iosb<int>::_Fmtflags skipws=1;
    public const enum std::_Iosb<int>::_Fmtflags unitbuf=2;
    public const enum std::_Iosb<int>::_Fmtflags uppercase=4;
    public const enum std::_Iosb<int>::_Fmtflags showbase=8;
    public const enum std::_Iosb<int>::_Fmtflags showpoint=16;
    public const enum std::_Iosb<int>::_Fmtflags showpos=32;
    public const enum std::_Iosb<int>::_Fmtflags left=64;
    public const enum std::_Iosb<int>::_Fmtflags right=128;
    public const enum std::_Iosb<int>::_Fmtflags internal=256;
    public const enum std::_Iosb<int>::_Fmtflags dec=512;
    public const enum std::_Iosb<int>::_Fmtflags oct=1024;
    public const enum std::_Iosb<int>::_Fmtflags hex=2048;
    public const enum std::_Iosb<int>::_Fmtflags scientific=4096;
    public const enum std::_Iosb<int>::_Fmtflags fixed=8192;
    public const enum std::_Iosb<int>::_Fmtflags hexfloat=12288;
    public const enum std::_Iosb<int>::_Fmtflags boolalpha=16384;
    public const enum std::_Iosb<int>::_Fmtflags _Stdio=32768;
    public const enum std::_Iosb<int>::_Fmtflags adjustfield=448;
    public const enum std::_Iosb<int>::_Fmtflags basefield=3584;
    public const enum std::_Iosb<int>::_Fmtflags floatfield=12288;
    enum _Iostate
    {
        _Statmask=23
    };
    public const enum std::_Iosb<int>::_Iostate goodbit=0;
    public const enum std::_Iosb<int>::_Iostate eofbit=1;
    public const enum std::_Iosb<int>::_Iostate failbit=2;
    public const enum std::_Iosb<int>::_Iostate badbit=4;
    enum _Openmode
    {
        _Openmask=255
    };
    public const enum std::_Iosb<int>::_Openmode in=1;
    public const enum std::_Iosb<int>::_Openmode out=2;
    public const enum std::_Iosb<int>::_Openmode ate=4;
    public const enum std::_Iosb<int>::_Openmode app=8;
    public const enum std::_Iosb<int>::_Openmode trunc=16;
    public const enum std::_Iosb<int>::_Openmode _Nocreate=64;
    public const enum std::_Iosb<int>::_Openmode _Noreplace=128;
    public const enum std::_Iosb<int>::_Openmode binary=32;
    enum _Seekdir
    {
        _Seekbeg=0,
        _Seekcur=1,
        _Seekend=2
    };
    public const enum std::_Iosb<int>::_Seekdir beg=0;
    public const enum std::_Iosb<int>::_Seekdir cur=1;
    public const enum std::_Iosb<int>::_Seekdir end=2;
    enum <unnamed-enum-_Openprot>
    {
        _Openprot=64
    };
};

struct std::allocator_traits<std::allocator<char32_t> > : public std::_Default_allocator_traits<std::allocator<char32_t> >
{
};

struct std::is_error_code_enum<std::error_code> : public std::integral_constant<bool,0>
{
};

class std::num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(class std::_Locinfo & ,unsigned int );
    public void num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(unsigned int );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,void &** );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned long & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,long & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,bool & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,void &** );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned long & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,long & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,bool & );
    private int _Getifld(char * ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,int ,class std::locale & );
    private int _Getffld(char * ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::ios_base & ,int * );
    private int _Getffldx(char * ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::ios_base & ,int * );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > : public std::locale::facet
{
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public class std::locale::id id;
    protected void ~num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >();
    protected void _Init(class std::_Locinfo & );
    public void num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(class std::_Locinfo & ,unsigned int );
    public void num_get<wchar_t,std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > >(unsigned int );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,void &** );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned long & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,long & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,bool & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,void &** );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,float & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned long & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,long & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,unsigned int & );
    protected class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > do_get(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > ,class std::ios_base & ,int & ,bool & );
    private int _Getifld(char * ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,int ,class std::locale & );
    private int _Getffld(char * ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::ios_base & ,int * );
    private int _Getffldx(char * ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & ,class std::ios_base & ,int * );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::remove_pointer<char const *>
{
};

struct std::_Facetptr<std::numpunct<wchar_t> >
{
    class std::locale::facet * _Psave;
};

struct std::is_signed<char> : public std::integral_constant<bool,1>
{
};

struct std::aligned_union<1,std::_Iostream_error_category>
{
    const unsigned int _Max_len=8;
    const unsigned int alignment_value=4;
};

struct std::_Is_integral<unsigned short> : public std::integral_constant<bool,1>
{
};

struct std::_Priority_tag<0>
{
};

class std::_Locbase<int>
{
    public const int collate=1;
    public const int ctype=2;
    public const int monetary=4;
    public const int numeric=8;
    public const int time=16;
    public const int messages=32;
    public const int all=63;
    public const int none=0;
};

struct std::char_traits<char16_t> : public std::_WChar_traits<char16_t>
{
};

struct std::_Container_base12
{
    void _Container_base12(struct std::_Container_base12 & );
    void _Container_base12();
    struct std::_Container_base12 & operator=(struct std::_Container_base12 & );
    struct std::_Iterator_base12 ** _Getpfirst();
    void _Orphan_all();
    void _Swap_all(struct std::_Container_base12 & );
    struct std::_Container_proxy * _Myproxy;
};

enum std::io_errc
{
    stream=1
};

struct std::_Is_integral<__int64> : public std::integral_constant<bool,1>
{
};

enum std::ios_base::event
{
    erase_event=0,
    imbue_event=1,
    copyfmt_event=2
};

class std::ios_base : public std::_Iosb<int>
{
    enum event
    {
        erase_event=0,
        imbue_event=1,
        copyfmt_event=2
    };
    class failure : public std::system_error
    {
        public void failure(class std::ios_base::failure * );
        public void failure(class std::ios_base::failure & );
        public void failure(char * ,class std::error_code & );
        public void failure(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::error_code & );
        public void ~failure();
        public class std::ios_base::failure & operator=(class std::ios_base::failure * );
        public class std::ios_base::failure & operator=(class std::ios_base::failure & );
        public void * __vecDelDtor(unsigned int );
    };
    class Init
    {
        public void Init();
        public void ~Init();
        private void _Init_ctor(class std::ios_base::Init * );
        private void _Init_dtor(class std::ios_base::Init * );
        private int _Init_cnt;
        private int & _Init_cnt_func();
        public void * __vecDelDtor(unsigned int );
    };
    public bool operator bool();
    public bool operator!();
    public void clear(unsigned int );
    public void clear(int );
    public void clear(int ,bool );
    public int rdstate();
    public void setstate(unsigned int );
    public void setstate(int );
    public void setstate(int ,bool );
    public bool good();
    public bool eof();
    public bool fail();
    public bool bad();
    public void exceptions(unsigned int );
    public void exceptions(int );
    public int exceptions();
    public int flags(int );
    public int flags();
    public int setf(int ,int );
    public int setf(int );
    public void unsetf(int );
    public int precision(int );
    public int precision();
    public int width(int );
    public int width();
    public class std::locale getloc();
    public class std::locale imbue(class std::locale & );
    public int xalloc();
    public long & iword(int );
    public void &** pword(int );
    public void register_callback(void  ( * )(enum std::ios_base::event ,class std::ios_base & ,int ),int );
    public class std::ios_base & copyfmt(class std::ios_base & );
    public bool sync_with_stdio(bool );
    public void swap(class std::ios_base & );
    public void ~ios_base();
    public void _Addstd(class std::ios_base * );
    public unsigned int _Stdstr;
    public void ios_base(class std::ios_base & );
    protected void ios_base();
    protected void _Init();
    struct _Iosarray : public std::_Crt_new_delete
    {
        void _Iosarray(int ,struct std::ios_base::_Iosarray * );
        struct std::ios_base::_Iosarray * _Next;
        int _Index;
        long _Lo;
        void * _Vp;
    };
    struct _Fnarray : public std::_Crt_new_delete
    {
        void _Fnarray(int ,void  ( * )(enum std::ios_base::event ,class std::ios_base & ,int ),struct std::ios_base::_Fnarray * );
        struct std::ios_base::_Fnarray * _Next;
        int _Index;
        void  ( * _Pfn)(enum std::ios_base::event ,class std::ios_base & ,int );
    };
    private void _Callfns(enum std::ios_base::event );
    private struct std::ios_base::_Iosarray & _Findarr(int );
    private void _Tidy();
    private int _Mystate;
    private int _Except;
    private int _Fmtfl;
    private int _Prec;
    private int _Wide;
    private struct std::ios_base::_Iosarray * _Arr;
    private struct std::ios_base::_Fnarray * _Calls;
    private class std::locale * _Ploc;
    private int _Index;
    private bool _Sync;
    private void _Ios_base_dtor(class std::ios_base * );
    public class std::ios_base & operator=(class std::ios_base & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::ios_base : public std::_Iosb<int>
{
    enum event
    {
        erase_event=0,
        imbue_event=1,
        copyfmt_event=2
    };
    class failure : public std::system_error
    {
        public void failure(class std::ios_base::failure * );
        public void failure(class std::ios_base::failure & );
        public void failure(char * ,class std::error_code & );
        public void failure(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::error_code & );
        public void ~failure();
        public class std::ios_base::failure & operator=(class std::ios_base::failure * );
        public class std::ios_base::failure & operator=(class std::ios_base::failure & );
        public void * __vecDelDtor(unsigned int );
    };
    class Init
    {
        public void Init();
        public void ~Init();
        private void _Init_ctor(class std::ios_base::Init * );
        private void _Init_dtor(class std::ios_base::Init * );
        private int _Init_cnt;
        private int & _Init_cnt_func();
        public void * __vecDelDtor(unsigned int );
    };
    public bool operator bool();
    public bool operator!();
    public void clear(unsigned int );
    public void clear(int );
    public void clear(int ,bool );
    public int rdstate();
    public void setstate(unsigned int );
    public void setstate(int );
    public void setstate(int ,bool );
    public bool good();
    public bool eof();
    public bool fail();
    public bool bad();
    public void exceptions(unsigned int );
    public void exceptions(int );
    public int exceptions();
    public int flags(int );
    public int flags();
    public int setf(int ,int );
    public int setf(int );
    public void unsetf(int );
    public int precision(int );
    public int precision();
    public int width(int );
    public int width();
    public class std::locale getloc();
    public class std::locale imbue(class std::locale & );
    public int xalloc();
    public long & iword(int );
    public void &** pword(int );
    public void register_callback(void  ( * )(enum std::ios_base::event ,class std::ios_base & ,int ),int );
    public class std::ios_base & copyfmt(class std::ios_base & );
    public bool sync_with_stdio(bool );
    public void swap(class std::ios_base & );
    public void ~ios_base();
    public void _Addstd(class std::ios_base * );
    public unsigned int _Stdstr;
    public void ios_base(class std::ios_base & );
    protected void ios_base();
    protected void _Init();
    struct _Iosarray : public std::_Crt_new_delete
    {
        void _Iosarray(int ,struct std::ios_base::_Iosarray * );
        struct std::ios_base::_Iosarray * _Next;
        int _Index;
        long _Lo;
        void * _Vp;
    };
    struct _Fnarray : public std::_Crt_new_delete
    {
        void _Fnarray(int ,void  ( * )(enum std::ios_base::event ,class std::ios_base & ,int ),struct std::ios_base::_Fnarray * );
        struct std::ios_base::_Fnarray * _Next;
        int _Index;
        void  ( * _Pfn)(enum std::ios_base::event ,class std::ios_base & ,int );
    };
    private void _Callfns(enum std::ios_base::event );
    private struct std::ios_base::_Iosarray & _Findarr(int );
    private void _Tidy();
    private int _Mystate;
    private int _Except;
    private int _Fmtfl;
    private int _Prec;
    private int _Wide;
    private struct std::ios_base::_Iosarray * _Arr;
    private struct std::ios_base::_Fnarray * _Calls;
    private class std::locale * _Ploc;
    private int _Index;
    private bool _Sync;
    private void _Ios_base_dtor(class std::ios_base * );
    public class std::ios_base & operator=(class std::ios_base & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::ios_base::_Fnarray : public std::_Crt_new_delete
{
    void _Fnarray(int ,void  ( * )(enum std::ios_base::event ,class std::ios_base & ,int ),struct std::ios_base::_Fnarray * );
    struct std::ios_base::_Fnarray * _Next;
    int _Index;
    void  ( * _Pfn)(enum std::ios_base::event ,class std::ios_base & ,int );
};

struct std::ios_base::_Iosarray : public std::_Crt_new_delete
{
    void _Iosarray(int ,struct std::ios_base::_Iosarray * );
    struct std::ios_base::_Iosarray * _Next;
    int _Index;
    long _Lo;
    void * _Vp;
};

class std::ios_base::Init
{
    public void Init();
    public void ~Init();
    private void _Init_ctor(class std::ios_base::Init * );
    private void _Init_dtor(class std::ios_base::Init * );
    private int _Init_cnt;
    private int & _Init_cnt_func();
    public void * __vecDelDtor(unsigned int );
};

class std::ios_base::failure : public std::system_error
{
    public void failure(class std::ios_base::failure * );
    public void failure(class std::ios_base::failure & );
    public void failure(char * ,class std::error_code & );
    public void failure(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::error_code & );
    public void ~failure();
    public class std::ios_base::failure & operator=(class std::ios_base::failure * );
    public class std::ios_base::failure & operator=(class std::ios_base::failure & );
    public void * __vecDelDtor(unsigned int );
};

class std::ios_base::failure : public std::system_error
{
    public void failure(class std::ios_base::failure * );
    public void failure(class std::ios_base::failure & );
    public void failure(char * ,class std::error_code & );
    public void failure(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::error_code & );
    public void ~failure();
    public class std::ios_base::failure & operator=(class std::ios_base::failure * );
    public class std::ios_base::failure & operator=(class std::ios_base::failure & );
    public void * __vecDelDtor(unsigned int );
};

struct std::_Is_integral<bool> : public std::integral_constant<bool,1>
{
};

class std::numeric_limits<unsigned char> : public std::_Num_int_base
{
    public unsigned int min();
    public unsigned int max();
    public unsigned int lowest();
    public unsigned int epsilon();
    public unsigned int round_error();
    public unsigned int denorm_min();
    public unsigned int infinity();
    public unsigned int quiet_NaN();
    public unsigned int signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=8;
    public const int digits10=2;
};

struct std::_General_ptr_iterator_tag
{
};

struct std::_Is_floating_point<float> : public std::integral_constant<bool,1>
{
};

class std::numeric_limits<long> : public std::_Num_int_base
{
    public long min();
    public long max();
    public long lowest();
    public long epsilon();
    public long round_error();
    public long denorm_min();
    public long infinity();
    public long quiet_NaN();
    public long signaling_NaN();
    public const bool is_signed=1;
    public const int digits=31;
    public const int digits10=9;
};

class std::initializer_list<char>
{
    public void initializer_list<char>(char * ,char * );
    public void initializer_list<char>();
    public char * begin();
    public char * end();
    public unsigned int size();
    private char * _First;
    private char * _Last;
};

struct std::nothrow_t
{
};

struct std::_Default_allocate_traits
{
    void * _Allocate(const unsigned int );
};

struct std::aligned_storage<8,4>
{
};

struct std::allocator_traits<std::allocator<char> > : public std::_Default_allocator_traits<std::allocator<char> >
{
};

struct std::is_void<void volatile > : public std::integral_constant<bool,1>
{
};

class std::numeric_limits<short> : public std::_Num_int_base
{
    public int min();
    public int max();
    public int lowest();
    public int epsilon();
    public int round_error();
    public int denorm_min();
    public int infinity();
    public int quiet_NaN();
    public int signaling_NaN();
    public const bool is_signed=1;
    public const int digits=15;
    public const int digits10=4;
};

union std::_Align_type<int,8>
{
    int _Val;
    char _Pad[8];
};

struct std::is_unsigned<unsigned int> : public std::integral_constant<bool,1>
{
};

class std::ctype<unsigned short> : public std::ctype_base
{
    public unsigned int * is(unsigned int * ,unsigned int * ,int * );
    public bool is(int ,unsigned int );
    public unsigned int * scan_is(int ,unsigned int * ,unsigned int * );
    public unsigned int * scan_not(int ,unsigned int * ,unsigned int * );
    public unsigned int * tolower(unsigned int * ,unsigned int * );
    public unsigned int tolower(unsigned int );
    public unsigned int * toupper(unsigned int * ,unsigned int * );
    public unsigned int toupper(unsigned int );
    public char * widen(char * ,char * ,unsigned int * );
    public unsigned int widen(char );
    public unsigned int * narrow(unsigned int * ,unsigned int * ,char ,char * );
    public char narrow(unsigned int ,char );
    public class std::locale::id id;
    public void ctype<unsigned short>(class std::_Locinfo & ,unsigned int );
    public void ctype<unsigned short>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~ctype<unsigned short>();
    protected void _Init(class std::_Locinfo & );
    protected unsigned int * do_is(unsigned int * ,unsigned int * ,int * );
    protected bool do_is(int ,unsigned int );
    protected unsigned int * do_scan_is(int ,unsigned int * ,unsigned int * );
    protected unsigned int * do_scan_not(int ,unsigned int * ,unsigned int * );
    protected unsigned int * do_tolower(unsigned int * ,unsigned int * );
    protected unsigned int do_tolower(unsigned int );
    protected unsigned int * do_toupper(unsigned int * ,unsigned int * );
    protected unsigned int do_toupper(unsigned int );
    protected unsigned int _Dowiden(char );
    protected char * do_widen(char * ,char * ,unsigned int * );
    protected unsigned int do_widen(char );
    protected char _Donarrow(unsigned int ,char );
    protected unsigned int * do_narrow(unsigned int * ,unsigned int * ,char ,char * );
    protected char do_narrow(unsigned int ,char );
    private struct _Ctypevec _Ctype;
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::ctype<unsigned short> : public std::ctype_base
{
    public unsigned int * is(unsigned int * ,unsigned int * ,int * );
    public bool is(int ,unsigned int );
    public unsigned int * scan_is(int ,unsigned int * ,unsigned int * );
    public unsigned int * scan_not(int ,unsigned int * ,unsigned int * );
    public unsigned int * tolower(unsigned int * ,unsigned int * );
    public unsigned int tolower(unsigned int );
    public unsigned int * toupper(unsigned int * ,unsigned int * );
    public unsigned int toupper(unsigned int );
    public char * widen(char * ,char * ,unsigned int * );
    public unsigned int widen(char );
    public unsigned int * narrow(unsigned int * ,unsigned int * ,char ,char * );
    public char narrow(unsigned int ,char );
    public class std::locale::id id;
    public void ctype<unsigned short>(class std::_Locinfo & ,unsigned int );
    public void ctype<unsigned short>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~ctype<unsigned short>();
    protected void _Init(class std::_Locinfo & );
    protected unsigned int * do_is(unsigned int * ,unsigned int * ,int * );
    protected bool do_is(int ,unsigned int );
    protected unsigned int * do_scan_is(int ,unsigned int * ,unsigned int * );
    protected unsigned int * do_scan_not(int ,unsigned int * ,unsigned int * );
    protected unsigned int * do_tolower(unsigned int * ,unsigned int * );
    protected unsigned int do_tolower(unsigned int );
    protected unsigned int * do_toupper(unsigned int * ,unsigned int * );
    protected unsigned int do_toupper(unsigned int );
    protected unsigned int _Dowiden(char );
    protected char * do_widen(char * ,char * ,unsigned int * );
    protected unsigned int do_widen(char );
    protected char _Donarrow(unsigned int ,char );
    protected unsigned int * do_narrow(unsigned int * ,unsigned int * ,char ,char * );
    protected char do_narrow(unsigned int ,char );
    private struct _Ctypevec _Ctype;
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::_Range_verifiable<wchar_t *,wchar_t *,void> : public std::integral_constant<bool,0>
{
};

enum std::_String_val<std::_Simple_types<char16_t> >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=8
};

enum std::_String_val<std::_Simple_types<char16_t> >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=7
};

class std::_String_val<std::_Simple_types<char16_t> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<char16_t> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public char16_t * _Myptr();
    public char16_t * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char16_t _Buf[8];
        char16_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<char16_t> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<char16_t> >();
    public void * __vecDelDtor(unsigned int );
};

union std::_String_val<std::_Simple_types<char16_t> >::_Bxty
{
    void _Bxty();
    void ~_Bxty();
    char16_t _Buf[8];
    char16_t * _Ptr;
    char _Alias[8];
    void * __vecDelDtor(unsigned int );
};

class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
{
    public void ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator*();
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++(int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++();
    public bool failed();
    private bool _Failed;
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
};

class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
{
    public void ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator*();
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++(int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++();
    public bool failed();
    private bool _Failed;
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
};

struct std::is_unsigned<unsigned __int64> : public std::integral_constant<bool,1>
{
};

struct std::is_pointer<std::default_delete<std::_Facet_base> > : public std::integral_constant<bool,0>
{
};

class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > : public std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >
{
    public void unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public void unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > * );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > * );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(void * );
    public void swap(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public void ~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >();
    public class std::_Facet_base & operator*();
    public class std::_Facet_base * operator->();
    public class std::_Facet_base * get();
    public bool operator bool();
    public class std::_Facet_base * release();
    public void reset(class std::_Facet_base * );
    public void * __vecDelDtor(unsigned int );
};

class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > : public std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >
{
    public void unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public void unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > * );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > * );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(void * );
    public void swap(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public void ~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >();
    public class std::_Facet_base & operator*();
    public class std::_Facet_base * operator->();
    public class std::_Facet_base * get();
    public bool operator bool();
    public class std::_Facet_base * release();
    public void reset(class std::_Facet_base * );
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > : public std::_Iterator_base0
{
    public void _String_const_iterator<std::_String_val<std::_Simple_types<char> > >(char * ,struct std::_Container_base0 * );
    public void _String_const_iterator<std::_String_val<std::_Simple_types<char> > >();
    public char & operator*();
    public char * operator->();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator++(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator++();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator--(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator--();
    public void _Verify_offset(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator+=(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator+(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator-=(const int );
    public int operator-(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator-(const int );
    public char & operator[](const int );
    public bool operator==(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator!=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator<(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator>(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator<=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator>=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public void _Compat(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public char * _Unwrapped();
    public void _Seek_to(char * );
    public char * _Ptr;
};

struct std::_Shared_ptr_spin_lock
{
    void _Shared_ptr_spin_lock();
    void ~_Shared_ptr_spin_lock();
    void * __vecDelDtor(unsigned int );
};

struct std::make_unsigned<unsigned long>
{
};

struct std::_Is_integral<char16_t> : public std::integral_constant<bool,1>
{
};

struct std::_String_base_types<char32_t,std::allocator<char32_t> >
{
};

class std::bad_alloc : public std::exception
{
    public void bad_alloc(class std::bad_alloc * );
    public void bad_alloc(class std::bad_alloc & );
    private void bad_alloc(const char * );
    public void bad_alloc();
    public void ~bad_alloc();
    public class std::bad_alloc & operator=(class std::bad_alloc * );
    public class std::bad_alloc & operator=(class std::bad_alloc & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_alloc : public std::exception
{
    public void bad_alloc(class std::bad_alloc * );
    public void bad_alloc(class std::bad_alloc & );
    private void bad_alloc(const char * );
    public void bad_alloc();
    public void ~bad_alloc();
    public class std::bad_alloc & operator=(class std::bad_alloc * );
    public class std::bad_alloc & operator=(class std::bad_alloc & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::underflow_error : public std::runtime_error
{
    public void underflow_error(class std::underflow_error * );
    public void underflow_error(class std::underflow_error & );
    public void underflow_error(char * );
    public void underflow_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~underflow_error();
    public class std::underflow_error & operator=(class std::underflow_error * );
    public class std::underflow_error & operator=(class std::underflow_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::underflow_error : public std::runtime_error
{
    public void underflow_error(class std::underflow_error * );
    public void underflow_error(class std::underflow_error & );
    public void underflow_error(char * );
    public void underflow_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~underflow_error();
    public class std::underflow_error & operator=(class std::underflow_error * );
    public class std::underflow_error & operator=(class std::underflow_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::basic_ofstream<wchar_t,std::char_traits<wchar_t> >
{
};

struct std::_Add_reference<char const * const &,void>
{
};

class std::basic_stringbuf<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
{
};

class std::out_of_range : public std::logic_error
{
    public void out_of_range(class std::out_of_range * );
    public void out_of_range(class std::out_of_range & );
    public void out_of_range(char * );
    public void out_of_range(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~out_of_range();
    public class std::out_of_range & operator=(class std::out_of_range * );
    public class std::out_of_range & operator=(class std::out_of_range & );
    public void * __vecDelDtor(unsigned int );
};

class std::out_of_range : public std::logic_error
{
    public void out_of_range(class std::out_of_range * );
    public void out_of_range(class std::out_of_range & );
    public void out_of_range(char * );
    public void out_of_range(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~out_of_range();
    public class std::out_of_range & operator=(class std::out_of_range * );
    public class std::out_of_range & operator=(class std::out_of_range & );
    public void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<__int64> : public std::_Num_int_base
{
    public int min();
    public int max();
    public int lowest();
    public int epsilon();
    public int round_error();
    public int denorm_min();
    public int infinity();
    public int quiet_NaN();
    public int signaling_NaN();
    public const bool is_signed=1;
    public const int digits=63;
    public const int digits10=18;
};

class std::ctype<char> : public std::ctype_base
{
    public char * is(char * ,char * ,int * );
    public bool is(int ,char );
    public char * scan_is(int ,char * ,char * );
    public char * scan_not(int ,char * ,char * );
    public char * tolower(char * ,char * );
    public char tolower(char );
    public char * toupper(char * ,char * );
    public char toupper(char );
    public char * widen(char * ,char * ,char * );
    public char widen(char );
    public char * narrow(char * ,char * ,char ,char * );
    public char narrow(char ,char );
    public class std::locale::id id;
    public void ctype<char>(class std::_Locinfo & ,unsigned int );
    public void ctype<char>(int * ,bool ,unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public int * table();
    public int * classic_table();
    public const unsigned int table_size=256;
    protected void ~ctype<char>();
    protected void _Init(class std::_Locinfo & );
    protected void _Tidy();
    protected char * do_tolower(char * ,char * );
    protected char do_tolower(char );
    protected char * do_toupper(char * ,char * );
    protected char do_toupper(char );
    protected char * do_widen(char * ,char * ,char * );
    protected char do_widen(char );
    protected char * do_narrow(char * ,char * ,char ,char * );
    protected char do_narrow(char ,char );
    private struct _Ctypevec _Ctype;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::ctype<char> : public std::ctype_base
{
    public char * is(char * ,char * ,int * );
    public bool is(int ,char );
    public char * scan_is(int ,char * ,char * );
    public char * scan_not(int ,char * ,char * );
    public char * tolower(char * ,char * );
    public char tolower(char );
    public char * toupper(char * ,char * );
    public char toupper(char );
    public char * widen(char * ,char * ,char * );
    public char widen(char );
    public char * narrow(char * ,char * ,char ,char * );
    public char narrow(char ,char );
    public class std::locale::id id;
    public void ctype<char>(class std::_Locinfo & ,unsigned int );
    public void ctype<char>(int * ,bool ,unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    public int * table();
    public int * classic_table();
    public const unsigned int table_size=256;
    protected void ~ctype<char>();
    protected void _Init(class std::_Locinfo & );
    protected void _Tidy();
    protected char * do_tolower(char * ,char * );
    protected char do_tolower(char );
    protected char * do_toupper(char * ,char * );
    protected char do_toupper(char );
    protected char * do_widen(char * ,char * ,char * );
    protected char do_widen(char );
    protected char * do_narrow(char * ,char * ,char ,char * );
    protected char do_narrow(char ,char );
    private struct _Ctypevec _Ctype;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::_Invoker_functor
{
};

struct std::_Simple_types<char32_t>
{
};

class std::_Iostream_error_category : public std::_Generic_error_category
{
    public void _Iostream_error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public void ~_Iostream_error_category();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_Iostream_error_category : public std::_Generic_error_category
{
    public void _Iostream_error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public void ~_Iostream_error_category();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::is_error_condition_enum<unsigned int> : public std::integral_constant<bool,0>
{
};

class std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1> : private std::allocator<wchar_t>
{
    private class std::_String_val<std::_Simple_types<wchar_t> > _Myval2;
    public class std::allocator<wchar_t> & _Get_first();
    public class std::allocator<wchar_t> & _Get_first();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_second();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_val<std::_Simple_types<wchar_t> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<wchar_t> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public wchar_t * _Myptr();
    public wchar_t * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        wchar_t _Buf[8];
        wchar_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<wchar_t> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<wchar_t> >();
    public void * __vecDelDtor(unsigned int );
};

class std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1> : private std::allocator<wchar_t>
{
    private class std::_String_val<std::_Simple_types<wchar_t> > _Myval2;
    public class std::allocator<wchar_t> & _Get_first();
    public class std::allocator<wchar_t> & _Get_first();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_second();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>();
    public void * __vecDelDtor(unsigned int );
};

class std::system_error : public std::_System_error
{
    public void system_error(class std::system_error * );
    public void system_error(class std::system_error & );
    public void system_error(int ,class std::error_category & ,char * );
    public void system_error(int ,class std::error_category & ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void system_error(int ,class std::error_category & );
    public void system_error(class std::error_code ,char * );
    public void system_error(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void system_error(class std::error_code );
    public class std::error_code & code();
    public void ~system_error();
    public class std::system_error & operator=(class std::system_error * );
    public class std::system_error & operator=(class std::system_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::system_error : public std::_System_error
{
    public void system_error(class std::system_error * );
    public void system_error(class std::system_error & );
    public void system_error(int ,class std::error_category & ,char * );
    public void system_error(int ,class std::error_category & ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void system_error(int ,class std::error_category & );
    public void system_error(class std::error_code ,char * );
    public void system_error(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void system_error(class std::error_code );
    public class std::error_code & code();
    public void ~system_error();
    public class std::system_error & operator=(class std::system_error * );
    public class std::system_error & operator=(class std::system_error & );
    public void * __vecDelDtor(unsigned int );
};

struct std::_Default_allocator_traits<std::allocator<char> >
{
    char * allocate(class std::allocator<char> & ,const unsigned int ,void * );
    char * allocate(class std::allocator<char> & ,const unsigned int );
    void deallocate(class std::allocator<char> & ,const char * ,const unsigned int );
    unsigned int max_size(class std::allocator<char> & );
    class std::allocator<char> select_on_container_copy_construction(class std::allocator<char> & );
};

struct std::integral_constant<unsigned int,2>
{
    const unsigned int value=2;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

struct std::integral_constant<unsigned int,2>
{
    const unsigned int value=2;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

struct std::forward_iterator_tag : public std::input_iterator_tag
{
};

class std::runtime_error : public std::exception
{
    public void runtime_error(class std::runtime_error * );
    public void runtime_error(class std::runtime_error & );
    public void runtime_error(char * );
    public void runtime_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~runtime_error();
    public class std::runtime_error & operator=(class std::runtime_error * );
    public class std::runtime_error & operator=(class std::runtime_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::runtime_error : public std::exception
{
    public void runtime_error(class std::runtime_error * );
    public void runtime_error(class std::runtime_error & );
    public void runtime_error(char * );
    public void runtime_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~runtime_error();
    public class std::runtime_error & operator=(class std::runtime_error * );
    public class std::runtime_error & operator=(class std::runtime_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::bad_array_new_length : public std::bad_alloc
{
    public void bad_array_new_length(class std::bad_array_new_length * );
    public void bad_array_new_length(class std::bad_array_new_length & );
    public void bad_array_new_length();
    public void ~bad_array_new_length();
    public class std::bad_array_new_length & operator=(class std::bad_array_new_length * );
    public class std::bad_array_new_length & operator=(class std::bad_array_new_length & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_array_new_length : public std::bad_alloc
{
    public void bad_array_new_length(class std::bad_array_new_length * );
    public void bad_array_new_length(class std::bad_array_new_length & );
    public void bad_array_new_length();
    public void ~bad_array_new_length();
    public class std::bad_array_new_length & operator=(class std::bad_array_new_length * );
    public class std::bad_array_new_length & operator=(class std::bad_array_new_length & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=8
};

enum std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=7
};

class std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        wchar_t _Buf[8];
        wchar_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public void _String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >();
    public void _Copy_alloc(class std::allocator<wchar_t> & );
    public void _Move_alloc(class std::allocator<wchar_t> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > > & );
    public class std::allocator<wchar_t> & _Getal();
    public class std::allocator<wchar_t> & _Getal();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_data();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        wchar_t _Buf[8];
        wchar_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public void _String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >();
    public void _Copy_alloc(class std::allocator<wchar_t> & );
    public void _Move_alloc(class std::allocator<wchar_t> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > > & );
    public class std::allocator<wchar_t> & _Getal();
    public class std::allocator<wchar_t> & _Getal();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_data();
    public class std::_String_val<std::_Simple_types<wchar_t> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<wchar_t,std::allocator<wchar_t> > >();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Add_reference<char * const &,void>
{
};

enum std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=16
};

enum std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=15
};

class std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char _Buf[16];
        char * _Ptr;
        char _Alias[16];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=16
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=15
    };
    public void _String_alloc<std::_String_base_types<char,std::allocator<char> > >();
    public void _Copy_alloc(class std::allocator<char> & );
    public void _Move_alloc(class std::allocator<char> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<char,std::allocator<char> > > & );
    public class std::allocator<char> & _Getal();
    public class std::allocator<char> & _Getal();
    public class std::_String_val<std::_Simple_types<char> > & _Get_data();
    public class std::_String_val<std::_Simple_types<char> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<char,std::allocator<char> > >();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char _Buf[16];
        char * _Ptr;
        char _Alias[16];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=16
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=15
    };
    public void _String_alloc<std::_String_base_types<char,std::allocator<char> > >();
    public void _Copy_alloc(class std::allocator<char> & );
    public void _Move_alloc(class std::allocator<char> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<char,std::allocator<char> > > & );
    public class std::allocator<char> & _Getal();
    public class std::allocator<char> & _Getal();
    public class std::_String_val<std::_Simple_types<char> > & _Get_data();
    public class std::_String_val<std::_Simple_types<char> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<char,std::allocator<char> > >();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Unforced
{
};

struct std::_Add_reference<unsigned short const * const &,void>
{
};

struct std::_Invoker_pmd_pointer
{
};

class std::_Yarn<char>
{
    public void _Yarn<char>(char * );
    public void _Yarn<char>(class std::_Yarn<char> & );
    public void _Yarn<char>();
    public class std::_Yarn<char> & operator=(char * );
    public class std::_Yarn<char> & operator=(class std::_Yarn<char> & );
    public void ~_Yarn<char>();
    public bool empty();
    public char * c_str();
    public bool _Empty();
    public char * _C_str();
    private void _Tidy();
    private char * _Myptr;
    private char _Nul;
    public void * __vecDelDtor(unsigned int );
};

class std::_Yarn<char>
{
    public void _Yarn<char>(char * );
    public void _Yarn<char>(class std::_Yarn<char> & );
    public void _Yarn<char>();
    public class std::_Yarn<char> & operator=(char * );
    public class std::_Yarn<char> & operator=(class std::_Yarn<char> & );
    public void ~_Yarn<char>();
    public bool empty();
    public char * c_str();
    public bool _Empty();
    public char * _C_str();
    private void _Tidy();
    private char * _Myptr;
    private char _Nul;
    public void * __vecDelDtor(unsigned int );
};

struct std::_Container_proxy
{
    void _Container_proxy();
    struct std::_Container_base12 * _Mycont;
    struct std::_Iterator_base12 * _Myfirstiter;
};

struct std::_Facetptr<std::ctype<char> >
{
    class std::locale::facet * _Psave;
};

class std::numpunct<char> : public std::locale::facet
{
    public class std::locale::id id;
    public char decimal_point();
    public char thousands_sep();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > grouping();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > falsename();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > truename();
    protected void numpunct<char>(char * ,unsigned int ,bool );
    public void numpunct<char>(class std::_Locinfo & ,unsigned int ,bool );
    public void numpunct<char>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~numpunct<char>();
    protected void _Getvals(wchar_t ,struct lconv * ,struct _Cvtvec );
    protected void _Init(class std::_Locinfo & ,bool );
    protected char do_decimal_point();
    protected char do_thousands_sep();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_grouping();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_falsename();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_truename();
    private void _Tidy();
    private char * _Grouping;
    private char _Dp;
    private char _Kseparator;
    private char * _Falsename;
    private char * _Truename;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::numpunct<char> : public std::locale::facet
{
    public class std::locale::id id;
    public char decimal_point();
    public char thousands_sep();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > grouping();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > falsename();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > truename();
    protected void numpunct<char>(char * ,unsigned int ,bool );
    public void numpunct<char>(class std::_Locinfo & ,unsigned int ,bool );
    public void numpunct<char>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~numpunct<char>();
    protected void _Getvals(wchar_t ,struct lconv * ,struct _Cvtvec );
    protected void _Init(class std::_Locinfo & ,bool );
    protected char do_decimal_point();
    protected char do_thousands_sep();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_grouping();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_falsename();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_truename();
    private void _Tidy();
    private char * _Grouping;
    private char _Dp;
    private char _Kseparator;
    private char * _Falsename;
    private char * _Truename;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::greater_equal<void>
{
};

struct std::is_default_constructible<std::default_delete<std::_Facet_base> > : public std::integral_constant<bool,1>
{
};

struct std::default_delete<std::_Facet_base>
{
    void operator()(class std::_Facet_base * );
};

class std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1> : private std::default_delete<std::_Facet_base>
{
    private class std::_Facet_base * _Myval2;
    public struct std::default_delete<std::_Facet_base> & _Get_first();
    public struct std::default_delete<std::_Facet_base> & _Get_first();
    public class std::_Facet_base &** _Get_second();
    public class std::_Facet_base &** _Get_second();
};

class std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1> : private std::default_delete<std::_Facet_base>
{
    private class std::_Facet_base * _Myval2;
    public struct std::default_delete<std::_Facet_base> & _Get_first();
    public struct std::default_delete<std::_Facet_base> & _Get_first();
    public class std::_Facet_base &** _Get_second();
    public class std::_Facet_base &** _Get_second();
};

class std::nested_exception
{
    public void nested_exception(class std::nested_exception & );
    public void nested_exception();
    public class std::nested_exception & operator=(class std::nested_exception & );
    public void ~nested_exception();
    public void rethrow_nested();
    public class std::exception_ptr nested_ptr();
    private class std::exception_ptr _Exc;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::nested_exception
{
    public void nested_exception(class std::nested_exception & );
    public void nested_exception();
    public class std::nested_exception & operator=(class std::nested_exception & );
    public void ~nested_exception();
    public void rethrow_nested();
    public class std::exception_ptr nested_ptr();
    private class std::exception_ptr _Exc;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Distance_unknown
{
    struct std::_Distance_unknown operator-();
};

struct std::_Distance_unknown
{
    struct std::_Distance_unknown operator-();
};

class std::numeric_limits<unsigned int> : public std::_Num_int_base
{
    public unsigned int min();
    public unsigned int max();
    public unsigned int lowest();
    public unsigned int epsilon();
    public unsigned int round_error();
    public unsigned int denorm_min();
    public unsigned int infinity();
    public unsigned int quiet_NaN();
    public unsigned int signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=32;
    public const int digits10=9;
};

class std::codecvt<char32_t,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,char32_t * ,char32_t * ,char32_t &** );
    public int out(struct _Mbstatet & ,char32_t * ,char32_t * ,char32_t &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<char32_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned long ,enum std::_Codecvt_mode ,unsigned int );
    public void codecvt<char32_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<char32_t,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<char32_t,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,char32_t * ,char32_t * ,char32_t &** );
    protected int do_out(struct _Mbstatet & ,char32_t * ,char32_t * ,char32_t &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private unsigned long _Maxcode;
    private enum std::_Codecvt_mode _Mode;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::codecvt<char32_t,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,char32_t * ,char32_t * ,char32_t &** );
    public int out(struct _Mbstatet & ,char32_t * ,char32_t * ,char32_t &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<char32_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned long ,enum std::_Codecvt_mode ,unsigned int );
    public void codecvt<char32_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<char32_t,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<char32_t,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,char32_t * ,char32_t * ,char32_t &** );
    protected int do_out(struct _Mbstatet & ,char32_t * ,char32_t * ,char32_t &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private unsigned long _Maxcode;
    private enum std::_Codecvt_mode _Mode;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::basic_fstream<wchar_t,std::char_traits<wchar_t> >
{
};

struct std::_String_base_types<char16_t,std::allocator<char16_t> >
{
};

struct std::_Maximum<1,8> : public std::integral_constant<unsigned int,8>
{
};

enum std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=4
};

enum std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=3
};

class std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char32_t _Buf[4];
        char32_t * _Ptr;
        char _Alias[4];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=4
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=3
    };
    public void _String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >();
    public void _Copy_alloc(class std::allocator<char32_t> & );
    public void _Move_alloc(class std::allocator<char32_t> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > > & );
    public class std::allocator<char32_t> & _Getal();
    public class std::allocator<char32_t> & _Getal();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_data();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >
{
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char32_t _Buf[4];
        char32_t * _Ptr;
        char _Alias[4];
        void * __vecDelDtor(unsigned int );
    };
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=4
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=3
    };
    public void _String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >();
    public void _Copy_alloc(class std::allocator<char32_t> & );
    public void _Move_alloc(class std::allocator<char32_t> & );
    public void _Orphan_all();
    public void _Swap_all(class std::_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > > & );
    public class std::allocator<char32_t> & _Getal();
    public class std::allocator<char32_t> & _Getal();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_data();
    public class std::_String_val<std::_Simple_types<char32_t> > & _Get_data();
    private class std::_Compressed_pair<std::allocator<char32_t>,std::_String_val<std::_Simple_types<char32_t> >,1> _Mypair;
    public void ~_String_alloc<std::_String_base_types<char32_t,std::allocator<char32_t> > >();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Sign_base<unsigned int,1>
{
};

class std::initializer_list<char32_t>
{
    public void initializer_list<char32_t>(char32_t * ,char32_t * );
    public void initializer_list<char32_t>();
    public char32_t * begin();
    public char32_t * end();
    public unsigned int size();
    private char32_t * _First;
    private char32_t * _Last;
};

class std::initializer_list<char16_t>
{
    public void initializer_list<char16_t>(char16_t * ,char16_t * );
    public void initializer_list<char16_t>();
    public char16_t * begin();
    public char16_t * end();
    public unsigned int size();
    private char16_t * _First;
    private char16_t * _Last;
};

class std::initializer_list<wchar_t>
{
    public void initializer_list<wchar_t>(wchar_t * ,wchar_t * );
    public void initializer_list<wchar_t>();
    public wchar_t * begin();
    public wchar_t * end();
    public unsigned int size();
    private wchar_t * _First;
    private wchar_t * _Last;
};

struct std::hash<std::nullptr_t>
{
    unsigned int operator()(void * );
};

struct std::hash<std::nullptr_t>
{
    unsigned int operator()(void * );
};

class std::numeric_limits<long double> : public std::_Num_float_base
{
    public float min();
    public float max();
    public float lowest();
    public float epsilon();
    public float round_error();
    public float denorm_min();
    public float infinity();
    public float quiet_NaN();
    public float signaling_NaN();
    public const int digits=53;
    public const int digits10=15;
    public const int max_digits10=17;
    public const int max_exponent=1024;
    public const int max_exponent10=308;
    public const int min_exponent=-1021;
    public const int min_exponent10=-307;
};

enum std::errc
{
    address_family_not_supported=102,
    address_in_use=100,
    address_not_available=101,
    already_connected=113,
    argument_list_too_long=7,
    argument_out_of_domain=33,
    bad_address=14,
    bad_file_descriptor=9,
    bad_message=104,
    broken_pipe=32,
    connection_aborted=106,
    connection_already_in_progress=103,
    connection_refused=107,
    connection_reset=108,
    cross_device_link=18,
    destination_address_required=109,
    device_or_resource_busy=16,
    directory_not_empty=41,
    executable_format_error=8,
    file_exists=17,
    file_too_large=27,
    filename_too_long=38,
    function_not_supported=40,
    host_unreachable=110,
    identifier_removed=111,
    illegal_byte_sequence=42,
    inappropriate_io_control_operation=25,
    interrupted=4,
    invalid_argument=22,
    invalid_seek=29,
    io_error=5,
    is_a_directory=21,
    message_size=115,
    network_down=116,
    network_reset=117,
    network_unreachable=118,
    no_buffer_space=119,
    no_child_process=10,
    no_link=121,
    no_lock_available=39,
    no_message_available=120,
    no_message=122,
    no_protocol_option=123,
    no_space_on_device=28,
    no_stream_resources=124,
    no_such_device_or_address=6,
    no_such_device=19,
    no_such_file_or_directory=2,
    no_such_process=3,
    not_a_directory=20,
    not_a_socket=128,
    not_a_stream=125,
    not_connected=126,
    not_enough_memory=12,
    not_supported=129,
    operation_canceled=105,
    operation_in_progress=112,
    operation_not_permitted=1,
    operation_not_supported=130,
    operation_would_block=140,
    owner_dead=133,
    permission_denied=13,
    protocol_error=134,
    protocol_not_supported=135,
    read_only_file_system=30,
    resource_deadlock_would_occur=36,
    resource_unavailable_try_again=11,
    result_out_of_range=34,
    state_not_recoverable=127,
    stream_timeout=137,
    text_file_busy=139,
    timed_out=138,
    too_many_files_open_in_system=23,
    too_many_files_open=24,
    too_many_links=31,
    too_many_symbolic_link_levels=114,
    value_too_large=132,
    wrong_protocol_type=136
};

struct std::_Invoker_pmd_object
{
};

struct std::_Add_reference<wchar_t const * const &,void>
{
};

struct std::default_delete<std::_Facet_base>
{
    void operator()(class std::_Facet_base * );
};

class std::range_error : public std::runtime_error
{
    public void range_error(class std::range_error * );
    public void range_error(class std::range_error & );
    public void range_error(char * );
    public void range_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~range_error();
    public class std::range_error & operator=(class std::range_error * );
    public class std::range_error & operator=(class std::range_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::range_error : public std::runtime_error
{
    public void range_error(class std::range_error * );
    public void range_error(class std::range_error & );
    public void range_error(char * );
    public void range_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~range_error();
    public class std::range_error & operator=(class std::range_error * );
    public class std::range_error & operator=(class std::range_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::bad_typeid : public std::exception
{
    public void bad_typeid(class std::bad_typeid * );
    public void bad_typeid(class std::bad_typeid & );
    private void bad_typeid(const char * ,int );
    public void bad_typeid();
    public class std::bad_typeid __construct_from_string_literal(const char * );
    public void ~bad_typeid();
    public class std::bad_typeid & operator=(class std::bad_typeid * );
    public class std::bad_typeid & operator=(class std::bad_typeid & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_typeid : public std::exception
{
    public void bad_typeid(class std::bad_typeid * );
    public void bad_typeid(class std::bad_typeid & );
    private void bad_typeid(const char * ,int );
    public void bad_typeid();
    public class std::bad_typeid __construct_from_string_literal(const char * );
    public void ~bad_typeid();
    public class std::bad_typeid & operator=(class std::bad_typeid * );
    public class std::bad_typeid & operator=(class std::bad_typeid & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Maximum<8> : public std::integral_constant<unsigned int,8>
{
};

class std::allocator<char16_t>
{
    public char16_t * address(char16_t & );
    public char16_t * address(char16_t & );
    public void allocator<char16_t>();
    public void deallocate(const char16_t * ,const unsigned int );
    public char16_t * allocate(const unsigned int ,void * );
    public char16_t * allocate(const unsigned int );
    public unsigned int max_size();
};

struct std::minus<void>
{
};

class std::basic_istringstream<char,std::char_traits<char>,std::allocator<char> >
{
};

class std::auto_ptr<void>
{
};

struct std::_Aligned<8,4,int,1>
{
};

struct std::_Is_default_allocator<std::allocator<char16_t>,void> : public std::integral_constant<bool,1>
{
};

struct std::greater<void>
{
};

struct std::_Not_a_node_tag
{
};

struct std::_Crt_new_delete
{
};

struct std::_Sign_base<char const ,1>
{
};

struct std::_Sign_base<unsigned long,1>
{
};

class std::allocator<char>
{
    public char * address(char & );
    public char * address(char & );
    public void allocator<char>();
    public void deallocate(const char * ,const unsigned int );
    public char * allocate(const unsigned int ,void * );
    public char * allocate(const unsigned int );
    public unsigned int max_size();
};

struct std::is_error_code_enum<std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > > : public std::integral_constant<bool,0>
{
};

struct std::random_access_iterator_tag : public std::bidirectional_iterator_tag
{
};

struct std::aligned_union<1,std::_System_error_category>
{
    const unsigned int _Max_len=8;
    const unsigned int alignment_value=4;
};

struct std::is_void<void const > : public std::integral_constant<bool,1>
{
};

struct std::_Change_sign<unsigned long>
{
};

class std::bad_weak_ptr : public std::exception
{
    public void bad_weak_ptr(class std::bad_weak_ptr * );
    public void bad_weak_ptr(class std::bad_weak_ptr & );
    public void bad_weak_ptr();
    public char * what();
    public void ~bad_weak_ptr();
    public class std::bad_weak_ptr & operator=(class std::bad_weak_ptr * );
    public class std::bad_weak_ptr & operator=(class std::bad_weak_ptr & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_weak_ptr : public std::exception
{
    public void bad_weak_ptr(class std::bad_weak_ptr * );
    public void bad_weak_ptr(class std::bad_weak_ptr & );
    public void bad_weak_ptr();
    public char * what();
    public void ~bad_weak_ptr();
    public class std::bad_weak_ptr & operator=(class std::bad_weak_ptr * );
    public class std::bad_weak_ptr & operator=(class std::bad_weak_ptr & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::numeric_limits<unsigned long> : public std::_Num_int_base
{
    public unsigned long min();
    public unsigned long max();
    public unsigned long lowest();
    public unsigned long epsilon();
    public unsigned long round_error();
    public unsigned long denorm_min();
    public unsigned long infinity();
    public unsigned long quiet_NaN();
    public unsigned long signaling_NaN();
    public const bool is_modulo=1;
    public const int digits=32;
    public const int digits10=9;
};

class std::_Yarn<wchar_t>
{
    public void _Yarn<wchar_t>(wchar_t * );
    public void _Yarn<wchar_t>(class std::_Yarn<wchar_t> & );
    public void _Yarn<wchar_t>();
    public class std::_Yarn<wchar_t> & operator=(wchar_t * );
    public class std::_Yarn<wchar_t> & operator=(class std::_Yarn<wchar_t> & );
    public void ~_Yarn<wchar_t>();
    public bool empty();
    public wchar_t * c_str();
    public bool _Empty();
    public wchar_t * _C_str();
    private void _Tidy();
    private wchar_t * _Myptr;
    private wchar_t _Nul;
    public void * __vecDelDtor(unsigned int );
};

class std::_Yarn<wchar_t>
{
    public void _Yarn<wchar_t>(wchar_t * );
    public void _Yarn<wchar_t>(class std::_Yarn<wchar_t> & );
    public void _Yarn<wchar_t>();
    public class std::_Yarn<wchar_t> & operator=(wchar_t * );
    public class std::_Yarn<wchar_t> & operator=(class std::_Yarn<wchar_t> & );
    public void ~_Yarn<wchar_t>();
    public bool empty();
    public wchar_t * c_str();
    public bool _Empty();
    public wchar_t * _C_str();
    private void _Tidy();
    private wchar_t * _Myptr;
    private wchar_t _Nul;
    public void * __vecDelDtor(unsigned int );
};

class std::ctype_byname<char> : public std::ctype<char>
{
    public void ctype_byname<char>(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,unsigned int );
    public void ctype_byname<char>(char * ,unsigned int );
    protected void ~ctype_byname<char>();
    protected void * __vecDelDtor(unsigned int );
};

struct std::iterator_traits<wchar_t *> : public std::_Iterator_traits_pointer_base<wchar_t,1>
{
};

struct std::_Maximum<> : public std::integral_constant<unsigned int,0>
{
};

class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > : public std::basic_istream<wchar_t,std::char_traits<wchar_t> >, public std::basic_ostream<wchar_t,std::char_traits<wchar_t> >, public std::basic_ios<wchar_t,std::char_traits<wchar_t> >
{
    public void basic_iostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_iostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > * );
    public void basic_iostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & );
    protected class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > * );
    protected void swap(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_iostream<wchar_t,std::char_traits<wchar_t> >();
    public void * __vecDelDtor(unsigned int );
};

class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > : public std::basic_istream<wchar_t,std::char_traits<wchar_t> >, public std::basic_ostream<wchar_t,std::char_traits<wchar_t> >, public std::basic_ios<wchar_t,std::char_traits<wchar_t> >
{
    public void basic_iostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & );
    protected void basic_iostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > * );
    public void basic_iostream<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & );
    protected class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & operator=(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > * );
    protected void swap(class std::basic_iostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ~basic_iostream<wchar_t,std::char_traits<wchar_t> >();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Range_verifiable<std::istreambuf_iterator<char,std::char_traits<char> >,std::istreambuf_iterator<char,std::char_traits<char> >,void> : public std::integral_constant<bool,0>
{
};

struct std::_Add_reference<char * &,void>
{
};

class std::numeric_limits<signed char> : public std::_Num_int_base
{
    public int min();
    public int max();
    public int lowest();
    public int epsilon();
    public int round_error();
    public int denorm_min();
    public int infinity();
    public int quiet_NaN();
    public int signaling_NaN();
    public const bool is_signed=1;
    public const int digits=7;
    public const int digits10=2;
};

class std::domain_error : public std::logic_error
{
    public void domain_error(class std::domain_error * );
    public void domain_error(class std::domain_error & );
    public void domain_error(char * );
    public void domain_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~domain_error();
    public class std::domain_error & operator=(class std::domain_error * );
    public class std::domain_error & operator=(class std::domain_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::domain_error : public std::logic_error
{
    public void domain_error(class std::domain_error * );
    public void domain_error(class std::domain_error & );
    public void domain_error(char * );
    public void domain_error(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void ~domain_error();
    public class std::domain_error & operator=(class std::domain_error * );
    public class std::domain_error & operator=(class std::domain_error & );
    public void * __vecDelDtor(unsigned int );
};

class std::istreambuf_iterator<char,std::char_traits<char> >
{
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy & );
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > & );
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public void istreambuf_iterator<char,std::char_traits<char> >();
    class _Istreambuf_proxy
    {
        public char operator*();
        private void _Istreambuf_proxy(class std::basic_streambuf<char,std::char_traits<char> > * ,char );
        private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
        private char _Keep;
    };
    public char operator*();
    public class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy operator++(int );
    public class std::istreambuf_iterator<char,std::char_traits<char> > & operator++();
    public bool equal(class std::istreambuf_iterator<char,std::char_traits<char> > & );
    private void _Inc();
    private char _Peek();
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    private bool _Got;
    private char _Val;
};

struct std::_Add_reference<std::istreambuf_iterator<char,std::char_traits<char> > const &,void>
{
};

struct std::_Is_character<unsigned char> : public std::integral_constant<bool,1>
{
};

struct std::is_unsigned<unsigned long> : public std::integral_constant<bool,1>
{
};

class std::allocator<wchar_t>
{
    public wchar_t * address(wchar_t & );
    public wchar_t * address(wchar_t & );
    public void allocator<wchar_t>();
    public void deallocate(const wchar_t * ,const unsigned int );
    public wchar_t * allocate(const unsigned int ,void * );
    public wchar_t * allocate(const unsigned int );
    public unsigned int max_size();
};

class std::allocator<void>
{
};

class std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
{
};

struct std::_Is_floating_point<double> : public std::integral_constant<bool,1>
{
};

class std::numeric_limits<char> : public std::_Num_int_base
{
    public char min();
    public char max();
    public char lowest();
    public char epsilon();
    public char round_error();
    public char denorm_min();
    public char infinity();
    public char quiet_NaN();
    public char signaling_NaN();
    public const bool is_signed=1;
    public const bool is_modulo=0;
    public const int digits=7;
    public const int digits10=2;
};

enum std::ctype_base::<unnamed-enum-alnum>
{
    alnum=263,
    alpha=259,
    cntrl=32,
    digit=4,
    graph=279,
    lower=2,
    print=471,
    punct=16,
    space=72,
    upper=1,
    xdigit=128,
    blank=72
};

struct std::ctype_base : public std::locale::facet
{
    enum <unnamed-enum-alnum>
    {
        alnum=263,
        alpha=259,
        cntrl=32,
        digit=4,
        graph=279,
        lower=2,
        print=471,
        punct=16,
        space=72,
        upper=1,
        xdigit=128,
        blank=72
    };
    void ctype_base(unsigned int );
    void ~ctype_base();
    void __dflt_ctor_closure();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

class std::codecvt<char16_t,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,char16_t * ,char16_t * ,char16_t &** );
    public int out(struct _Mbstatet & ,char16_t * ,char16_t * ,char16_t &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<char16_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned long ,enum std::_Codecvt_mode ,unsigned int );
    public void codecvt<char16_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<char16_t,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<char16_t,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,char16_t * ,char16_t * ,char16_t &** );
    protected int do_out(struct _Mbstatet & ,char16_t * ,char16_t * ,char16_t &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private unsigned long _Maxcode;
    private enum std::_Codecvt_mode _Mode;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::codecvt<char16_t,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,char16_t * ,char16_t * ,char16_t &** );
    public int out(struct _Mbstatet & ,char16_t * ,char16_t * ,char16_t &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<char16_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned long ,enum std::_Codecvt_mode ,unsigned int );
    public void codecvt<char16_t,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<char16_t,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<char16_t,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,char16_t * ,char16_t * ,char16_t &** );
    protected int do_out(struct _Mbstatet & ,char16_t * ,char16_t * ,char16_t &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private unsigned long _Maxcode;
    private enum std::_Codecvt_mode _Mode;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::char_traits<char>
{
    int compare(const char * ,const char * ,const unsigned int );
    unsigned int length(const char * );
    char * copy(const char * ,const char * ,const unsigned int );
    char * _Copy_s(const char * ,const unsigned int ,const char * ,const unsigned int );
    char * find(const char * ,const unsigned int ,char & );
    char * move(const char * ,const char * ,const unsigned int );
    void assign(char & ,char & );
    char * assign(const char * ,const unsigned int ,const char );
    bool eq(char & ,char & );
    bool lt(char & ,char & );
    char to_char_type(int & );
    int to_int_type(char & );
    bool eq_int_type(int & ,int & );
    int not_eof(int & );
    int eof();
};

enum std::error_category::<unnamed-enum-_Future_addr>
{
    _Future_addr=1,
    _Generic_addr=3,
    _Iostream_addr=5,
    _System_addr=7
};

class std::error_category
{
    public void error_category(class std::error_category & );
    public void error_category();
    public void ~error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public class std::error_condition default_error_condition(int );
    public bool equivalent(class std::error_code & ,int );
    public bool equivalent(int ,class std::error_condition & );
    public bool operator==(class std::error_category & );
    public bool operator!=(class std::error_category & );
    public bool operator<(class std::error_category & );
    public class std::error_category & operator=(class std::error_category & );
    protected unsigned int _Addr;
    enum <unnamed-enum-_Future_addr>
    {
        _Future_addr=1,
        _Generic_addr=3,
        _Iostream_addr=5,
        _System_addr=7
    };
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Unused_parameter
{
};

struct std::_Is_character<signed char> : public std::integral_constant<bool,1>
{
};

class std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1> : private std::allocator<char16_t>
{
    private class std::_String_val<std::_Simple_types<char16_t> > _Myval2;
    public class std::allocator<char16_t> & _Get_first();
    public class std::allocator<char16_t> & _Get_first();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_second();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>();
    public void * __vecDelDtor(unsigned int );
};

class std::_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1> : private std::allocator<char16_t>
{
    private class std::_String_val<std::_Simple_types<char16_t> > _Myval2;
    public class std::allocator<char16_t> & _Get_first();
    public class std::allocator<char16_t> & _Get_first();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_second();
    public class std::_String_val<std::_Simple_types<char16_t> > & _Get_second();
    public void ~_Compressed_pair<std::allocator<char16_t>,std::_String_val<std::_Simple_types<char16_t> >,1>();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Invoker_pmd_refwrap
{
};

struct std::_Is_integral<short> : public std::integral_constant<bool,1>
{
};

struct std::is_error_code_enum<enum std::io_errc> : public std::integral_constant<bool,1>
{
};

struct std::_Default_allocator_traits<std::allocator<char16_t> >
{
    char16_t * allocate(class std::allocator<char16_t> & ,const unsigned int ,void * );
    char16_t * allocate(class std::allocator<char16_t> & ,const unsigned int );
    void deallocate(class std::allocator<char16_t> & ,const char16_t * ,const unsigned int );
    unsigned int max_size(class std::allocator<char16_t> & );
    class std::allocator<char16_t> select_on_container_copy_construction(class std::allocator<char16_t> & );
};

struct std::_Facetptr<std::ctype<wchar_t> >
{
    class std::locale::facet * _Psave;
};

struct std::iterator_traits<char *> : public std::_Iterator_traits_pointer_base<char,1>
{
};

class std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
{
};

enum std::_String_val<std::_Simple_types<wchar_t> >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=8
};

enum std::_String_val<std::_Simple_types<wchar_t> >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=7
};

class std::_String_val<std::_Simple_types<wchar_t> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<wchar_t> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=8
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=7
    };
    public wchar_t * _Myptr();
    public wchar_t * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        wchar_t _Buf[8];
        wchar_t * _Ptr;
        char _Alias[8];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<wchar_t> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<wchar_t> >();
    public void * __vecDelDtor(unsigned int );
};

union std::_String_val<std::_Simple_types<wchar_t> >::_Bxty
{
    void _Bxty();
    void ~_Bxty();
    wchar_t _Buf[8];
    wchar_t * _Ptr;
    char _Alias[8];
    void * __vecDelDtor(unsigned int );
};

class std::_Facet_base
{
    public void ~_Facet_base();
    public void _Incref();
    public class std::_Facet_base * _Decref();
    public void _Facet_base(class std::_Facet_base & );
    public void _Facet_base();
    public class std::_Facet_base & operator=(class std::_Facet_base & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_Facet_base
{
    public void ~_Facet_base();
    public void _Incref();
    public class std::_Facet_base * _Decref();
    public void _Facet_base(class std::_Facet_base & );
    public void _Facet_base();
    public class std::_Facet_base & operator=(class std::_Facet_base & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_WChar_traits<wchar_t>
{
    int compare(const wchar_t * ,const wchar_t * ,const unsigned int );
    unsigned int length(wchar_t * );
    wchar_t * copy(const wchar_t * ,const wchar_t * ,const unsigned int );
    wchar_t * _Copy_s(const wchar_t * ,const unsigned int ,const wchar_t * ,const unsigned int );
    wchar_t * find(wchar_t * ,const unsigned int ,wchar_t & );
    wchar_t * move(const wchar_t * ,const wchar_t * ,const unsigned int );
    void assign(wchar_t & ,wchar_t & );
    wchar_t * assign(const wchar_t * ,unsigned int ,wchar_t );
    bool eq(wchar_t & ,wchar_t & );
    bool lt(wchar_t & ,wchar_t & );
    wchar_t to_char_type(unsigned int & );
    unsigned int to_int_type(wchar_t & );
    bool eq_int_type(unsigned int & ,unsigned int & );
    unsigned int not_eof(unsigned int & );
    unsigned int eof();
};

class std::codecvt<unsigned short,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,unsigned int * ,unsigned int * ,unsigned int &** );
    public int out(struct _Mbstatet & ,unsigned int * ,unsigned int * ,unsigned int &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<unsigned short,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<unsigned short,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<unsigned short,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,unsigned int * ,unsigned int * ,unsigned int &** );
    protected int do_out(struct _Mbstatet & ,unsigned int * ,unsigned int * ,unsigned int &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::codecvt<unsigned short,char,_Mbstatet> : public std::codecvt_base
{
    public int in(struct _Mbstatet & ,char * ,char * ,char &** ,unsigned int * ,unsigned int * ,unsigned int &** );
    public int out(struct _Mbstatet & ,unsigned int * ,unsigned int * ,unsigned int &** ,char * ,char * ,char &** );
    public int unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    public int length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    public class std::locale::id id;
    public void codecvt<unsigned short,char,_Mbstatet>(class std::_Locinfo & ,unsigned int );
    public void codecvt<unsigned short,char,_Mbstatet>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~codecvt<unsigned short,char,_Mbstatet>();
    protected void _Init(class std::_Locinfo & );
    protected int do_in(struct _Mbstatet & ,char * ,char * ,char &** ,unsigned int * ,unsigned int * ,unsigned int &** );
    protected int do_out(struct _Mbstatet & ,unsigned int * ,unsigned int * ,unsigned int &** ,char * ,char * ,char &** );
    protected int do_unshift(struct _Mbstatet & ,char * ,char * ,char &** );
    protected int do_length(struct _Mbstatet & ,char * ,char * ,unsigned int );
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    private struct _Cvtvec _Cvt;
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

struct std::_Unwrappable<char *,void> : public std::integral_constant<bool,0>
{
};

struct std::_Is_integral<char> : public std::integral_constant<bool,1>
{
};

struct std::is_error_condition_enum<std::error_code> : public std::integral_constant<bool,0>
{
};

class std::_Generic_error_category : public std::error_category
{
    public void _Generic_error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public void ~_Generic_error_category();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_Generic_error_category : public std::error_category
{
    public void _Generic_error_category();
    public char * name();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message(int );
    public void ~_Generic_error_category();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct std::_Range_verifiable<wchar_t const *,wchar_t const *,void> : public std::integral_constant<bool,0>
{
};

struct std::input_iterator_tag
{
};

struct std::_Facetptr<std::numpunct<char> >
{
    class std::locale::facet * _Psave;
};

struct std::_Is_integral<unsigned char> : public std::integral_constant<bool,1>
{
};

struct std::is_floating_point<long double> : public std::integral_constant<bool,1>
{
};

struct std::_WChar_traits<unsigned short>
{
    int compare(const unsigned int * ,const unsigned int * ,const unsigned int );
    unsigned int length(unsigned int * );
    unsigned int * copy(const unsigned int * ,const unsigned int * ,const unsigned int );
    unsigned int * _Copy_s(const unsigned int * ,const unsigned int ,const unsigned int * ,const unsigned int );
    unsigned int * find(unsigned int * ,const unsigned int ,unsigned int & );
    unsigned int * move(const unsigned int * ,const unsigned int * ,const unsigned int );
    void assign(unsigned int & ,unsigned int & );
    unsigned int * assign(const unsigned int * ,unsigned int ,unsigned int );
    bool eq(unsigned int & ,unsigned int & );
    bool lt(unsigned int & ,unsigned int & );
    unsigned int to_char_type(unsigned int & );
    unsigned int to_int_type(unsigned int & );
    bool eq_int_type(unsigned int & ,unsigned int & );
    unsigned int not_eof(unsigned int & );
    unsigned int eof();
};

enum std::codecvt_base::<unnamed-enum-ok>
{
    ok=0,
    partial=1,
    error=2,
    noconv=3
};

class std::codecvt_base : public std::locale::facet
{
    enum <unnamed-enum-ok>
    {
        ok=0,
        partial=1,
        error=2,
        noconv=3
    };
    public void codecvt_base(unsigned int );
    public bool always_noconv();
    public int max_length();
    public int encoding();
    public void ~codecvt_base();
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::codecvt_base : public std::locale::facet
{
    enum <unnamed-enum-ok>
    {
        ok=0,
        partial=1,
        error=2,
        noconv=3
    };
    public void codecvt_base(unsigned int );
    public bool always_noconv();
    public int max_length();
    public int encoding();
    public void ~codecvt_base();
    protected bool do_always_noconv();
    protected int do_max_length();
    protected int do_encoding();
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy
{
    public wchar_t operator*();
    private void _Istreambuf_proxy(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,wchar_t );
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    private wchar_t _Keep;
};

class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
{
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy & );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >();
    class _Istreambuf_proxy
    {
        public wchar_t operator*();
        private void _Istreambuf_proxy(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,wchar_t );
        private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
        private wchar_t _Keep;
    };
    public wchar_t operator*();
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy operator++(int );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++();
    public bool equal(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & );
    private void _Inc();
    private wchar_t _Peek();
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    private bool _Got;
    private wchar_t _Val;
};

class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
{
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy & );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >();
    class _Istreambuf_proxy
    {
        public wchar_t operator*();
        private void _Istreambuf_proxy(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,wchar_t );
        private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
        private wchar_t _Keep;
    };
    public wchar_t operator*();
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy operator++(int );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++();
    public bool equal(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & );
    private void _Inc();
    private wchar_t _Peek();
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    private bool _Got;
    private wchar_t _Val;
};

class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy
{
    public wchar_t operator*();
    private void _Istreambuf_proxy(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,wchar_t );
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    private wchar_t _Keep;
};

struct std::_Add_reference<std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > const &,void>
{
};

struct std::is_pointer<int> : public std::integral_constant<bool,0>
{
};

struct std::is_error_condition_enum<std::error_category> : public std::integral_constant<bool,0>
{
};

struct std::integral_constant<unsigned int,8>
{
    const unsigned int value=8;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

struct std::integral_constant<unsigned int,8>
{
    const unsigned int value=8;
    unsigned int operator unsigned int();
    unsigned int operator()();
};

class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy
{
    public char operator*();
    private void _Istreambuf_proxy(class std::basic_streambuf<char,std::char_traits<char> > * ,char );
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    private char _Keep;
};

class std::istreambuf_iterator<char,std::char_traits<char> >
{
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy & );
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > & );
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public void istreambuf_iterator<char,std::char_traits<char> >();
    class _Istreambuf_proxy
    {
        public char operator*();
        private void _Istreambuf_proxy(class std::basic_streambuf<char,std::char_traits<char> > * ,char );
        private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
        private char _Keep;
    };
    public char operator*();
    public class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy operator++(int );
    public class std::istreambuf_iterator<char,std::char_traits<char> > & operator++();
    public bool equal(class std::istreambuf_iterator<char,std::char_traits<char> > & );
    private void _Inc();
    private char _Peek();
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    private bool _Got;
    private char _Val;
};

class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy
{
    public char operator*();
    private void _Istreambuf_proxy(class std::basic_streambuf<char,std::char_traits<char> > * ,char );
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    private char _Keep;
};

struct std::allocator_traits<std::allocator<char16_t> > : public std::_Default_allocator_traits<std::allocator<char16_t> >
{
};

struct std::_Is_default_allocator<std::allocator<wchar_t>,void> : public std::integral_constant<bool,1>
{
};

struct std::is_object<wchar_t> : public std::integral_constant<bool,1>
{
};

class std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >
{
    public struct std::default_delete<std::_Facet_base> & get_deleter();
    public struct std::default_delete<std::_Facet_base> & get_deleter();
    public class std::_Facet_base &** _Myptr();
    public class std::_Facet_base &** _Myptr();
    public class std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1> _Mypair;
};

class std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >
{
    public struct std::default_delete<std::_Facet_base> & get_deleter();
    public struct std::default_delete<std::_Facet_base> & get_deleter();
    public class std::_Facet_base &** _Myptr();
    public class std::_Facet_base &** _Myptr();
    public class std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1> _Mypair;
};

class std::numeric_limits<int> : public std::_Num_int_base
{
    public int min();
    public int max();
    public int lowest();
    public int epsilon();
    public int round_error();
    public int denorm_min();
    public int infinity();
    public int quiet_NaN();
    public int signaling_NaN();
    public const bool is_signed=1;
    public const int digits=31;
    public const int digits10=9;
};

struct std::_Is_integral<unsigned int> : public std::integral_constant<bool,1>
{
};

enum std::_String_val<std::_Simple_types<char> >::<unnamed-enum-_BUF_SIZE>
{
    _BUF_SIZE=16
};

enum std::_String_val<std::_Simple_types<char> >::<unnamed-enum-_ALLOC_MASK>
{
    _ALLOC_MASK=15
};

class std::_String_val<std::_Simple_types<char> > : public std::_Container_base0
{
    public void _String_val<std::_Simple_types<char> >();
    enum <unnamed-enum-_BUF_SIZE>
    {
        _BUF_SIZE=16
    };
    enum <unnamed-enum-_ALLOC_MASK>
    {
        _ALLOC_MASK=15
    };
    public char * _Myptr();
    public char * _Myptr();
    public bool _Large_string_engaged();
    public void _Check_offset(const unsigned int );
    public void _Check_offset_exclusive(const unsigned int );
    public void _Xran();
    public unsigned int _Clamp_suffix_size(const unsigned int ,const unsigned int );
    union _Bxty
    {
        void _Bxty();
        void ~_Bxty();
        char _Buf[16];
        char * _Ptr;
        char _Alias[16];
        void * __vecDelDtor(unsigned int );
    };
    public union std::_String_val<std::_Simple_types<char> >::_Bxty _Bx;
    public unsigned int _Mysize;
    public unsigned int _Myres;
    public void ~_String_val<std::_Simple_types<char> >();
    public void * __vecDelDtor(unsigned int );
};

union std::_String_val<std::_Simple_types<char> >::_Bxty
{
    void _Bxty();
    void ~_Bxty();
    char _Buf[16];
    char * _Ptr;
    char _Alias[16];
    void * __vecDelDtor(unsigned int );
};

struct std::make_unsigned<long>
{
};

struct tagENUMTEXTMETRICA
{
    struct tagNEWTEXTMETRICEXA etmNewTextMetricEx;
    struct tagAXESLISTA etmAxesList;
};

struct tagMCI_ANIM_RECT_PARMS
{
    unsigned long dwCallback;
    struct tagRECT rc;
};

struct _LDT_ENTRY
{
    unsigned int LimitLow;
    unsigned int BaseLow;
    union <unnamed-type-HighWord>
    {
        struct <unnamed-type-Bytes>
        {
            unsigned int BaseMid;
            unsigned int Flags1;
            unsigned int Flags2;
            unsigned int BaseHi;
        };
        struct _LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bytes> Bytes;
        struct <unnamed-type-Bits>
        {
            unsigned long BaseMid:8;
            unsigned long Type:5;
            unsigned long Dpl:2;
            unsigned long Pres:1;
            unsigned long LimitHi:4;
            unsigned long Sys:1;
            unsigned long Reserved_0:1;
            unsigned long Default_Big:1;
            unsigned long Granularity:1;
            unsigned long BaseHi:8;
        };
        struct _LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bits> Bits;
    };
    union _LDT_ENTRY::<unnamed-type-HighWord> HighWord;
};

union _LDT_ENTRY::<unnamed-type-HighWord>
{
    struct <unnamed-type-Bytes>
    {
        unsigned int BaseMid;
        unsigned int Flags1;
        unsigned int Flags2;
        unsigned int BaseHi;
    };
    struct _LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bytes> Bytes;
    struct <unnamed-type-Bits>
    {
        unsigned long BaseMid:8;
        unsigned long Type:5;
        unsigned long Dpl:2;
        unsigned long Pres:1;
        unsigned long LimitHi:4;
        unsigned long Sys:1;
        unsigned long Reserved_0:1;
        unsigned long Default_Big:1;
        unsigned long Granularity:1;
        unsigned long BaseHi:8;
    };
    struct _LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bits> Bits;
};

struct _LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bits>
{
    unsigned long BaseMid:8;
    unsigned long Type:5;
    unsigned long Dpl:2;
    unsigned long Pres:1;
    unsigned long LimitHi:4;
    unsigned long Sys:1;
    unsigned long Reserved_0:1;
    unsigned long Default_Big:1;
    unsigned long Granularity:1;
    unsigned long BaseHi:8;
};

struct _LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bytes>
{
    unsigned int BaseMid;
    unsigned int Flags1;
    unsigned int Flags2;
    unsigned int BaseHi;
};

struct tagBITMAPINFOHEADER
{
    unsigned long biSize;
    long biWidth;
    long biHeight;
    unsigned int biPlanes;
    unsigned int biBitCount;
    unsigned long biCompression;
    unsigned long biSizeImage;
    long biXPelsPerMeter;
    long biYPelsPerMeter;
    unsigned long biClrUsed;
    unsigned long biClrImportant;
};

struct tagAXISINFOA
{
    long axMinValue;
    long axMaxValue;
    unsigned int axAxisName[16];
};

struct _SYSTEM_POWER_STATUS
{
    unsigned int ACLineStatus;
    unsigned int BatteryFlag;
    unsigned int BatteryLifePercent;
    unsigned int Reserved1;
    unsigned long BatteryLifeTime;
    unsigned long BatteryFullLifeTime;
};

struct tagFILTERKEYS
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long iWaitMSec;
    unsigned long iDelayMSec;
    unsigned long iRepeatMSec;
    unsigned long iBounceMSec;
};

struct _ACTIVATION_CONTEXT_BASIC_INFORMATION
{
    void * hActCtx;
    unsigned long dwFlags;
};

class SVersion
{
    public void SVersion(class SString );
    public void SVersion(int );
    public void SVersion(enum SwineVersionType ,int ,int );
    public void SVersion();
    public class SString GetVersionTypeString();
    public enum SwineVersionType GetVersionTypeFromString(char * );
    public float GetFloat();
    public int GetInt();
    public class SString GetLongString();
    public class SString GetShortString();
    public class SString GetNetworkString();
    public bool IsGoodVersion(class SVersion );
    public int GetMajorVersion();
    public int GetMinorVersion();
    public enum SwineVersionType GetVersionType();
    private int MajorVersion;
    private int MinorVersion;
    private enum SwineVersionType VersionType;
};

struct BITMAPV5HEADER
{
    unsigned long bV5Size;
    long bV5Width;
    long bV5Height;
    unsigned int bV5Planes;
    unsigned int bV5BitCount;
    unsigned long bV5Compression;
    unsigned long bV5SizeImage;
    long bV5XPelsPerMeter;
    long bV5YPelsPerMeter;
    unsigned long bV5ClrUsed;
    unsigned long bV5ClrImportant;
    unsigned long bV5RedMask;
    unsigned long bV5GreenMask;
    unsigned long bV5BlueMask;
    unsigned long bV5AlphaMask;
    unsigned long bV5CSType;
    struct tagICEXYZTRIPLE bV5Endpoints;
    unsigned long bV5GammaRed;
    unsigned long bV5GammaGreen;
    unsigned long bV5GammaBlue;
    unsigned long bV5Intent;
    unsigned long bV5ProfileData;
    unsigned long bV5ProfileSize;
    unsigned long bV5Reserved;
};

union _ldouble_val
{
    unsigned int _Sh[4];
    float _Val;
};

struct _JOBOBJECT_BASIC_PROCESS_ID_LIST
{
    unsigned long NumberOfAssignedProcesses;
    unsigned long NumberOfProcessIdsInList;
    unsigned long ProcessIdList[1];
};

struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY
{
    unsigned long FuncStart;
    unsigned long PrologLen:8;
    unsigned long FuncLen:22;
    unsigned long ThirtyTwoBit:1;
    unsigned long ExceptionFlag:1;
};

struct _UNIVERSAL_NAME_INFOA
{
    char * lpUniversalName;
};

struct tagMCI_OVLY_RECT_PARMS
{
    unsigned long dwCallback;
    struct tagRECT rc;
};

struct _TRANSACTION_NOTIFICATION
{
    void * TransactionKey;
    unsigned long TransactionNotification;
    union _LARGE_INTEGER TmVirtualClock;
    unsigned long ArgumentLength;
};

struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
{
    void * lpInformation;
    void * lpSectionBase;
    unsigned long ulSectionLength;
    void * lpSectionGlobalDataBase;
    unsigned long ulSectionGlobalDataLength;
};

struct _SERVICE_FAILURE_ACTIONSW
{
    unsigned long dwResetPeriod;
    wchar_t * lpRebootMsg;
    wchar_t * lpCommand;
    unsigned long cActions;
    struct _SC_ACTION * lpsaActions;
};

struct _TOKEN_ACCESS_INFORMATION
{
    struct _SID_AND_ATTRIBUTES_HASH * SidHash;
    struct _SID_AND_ATTRIBUTES_HASH * RestrictedSidHash;
    struct _TOKEN_PRIVILEGES * Privileges;
    struct _LUID AuthenticationId;
    enum _TOKEN_TYPE TokenType;
    enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    struct _TOKEN_MANDATORY_POLICY MandatoryPolicy;
    unsigned long Flags;
};

struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION
{
    unsigned long EndOfJobTimeAction;
};

struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION
{
    unsigned long LogPathLength;
    wchar_t LogPath[1];
};

struct _TOKEN_ELEVATION
{
    unsigned long TokenIsElevated;
};

struct tagEMRSETPALETTEENTRIES
{
    struct tagEMR emr;
    unsigned long ihPal;
    unsigned long iStart;
    unsigned long cEntries;
    struct tagPALETTEENTRY aPalEntries[1];
};

struct tagSIZE
{
    long cx;
    long cy;
};

struct tagWAVEINCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct _SERVICE_TABLE_ENTRYA
{
    char * lpServiceName;
    void  ( * lpServiceProc)(unsigned long ,char ** );
};

struct PPM_WMI_IDLE_STATES_EX
{
    unsigned long Type;
    unsigned long Count;
    unsigned long TargetState;
    unsigned long OldState;
    void * TargetProcessors;
    struct PPM_WMI_IDLE_STATE State[1];
};

struct _TOKEN_GROUPS_AND_PRIVILEGES
{
    unsigned long SidCount;
    unsigned long SidLength;
    struct _SID_AND_ATTRIBUTES * Sids;
    unsigned long RestrictedSidCount;
    unsigned long RestrictedSidLength;
    struct _SID_AND_ATTRIBUTES * RestrictedSids;
    unsigned long PrivilegeCount;
    unsigned long PrivilegeLength;
    struct _LUID_AND_ATTRIBUTES * Privileges;
    struct _LUID AuthenticationId;
};

struct tagMONITORINFOEXA : public tagMONITORINFO
{
    char szDevice[32];
};

struct _SID_IDENTIFIER_AUTHORITY
{
    unsigned int Value[6];
};

struct _DOCINFOW
{
    int cbSize;
    wchar_t * lpszDocName;
    wchar_t * lpszOutput;
    wchar_t * lpszDatatype;
    unsigned long fwType;
};

struct SPoint3
{
    float x;
    float y;
    float z;
    void SPoint3(float ,float ,float );
    void SPoint3();
    struct SPoint3 operator+(struct SVector3 & );
    struct SPoint3 & operator+=(struct SVector3 & );
    struct SVector3 operator-(struct SPoint3 & );
    struct SPoint3 operator-(struct SVector3 & );
    struct SPoint3 & operator-=(struct SVector3 & );
    float DistanceSqr(struct SPoint3 & );
    float Distance(struct SPoint3 & );
    struct SPoint3 Lerp(struct SPoint3 & ,struct SPoint3 & ,float );
};

struct SPlane
{
    float a;
    float b;
    float c;
    float d;
    void SPlane(struct SPoint3 & ,struct SPoint3 & ,struct SVector3 & );
    void SPlane(struct SPoint3 & ,struct SPoint3 & ,struct SPoint3 & );
    void SPlane(float ,float ,float ,float );
    void SPlane();
    float LengthSqr();
    struct SPlane & Normalize();
    struct SPlane GetNormalized();
};

struct SPlane
{
    float a;
    float b;
    float c;
    float d;
    void SPlane(struct SPoint3 & ,struct SPoint3 & ,struct SVector3 & );
    void SPlane(struct SPoint3 & ,struct SPoint3 & ,struct SPoint3 & );
    void SPlane(float ,float ,float ,float );
    void SPlane();
    float LengthSqr();
    struct SPlane & Normalize();
    struct SPlane GetNormalized();
};

struct tagMCI_ANIM_OPEN_PARMSA
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    char * lpstrDeviceType;
    char * lpstrElementName;
    char * lpstrAlias;
    unsigned long dwStyle;
    struct HWND__ * hWndParent;
};

struct tagCLIENTCREATESTRUCT
{
    void * hWindowMenu;
    unsigned int idFirstChild;
};

struct tagSOUNDSENTRYW
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long iFSTextEffect;
    unsigned long iFSTextEffectMSec;
    unsigned long iFSTextEffectColorBits;
    unsigned long iFSGrafEffect;
    unsigned long iFSGrafEffectMSec;
    unsigned long iFSGrafEffectColor;
    unsigned long iWindowsEffect;
    unsigned long iWindowsEffectMSec;
    wchar_t * lpszWindowsEffectDLL;
    unsigned long iWindowsEffectOrdinal;
};

struct tagSTYLEBUFW
{
    unsigned long dwStyle;
    wchar_t szDescription[32];
};

struct _MMCKINFO
{
    unsigned long ckid;
    unsigned long cksize;
    unsigned long fccType;
    unsigned long dwDataOffset;
    unsigned long dwFlags;
};

struct _DRAWPATRECT
{
    struct tagPOINT ptPosition;
    struct tagPOINT ptSize;
    unsigned int wStyle;
    unsigned int wPattern;
};

struct _wfinddata64i32_t
{
    unsigned int attrib;
    int time_create;
    int time_access;
    int time_write;
    unsigned long size;
    wchar_t name[260];
};

struct tagMCI_BREAK_PARMS
{
    unsigned long dwCallback;
    int nVirtKey;
    struct HWND__ * hwndBreak;
};

struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
{
    unsigned long ulFlags;
    unsigned long ulEncodedAssemblyIdentityLength;
    unsigned long ulManifestPathType;
    unsigned long ulManifestPathLength;
    union _LARGE_INTEGER liManifestLastWriteTime;
    unsigned long ulPolicyPathType;
    unsigned long ulPolicyPathLength;
    union _LARGE_INTEGER liPolicyLastWriteTime;
    unsigned long ulMetadataSatelliteRosterIndex;
    unsigned long ulManifestVersionMajor;
    unsigned long ulManifestVersionMinor;
    unsigned long ulPolicyVersionMajor;
    unsigned long ulPolicyVersionMinor;
    unsigned long ulAssemblyDirectoryNameLength;
    wchar_t * lpAssemblyEncodedAssemblyIdentity;
    wchar_t * lpAssemblyManifestPath;
    wchar_t * lpAssemblyPolicyPath;
    wchar_t * lpAssemblyDirectoryName;
    unsigned long ulFileCount;
};

struct _FILE_STREAM_INFO
{
    unsigned long NextEntryOffset;
    unsigned long StreamNameLength;
    union _LARGE_INTEGER StreamSize;
    union _LARGE_INTEGER StreamAllocationSize;
    wchar_t StreamName[1];
};

struct tagRID_DEVICE_INFO_KEYBOARD
{
    unsigned long dwType;
    unsigned long dwSubType;
    unsigned long dwKeyboardMode;
    unsigned long dwNumberOfFunctionKeys;
    unsigned long dwNumberOfIndicators;
    unsigned long dwNumberOfKeysTotal;
};

struct DISPLAYCONFIG_TARGET_DEVICE_NAME
{
    struct DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
    enum DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    unsigned int edidManufactureId;
    unsigned int edidProductCodeId;
    unsigned int connectorInstance;
    wchar_t monitorFriendlyDeviceName[64];
    wchar_t monitorDevicePath[128];
};

struct _WOW64_LDT_ENTRY
{
    unsigned int LimitLow;
    unsigned int BaseLow;
    union <unnamed-type-HighWord>
    {
        struct <unnamed-type-Bytes>
        {
            unsigned int BaseMid;
            unsigned int Flags1;
            unsigned int Flags2;
            unsigned int BaseHi;
        };
        struct _WOW64_LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bytes> Bytes;
        struct <unnamed-type-Bits>
        {
            unsigned long BaseMid:8;
            unsigned long Type:5;
            unsigned long Dpl:2;
            unsigned long Pres:1;
            unsigned long LimitHi:4;
            unsigned long Sys:1;
            unsigned long Reserved_0:1;
            unsigned long Default_Big:1;
            unsigned long Granularity:1;
            unsigned long BaseHi:8;
        };
        struct _WOW64_LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bits> Bits;
    };
    union _WOW64_LDT_ENTRY::<unnamed-type-HighWord> HighWord;
};

struct _TP_CALLBACK_ENVIRON_V3
{
    unsigned long Version;
    struct _TP_POOL * Pool;
    struct _TP_CLEANUP_GROUP * CleanupGroup;
    void  ( * CleanupGroupCancelCallback)(void * ,void * );
    void * RaceDll;
    struct _ACTIVATION_CONTEXT * ActivationContext;
    void  ( * FinalizationCallback)(struct _TP_CALLBACK_INSTANCE * ,void * );
    union <unnamed-type-u>
    {
        unsigned long Flags;
        struct <unnamed-type-s>
        {
            unsigned long LongFunction:1;
            unsigned long Persistent:1;
            unsigned long Private:30;
        };
        struct _TP_CALLBACK_ENVIRON_V3::<unnamed-type-u>::<unnamed-type-s> s;
    };
    union _TP_CALLBACK_ENVIRON_V3::<unnamed-type-u> u;
    enum _TP_CALLBACK_PRIORITY CallbackPriority;
    unsigned long Size;
};

union _TP_CALLBACK_ENVIRON_V3::<unnamed-type-u>
{
    unsigned long Flags;
    struct <unnamed-type-s>
    {
        unsigned long LongFunction:1;
        unsigned long Persistent:1;
        unsigned long Private:30;
    };
    struct _TP_CALLBACK_ENVIRON_V3::<unnamed-type-u>::<unnamed-type-s> s;
};

struct _TP_CALLBACK_ENVIRON_V3::<unnamed-type-u>::<unnamed-type-s>
{
    unsigned long LongFunction:1;
    unsigned long Persistent:1;
    unsigned long Private:30;
};

struct tagHANDLETABLE
{
    void * objectHandle[1];
};

struct tagNONCLIENTMETRICSA
{
    unsigned int cbSize;
    int iBorderWidth;
    int iScrollWidth;
    int iScrollHeight;
    int iCaptionWidth;
    int iCaptionHeight;
    struct tagLOGFONTA lfCaptionFont;
    int iSmCaptionWidth;
    int iSmCaptionHeight;
    struct tagLOGFONTA lfSmCaptionFont;
    int iMenuWidth;
    int iMenuHeight;
    struct tagLOGFONTA lfMenuFont;
    struct tagLOGFONTA lfStatusFont;
    struct tagLOGFONTA lfMessageFont;
    int iPaddedBorderWidth;
};

struct midiproptempo_tag
{
    unsigned long cbStruct;
    unsigned long dwTempo;
};

struct PPM_THERMALCHANGE_EVENT
{
    unsigned long ThermalConstraint;
    unsigned int Processors;
};

struct CM_Power_Data_s
{
    unsigned long PD_Size;
    enum _DEVICE_POWER_STATE PD_MostRecentPowerState;
    unsigned long PD_Capabilities;
    unsigned long PD_D1Latency;
    unsigned long PD_D2Latency;
    unsigned long PD_D3Latency;
    enum _DEVICE_POWER_STATE PD_PowerStateMapping[7];
    enum _SYSTEM_POWER_STATE PD_DeepestSystemWake;
};

union _ULARGE_INTEGER
{
    unsigned long LowPart;
    unsigned long HighPart;
    struct <unnamed-type-u>
    {
        unsigned long LowPart;
        unsigned long HighPart;
    };
    struct _ULARGE_INTEGER::<unnamed-type-u> u;
    unsigned int QuadPart;
};

struct _ULARGE_INTEGER::<unnamed-type-u>
{
    unsigned long LowPart;
    unsigned long HighPart;
};

struct wavehdr_tag
{
    char * lpData;
    unsigned long dwBufferLength;
    unsigned long dwBytesRecorded;
    unsigned long dwUser;
    unsigned long dwFlags;
    unsigned long dwLoops;
    struct wavehdr_tag * lpNext;
    unsigned long reserved;
};

struct _SYSTEM_AUDIT_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct _MESSAGE_RESOURCE_DATA
{
    unsigned long NumberOfBlocks;
    struct _MESSAGE_RESOURCE_BLOCK Blocks[1];
};

struct lconv
{
    char * decimal_point;
    char * thousands_sep;
    char * grouping;
    char * int_curr_symbol;
    char * currency_symbol;
    char * mon_decimal_point;
    char * mon_thousands_sep;
    char * mon_grouping;
    char * positive_sign;
    char * negative_sign;
    char int_frac_digits;
    char frac_digits;
    char p_cs_precedes;
    char p_sep_by_space;
    char n_cs_precedes;
    char n_sep_by_space;
    char p_sign_posn;
    char n_sign_posn;
    wchar_t * _W_decimal_point;
    wchar_t * _W_thousands_sep;
    wchar_t * _W_int_curr_symbol;
    wchar_t * _W_currency_symbol;
    wchar_t * _W_mon_decimal_point;
    wchar_t * _W_mon_thousands_sep;
    wchar_t * _W_positive_sign;
    wchar_t * _W_negative_sign;
};

struct _WOW64_FLOATING_SAVE_AREA
{
    unsigned long ControlWord;
    unsigned long StatusWord;
    unsigned long TagWord;
    unsigned long ErrorOffset;
    unsigned long ErrorSelector;
    unsigned long DataOffset;
    unsigned long DataSelector;
    unsigned int RegisterArea[80];
    unsigned long Cr0NpxState;
};

struct tagMCI_VD_ESCAPE_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpstrCommand;
};

struct tagMULTIKEYHELPW
{
    unsigned long mkSize;
    wchar_t mkKeylist;
    wchar_t szKeyphrase[1];
};

struct tagCURSORINFO
{
    unsigned long cbSize;
    unsigned long flags;
    struct HICON__ * hCursor;
    struct tagPOINT ptScreenPos;
};

struct HINSTANCE__
{
    int unused;
};

struct _UMS_CREATE_THREAD_ATTRIBUTES
{
    unsigned long UmsVersion;
    void * UmsContext;
    void * UmsCompletionList;
};

struct _TAPE_ERASE
{
    unsigned long Type;
    unsigned int Immediate;
};

struct _EXIT_PROCESS_DEBUG_INFO
{
    unsigned long dwExitCode;
};

struct SArchiveInfo
{
    char * FileName;
    int HeaderSize;
    unsigned int * Header;
    struct SArchiveHeaderEntry * Lookup(char * );
    void FindFiles(char * ,char * ,class SDArray<SString> & );
    void FindFilesIterate(class SString & ,class SString & ,class SDArray<SString> & ,unsigned int * ,class SString );
    void Iterate(unsigned int * ,class SString );
};

struct SArchiveInfo
{
    char * FileName;
    int HeaderSize;
    unsigned int * Header;
    struct SArchiveHeaderEntry * Lookup(char * );
    void FindFiles(char * ,char * ,class SDArray<SString> & );
    void FindFilesIterate(class SString & ,class SString & ,class SDArray<SString> & ,unsigned int * ,class SString );
    void Iterate(unsigned int * ,class SString );
};

struct tagWTSSESSION_NOTIFICATION
{
    unsigned long cbSize;
    unsigned long dwSessionId;
};

struct tagMCI_VD_STEP_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrames;
};

struct _STARTUPINFOW
{
    unsigned long cb;
    wchar_t * lpReserved;
    wchar_t * lpDesktop;
    wchar_t * lpTitle;
    unsigned long dwX;
    unsigned long dwY;
    unsigned long dwXSize;
    unsigned long dwYSize;
    unsigned long dwXCountChars;
    unsigned long dwYCountChars;
    unsigned long dwFillAttribute;
    unsigned long dwFlags;
    unsigned int wShowWindow;
    unsigned int cbReserved2;
    unsigned int * lpReserved2;
    void * hStdInput;
    void * hStdOutput;
    void * hStdError;
};

class SLogger
{
    private const int LogBufferSize=512;
    private char * LogBufferContent[512];
    private int LogBufferUsed;
    private const int LogBufferLineMaxLength=522;
    private bool LogToFile;
    private bool Logging;
    private char * LogFileName;
    private struct HWND__ * hWnd;
    private int LogLevel;
    public void SLogger(char * ,char * ,bool ,int );
    public void ~SLogger();
    public void Attach(struct HWND__ * );
    public void SetLogLevel(int );
    public void Log(int ,char * ,<btNoType> );
    public void WirteBufferToLog();
    public void Warning(char * ,<btNoType> );
    public void Panic(char * ,<btNoType> );
    public void LogCallStack(int );
    public void * __vecDelDtor(unsigned int );
};

class Utf16WriteIterator
{
    public void Utf16WriteIterator(wchar_t * ,int );
    public unsigned long GetCodepointSize(unsigned long );
    public void AppendCodepoint(unsigned long );
    private unsigned int * p;
    private unsigned int * end;
};

struct tagEMRROUNDRECT
{
    struct tagEMR emr;
    struct _RECTL rclBox;
    struct tagSIZE szlCorner;
};

struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
{
    unsigned long MarshalCookie;
    struct _GUID UOW;
};

struct __vcrt_assert_va_start_is_not_reference<wchar_t const *>
{
};

struct _FLOAT128
{
    int LowPart;
    int HighPart;
};

struct tagJOYCAPSA
{
    unsigned int wMid;
    unsigned int wPid;
    char szPname[32];
    unsigned int wXmin;
    unsigned int wXmax;
    unsigned int wYmin;
    unsigned int wYmax;
    unsigned int wZmin;
    unsigned int wZmax;
    unsigned int wNumButtons;
    unsigned int wPeriodMin;
    unsigned int wPeriodMax;
    unsigned int wRmin;
    unsigned int wRmax;
    unsigned int wUmin;
    unsigned int wUmax;
    unsigned int wVmin;
    unsigned int wVmax;
    unsigned int wCaps;
    unsigned int wMaxAxes;
    unsigned int wNumAxes;
    unsigned int wMaxButtons;
    char szRegKey[32];
    char szOEMVxD[260];
};

struct _DEBUG_EVENT
{
    unsigned long dwDebugEventCode;
    unsigned long dwProcessId;
    unsigned long dwThreadId;
    union <unnamed-type-u>
    {
        struct _EXCEPTION_DEBUG_INFO Exception;
        struct _CREATE_THREAD_DEBUG_INFO CreateThread;
        struct _CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
        struct _EXIT_THREAD_DEBUG_INFO ExitThread;
        struct _EXIT_PROCESS_DEBUG_INFO ExitProcess;
        struct _LOAD_DLL_DEBUG_INFO LoadDll;
        struct _UNLOAD_DLL_DEBUG_INFO UnloadDll;
        struct _OUTPUT_DEBUG_STRING_INFO DebugString;
        struct _RIP_INFO RipInfo;
    };
    union _DEBUG_EVENT::<unnamed-type-u> u;
};

union _DEBUG_EVENT::<unnamed-type-u>
{
    struct _EXCEPTION_DEBUG_INFO Exception;
    struct _CREATE_THREAD_DEBUG_INFO CreateThread;
    struct _CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
    struct _EXIT_THREAD_DEBUG_INFO ExitThread;
    struct _EXIT_PROCESS_DEBUG_INFO ExitProcess;
    struct _LOAD_DLL_DEBUG_INFO LoadDll;
    struct _UNLOAD_DLL_DEBUG_INFO UnloadDll;
    struct _OUTPUT_DEBUG_STRING_INFO DebugString;
    struct _RIP_INFO RipInfo;
};

struct HCOLORSPACE__
{
    int unused;
};

struct tagMCI_WAVE_SET_PARMS
{
    unsigned long dwCallback;
    unsigned long dwTimeFormat;
    unsigned long dwAudio;
    unsigned int wInput;
    unsigned int wOutput;
    unsigned int wFormatTag;
    unsigned int wReserved2;
    unsigned int nChannels;
    unsigned int wReserved3;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
    unsigned int wReserved4;
    unsigned int wBitsPerSample;
    unsigned int wReserved5;
};

struct _WOW64_CONTEXT
{
    unsigned long ContextFlags;
    unsigned long Dr0;
    unsigned long Dr1;
    unsigned long Dr2;
    unsigned long Dr3;
    unsigned long Dr6;
    unsigned long Dr7;
    struct _WOW64_FLOATING_SAVE_AREA FloatSave;
    unsigned long SegGs;
    unsigned long SegFs;
    unsigned long SegEs;
    unsigned long SegDs;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Ebx;
    unsigned long Edx;
    unsigned long Ecx;
    unsigned long Eax;
    unsigned long Ebp;
    unsigned long Eip;
    unsigned long SegCs;
    unsigned long EFlags;
    unsigned long Esp;
    unsigned long SegSs;
    unsigned int ExtendedRegisters[512];
};

struct HBRUSH__
{
    int unused;
};

struct tagMENUITEMINFOW
{
    unsigned int cbSize;
    unsigned int fMask;
    unsigned int fType;
    unsigned int fState;
    unsigned int wID;
    struct HMENU__ * hSubMenu;
    struct HBITMAP__ * hbmpChecked;
    struct HBITMAP__ * hbmpUnchecked;
    unsigned long dwItemData;
    wchar_t * dwTypeData;
    unsigned int cch;
    struct HBITMAP__ * hbmpItem;
};

struct tagEMRSETCOLORSPACE
{
    struct tagEMR emr;
    unsigned long ihCS;
};

struct _CONSOLE_HISTORY_INFO
{
    unsigned int cbSize;
    unsigned int HistoryBufferSize;
    unsigned int NumberOfHistoryBuffers;
    unsigned long dwFlags;
};

struct _SERVICE_DESCRIPTIONW
{
    wchar_t * lpDescription;
};

struct tagCWPSTRUCT
{
    long lParam;
    unsigned int wParam;
    unsigned int message;
    struct HWND__ * hwnd;
};

struct tagMCI_OVLY_SAVE_PARMSA
{
    unsigned long dwCallback;
    char * lpfilename;
    struct tagRECT rc;
};

struct _SECURITY_DESCRIPTOR_RELATIVE
{
    unsigned int Revision;
    unsigned int Sbz1;
    unsigned int Control;
    unsigned long Owner;
    unsigned long Group;
    unsigned long Sacl;
    unsigned long Dacl;
};

struct _IMAGE_RESOURCE_DIRECTORY
{
    unsigned long Characteristics;
    unsigned long TimeDateStamp;
    unsigned int MajorVersion;
    unsigned int MinorVersion;
    unsigned int NumberOfNamedEntries;
    unsigned int NumberOfIdEntries;
};

struct DRVCONFIGINFOEX
{
    unsigned long dwDCISize;
    wchar_t * lpszDCISectionName;
    wchar_t * lpszDCIAliasName;
    unsigned long dnDevNode;
};

struct _IMAGE_OPTIONAL_HEADER
{
    unsigned int Magic;
    unsigned int MajorLinkerVersion;
    unsigned int MinorLinkerVersion;
    unsigned long SizeOfCode;
    unsigned long SizeOfInitializedData;
    unsigned long SizeOfUninitializedData;
    unsigned long AddressOfEntryPoint;
    unsigned long BaseOfCode;
    unsigned long BaseOfData;
    unsigned long ImageBase;
    unsigned long SectionAlignment;
    unsigned long FileAlignment;
    unsigned int MajorOperatingSystemVersion;
    unsigned int MinorOperatingSystemVersion;
    unsigned int MajorImageVersion;
    unsigned int MinorImageVersion;
    unsigned int MajorSubsystemVersion;
    unsigned int MinorSubsystemVersion;
    unsigned long Win32VersionValue;
    unsigned long SizeOfImage;
    unsigned long SizeOfHeaders;
    unsigned long CheckSum;
    unsigned int Subsystem;
    unsigned int DllCharacteristics;
    unsigned long SizeOfStackReserve;
    unsigned long SizeOfStackCommit;
    unsigned long SizeOfHeapReserve;
    unsigned long SizeOfHeapCommit;
    unsigned long LoaderFlags;
    unsigned long NumberOfRvaAndSizes;
    struct _IMAGE_DATA_DIRECTORY DataDirectory[16];
};

struct tagMCI_SET_PARMS
{
    unsigned long dwCallback;
    unsigned long dwTimeFormat;
    unsigned long dwAudio;
};

struct tagEMREXTTEXTOUTA
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long iGraphicsMode;
    float exScale;
    float eyScale;
    struct tagEMRTEXT emrtext;
};

struct stat
{
    unsigned int st_dev;
    unsigned int st_ino;
    unsigned int st_mode;
    int st_nlink;
    int st_uid;
    int st_gid;
    unsigned int st_rdev;
    long st_size;
    int st_atime;
    int st_mtime;
    int st_ctime;
};

struct _RTL_SRWLOCK
{
    void * Ptr;
};

struct tagCWPRETSTRUCT
{
    long lResult;
    long lParam;
    unsigned int wParam;
    unsigned int message;
    struct HWND__ * hwnd;
};

struct pcmwaveformat_tag
{
    struct waveformat_tag wf;
    unsigned int wBitsPerSample;
};

struct _WGLSWAP
{
    struct HDC__ * hdc;
    unsigned int uiFlags;
};

struct tagEMRCREATEPEN
{
    struct tagEMR emr;
    unsigned long ihPen;
    struct tagLOGPEN lopn;
};

struct _TRANSACTIONMANAGER_OLDEST_INFORMATION
{
    struct _GUID OldestTransactionGuid;
};

struct _SC_ACTION
{
    enum _SC_ACTION_TYPE Type;
    unsigned long Delay;
};

struct _NT_TIB64
{
    unsigned int ExceptionList;
    unsigned int StackBase;
    unsigned int StackLimit;
    unsigned int SubSystemTib;
    unsigned int FiberData;
    unsigned long Version;
    unsigned int ArbitraryUserPointer;
    unsigned int Self;
};

struct _LUID
{
    unsigned long LowPart;
    long HighPart;
};

struct _MEMORYSTATUSEX
{
    unsigned long dwLength;
    unsigned long dwMemoryLoad;
    unsigned int ullTotalPhys;
    unsigned int ullAvailPhys;
    unsigned int ullTotalPageFile;
    unsigned int ullAvailPageFile;
    unsigned int ullTotalVirtual;
    unsigned int ullAvailVirtual;
    unsigned int ullAvailExtendedVirtual;
};

union _IMAGE_SYMBOL::<unnamed-type-N>
{
    unsigned int ShortName[8];
    struct <unnamed-type-Name>
    {
        unsigned long Short;
        unsigned long Long;
    };
    struct _IMAGE_SYMBOL::<unnamed-type-N>::<unnamed-type-Name> Name;
    unsigned long LongName[2];
};

struct _IMAGE_SYMBOL::<unnamed-type-N>::<unnamed-type-Name>
{
    unsigned long Short;
    unsigned long Long;
};

struct tagSOUNDSENTRYA
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long iFSTextEffect;
    unsigned long iFSTextEffectMSec;
    unsigned long iFSTextEffectColorBits;
    unsigned long iFSGrafEffect;
    unsigned long iFSGrafEffectMSec;
    unsigned long iFSGrafEffectColor;
    unsigned long iWindowsEffect;
    unsigned long iWindowsEffectMSec;
    char * lpszWindowsEffectDLL;
    unsigned long iWindowsEffectOrdinal;
};

struct tagENHMETARECORD
{
    unsigned long iType;
    unsigned long nSize;
    unsigned long dParm[1];
};

struct tagKERNINGPAIR
{
    unsigned int wFirst;
    unsigned int wSecond;
    int iKernAmount;
};

struct tagSERIALKEYSA
{
    unsigned int cbSize;
    unsigned long dwFlags;
    char * lpszActivePort;
    char * lpszPort;
    unsigned int iBaudRate;
    unsigned int iPortState;
    unsigned int iActive;
};

struct tagSTICKYKEYS
{
    unsigned int cbSize;
    unsigned long dwFlags;
};

struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
{
    unsigned long ulFlags;
    enum ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
    unsigned long UiAccess;
};

struct _SE_IMPERSONATION_STATE
{
    void * Token;
    unsigned int CopyOnOpen;
    unsigned int EffectiveOnly;
    enum _SECURITY_IMPERSONATION_LEVEL Level;
};

struct _GUID
{
    unsigned long Data1;
    unsigned int Data2;
    unsigned int Data3;
    unsigned int Data4[8];
};

struct _IMAGE_TLS_DIRECTORY32
{
    unsigned long StartAddressOfRawData;
    unsigned long EndAddressOfRawData;
    unsigned long AddressOfIndex;
    unsigned long AddressOfCallBacks;
    unsigned long SizeOfZeroFill;
    unsigned long Characteristics;
};

struct _SYSTEM_AUDIT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
{
    unsigned long SavepointId;
};

struct tagEMRCREATECOLORSPACE
{
    struct tagEMR emr;
    unsigned long ihCS;
    struct tagLOGCOLORSPACEA lcs;
};

struct tagMENUINFO
{
    unsigned long cbSize;
    unsigned long fMask;
    unsigned long dwStyle;
    unsigned int cyMax;
    struct HBRUSH__ * hbrBack;
    unsigned long dwContextHelpID;
    unsigned long dwMenuData;
};

struct _ENUM_SERVICE_STATUS_PROCESSW
{
    wchar_t * lpServiceName;
    wchar_t * lpDisplayName;
    struct _SERVICE_STATUS_PROCESS ServiceStatusProcess;
};

struct _IMAGE_IMPORT_DESCRIPTOR
{
    unsigned long Characteristics;
    unsigned long OriginalFirstThunk;
    unsigned long TimeDateStamp;
    unsigned long ForwarderChain;
    unsigned long Name;
    unsigned long FirstThunk;
};

struct _ACCESS_ALLOWED_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct tagHIGHCONTRASTA
{
    unsigned int cbSize;
    unsigned long dwFlags;
    char * lpszDefaultScheme;
};

struct BSMINFO
{
    unsigned int cbSize;
    struct HDESK__ * hdesk;
    struct HWND__ * hwnd;
    struct _LUID luid;
};

struct _ENLISTMENT_CRM_INFORMATION
{
    struct _GUID CrmTransactionManagerId;
    struct _GUID CrmResourceManagerId;
    struct _GUID CrmEnlistmentId;
};

struct tagRAWINPUT
{
    struct tagRAWINPUTHEADER header;
    union <unnamed-type-data>
    {
        struct tagRAWMOUSE mouse;
        struct tagRAWKEYBOARD keyboard;
        struct tagRAWHID hid;
    };
    union tagRAWINPUT::<unnamed-type-data> data;
};

struct tagLASTINPUTINFO
{
    unsigned int cbSize;
    unsigned long dwTime;
};

union _FILE_SEGMENT_ELEMENT
{
    void * Buffer;
    unsigned int Alignment;
};

struct tagAXESLISTW
{
    unsigned long axlReserved;
    unsigned long axlNumAxes;
    struct tagAXISINFOW axlAxisInfo[16];
};

struct _Real_type<long double>
{
};

struct _MESSAGE_RESOURCE_ENTRY
{
    unsigned int Length;
    unsigned int Flags;
    unsigned int Text[1];
};

struct SET_POWER_SETTING_VALUE
{
    unsigned long Version;
    struct _GUID Guid;
    enum SYSTEM_POWER_CONDITION PowerCondition;
    unsigned long DataLength;
    unsigned int Data[1];
};

struct _CACHE_RELATIONSHIP
{
    unsigned int Level;
    unsigned int Associativity;
    unsigned int LineSize;
    unsigned long CacheSize;
    enum _PROCESSOR_CACHE_TYPE Type;
    unsigned int Reserved[20];
    struct _GROUP_AFFINITY GroupMask;
};

struct _NT_TIB
{
    struct _EXCEPTION_REGISTRATION_RECORD * ExceptionList;
    void * StackBase;
    void * StackLimit;
    void * SubSystemTib;
    void * FiberData;
    unsigned long Version;
    void * ArbitraryUserPointer;
    struct _NT_TIB * Self;
};

struct tagMDICREATESTRUCTW
{
    wchar_t * szClass;
    wchar_t * szTitle;
    void * hOwner;
    int x;
    int y;
    int cx;
    int cy;
    unsigned long style;
    long lParam;
};

struct tagAUXCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned int wTechnology;
    unsigned int wReserved1;
    unsigned long dwSupport;
};

struct tMIXERCONTROLDETAILS
{
    unsigned long cbStruct;
    unsigned long dwControlID;
    unsigned long cChannels;
    struct HWND__ * hwndOwner;
    unsigned long cMultipleItems;
    unsigned long cbDetails;
    void * paDetails;
};

struct tagAXESLISTA
{
    unsigned long axlReserved;
    unsigned long axlNumAxes;
    struct tagAXISINFOA axlAxisInfo[16];
};

struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION
{
    unsigned long ProcessorMask;
    enum _LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION::_anonymous_1961::<unnamed-type-ProcessorCore> ProcessorCore;
    struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION::_anonymous_1960::<unnamed-type-NumaNode> NumaNode;
    struct _CACHE_DESCRIPTOR Cache;
    unsigned int Reserved[2];
};

struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION::_anonymous_1960::<unnamed-type-NumaNode>
{
    unsigned long NodeNumber;
};

struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION::_anonymous_1961::<unnamed-type-ProcessorCore>
{
    unsigned int Flags;
};

struct tagEMRSETMAPPERFLAGS
{
    struct tagEMR emr;
    unsigned long dwFlags;
};

struct HWAVEIN__
{
    int unused;
};

struct tagMSGBOXPARAMSA
{
    unsigned int cbSize;
    struct HWND__ * hwndOwner;
    struct HINSTANCE__ * hInstance;
    char * lpszText;
    char * lpszCaption;
    unsigned long dwStyle;
    char * lpszIcon;
    unsigned long dwContextHelpId;
    void  ( * lpfnMsgBoxCallback)(struct tagHELPINFO * );
    unsigned long dwLanguageId;
};

struct tagMCI_OVLY_SAVE_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpfilename;
    struct tagRECT rc;
};

struct _NETINFOSTRUCT
{
    unsigned long cbStructure;
    unsigned long dwProviderVersion;
    unsigned long dwStatus;
    unsigned long dwCharacteristics;
    unsigned long dwHandle;
    unsigned int wNetType;
    unsigned long dwPrinters;
    unsigned long dwDrives;
};

struct tagEMRCREATEBRUSHINDIRECT
{
    struct tagEMR emr;
    unsigned long ihBrush;
    struct tagLOGBRUSH32 lb;
};

struct _M128A
{
    unsigned int Low;
    int High;
};

struct HGESTUREINFO__
{
    int unused;
};

struct _IMAGE_THUNK_DATA64
{
    union <unnamed-type-u1>
    {
        unsigned int ForwarderString;
        unsigned int Function;
        unsigned int Ordinal;
        unsigned int AddressOfData;
    };
    union _IMAGE_THUNK_DATA64::<unnamed-type-u1> u1;
};

union _IMAGE_THUNK_DATA64::<unnamed-type-u1>
{
    unsigned int ForwarderString;
    unsigned int Function;
    unsigned int Ordinal;
    unsigned int AddressOfData;
};

struct FILE_ID_DESCRIPTOR
{
    unsigned long dwSize;
    enum _FILE_ID_TYPE Type;
    union _LARGE_INTEGER FileId;
    struct _GUID ObjectId;
};

struct tagBITMAPCOREHEADER
{
    unsigned long bcSize;
    unsigned int bcWidth;
    unsigned int bcHeight;
    unsigned int bcPlanes;
    unsigned int bcBitCount;
};

struct tagLOGBRUSH32
{
    unsigned int lbStyle;
    unsigned long lbColor;
    unsigned long lbHatch;
};

struct _XSAVE_AREA_HEADER
{
    unsigned int Mask;
    unsigned int Reserved[7];
};

struct tagEMRPOLYDRAW16
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cpts;
    struct tagPOINTS apts[1];
    unsigned int abTypes[1];
};

struct _IMAGE_NT_HEADERS
{
    unsigned long Signature;
    struct _IMAGE_FILE_HEADER FileHeader;
    struct _IMAGE_OPTIONAL_HEADER OptionalHeader;
};

struct _devicemodeA
{
    unsigned int dmDeviceName[32];
    unsigned int dmSpecVersion;
    unsigned int dmDriverVersion;
    unsigned int dmSize;
    unsigned int dmDriverExtra;
    unsigned long dmFields;
    int dmOrientation;
    int dmPaperSize;
    int dmPaperLength;
    int dmPaperWidth;
    int dmScale;
    int dmCopies;
    int dmDefaultSource;
    int dmPrintQuality;
    struct _POINTL dmPosition;
    unsigned long dmDisplayOrientation;
    unsigned long dmDisplayFixedOutput;
    int dmColor;
    int dmDuplex;
    int dmYResolution;
    int dmTTOption;
    int dmCollate;
    unsigned int dmFormName[32];
    unsigned int dmLogPixels;
    unsigned long dmBitsPerPel;
    unsigned long dmPelsWidth;
    unsigned long dmPelsHeight;
    unsigned long dmDisplayFlags;
    unsigned long dmNup;
    unsigned long dmDisplayFrequency;
    unsigned long dmICMMethod;
    unsigned long dmICMIntent;
    unsigned long dmMediaType;
    unsigned long dmDitherType;
    unsigned long dmReserved1;
    unsigned long dmReserved2;
    unsigned long dmPanningWidth;
    unsigned long dmPanningHeight;
};

struct tagMCI_OVLY_OPEN_PARMSW
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    wchar_t * lpstrDeviceType;
    wchar_t * lpstrElementName;
    wchar_t * lpstrAlias;
    unsigned long dwStyle;
    struct HWND__ * hWndParent;
};

struct SSphere
{
    struct SPoint3 Center;
    float Radius;
    void SSphere(struct SPoint3 & ,float );
    void SSphere();
};

struct tagEMRSTRETCHBLT
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long cxDest;
    long cyDest;
    unsigned long dwRop;
    long xSrc;
    long ySrc;
    struct tagXFORM xformSrc;
    unsigned long crBkColorSrc;
    unsigned long iUsageSrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    long cxSrc;
    long cySrc;
};

struct SSearchPath
{
    struct SArchiveInfo Archive;
    char * Path;
};

struct _ACL_SIZE_INFORMATION
{
    unsigned long AceCount;
    unsigned long AclBytesInUse;
    unsigned long AclBytesFree;
};

struct _COMPATIBILITY_CONTEXT_ELEMENT
{
    struct _GUID Id;
    enum ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
};

struct tagLOGFONTA
{
    long lfHeight;
    long lfWidth;
    long lfEscapement;
    long lfOrientation;
    long lfWeight;
    unsigned int lfItalic;
    unsigned int lfUnderline;
    unsigned int lfStrikeOut;
    unsigned int lfCharSet;
    unsigned int lfOutPrecision;
    unsigned int lfClipPrecision;
    unsigned int lfQuality;
    unsigned int lfPitchAndFamily;
    char lfFaceName[32];
};

struct _SE_ACCESS_REQUEST
{
    unsigned long Size;
    struct _SE_SECURITY_DESCRIPTOR * SeSecurityDescriptor;
    unsigned long DesiredAccess;
    unsigned long PreviouslyGrantedAccess;
    void * PrincipalSelfSid;
    struct _GENERIC_MAPPING * GenericMapping;
    unsigned long ObjectTypeListCount;
    struct _OBJECT_TYPE_LIST * ObjectTypeList;
};

struct _RESOURCEMANAGER_COMPLETION_INFORMATION
{
    void * IoCompletionPortHandle;
    unsigned long CompletionKey;
};

struct _FLOATING_SAVE_AREA
{
    unsigned long ControlWord;
    unsigned long StatusWord;
    unsigned long TagWord;
    unsigned long ErrorOffset;
    unsigned long ErrorSelector;
    unsigned long DataOffset;
    unsigned long DataSelector;
    unsigned int RegisterArea[80];
    unsigned long Cr0NpxState;
};

struct _cpinfoexW
{
    unsigned int MaxCharSize;
    unsigned int DefaultChar[2];
    unsigned int LeadByte[12];
    wchar_t UnicodeDefaultChar;
    unsigned int CodePage;
    wchar_t CodePageName[260];
};

struct HRAWINPUT__
{
    int unused;
};

struct tagCOMPOSITIONFORM
{
    unsigned long dwStyle;
    struct tagPOINT ptCurrentPos;
    struct tagRECT rcArea;
};

struct _TAPE_SET_POSITION
{
    unsigned long Method;
    unsigned long Partition;
    union _LARGE_INTEGER Offset;
    unsigned int Immediate;
};

struct tagDELETEITEMSTRUCT
{
    unsigned int CtlType;
    unsigned int CtlID;
    unsigned int itemID;
    struct HWND__ * hwndItem;
    unsigned long itemData;
};

struct PPM_IDLE_STATE_ACCOUNTING_EX
{
    unsigned int TotalTime;
    unsigned long IdleTransitions;
    unsigned long FailedTransitions;
    unsigned long InvalidBucketIndex;
    unsigned long MinTimeUs;
    unsigned long MaxTimeUs;
    struct PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
};

struct _CONSOLE_SCREEN_BUFFER_INFO
{
    struct _COORD dwSize;
    struct _COORD dwCursorPosition;
    unsigned int wAttributes;
    struct _SMALL_RECT srWindow;
    struct _COORD dwMaximumWindowSize;
};

struct tagMCI_ANIM_WINDOW_PARMSW
{
    unsigned long dwCallback;
    struct HWND__ * hWnd;
    unsigned int nCmdShow;
    wchar_t * lpstrText;
};

struct _FILE_ATTRIBUTE_TAG_INFO
{
    unsigned long FileAttributes;
    unsigned long ReparseTag;
};

struct tagMIXERCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long fdwSupport;
    unsigned long cDestinations;
};

struct _IMAGE_SEPARATE_DEBUG_HEADER
{
    unsigned int Signature;
    unsigned int Flags;
    unsigned int Machine;
    unsigned int Characteristics;
    unsigned long TimeDateStamp;
    unsigned long CheckSum;
    unsigned long ImageBase;
    unsigned long SizeOfImage;
    unsigned long NumberOfSections;
    unsigned long ExportedNamesSize;
    unsigned long DebugDirectorySize;
    unsigned long SectionAlignment;
    unsigned long Reserved[2];
};

struct tagPELARRAY
{
    long paXCount;
    long paYCount;
    long paXExt;
    long paYExt;
    unsigned int paRGBs;
};

struct _Mbstatet
{
    unsigned long _Wchar;
    unsigned int _Byte;
    unsigned int _State;
};

struct tagMCI_SEEK_PARMS
{
    unsigned long dwCallback;
    unsigned long dwTo;
};

struct NOTIFY_USER_POWER_SETTING
{
    struct _GUID Guid;
};

struct tagWNDCLASSW
{
    unsigned int style;
    long  ( * lpfnWndProc)(struct HWND__ * ,unsigned int ,unsigned int ,long );
    int cbClsExtra;
    int cbWndExtra;
    struct HINSTANCE__ * hInstance;
    struct HICON__ * hIcon;
    struct HICON__ * hCursor;
    struct HBRUSH__ * hbrBackground;
    wchar_t * lpszMenuName;
    wchar_t * lpszClassName;
};

struct tagMIXERCONTROLA
{
    unsigned long cbStruct;
    unsigned long dwControlID;
    unsigned long dwControlType;
    unsigned long fdwControl;
    unsigned long cMultipleItems;
    char szShortName[16];
    char szName[64];
    union <unnamed-type-Bounds>
    {
        long lMinimum;
        long lMaximum;
        unsigned long dwMinimum;
        unsigned long dwMaximum;
        unsigned long dwReserved[6];
    };
    union tagMIXERCONTROLA::<unnamed-type-Bounds> Bounds;
    union <unnamed-type-Metrics>
    {
        unsigned long cSteps;
        unsigned long cbCustomData;
        unsigned long dwReserved[6];
    };
    union tagMIXERCONTROLA::<unnamed-type-Metrics> Metrics;
};

struct POWERBROADCAST_SETTING
{
    struct _GUID PowerSetting;
    unsigned long DataLength;
    unsigned int Data[1];
};

struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW
{
    unsigned long dwReason;
    wchar_t * pszComment;
    struct _SERVICE_STATUS_PROCESS ServiceStatus;
};

struct tagCOLORMATCHTOTARGET
{
    struct tagEMR emr;
    unsigned long dwAction;
    unsigned long dwFlags;
    unsigned long cbName;
    unsigned long cbData;
    unsigned int Data[1];
};

struct tagWNDCLASSEXW
{
    unsigned int cbSize;
    unsigned int style;
    long  ( * lpfnWndProc)(struct HWND__ * ,unsigned int ,unsigned int ,long );
    int cbClsExtra;
    int cbWndExtra;
    struct HINSTANCE__ * hInstance;
    struct HICON__ * hIcon;
    struct HICON__ * hCursor;
    struct HBRUSH__ * hbrBackground;
    wchar_t * lpszMenuName;
    wchar_t * lpszClassName;
    struct HICON__ * hIconSm;
};

struct _SECURITY_ATTRIBUTES
{
    unsigned long nLength;
    void * lpSecurityDescriptor;
    int bInheritHandle;
};

struct tagCANDIDATELIST
{
    unsigned long dwSize;
    unsigned long dwStyle;
    unsigned long dwCount;
    unsigned long dwSelection;
    unsigned long dwPageStart;
    unsigned long dwPageSize;
    unsigned long dwOffset[1];
};

union mmtime_tag::<unnamed-type-u>
{
    unsigned long ms;
    unsigned long sample;
    unsigned long cb;
    unsigned long ticks;
    struct <unnamed-type-smpte>
    {
        unsigned int hour;
        unsigned int min;
        unsigned int sec;
        unsigned int frame;
        unsigned int fps;
        unsigned int dummy;
        unsigned int pad[2];
    };
    struct mmtime_tag::<unnamed-type-u>::<unnamed-type-smpte> smpte;
    struct <unnamed-type-midi>
    {
        unsigned long songptrpos;
    };
    struct mmtime_tag::<unnamed-type-u>::<unnamed-type-midi> midi;
};

struct mmtime_tag::<unnamed-type-u>::<unnamed-type-midi>
{
    unsigned long songptrpos;
};

struct mmtime_tag::<unnamed-type-u>::<unnamed-type-smpte>
{
    unsigned int hour;
    unsigned int min;
    unsigned int sec;
    unsigned int frame;
    unsigned int fps;
    unsigned int dummy;
    unsigned int pad[2];
};

struct tagMIXERCONTROLDETAILS_LISTTEXTW
{
    unsigned long dwParam1;
    unsigned long dwParam2;
    wchar_t szName[64];
};

struct _MMCKINFO
{
    unsigned long ckid;
    unsigned long cksize;
    unsigned long fccType;
    unsigned long dwDataOffset;
    unsigned long dwFlags;
};

struct tagEXTLOGFONTA
{
    struct tagLOGFONTA elfLogFont;
    unsigned int elfFullName[64];
    unsigned int elfStyle[32];
    unsigned long elfVersion;
    unsigned long elfStyleSize;
    unsigned long elfMatch;
    unsigned long elfReserved;
    unsigned int elfVendorId[4];
    unsigned long elfCulture;
    struct tagPANOSE elfPanose;
};

struct tagVS_FIXEDFILEINFO
{
    unsigned long dwSignature;
    unsigned long dwStrucVersion;
    unsigned long dwFileVersionMS;
    unsigned long dwFileVersionLS;
    unsigned long dwProductVersionMS;
    unsigned long dwProductVersionLS;
    unsigned long dwFileFlagsMask;
    unsigned long dwFileFlags;
    unsigned long dwFileOS;
    unsigned long dwFileType;
    unsigned long dwFileSubtype;
    unsigned long dwFileDateMS;
    unsigned long dwFileDateLS;
};

struct tagRID_DEVICE_INFO_MOUSE
{
    unsigned long dwId;
    unsigned long dwNumberOfButtons;
    unsigned long dwSampleRate;
    int fHasHorizontalWheel;
};

struct _Combined_type<float,long double>
{
};

struct _DISPLAY_DEVICEA
{
    unsigned long cb;
    char DeviceName[32];
    char DeviceString[128];
    unsigned long StateFlags;
    char DeviceID[128];
    char DeviceKey[128];
};

struct _ImageArchitectureHeader
{
    unsigned int AmaskValue:1;
    unsigned int AmaskShift:8;
    unsigned long FirstEntryRVA;
};

struct _CONTEXT
{
    unsigned long ContextFlags;
    unsigned long Dr0;
    unsigned long Dr1;
    unsigned long Dr2;
    unsigned long Dr3;
    unsigned long Dr6;
    unsigned long Dr7;
    struct _FLOATING_SAVE_AREA FloatSave;
    unsigned long SegGs;
    unsigned long SegFs;
    unsigned long SegEs;
    unsigned long SegDs;
    unsigned long Edi;
    unsigned long Esi;
    unsigned long Ebx;
    unsigned long Edx;
    unsigned long Ecx;
    unsigned long Eax;
    unsigned long Ebp;
    unsigned long Eip;
    unsigned long SegCs;
    unsigned long EFlags;
    unsigned long Esp;
    unsigned long SegSs;
    unsigned int ExtendedRegisters[512];
};

struct _FILE_NOTIFY_INFORMATION
{
    unsigned long NextEntryOffset;
    unsigned long Action;
    unsigned long FileNameLength;
    wchar_t FileName[1];
};

struct _IMAGE_EXPORT_DIRECTORY
{
    unsigned long Characteristics;
    unsigned long TimeDateStamp;
    unsigned int MajorVersion;
    unsigned int MinorVersion;
    unsigned long Name;
    unsigned long Base;
    unsigned long NumberOfFunctions;
    unsigned long NumberOfNames;
    unsigned long AddressOfFunctions;
    unsigned long AddressOfNames;
    unsigned long AddressOfNameOrdinals;
};

struct tagEMRGRADIENTFILL
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long nVer;
    unsigned long nTri;
    unsigned long ulMode;
    struct _TRIVERTEX Ver[1];
};

struct _KCRM_TRANSACTION_BLOB
{
    struct _GUID UOW;
    struct _GUID TmIdentity;
    unsigned long IsolationLevel;
    unsigned long IsolationFlags;
    unsigned long Timeout;
    wchar_t Description[64];
};

struct tagEMRARC
{
    struct tagEMR emr;
    struct _RECTL rclBox;
    struct _POINTL ptlStart;
    struct _POINTL ptlEnd;
};

struct _GRADIENT_TRIANGLE
{
    unsigned long Vertex1;
    unsigned long Vertex2;
    unsigned long Vertex3;
};

struct _PROCESSOR_RELATIONSHIP
{
    unsigned int Flags;
    unsigned int Reserved[21];
    unsigned int GroupCount;
    struct _GROUP_AFFINITY GroupMask[1];
};

struct _RTL_CONDITION_VARIABLE
{
    void * Ptr;
};

struct _WIN32_FIND_STREAM_DATA
{
    union _LARGE_INTEGER StreamSize;
    wchar_t cStreamName[296];
};

struct SYSTEM_POWER_LEVEL
{
    unsigned int Enable;
    unsigned int Spare[3];
    unsigned long BatteryLevel;
    struct POWER_ACTION_POLICY PowerPolicy;
    enum _SYSTEM_POWER_STATE MinSystemState;
};

struct HMIDI__
{
    int unused;
};

struct _CREATE_PROCESS_DEBUG_INFO
{
    void * hFile;
    void * hProcess;
    void * hThread;
    void * lpBaseOfImage;
    unsigned long dwDebugInfoFileOffset;
    unsigned long nDebugInfoSize;
    void * lpThreadLocalBase;
    unsigned long  ( * lpStartAddress)(void * );
    void * lpImageName;
    unsigned int fUnicode;
};

struct tagBITMAPCOREINFO
{
    struct tagBITMAPCOREHEADER bmciHeader;
    struct tagRGBTRIPLE bmciColors[1];
};

struct tagPALETTEENTRY
{
    unsigned int peRed;
    unsigned int peGreen;
    unsigned int peBlue;
    unsigned int peFlags;
};

struct tagEMRPOLYDRAW
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cptl;
    struct _POINTL aptl[1];
    unsigned int abTypes[1];
};

struct _s__RTTIBaseClassDescriptor
{
    struct _TypeDescriptor * pTypeDescriptor;
    unsigned long numContainedBases;
    struct _PMD where;
    unsigned long attributes;
    struct _s__RTTIClassHierarchyDescriptor * pClassDescriptor;
};

struct _s__RTTIBaseClassArray
{
    struct _s__RTTIBaseClassDescriptor * arrayOfBaseClassDescriptors[0];
};

struct tagMCI_OVLY_WINDOW_PARMSW
{
    unsigned long dwCallback;
    struct HWND__ * hWnd;
    unsigned int nCmdShow;
    wchar_t * lpstrText;
};

struct _JOBOBJECT_BASIC_LIMIT_INFORMATION
{
    union _LARGE_INTEGER PerProcessUserTimeLimit;
    union _LARGE_INTEGER PerJobUserTimeLimit;
    unsigned long LimitFlags;
    unsigned long MinimumWorkingSetSize;
    unsigned long MaximumWorkingSetSize;
    unsigned long ActiveProcessLimit;
    unsigned long Affinity;
    unsigned long PriorityClass;
    unsigned long SchedulingClass;
};

struct _s__CatchableTypeArray
{
    int nCatchableTypes;
    struct _s__CatchableType * arrayOfCatchableTypes[0];
};

struct _s__ThrowInfo
{
    unsigned int attributes;
    void  ( * pmfnUnwind)(void * );
    int  ( * pForwardCompat)(<btNoType> );
    struct _s__CatchableTypeArray * pCatchableTypeArray;
};

struct _TP_WORK
{
};

struct tagTITLEBARINFOEX
{
    unsigned long cbSize;
    struct tagRECT rcTitleBar;
    unsigned long rgstate[6];
    struct tagRECT rgrect[6];
};

struct _IMAGE_SYMBOL_EX
{
    union <unnamed-type-N>
    {
        unsigned int ShortName[8];
        struct <unnamed-type-Name>
        {
            unsigned long Short;
            unsigned long Long;
        };
        struct _IMAGE_SYMBOL_EX::<unnamed-type-N>::<unnamed-type-Name> Name;
        unsigned long LongName[2];
    };
    union _IMAGE_SYMBOL_EX::<unnamed-type-N> N;
    unsigned long Value;
    long SectionNumber;
    unsigned int Type;
    unsigned int StorageClass;
    unsigned int NumberOfAuxSymbols;
};

union _IMAGE_SYMBOL_EX::<unnamed-type-N>
{
    unsigned int ShortName[8];
    struct <unnamed-type-Name>
    {
        unsigned long Short;
        unsigned long Long;
    };
    struct _IMAGE_SYMBOL_EX::<unnamed-type-N>::<unnamed-type-Name> Name;
    unsigned long LongName[2];
};

struct _IMAGE_SYMBOL_EX::<unnamed-type-N>::<unnamed-type-Name>
{
    unsigned long Short;
    unsigned long Long;
};

struct _ASSEMBLY_FILE_DETAILED_INFORMATION
{
    unsigned long ulFlags;
    unsigned long ulFilenameLength;
    unsigned long ulPathLength;
    wchar_t * lpFileName;
    wchar_t * lpFilePath;
};

struct HWAVE__
{
    int unused;
};

struct _ldiv_t
{
    long quot;
    long rem;
};

struct tagMETARECORD
{
    unsigned long rdSize;
    unsigned int rdFunction;
    unsigned int rdParm[1];
};

struct tagACTCTX_SECTION_KEYED_DATA
{
    unsigned long cbSize;
    unsigned long ulDataFormatVersion;
    void * lpData;
    unsigned long ulLength;
    void * lpSectionGlobalData;
    unsigned long ulSectionGlobalDataLength;
    void * lpSectionBase;
    unsigned long ulSectionTotalLength;
    void * hActCtx;
    unsigned long ulAssemblyRosterIndex;
    unsigned long ulFlags;
    struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
};

struct _TOKEN_OWNER
{
    void * Owner;
};

struct _APPLICATIONLAUNCH_SETTING_VALUE
{
    union _LARGE_INTEGER ActivationTime;
    unsigned long Flags;
    unsigned long ButtonInstanceID;
};

struct _Cvtvec
{
    unsigned int _Page;
    unsigned int _Mbcurmax;
    int _Isclocale;
    unsigned int _Isleadbyte[32];
};

struct _DOCINFOA
{
    int cbSize;
    char * lpszDocName;
    char * lpszOutput;
    char * lpszDatatype;
    unsigned long fwType;
};

struct _EVENTLOGRECORD
{
    unsigned long Length;
    unsigned long Reserved;
    unsigned long RecordNumber;
    unsigned long TimeGenerated;
    unsigned long TimeWritten;
    unsigned long EventID;
    unsigned int EventType;
    unsigned int NumStrings;
    unsigned int EventCategory;
    unsigned int ReservedFlags;
    unsigned long ClosingRecordNumber;
    unsigned long StringOffset;
    unsigned long UserSidLength;
    unsigned long UserSidOffset;
    unsigned long DataLength;
    unsigned long DataOffset;
};

struct PPM_PERFSTATE_DOMAIN_EVENT
{
    unsigned long State;
    unsigned long Latency;
    unsigned long Speed;
    unsigned int Processors;
};

struct tagRGBTRIPLE
{
    unsigned int rgbtBlue;
    unsigned int rgbtGreen;
    unsigned int rgbtRed;
};

struct _OSVERSIONINFOW
{
    unsigned long dwOSVersionInfoSize;
    unsigned long dwMajorVersion;
    unsigned long dwMinorVersion;
    unsigned long dwBuildNumber;
    unsigned long dwPlatformId;
    wchar_t szCSDVersion[128];
};

union _double_val
{
    unsigned int _Sh[4];
    float _Val;
};

struct HMONITOR__
{
    int unused;
};

class SStreamBuffer : public SStream
{
    private unsigned long RefCount;
    private class SDArray<unsigned char *> Blocks;
    private int Size;
    private int Position;
    public void SStreamBuffer(class SStreamBuffer & );
    public void SStreamBuffer();
    public void ~SStreamBuffer();
    public void AddRef();
    public void Release();
    public void Reset();
    public unsigned long GenerateCRC();
    public int getSize();
    public int canRead(int );
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int getSeek();
    public int Seek(int ,int );
    public class SStreamBuffer & operator=(class SStreamBuffer & );
    public void * __vecDelDtor(unsigned int );
};

struct HMETAFILE__
{
    int unused;
};

struct _OSVERSIONINFOEXA
{
    unsigned long dwOSVersionInfoSize;
    unsigned long dwMajorVersion;
    unsigned long dwMinorVersion;
    unsigned long dwBuildNumber;
    unsigned long dwPlatformId;
    char szCSDVersion[128];
    unsigned int wServicePackMajor;
    unsigned int wServicePackMinor;
    unsigned int wSuiteMask;
    unsigned int wProductType;
    unsigned int wReserved;
};

struct tagEXTLOGPEN
{
    unsigned long elpPenStyle;
    unsigned long elpWidth;
    unsigned int elpBrushStyle;
    unsigned long elpColor;
    unsigned long elpHatch;
    unsigned long elpNumEntries;
    unsigned long elpStyleEntry[1];
};

struct _XSAVE_AREA
{
    struct _XSAVE_FORMAT LegacyState;
    struct _XSAVE_AREA_HEADER Header;
};

struct HWAVEOUT__
{
    int unused;
};

struct tagEMRPOLYPOLYLINE
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long nPolys;
    unsigned long cptl;
    unsigned long aPolyCounts[1];
    struct _POINTL aptl[1];
};

struct tagSTYLESTRUCT
{
    unsigned long styleOld;
    unsigned long styleNew;
};

struct tagSERIALKEYSW
{
    unsigned int cbSize;
    unsigned long dwFlags;
    wchar_t * lpszActivePort;
    wchar_t * lpszPort;
    unsigned int iBaudRate;
    unsigned int iPortState;
    unsigned int iActive;
};

struct _COORD
{
    int X;
    int Y;
};

struct tagHARDWAREINPUT
{
    unsigned long uMsg;
    unsigned int wParamL;
    unsigned int wParamH;
};

struct tagMCI_WAVE_OPEN_PARMSW
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    wchar_t * lpstrDeviceType;
    wchar_t * lpstrElementName;
    wchar_t * lpstrAlias;
    unsigned long dwBufferSeconds;
};

struct _TOKEN_USER
{
    struct _SID_AND_ATTRIBUTES User;
};

struct PPM_WMI_PERF_STATES
{
    unsigned long Count;
    unsigned long MaxFrequency;
    unsigned long CurrentState;
    unsigned long MaxPerfState;
    unsigned long MinPerfState;
    unsigned long LowestPerfState;
    unsigned long ThermalConstraint;
    unsigned int BusyAdjThreshold;
    unsigned int PolicyType;
    unsigned int Type;
    unsigned int Reserved;
    unsigned long TimerInterval;
    unsigned int TargetProcessors;
    unsigned long PStateHandler;
    unsigned long PStateContext;
    unsigned long TStateHandler;
    unsigned long TStateContext;
    unsigned long FeedbackHandler;
    unsigned long Reserved1;
    unsigned int Reserved2;
    struct PPM_WMI_PERF_STATE State[1];
};

struct _RECTL
{
    long left;
    long top;
    long right;
    long bottom;
};

struct _SE_SECURITY_DESCRIPTOR
{
    unsigned long Size;
    unsigned long Flags;
    void * SecurityDescriptor;
};

struct PPM_WMI_IDLE_STATE
{
    unsigned long Latency;
    unsigned long Power;
    unsigned long TimeCheck;
    unsigned int PromotePercent;
    unsigned int DemotePercent;
    unsigned int StateType;
    unsigned int Reserved;
    unsigned long StateFlags;
    unsigned long Context;
    unsigned long IdleHandler;
    unsigned long Reserved1;
};

struct PPM_WMI_PERF_STATE
{
    unsigned long Frequency;
    unsigned long Power;
    unsigned int PercentFrequency;
    unsigned int IncreaseLevel;
    unsigned int DecreaseLevel;
    unsigned int Type;
    unsigned long IncreaseTime;
    unsigned long DecreaseTime;
    unsigned int Control;
    unsigned int Status;
    unsigned long HitCount;
    unsigned long Reserved1;
    unsigned int Reserved2;
    unsigned int Reserved3;
};

struct PPM_WMI_PERF_STATES_EX
{
    unsigned long Count;
    unsigned long MaxFrequency;
    unsigned long CurrentState;
    unsigned long MaxPerfState;
    unsigned long MinPerfState;
    unsigned long LowestPerfState;
    unsigned long ThermalConstraint;
    unsigned int BusyAdjThreshold;
    unsigned int PolicyType;
    unsigned int Type;
    unsigned int Reserved;
    unsigned long TimerInterval;
    void * TargetProcessors;
    unsigned long PStateHandler;
    unsigned long PStateContext;
    unsigned long TStateHandler;
    unsigned long TStateContext;
    unsigned long FeedbackHandler;
    unsigned long Reserved1;
    unsigned int Reserved2;
    struct PPM_WMI_PERF_STATE State[1];
};

struct PPM_IDLE_STATE_BUCKET_EX
{
    unsigned int TotalTimeUs;
    unsigned long MinTimeUs;
    unsigned long MaxTimeUs;
    unsigned long Count;
};

struct PROCESSOR_IDLESTATE_INFO
{
    unsigned long TimeCheck;
    unsigned int DemotePercent;
    unsigned int PromotePercent;
    unsigned int Spare[2];
};

struct PROCESSOR_IDLESTATE_POLICY
{
    unsigned int Revision;
    union <unnamed-type-Flags>
    {
        unsigned int AsWORD;
        unsigned int AllowScaling:1;
        unsigned int Disabled:1;
        unsigned int Reserved:14;
    };
    union PROCESSOR_IDLESTATE_POLICY::<unnamed-type-Flags> Flags;
    unsigned long PolicyCount;
    struct PROCESSOR_IDLESTATE_INFO Policy[3];
};

union PROCESSOR_IDLESTATE_POLICY::<unnamed-type-Flags>
{
    unsigned int AsWORD;
    unsigned int AllowScaling:1;
    unsigned int Disabled:1;
    unsigned int Reserved:14;
};

struct PROCESSOR_PERFSTATE_POLICY
{
    unsigned long Revision;
    unsigned int MaxThrottle;
    unsigned int MinThrottle;
    unsigned int BusyAdjThreshold;
    unsigned int Spare;
    union PROCESSOR_PERFSTATE_POLICY::_anonymous_2089::<unnamed-type-Flags> Flags;
    unsigned long TimeCheck;
    unsigned long IncreaseTime;
    unsigned long DecreaseTime;
    unsigned long IncreasePercent;
    unsigned long DecreasePercent;
};

union PROCESSOR_PERFSTATE_POLICY::_anonymous_2089::<unnamed-type-Flags>
{
    unsigned int AsBYTE;
    unsigned int NoDomainAccounting:1;
    unsigned int IncreasePolicy:2;
    unsigned int DecreasePolicy:2;
    unsigned int Reserved:3;
};

struct SYSTEM_POWER_CAPABILITIES
{
    unsigned int PowerButtonPresent;
    unsigned int SleepButtonPresent;
    unsigned int LidPresent;
    unsigned int SystemS1;
    unsigned int SystemS2;
    unsigned int SystemS3;
    unsigned int SystemS4;
    unsigned int SystemS5;
    unsigned int HiberFilePresent;
    unsigned int FullWake;
    unsigned int VideoDimPresent;
    unsigned int ApmPresent;
    unsigned int UpsPresent;
    unsigned int ThermalControl;
    unsigned int ProcessorThrottle;
    unsigned int ProcessorMinThrottle;
    unsigned int ProcessorMaxThrottle;
    unsigned int FastSystemS4;
    unsigned int spare2[3];
    unsigned int DiskSpinDown;
    unsigned int spare3[8];
    unsigned int SystemBatteriesPresent;
    unsigned int BatteriesAreShortTerm;
    struct BATTERY_REPORTING_SCALE BatteryScale[3];
    enum _SYSTEM_POWER_STATE AcOnLineWake;
    enum _SYSTEM_POWER_STATE SoftLidWake;
    enum _SYSTEM_POWER_STATE RtcWake;
    enum _SYSTEM_POWER_STATE MinDeviceWakeState;
    enum _SYSTEM_POWER_STATE DefaultLowLatencyWake;
};

struct SYSTEM_BATTERY_STATE
{
    unsigned int AcOnLine;
    unsigned int BatteryPresent;
    unsigned int Charging;
    unsigned int Discharging;
    unsigned int Spare1[4];
    unsigned long MaxCapacity;
    unsigned long RemainingCapacity;
    unsigned long Rate;
    unsigned long EstimatedTime;
    unsigned long DefaultAlert1;
    unsigned long DefaultAlert2;
};

struct IMAGE_LOAD_CONFIG_DIRECTORY32
{
    unsigned long Size;
    unsigned long TimeDateStamp;
    unsigned int MajorVersion;
    unsigned int MinorVersion;
    unsigned long GlobalFlagsClear;
    unsigned long GlobalFlagsSet;
    unsigned long CriticalSectionDefaultTimeout;
    unsigned long DeCommitFreeBlockThreshold;
    unsigned long DeCommitTotalFreeThreshold;
    unsigned long LockPrefixTable;
    unsigned long MaximumAllocationSize;
    unsigned long VirtualMemoryThreshold;
    unsigned long ProcessHeapFlags;
    unsigned long ProcessAffinityMask;
    unsigned int CSDVersion;
    unsigned int Reserved1;
    unsigned long EditList;
    unsigned long SecurityCookie;
    unsigned long SEHandlerTable;
    unsigned long SEHandlerCount;
};

struct BITMAPV4HEADER
{
    unsigned long bV4Size;
    long bV4Width;
    long bV4Height;
    unsigned int bV4Planes;
    unsigned int bV4BitCount;
    unsigned long bV4V4Compression;
    unsigned long bV4SizeImage;
    long bV4XPelsPerMeter;
    long bV4YPelsPerMeter;
    unsigned long bV4ClrUsed;
    unsigned long bV4ClrImportant;
    unsigned long bV4RedMask;
    unsigned long bV4GreenMask;
    unsigned long bV4BlueMask;
    unsigned long bV4AlphaMask;
    unsigned long bV4CSType;
    struct tagICEXYZTRIPLE bV4Endpoints;
    unsigned long bV4GammaRed;
    unsigned long bV4GammaGreen;
    unsigned long bV4GammaBlue;
};

struct DLGTEMPLATE
{
    unsigned long style;
    unsigned long dwExtendedStyle;
    unsigned int cdit;
    int x;
    int y;
    int cx;
    int cy;
};

struct DLGITEMTEMPLATE
{
    unsigned long style;
    unsigned long dwExtendedStyle;
    int x;
    int y;
    int cx;
    int cy;
    unsigned int id;
};

struct MENUITEMTEMPLATEHEADER
{
    unsigned int versionNumber;
    unsigned int offset;
};

struct MENUITEMTEMPLATE
{
    unsigned int mtOption;
    unsigned int mtID;
    wchar_t mtString[1];
};

struct _LDOUBLE
{
    unsigned int ld[10];
};

struct _LONGDOUBLE
{
    float x;
};

union _float_val
{
    unsigned int _Sh[2];
    float _Val;
};

union _float_const
{
    unsigned int _Word[4];
    float _Float;
    float _Double;
    float _Long_double;
};

union _Dconst
{
    unsigned int _Word[8];
    float _Float;
    float _Double;
    float _Long_double;
};

struct _Real_widened<float,double>
{
};

struct _FILEMUIINFO
{
    unsigned long dwSize;
    unsigned long dwVersion;
    unsigned long dwFileType;
    unsigned int pChecksum[16];
    unsigned int pServiceChecksum[16];
    unsigned long dwLanguageNameOffset;
    unsigned long dwTypeIDMainSize;
    unsigned long dwTypeIDMainOffset;
    unsigned long dwTypeNameMainOffset;
    unsigned long dwTypeIDMUISize;
    unsigned long dwTypeIDMUIOffset;
    unsigned long dwTypeNameMUIOffset;
    unsigned int abBuffer[8];
};

struct tagTOUCHINPUT
{
    long x;
    long y;
    void * hSource;
    unsigned long dwID;
    unsigned long dwFlags;
    unsigned long dwMask;
    unsigned long dwTime;
    unsigned long dwExtraInfo;
    unsigned long cxContact;
    unsigned long cyContact;
};

struct tagMCI_OPEN_PARMSA
{
    unsigned long dwCallback;
    unsigned int wDeviceID;
    char * lpstrDeviceType;
    char * lpstrElementName;
    char * lpstrAlias;
};

struct tagMOUSEINPUT
{
    long dx;
    long dy;
    unsigned long mouseData;
    unsigned long dwFlags;
    unsigned long time;
    unsigned long dwExtraInfo;
};

struct _SERVICE_STATUS
{
    unsigned long dwServiceType;
    unsigned long dwCurrentState;
    unsigned long dwControlsAccepted;
    unsigned long dwWin32ExitCode;
    unsigned long dwServiceSpecificExitCode;
    unsigned long dwCheckPoint;
    unsigned long dwWaitHint;
};

struct tagGESTUREINFO
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long dwID;
    struct HWND__ * hwndTarget;
    struct tagPOINTS ptsLocation;
    unsigned long dwInstanceID;
    unsigned long dwSequenceID;
    unsigned int ullArguments;
    unsigned int cbExtraArgs;
};

struct tagMONITORINFO
{
    unsigned long cbSize;
    struct tagRECT rcMonitor;
    struct tagRECT rcWork;
    unsigned long dwFlags;
};

struct tagCANDIDATEFORM
{
    unsigned long dwIndex;
    unsigned long dwStyle;
    struct tagPOINT ptCurrentPos;
    struct tagRECT rcArea;
};

struct tagWNDCLASSA
{
    unsigned int style;
    long  ( * lpfnWndProc)(struct HWND__ * ,unsigned int ,unsigned int ,long );
    int cbClsExtra;
    int cbWndExtra;
    struct HINSTANCE__ * hInstance;
    struct HICON__ * hIcon;
    struct HICON__ * hCursor;
    struct HBRUSH__ * hbrBackground;
    char * lpszMenuName;
    char * lpszClassName;
};

struct _FILE_RENAME_INFO
{
    unsigned int ReplaceIfExists;
    void * RootDirectory;
    unsigned long FileNameLength;
    wchar_t FileName[1];
};

struct _JOBOBJECT_BASIC_UI_RESTRICTIONS
{
    unsigned long UIRestrictionsClass;
};

struct tagACTCTX_SECTION_KEYED_DATA_2600
{
    unsigned long cbSize;
    unsigned long ulDataFormatVersion;
    void * lpData;
    unsigned long ulLength;
    void * lpSectionGlobalData;
    unsigned long ulSectionGlobalDataLength;
    void * lpSectionBase;
    unsigned long ulSectionTotalLength;
    void * hActCtx;
    unsigned long ulAssemblyRosterIndex;
};

struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct _COMMPROP
{
    unsigned int wPacketLength;
    unsigned int wPacketVersion;
    unsigned long dwServiceMask;
    unsigned long dwReserved1;
    unsigned long dwMaxTxQueue;
    unsigned long dwMaxRxQueue;
    unsigned long dwMaxBaud;
    unsigned long dwProvSubType;
    unsigned long dwProvCapabilities;
    unsigned long dwSettableParams;
    unsigned long dwSettableBaud;
    unsigned int wSettableData;
    unsigned int wSettableStopParity;
    unsigned long dwCurrentTxQueue;
    unsigned long dwCurrentRxQueue;
    unsigned long dwProvSpec1;
    unsigned long dwProvSpec2;
    wchar_t wcProvChar[1];
};

struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
{
    void * lpInformation;
    void * lpSectionBase;
    unsigned long ulSectionLength;
    void * lpSectionGlobalDataBase;
    unsigned long ulSectionGlobalDataLength;
};

struct _LUID_AND_ATTRIBUTES
{
    struct _LUID Luid;
    unsigned long Attributes;
};

struct _XSTATE_CONFIGURATION
{
    unsigned int EnabledFeatures;
    unsigned long Size;
    unsigned long OptimizedSave:1;
    struct _XSTATE_FEATURE Features[64];
};

struct tagMCI_LOAD_PARMSA
{
    unsigned long dwCallback;
    char * lpfilename;
};

struct tagEMREXTSELECTCLIPRGN
{
    struct tagEMR emr;
    unsigned long cbRgnData;
    unsigned long iMode;
    unsigned int RgnData[1];
};

class SVector
{
    public float x;
    public float y;
    public float z;
    public void SVector(float ,float ,float );
    public void SVector();
    public class SVector operator+(class SVector & );
    public void operator+=(class SVector & );
    public class SVector operator-(class SVector & );
    public void operator-=(class SVector & );
    public class SVector operator*(float );
    public class SVector operator*(float );
    public void operator*=(float );
    public void operator*=(float );
    public float Dot(class SVector & );
    public void Cross(class SVector & ,class SVector & );
    public void Scale(class SVector & );
    public void Normalize();
    public class SVector Normalized();
    public float Distance(class SVector & );
    public float Length();
    public float LengthSquare();
    public void GetHVAngles(float * ,float * );
    public void SetHVAngles(float ,float );
    public class SVector One();
    public class SVector Zero();
};

struct tagACCEL
{
    unsigned int fVirt;
    unsigned int key;
    unsigned int cmd;
};

struct _SERVICE_FAILURE_ACTIONS_FLAG
{
    int fFailureActionsOnNonCrashFailures;
};

struct _s__CatchableTypeArray
{
    int nCatchableTypes;
    struct _s__CatchableType * arrayOfCatchableTypes[0];
};

struct tagMCI_GENERIC_PARMS
{
    unsigned long dwCallback;
};

struct tagMCI_ANIM_WINDOW_PARMSA
{
    unsigned long dwCallback;
    struct HWND__ * hWnd;
    unsigned int nCmdShow;
    char * lpstrText;
};

struct _ACCESS_DENIED_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct _FILE_DISPOSITION_INFO
{
    unsigned int DeleteFileA;
};

struct _wfinddata32i64_t
{
    unsigned int attrib;
    long time_create;
    long time_access;
    long time_write;
    int size;
    wchar_t name[260];
};

struct _OUTPUT_DEBUG_STRING_INFO
{
    char * lpDebugStringData;
    unsigned int fUnicode;
    unsigned int nDebugStringLength;
};

struct tagEMRSETVIEWPORTEXTEX
{
    struct tagEMR emr;
    struct tagSIZE szlExtent;
};

struct tagGUITHREADINFO
{
    unsigned long cbSize;
    unsigned long flags;
    struct HWND__ * hwndActive;
    struct HWND__ * hwndFocus;
    struct HWND__ * hwndCapture;
    struct HWND__ * hwndMenuOwner;
    struct HWND__ * hwndMoveSize;
    struct HWND__ * hwndCaret;
    struct tagRECT rcCaret;
};

struct tagMCI_VD_PLAY_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrom;
    unsigned long dwTo;
    unsigned long dwSpeed;
};

struct tagSCROLLINFO
{
    unsigned int cbSize;
    unsigned int fMask;
    int nMin;
    int nMax;
    unsigned int nPage;
    int nPos;
    int nTrackPos;
};

struct _IMAGE_RESOURCE_DIRECTORY_STRING
{
    unsigned int Length;
    char NameString[1];
};

struct tagEXTLOGFONTW
{
    struct tagLOGFONTW elfLogFont;
    wchar_t elfFullName[64];
    wchar_t elfStyle[32];
    unsigned long elfVersion;
    unsigned long elfStyleSize;
    unsigned long elfMatch;
    unsigned long elfReserved;
    unsigned int elfVendorId[4];
    unsigned long elfCulture;
    struct tagPANOSE elfPanose;
};

struct HMIDIIN__
{
    int unused;
};

struct HMMIO__
{
    int unused;
};

struct tagLOGCOLORSPACEW
{
    unsigned long lcsSignature;
    unsigned long lcsVersion;
    unsigned long lcsSize;
    long lcsCSType;
    long lcsIntent;
    struct tagICEXYZTRIPLE lcsEndpoints;
    unsigned long lcsGammaRed;
    unsigned long lcsGammaGreen;
    unsigned long lcsGammaBlue;
    wchar_t lcsFilename[260];
};

struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
{
    unsigned int pixelRate;
    struct DISPLAYCONFIG_RATIONAL hSyncFreq;
    struct DISPLAYCONFIG_RATIONAL vSyncFreq;
    struct DISPLAYCONFIG_2DREGION activeSize;
    struct DISPLAYCONFIG_2DREGION totalSize;
    unsigned int videoStandard;
    enum DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
};

struct tagEMRSELECTOBJECT
{
    struct tagEMR emr;
    unsigned long ihObject;
};

struct tagMCI_WAVE_DELETE_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrom;
    unsigned long dwTo;
};

struct DISPLAYCONFIG_TARGET_MODE
{
    struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
};

struct tagEMRSETMITERLIMIT
{
    struct tagEMR emr;
    float eMiterLimit;
};

struct tagWNDCLASSEXA
{
    unsigned int cbSize;
    unsigned int style;
    long  ( * lpfnWndProc)(struct HWND__ * ,unsigned int ,unsigned int ,long );
    int cbClsExtra;
    int cbWndExtra;
    struct HINSTANCE__ * hInstance;
    struct HICON__ * hIcon;
    struct HICON__ * hCursor;
    struct HBRUSH__ * hbrBackground;
    char * lpszMenuName;
    char * lpszClassName;
    struct HICON__ * hIconSm;
};

struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
{
    struct _TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
};

struct _EXCEPTION_DEBUG_INFO
{
    struct _EXCEPTION_RECORD ExceptionRecord;
    unsigned long dwFirstChance;
};

union _IMAGE_SECTION_HEADER::<unnamed-type-Misc>
{
    unsigned long PhysicalAddress;
    unsigned long VirtualSize;
};

struct _ImageArchitectureEntry
{
    unsigned long FixupInstRVA;
    unsigned long NewInst;
};

struct _PROCESSOR_POWER_POLICY
{
    unsigned long Revision;
    unsigned int DynamicThrottle;
    unsigned int Spare[3];
    unsigned long DisableCStates:1;
    unsigned long Reserved:31;
    unsigned long PolicyCount;
    struct _PROCESSOR_POWER_POLICY_INFO Policy[3];
};

struct _stat64i32
{
    unsigned int st_dev;
    unsigned int st_ino;
    unsigned int st_mode;
    int st_nlink;
    int st_uid;
    int st_gid;
    unsigned int st_rdev;
    long st_size;
    int st_atime;
    int st_mtime;
    int st_ctime;
};

struct _TAPE_GET_POSITION
{
    unsigned long Type;
    unsigned long Partition;
    union _LARGE_INTEGER Offset;
};

struct _REMOTE_NAME_INFOA
{
    char * lpUniversalName;
    char * lpConnectionName;
    char * lpRemainingPath;
};

struct tagEMR
{
    unsigned long iType;
    unsigned long nSize;
};

struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
{
    unsigned long mouseData;
};

struct _ACCESS_ALLOWED_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct _DISCDLGSTRUCTW
{
    unsigned long cbStructure;
    struct HWND__ * hwndOwner;
    wchar_t * lpLocalName;
    wchar_t * lpRemoteName;
    unsigned long dwFlags;
};

struct _FILE_STANDARD_INFO
{
    union _LARGE_INTEGER AllocationSize;
    union _LARGE_INTEGER EndOfFile;
    unsigned long NumberOfLinks;
    unsigned int DeletePending;
    unsigned int Directory;
};

struct tagEMRSETICMPROFILE
{
    struct tagEMR emr;
    unsigned long dwFlags;
    unsigned long cbName;
    unsigned long cbData;
    unsigned int Data[1];
};

struct _IMAGE_RESOURCE_DATA_ENTRY
{
    unsigned long OffsetToData;
    unsigned long Size;
    unsigned long CodePage;
    unsigned long Reserved;
};

struct tagMCI_INFO_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpstrReturn;
    unsigned long dwRetSize;
};

struct tagKEYBDINPUT
{
    unsigned int wVk;
    unsigned int wScan;
    unsigned long dwFlags;
    unsigned long time;
    unsigned long dwExtraInfo;
};

struct tagRAWINPUTDEVICELIST
{
    void * hDevice;
    unsigned long dwType;
};

struct _PMD
{
    int mdisp;
    int pdisp;
    int vdisp;
};

struct _Real_type<float>
{
};

class type_info
{
    public void type_info(class type_info & );
    public class type_info & operator=(class type_info & );
    public unsigned int hash_code();
    public bool operator==(class type_info & );
    public bool operator!=(class type_info & );
    public bool before(class type_info & );
    public char * name();
    public char * raw_name();
    public void ~type_info();
    private struct __std_type_info_data _Data;
    public void * __vecDelDtor(unsigned int );
};

union _IMAGE_AUX_SYMBOL
{
    struct <unnamed-type-Sym>
    {
        unsigned long TagIndex;
        union <unnamed-type-Misc>
        {
            struct <unnamed-type-LnSz>
            {
                unsigned int Linenumber;
                unsigned int Size;
            };
            struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc>::<unnamed-type-LnSz> LnSz;
            unsigned long TotalSize;
        };
        union _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc> Misc;
        union <unnamed-type-FcnAry>
        {
            struct <unnamed-type-Function>
            {
                unsigned long PointerToLinenumber;
                unsigned long PointerToNextFunction;
            };
            struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Function> Function;
            struct <unnamed-type-Array>
            {
                unsigned int Dimension[4];
            };
            struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Array> Array;
        };
        union _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry> FcnAry;
        unsigned int TvIndex;
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym> Sym;
    struct <unnamed-type-File>
    {
        unsigned int Name[18];
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-File> File;
    struct <unnamed-type-Section>
    {
        unsigned long Length;
        unsigned int NumberOfRelocations;
        unsigned int NumberOfLinenumbers;
        unsigned long CheckSum;
        int Number;
        unsigned int Selection;
        unsigned int bReserved;
        int HighNumber;
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-Section> Section;
    struct IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
    struct <unnamed-type-CRC>
    {
        unsigned long crc;
        unsigned int rgbReserved[14];
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-CRC> CRC;
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-CRC>
{
    unsigned long crc;
    unsigned int rgbReserved[14];
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-Section>
{
    unsigned long Length;
    unsigned int NumberOfRelocations;
    unsigned int NumberOfLinenumbers;
    unsigned long CheckSum;
    int Number;
    unsigned int Selection;
    unsigned int bReserved;
    int HighNumber;
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-File>
{
    unsigned int Name[18];
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>
{
    unsigned long TagIndex;
    union <unnamed-type-Misc>
    {
        struct <unnamed-type-LnSz>
        {
            unsigned int Linenumber;
            unsigned int Size;
        };
        struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc>::<unnamed-type-LnSz> LnSz;
        unsigned long TotalSize;
    };
    union _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc> Misc;
    union <unnamed-type-FcnAry>
    {
        struct <unnamed-type-Function>
        {
            unsigned long PointerToLinenumber;
            unsigned long PointerToNextFunction;
        };
        struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Function> Function;
        struct <unnamed-type-Array>
        {
            unsigned int Dimension[4];
        };
        struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Array> Array;
    };
    union _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry> FcnAry;
    unsigned int TvIndex;
};

union _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>
{
    struct <unnamed-type-Function>
    {
        unsigned long PointerToLinenumber;
        unsigned long PointerToNextFunction;
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Function> Function;
    struct <unnamed-type-Array>
    {
        unsigned int Dimension[4];
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Array> Array;
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Array>
{
    unsigned int Dimension[4];
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-FcnAry>::<unnamed-type-Function>
{
    unsigned long PointerToLinenumber;
    unsigned long PointerToNextFunction;
};

union _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc>
{
    struct <unnamed-type-LnSz>
    {
        unsigned int Linenumber;
        unsigned int Size;
    };
    struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc>::<unnamed-type-LnSz> LnSz;
    unsigned long TotalSize;
};

struct _IMAGE_AUX_SYMBOL::<unnamed-type-Sym>::<unnamed-type-Misc>::<unnamed-type-LnSz>
{
    unsigned int Linenumber;
    unsigned int Size;
};

struct _SYSTEM_ALARM_CALLBACK_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct __s_GUID
{
    unsigned long Data1;
    unsigned int Data2;
    unsigned int Data3;
    unsigned int Data4[8];
};

struct tagEMRPIXELFORMAT
{
    struct tagEMR emr;
    struct tagPIXELFORMATDESCRIPTOR pfd;
};

struct STransform
{
    struct SQuaternion q;
    struct SPoint3 t;
    float scale;
    void STransform(struct SQuaternion & ,struct SPoint3 & ,float );
    void STransform(struct SQuaternion & ,struct SPoint3 & );
    void STransform(struct SPoint3 & );
    void STransform(struct SQuaternion & );
    void STransform();
    struct STransform operator*(struct STransform & );
    struct STransform & operator*=(struct STransform & );
    struct STransform GetInverse();
    struct SVector3 GetXAxis();
    struct SVector3 GetYAxis();
    struct SVector3 GetZAxis();
    struct SPoint3 TransformPoint(struct SPoint3 & );
    struct SVector3 TransformVector(struct SVector3 & );
};

struct STransform
{
    struct SQuaternion q;
    struct SPoint3 t;
    float scale;
    void STransform(struct SQuaternion & ,struct SPoint3 & ,float );
    void STransform(struct SQuaternion & ,struct SPoint3 & );
    void STransform(struct SPoint3 & );
    void STransform(struct SQuaternion & );
    void STransform();
    struct STransform operator*(struct STransform & );
    struct STransform & operator*=(struct STransform & );
    struct STransform GetInverse();
    struct SVector3 GetXAxis();
    struct SVector3 GetYAxis();
    struct SVector3 GetZAxis();
    struct SPoint3 TransformPoint(struct SPoint3 & );
    struct SVector3 TransformVector(struct SVector3 & );
};

struct tagENHMETARECORD
{
    unsigned long iType;
    unsigned long nSize;
    unsigned long dParm[1];
};

struct _GLYPHMETRICSFLOAT
{
    float gmfBlackBoxX;
    float gmfBlackBoxY;
    struct _POINTFLOAT gmfptGlyphOrigin;
    float gmfCellIncX;
    float gmfCellIncY;
};

struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct _s__RTTIBaseClassArray
{
    struct _s__RTTIBaseClassDescriptor * arrayOfBaseClassDescriptors[0];
};

struct _s__RTTIClassHierarchyDescriptor
{
    unsigned long signature;
    unsigned long attributes;
    unsigned long numBaseClasses;
    struct _s__RTTIBaseClassArray * pBaseClassArray;
};

struct tagEMRBITBLT
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long cxDest;
    long cyDest;
    unsigned long dwRop;
    long xSrc;
    long ySrc;
    struct tagXFORM xformSrc;
    unsigned long crBkColorSrc;
    unsigned long iUsageSrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
};

struct tagEMREOF
{
    struct tagEMR emr;
    unsigned long nPalEntries;
    unsigned long offPalEntries;
    unsigned long nSizeLast;
};

union _REASON_CONTEXT::<unnamed-type-Reason>
{
    struct <unnamed-type-Detailed>
    {
        struct HINSTANCE__ * LocalizedReasonModule;
        unsigned long LocalizedReasonId;
        unsigned long ReasonStringCount;
        wchar_t ** ReasonStrings;
    };
    struct _REASON_CONTEXT::<unnamed-type-Reason>::<unnamed-type-Detailed> Detailed;
    wchar_t * SimpleReasonString;
};

struct _REASON_CONTEXT::<unnamed-type-Reason>::<unnamed-type-Detailed>
{
    struct HINSTANCE__ * LocalizedReasonModule;
    unsigned long LocalizedReasonId;
    unsigned long ReasonStringCount;
    wchar_t ** ReasonStrings;
};

struct tagEMRRESTOREDC
{
    struct tagEMR emr;
    long iRelative;
};

struct tagCOPYDATASTRUCT
{
    unsigned long dwData;
    unsigned long cbData;
    void * lpData;
};

struct DISPLAYCONFIG_2DREGION
{
    unsigned int cx;
    unsigned int cy;
};

struct _SERVICE_STATUS_PROCESS
{
    unsigned long dwServiceType;
    unsigned long dwCurrentState;
    unsigned long dwControlsAccepted;
    unsigned long dwWin32ExitCode;
    unsigned long dwServiceSpecificExitCode;
    unsigned long dwCheckPoint;
    unsigned long dwWaitHint;
    unsigned long dwProcessId;
    unsigned long dwServiceFlags;
};

struct LIST_ENTRY64
{
    unsigned int Flink;
    unsigned int Blink;
};

struct tagMIXERCONTROLW
{
    unsigned long cbStruct;
    unsigned long dwControlID;
    unsigned long dwControlType;
    unsigned long fdwControl;
    unsigned long cMultipleItems;
    wchar_t szShortName[16];
    wchar_t szName[64];
    union <unnamed-type-Bounds>
    {
        long lMinimum;
        long lMaximum;
        unsigned long dwMinimum;
        unsigned long dwMaximum;
        unsigned long dwReserved[6];
    };
    union tagMIXERCONTROLW::<unnamed-type-Bounds> Bounds;
    union <unnamed-type-Metrics>
    {
        unsigned long cSteps;
        unsigned long cbCustomData;
        unsigned long dwReserved[6];
    };
    union tagMIXERCONTROLW::<unnamed-type-Metrics> Metrics;
};

struct _SERVICE_SID_INFO
{
    unsigned long dwServiceSidType;
};

struct _SERVICE_TRIGGER_INFO
{
    unsigned long cTriggers;
    struct _SERVICE_TRIGGER * pTriggers;
    unsigned int * pReserved;
};

struct tagMCI_VD_ESCAPE_PARMSA
{
    unsigned long dwCallback;
    char * lpstrCommand;
};

struct $_s__RTTIBaseClassArray$_extraBytes_20
{
    struct _s__RTTIBaseClassDescriptor * arrayOfBaseClassDescriptors[5];
};

union tagMIXERCONTROLW::<unnamed-type-Metrics>
{
    unsigned long cSteps;
    unsigned long cbCustomData;
    unsigned long dwReserved[6];
};

union tagMIXERCONTROLW::<unnamed-type-Bounds>
{
    long lMinimum;
    long lMaximum;
    unsigned long dwMinimum;
    unsigned long dwMaximum;
    unsigned long dwReserved[6];
};

struct _PROCESSOR_GROUP_INFO
{
    unsigned int MaximumProcessorCount;
    unsigned int ActiveProcessorCount;
    unsigned int Reserved[38];
    unsigned long ActiveProcessorMask;
};

struct joyinfoex_tag
{
    unsigned long dwSize;
    unsigned long dwFlags;
    unsigned long dwXpos;
    unsigned long dwYpos;
    unsigned long dwZpos;
    unsigned long dwRpos;
    unsigned long dwUpos;
    unsigned long dwVpos;
    unsigned long dwButtons;
    unsigned long dwButtonNumber;
    unsigned long dwPOV;
    unsigned long dwReserved1;
    unsigned long dwReserved2;
};

struct _JOB_SET_ARRAY
{
    void * JobHandle;
    unsigned long MemberLevel;
    unsigned long Flags;
};

struct _ABCFLOAT
{
    float abcfA;
    float abcfB;
    float abcfC;
};

struct _IMAGE_BASE_RELOCATION
{
    unsigned long VirtualAddress;
    unsigned long SizeOfBlock;
};

struct _lldiv_t
{
    int quot;
    int rem;
};

struct _TOKEN_GROUPS
{
    unsigned long GroupCount;
    struct _SID_AND_ATTRIBUTES Groups[1];
};

struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
{
    struct DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    unsigned int bootPersistenceOn:1;
    unsigned int reserved:31;
    unsigned int value;
};

struct SArchiveHeaderEntry
{
    int Pos;
    int Size;
};

struct tagMCI_SAVE_PARMSW
{
    unsigned long dwCallback;
    wchar_t * lpfilename;
};

struct _IMAGE_ROM_OPTIONAL_HEADER
{
    unsigned int Magic;
    unsigned int MajorLinkerVersion;
    unsigned int MinorLinkerVersion;
    unsigned long SizeOfCode;
    unsigned long SizeOfInitializedData;
    unsigned long SizeOfUninitializedData;
    unsigned long AddressOfEntryPoint;
    unsigned long BaseOfCode;
    unsigned long BaseOfData;
    unsigned long BaseOfBss;
    unsigned long GprMask;
    unsigned long CprMask[4];
    unsigned long GpValue;
};

struct _EXCEPTION_RECORD64
{
    unsigned long ExceptionCode;
    unsigned long ExceptionFlags;
    unsigned int ExceptionRecord;
    unsigned int ExceptionAddress;
    unsigned long NumberParameters;
    unsigned long __unusedAlignment;
    unsigned int ExceptionInformation[15];
};

struct tagRID_DEVICE_INFO
{
    unsigned long cbSize;
    unsigned long dwType;
    struct tagRID_DEVICE_INFO_MOUSE mouse;
    struct tagRID_DEVICE_INFO_KEYBOARD keyboard;
    struct tagRID_DEVICE_INFO_HID hid;
};

struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION
{
    unsigned int LastRecoveredLsn;
};

struct HWINEVENTHOOK__
{
    int unused;
};

union _INPUT_RECORD::<unnamed-type-Event>
{
    struct _KEY_EVENT_RECORD KeyEvent;
    struct _MOUSE_EVENT_RECORD MouseEvent;
    struct _WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
    struct _MENU_EVENT_RECORD MenuEvent;
    struct _FOCUS_EVENT_RECORD FocusEvent;
};

struct HFONT__
{
    int unused;
};

struct tMIXERCONTROLDETAILS_SIGNED
{
    long lValue;
};

struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
{
    enum _LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
    unsigned long Size;
    struct _PROCESSOR_RELATIONSHIP Processor;
    struct _NUMA_NODE_RELATIONSHIP NumaNode;
    struct _CACHE_RELATIONSHIP Cache;
    struct _GROUP_RELATIONSHIP Group;
};

struct DISPLAYCONFIG_MODE_INFO
{
    enum DISPLAYCONFIG_MODE_INFO_TYPE infoType;
    unsigned int id;
    struct _LUID adapterId;
    struct DISPLAYCONFIG_TARGET_MODE targetMode;
    struct DISPLAYCONFIG_SOURCE_MODE sourceMode;
};

struct __vcrt_assert_va_start_is_not_reference<__crt_locale_pointers *>
{
};

struct _EXCEPTION_POINTERS
{
    struct _EXCEPTION_RECORD * ExceptionRecord;
    struct _CONTEXT * ContextRecord;
};

struct tagPOINT
{
    long x;
    long y;
};

struct SPoint3
{
    float x;
    float y;
    float z;
    void SPoint3(float ,float ,float );
    void SPoint3();
    struct SPoint3 operator+(struct SVector3 & );
    struct SPoint3 & operator+=(struct SVector3 & );
    struct SVector3 operator-(struct SPoint3 & );
    struct SPoint3 operator-(struct SVector3 & );
    struct SPoint3 & operator-=(struct SVector3 & );
    float DistanceSqr(struct SPoint3 & );
    float Distance(struct SPoint3 & );
    struct SPoint3 Lerp(struct SPoint3 & ,struct SPoint3 & ,float );
};

struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION
{
    unsigned long SecurityLimitFlags;
    void * JobToken;
    struct _TOKEN_GROUPS * SidsToDisable;
    struct _TOKEN_PRIVILEGES * PrivilegesToDelete;
    struct _TOKEN_GROUPS * RestrictedSids;
};

struct tagWAVEINCAPSW
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
};

union _IMAGE_THUNK_DATA32::<unnamed-type-u1>
{
    unsigned long ForwarderString;
    unsigned long Function;
    unsigned long Ordinal;
    unsigned long AddressOfData;
};

struct IMAGE_AUX_SYMBOL_TOKEN_DEF
{
    unsigned int bAuxType;
    unsigned int bReserved;
    unsigned long SymbolTableIndex;
    unsigned int rgbReserved[12];
};

struct _TRANSACTION_LIST_ENTRY
{
    struct _GUID UOW;
};

struct tagAUXCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned int wTechnology;
    unsigned int wReserved1;
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct _TRANSACTION_BIND_INFORMATION
{
    void * TmHandle;
};

struct _UNLOAD_DLL_DEBUG_INFO
{
    void * lpBaseOfDll;
};

struct _Real_widened<float,float>
{
};

struct __vcrt_assert_va_start_is_not_reference<char const *>
{
};

struct SC_HANDLE__
{
    int unused;
};

struct _FPO_DATA
{
    unsigned long ulOffStart;
    unsigned long cbProcSize;
    unsigned long cdwLocals;
    unsigned int cdwParams;
    unsigned int cbProlog:8;
    unsigned int cbRegs:3;
    unsigned int fHasSEH:1;
    unsigned int fUseBP:1;
    unsigned int reserved:1;
    unsigned int cbFrame:2;
};

struct tagEMRPLGBLT
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    struct _POINTL aptlDest[3];
    long xSrc;
    long ySrc;
    long cxSrc;
    long cySrc;
    struct tagXFORM xformSrc;
    unsigned long crBkColorSrc;
    unsigned long iUsageSrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    long xMask;
    long yMask;
    unsigned long iUsageMask;
    unsigned long offBmiMask;
    unsigned long cbBmiMask;
    unsigned long offBitsMask;
    unsigned long cbBitsMask;
};

struct tagEMRINVERTRGN
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long cbRgnData;
    unsigned int RgnData[1];
};

struct _MEMORY_BASIC_INFORMATION64
{
    unsigned int BaseAddress;
    unsigned int AllocationBase;
    unsigned long AllocationProtect;
    unsigned long __alignment1;
    unsigned int RegionSize;
    unsigned long State;
    unsigned long Protect;
    unsigned long Type;
    unsigned long __alignment2;
};

struct _MMIOINFO
{
    unsigned long dwFlags;
    unsigned long fccIOProc;
    long  ( * pIOProc)(char * ,unsigned int ,long ,long );
    unsigned int wErrorRet;
    struct HTASK__ * htask;
    long cchBuffer;
    char * pchBuffer;
    char * pchNext;
    char * pchEndRead;
    char * pchEndWrite;
    long lBufOffset;
    long lDiskOffset;
    unsigned long adwInfo[3];
    unsigned long dwReserved1;
    unsigned long dwReserved2;
    struct HMMIO__ * hmmio;
};

struct tagGESTUREINFO
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long dwID;
    struct HWND__ * hwndTarget;
    struct tagPOINTS ptsLocation;
    unsigned long dwInstanceID;
    unsigned long dwSequenceID;
    unsigned int ullArguments;
    unsigned int cbExtraArgs;
};

struct tagICEXYZTRIPLE
{
    struct tagCIEXYZ ciexyzRed;
    struct tagCIEXYZ ciexyzGreen;
    struct tagCIEXYZ ciexyzBlue;
};

struct tagRID_DEVICE_INFO_HID
{
    unsigned long dwVendorId;
    unsigned long dwProductId;
    unsigned long dwVersionNumber;
    unsigned int usUsagePage;
    unsigned int usUsage;
};

struct tagEMRGLSRECORD
{
    struct tagEMR emr;
    unsigned long cbData;
    unsigned int Data[1];
};

struct __std_type_info_data
{
    char * _UndecoratedName;
    char _DecoratedName[1];
    void __std_type_info_data(struct __std_type_info_data * );
    void __std_type_info_data(struct __std_type_info_data & );
    void __std_type_info_data();
    struct __std_type_info_data & operator=(struct __std_type_info_data * );
    struct __std_type_info_data & operator=(struct __std_type_info_data & );
};

struct __std_type_info_data
{
    char * _UndecoratedName;
    char _DecoratedName[1];
    void __std_type_info_data(struct __std_type_info_data * );
    void __std_type_info_data(struct __std_type_info_data & );
    void __std_type_info_data();
    struct __std_type_info_data & operator=(struct __std_type_info_data * );
    struct __std_type_info_data & operator=(struct __std_type_info_data & );
};

struct tagACTCTXA
{
    unsigned long cbSize;
    unsigned long dwFlags;
    char * lpSource;
    unsigned int wProcessorArchitecture;
    unsigned int wLangId;
    char * lpAssemblyDirectory;
    char * lpResourceName;
    char * lpApplicationName;
    struct HINSTANCE__ * hModule;
};

struct tagMIXERLINEW::<unnamed-type-Target>
{
    unsigned long dwType;
    unsigned long dwDeviceID;
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
};

struct _IMAGE_BOUND_FORWARDER_REF
{
    unsigned long TimeDateStamp;
    unsigned int OffsetModuleName;
    unsigned int Reserved;
};

struct _MOUSE_EVENT_RECORD
{
    struct _COORD dwMousePosition;
    unsigned long dwButtonState;
    unsigned long dwControlKeyState;
    unsigned long dwEventFlags;
};

struct _EXIT_THREAD_DEBUG_INFO
{
    unsigned long dwExitCode;
};

struct $_TypeDescriptor$_extraBytes_27
{
    void * pVFTable;
    void * spare;
    char name[27];
};

struct _TOKEN_ORIGIN
{
    struct _LUID OriginatingLogonSession;
};

struct _numberfmtA
{
    unsigned int NumDigits;
    unsigned int LeadingZero;
    unsigned int Grouping;
    char * lpDecimalSep;
    char * lpThousandSep;
    unsigned int NegativeOrder;
};

struct _SERVICE_TRIGGER
{
    unsigned long dwTriggerType;
    unsigned long dwAction;
    struct _GUID * pTriggerSubtype;
    unsigned long cDataItems;
    struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM * pDataItems;
};

struct _UMS_SCHEDULER_STARTUP_INFO
{
    unsigned long UmsVersion;
    void * CompletionList;
    void  ( * SchedulerProc)(enum _RTL_UMS_SCHEDULER_REASON ,unsigned long ,void * );
    void * SchedulerParam;
};

struct DISPLAYCONFIG_DEVICE_INFO_HEADER
{
    enum DISPLAYCONFIG_DEVICE_INFO_TYPE type;
    unsigned int size;
    struct _LUID adapterId;
    unsigned int id;
};

struct ANON_OBJECT_HEADER_V2
{
    unsigned int Sig1;
    unsigned int Sig2;
    unsigned int Version;
    unsigned int Machine;
    unsigned long TimeDateStamp;
    struct _GUID ClassID;
    unsigned long SizeOfData;
    unsigned long Flags;
    unsigned long MetaDataSize;
    unsigned long MetaDataOffset;
};

struct _STARTUPINFOEXW
{
    struct _STARTUPINFOW StartupInfo;
    struct _PROC_THREAD_ATTRIBUTE_LIST * lpAttributeList;
};

struct _TAPE_GET_MEDIA_PARAMETERS
{
    union _LARGE_INTEGER Capacity;
    union _LARGE_INTEGER Remaining;
    unsigned long BlockSize;
    unsigned long PartitionCount;
    unsigned int WriteProtected;
};

struct tagEMRSETARCDIRECTION
{
    struct tagEMR emr;
    unsigned long iArcDirection;
};

struct _EXCEPTION_RECORD
{
    unsigned long ExceptionCode;
    unsigned long ExceptionFlags;
    struct _EXCEPTION_RECORD * ExceptionRecord;
    void * ExceptionAddress;
    unsigned long NumberParameters;
    unsigned long ExceptionInformation[15];
};

struct tagMOUSEKEYS
{
    unsigned int cbSize;
    unsigned long dwFlags;
    unsigned long iMaxSpeed;
    unsigned long iTimeToMaxSpeed;
    unsigned long iCtrlSpeed;
    unsigned long dwReserved1;
    unsigned long dwReserved2;
};

struct _TRANSACTION_PROPERTIES_INFORMATION
{
    unsigned long IsolationLevel;
    unsigned long IsolationFlags;
    union _LARGE_INTEGER Timeout;
    unsigned long Outcome;
    unsigned long DescriptionLength;
    wchar_t Description[1];
};

struct _JIT_DEBUG_INFO
{
    unsigned long dwSize;
    unsigned long dwProcessorArchitecture;
    unsigned long dwThreadID;
    unsigned long dwReserved0;
    unsigned int lpExceptionAddress;
    unsigned int lpExceptionRecord;
    unsigned int lpContextRecord;
};

struct tagWINDOWPOS
{
    struct HWND__ * hwnd;
    struct HWND__ * hwndInsertAfter;
    int x;
    int y;
    int cx;
    int cy;
    unsigned int flags;
};

struct tagMETAFILEPICT
{
    long mm;
    long xExt;
    long yExt;
    struct HMETAFILE__ * hMF;
};

struct HSTR__
{
    int unused;
};

struct tagMSLLHOOKSTRUCT
{
    struct tagPOINT pt;
    unsigned long mouseData;
    unsigned long flags;
    unsigned long time;
    unsigned long dwExtraInfo;
};

struct tagEMRSETPIXELV
{
    struct tagEMR emr;
    struct _POINTL ptlPixel;
    unsigned long crColor;
};

struct _ACCESS_DENIED_CALLBACK_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long SidStart;
};

struct _PROCESS_HEAP_ENTRY::_anonymous_2276::<unnamed-type-Region>
{
    unsigned long dwCommittedSize;
    unsigned long dwUnCommittedSize;
    void * lpFirstBlock;
    void * lpLastBlock;
};

struct _PROCESS_HEAP_ENTRY::_anonymous_2277::<unnamed-type-Block>
{
    void * hMem;
    unsigned long dwReserved[3];
};

struct tagEMRPOLYPOLYLINE16
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    unsigned long nPolys;
    unsigned long cpts;
    unsigned long aPolyCounts[1];
    struct tagPOINTS apts[1];
};

struct _CONSOLE_READCONSOLE_CONTROL
{
    unsigned long nLength;
    unsigned long nInitialChars;
    unsigned long dwCtrlWakeupMask;
    unsigned long dwControlKeyState;
};

struct tagANIMATIONINFO
{
    unsigned int cbSize;
    int iMinAnimate;
};

struct tagEMRCREATEMONOBRUSH
{
    struct tagEMR emr;
    unsigned long ihBrush;
    unsigned long iUsage;
    unsigned long offBmi;
    unsigned long cbBmi;
    unsigned long offBits;
    unsigned long cbBits;
};

struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION
{
    unsigned long dwFlags;
    unsigned long ulFormatVersion;
    unsigned long ulAssemblyCount;
    unsigned long ulRootManifestPathType;
    unsigned long ulRootManifestPathChars;
    unsigned long ulRootConfigurationPathType;
    unsigned long ulRootConfigurationPathChars;
    unsigned long ulAppDirPathType;
    unsigned long ulAppDirPathChars;
    wchar_t * lpRootManifestPath;
    wchar_t * lpRootConfigurationPath;
    wchar_t * lpAppDirPath;
};

struct _CrtMemBlockHeader
{
};

struct _CrtMemState
{
    struct _CrtMemBlockHeader * pBlockHeader;
    unsigned int lCounts[5];
    unsigned int lSizes[5];
    unsigned int lHighWaterCount;
    unsigned int lTotalCount;
};

struct _ABC
{
    int abcA;
    unsigned int abcB;
    int abcC;
};

struct tagRAWKEYBOARD
{
    unsigned int MakeCode;
    unsigned int Flags;
    unsigned int Reserved;
    unsigned int VKey;
    unsigned int Message;
    unsigned long ExtraInformation;
};

class SDArray<unsigned char *>
{
    private int size;
    private int maxsize;
    public unsigned int ** array;
    public void SDArray<unsigned char *>(class SDArray<unsigned char *> & );
    public void SDArray<unsigned char *>();
    public void ~SDArray<unsigned char *>();
    public int Add(unsigned int &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int &** operator[](int );
    public void operator=(class SDArray<unsigned char *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<unsigned char *>
{
    private int size;
    private int maxsize;
    public unsigned int ** array;
    public void SDArray<unsigned char *>(class SDArray<unsigned char *> & );
    public void SDArray<unsigned char *>();
    public void ~SDArray<unsigned char *>();
    public int Add(unsigned int &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int &** operator[](int );
    public void operator=(class SDArray<unsigned char *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct tWAVEFORMATEX
{
    unsigned int wFormatTag;
    unsigned int nChannels;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
    unsigned int wBitsPerSample;
    unsigned int cbSize;
};

struct HLSURF__
{
    int unused;
};

struct tagEMRSETWORLDTRANSFORM
{
    struct tagEMR emr;
    struct tagXFORM xform;
};

struct tagNMHDR
{
    struct HWND__ * hwndFrom;
    unsigned int idFrom;
    unsigned int code;
};

struct _numberfmtW
{
    unsigned int NumDigits;
    unsigned int LeadingZero;
    unsigned int Grouping;
    wchar_t * lpDecimalSep;
    wchar_t * lpThousandSep;
    unsigned int NegativeOrder;
};

struct tagCURSORSHAPE
{
    int xHotSpot;
    int yHotSpot;
    int cx;
    int cy;
    int cbWidth;
    unsigned int Planes;
    unsigned int BitsPixel;
};

struct tagREGISTERWORDW
{
    wchar_t * lpReading;
    wchar_t * lpWord;
};

struct tagRAWHID
{
    unsigned long dwSizeHid;
    unsigned long dwCount;
    unsigned int bRawData[1];
};

struct tagTEXTMETRICW
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    wchar_t tmFirstChar;
    wchar_t tmLastChar;
    wchar_t tmDefaultChar;
    wchar_t tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
};

struct DISPLAYCONFIG_PATH_INFO
{
    struct DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
    struct DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
    unsigned int flags;
};

struct HBITMAP__
{
    int unused;
};

struct _MODEMDEVCAPS
{
    unsigned long dwActualSize;
    unsigned long dwRequiredSize;
    unsigned long dwDevSpecificOffset;
    unsigned long dwDevSpecificSize;
    unsigned long dwModemProviderVersion;
    unsigned long dwModemManufacturerOffset;
    unsigned long dwModemManufacturerSize;
    unsigned long dwModemModelOffset;
    unsigned long dwModemModelSize;
    unsigned long dwModemVersionOffset;
    unsigned long dwModemVersionSize;
    unsigned long dwDialOptions;
    unsigned long dwCallSetupFailTimer;
    unsigned long dwInactivityTimeout;
    unsigned long dwSpeakerVolume;
    unsigned long dwSpeakerMode;
    unsigned long dwModemOptions;
    unsigned long dwMaxDTERate;
    unsigned long dwMaxDCERate;
    unsigned int abVariablePortion[1];
};

struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
{
    struct DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    wchar_t viewGdiDeviceName[32];
};

struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
{
    struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
    struct _IO_COUNTERS IoInfo;
};

struct _ASSEMBLY_FILE_DETAILED_INFORMATION
{
    unsigned long ulFlags;
    unsigned long ulFilenameLength;
    unsigned long ulPathLength;
    wchar_t * lpFileName;
    wchar_t * lpFilePath;
};

struct HICON__
{
    int unused;
};

struct _CONTEXT_CHUNK
{
    long Offset;
    unsigned long Length;
};

struct tagRAWINPUTDEVICE
{
    unsigned int usUsagePage;
    unsigned int usUsage;
    unsigned long dwFlags;
    struct HWND__ * hwndTarget;
};

struct tagEMRSTRETCHDIBITS
{
    struct tagEMR emr;
    struct _RECTL rclBounds;
    long xDest;
    long yDest;
    long xSrc;
    long ySrc;
    long cxSrc;
    long cySrc;
    unsigned long offBmiSrc;
    unsigned long cbBmiSrc;
    unsigned long offBitsSrc;
    unsigned long cbBitsSrc;
    unsigned long iUsageSrc;
    unsigned long dwRop;
    long cxDest;
    long cyDest;
};

struct _RECTL
{
    long left;
    long top;
    long right;
    long bottom;
};

struct $_TypeDescriptor$_extraBytes_25
{
    void * pVFTable;
    void * spare;
    char name[25];
};

struct __vcrt_assert_va_start_is_not_reference<char const * const>
{
};

struct tagEVENTMSG
{
    unsigned int message;
    unsigned int paramL;
    unsigned int paramH;
    unsigned long time;
    struct HWND__ * hwnd;
};

struct _wfinddata32_t
{
    unsigned int attrib;
    long time_create;
    long time_access;
    long time_write;
    unsigned long size;
    wchar_t name[260];
};

struct _SERVICE_NOTIFY_1
{
    unsigned long dwVersion;
    void  ( * pfnNotifyCallback)(void * );
    void * pContext;
    unsigned long dwNotificationStatus;
    struct _SERVICE_STATUS_PROCESS ServiceStatus;
};

struct HWINSTA__
{
    int unused;
};

struct _Collvec
{
    unsigned int _Page;
    wchar_t * _LocaleName;
};

enum __vcrt_va_list_is_reference<wchar_t const *>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<wchar_t const *>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct _SECURITY_QUALITY_OF_SERVICE
{
    unsigned long Length;
    enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    unsigned int ContextTrackingMode;
    unsigned int EffectiveOnly;
};

struct _SERVICE_TABLE_ENTRYW
{
    wchar_t * lpServiceName;
    void  ( * lpServiceProc)(unsigned long ,wchar_t ** );
};

struct tagMIXERCONTROLDETAILS_LISTTEXTA
{
    unsigned long dwParam1;
    unsigned long dwParam2;
    char szName[64];
};

struct _TOKEN_MANDATORY_POLICY
{
    unsigned long Policy;
};

struct tagMINIMIZEDMETRICS
{
    unsigned int cbSize;
    int iWidth;
    int iHorzGap;
    int iVertGap;
    int iArrange;
};

struct tagEMRELLIPSE
{
    struct tagEMR emr;
    struct _RECTL rclBox;
};

struct tagAXISINFOW
{
    long axMinValue;
    long axMaxValue;
    wchar_t axAxisName[16];
};

struct _PSFEATURE_CUSTPAPER
{
    long lOrientation;
    long lWidth;
    long lHeight;
    long lWidthOffset;
    long lHeightOffset;
};

struct tagMIDIINCAPS2W
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    wchar_t szPname[32];
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

struct tagINPUT
{
    unsigned long type;
    struct tagMOUSEINPUT mi;
    struct tagKEYBDINPUT ki;
    struct tagHARDWAREINPUT hi;
};

struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
{
    unsigned int friendlyNameFromEdid:1;
    unsigned int friendlyNameForced:1;
    unsigned int edidIdsValid:1;
    unsigned int reserved:29;
    unsigned int value;
};

struct HKL__
{
    int unused;
};

struct HDC__
{
    int unused;
};

struct DISPLAYCONFIG_PATH_SOURCE_INFO
{
    struct _LUID adapterId;
    unsigned int id;
    unsigned int modeInfoIdx;
    unsigned int statusFlags;
};

union tagRAWINPUT::<unnamed-type-data>
{
    struct tagRAWMOUSE mouse;
    struct tagRAWKEYBOARD keyboard;
    struct tagRAWHID hid;
};

struct tagEMRGDICOMMENT
{
    struct tagEMR emr;
    unsigned long cbData;
    unsigned int Data[1];
};

class SOptions
{
    public void SOptions(class SOptions & );
    public void SOptions();
    public void ~SOptions();
    public int WriteOptionsIni();
    public void SetMouseScrollSpeed(int );
    public void SetKeyboardScrollSpeed(int );
    public void SetShowTipsAtStartup(int );
    public void SetSubtitles(int );
    public void SetFogOfWarView(int );
    public void SetUnitAcknowledgement(int );
    public void SetOtherUnitVoice(int );
    public float GetMouseScrollSpeed();
    public float GetKeyboardScrollSpeed();
    public int GetShowTipsAtStartup();
    public int GetSubtitles();
    public int GetFogOfWarView();
    public int GetUnitAcknowledgement();
    public int GetOtherUnitVoice();
    public int GetStartSp();
    public int GetPeriodicSp();
    public unsigned int GetGameType();
    public unsigned int GetCountMinute();
    public bool isEquipmentEnabled();
    public bool isLimitedammoEnabled();
    public bool isLimitedFuelEnabled();
    public bool isMovingforceEnabled();
    public bool isBomberEnabled();
    public bool isBuyingingameEnabled();
    public bool isRandomStartPositionEnabled();
    public bool isDominationEnabled();
    public void SetStartSp(int );
    public void SetPeriodicSp(int );
    public void SetGameType(unsigned int );
    public void SetCountMinute(unsigned int );
    public void SetEquipmentEnabled(bool );
    public void SetLimitedammoEnabled(bool );
    public void SetLimitedfuelEnabled(bool );
    public void SetMovingforceEnabled(bool );
    public void SetBomberEnabled(bool );
    public void SetBuyingingameEnabled(bool );
    public void SetRandomStartPositionEnabled(bool );
    public void SetDominationEnabled(bool );
    public void SetPlayerName(char * );
    public void SetLastHostIP(char * );
    public void SetMonitor(int );
    public void SetDisplayMode(int );
    public void SetScreenResolution(int );
    public void SetVSync(int );
    public void SetResolutionScale(float );
    public void SetMouseRestriction(int );
    public void SetCursorMode(int );
    public void SetAntialiasing(int );
    public void SetAnisotropicFiltering(int );
    public void SetShadows(int );
    public void SetTexturesDetail(int );
    public int GetMonitor();
    public int GetDisplayMode();
    public int GetScreenResolution();
    public float GetResolutionScale();
    public int GetVSync();
    public int GetMouseRestriction();
    public int GetCursorMode();
    public int GetAntialiasing();
    public int GetAnisotropicFiltering();
    public int GetShadows();
    public int GetTexturesDetail();
    public void SetMusicVolume(int );
    public void SetSoundEffectVolume(int );
    public void SetVoiceVolume(int );
    public void SetReverseChannels(int );
    public void SetPlaySoundInBackground(int );
    public int GetMusicVolume();
    public int GetSoundEffectVolume();
    public int GetVoiceVolume();
    public int GetReverseChannels();
    public int GetPlaySoundInBackground();
    public char * GetPlayerName();
    public char * GetLastHostIP();
    public void SetKeyboardMode(bool );
    public bool GetKeyboardMode();
    private class SProperties * OptionsIni;
    private float MouseScrollSpeed;
    private float KeyboardScrollSpeed;
    private int ShowTipsAtStartup;
    private int Subtitles;
    private int FogOfWarView;
    private int UnitAcknowledgement;
    private int OtherUnitVoice;
    private int Monitor;
    private int DisplayMode;
    private int ScreenResolution;
    private int ResolutionScale;
    private int VSync;
    private int MouseRestriction;
    private int CursorMode;
    private int Antialiasing;
    private int AnisotropicFiltering;
    private int Shadows;
    private int TexturesDetail;
    private int MusicVolume;
    private int SoundEffectVolume;
    private int VoiceVolume;
    private int ReverseChannels;
    private int PlaySoundInBackGround;
    private int StartSp;
    private int PeriodicSp;
    private unsigned int GameType;
    private unsigned int CountMinute;
    private bool equipment;
    private bool limitedammo;
    private bool limitedfuel;
    private bool movingforce;
    private bool bomber;
    private bool buyingingame;
    private bool randomstartposition;
    private bool domination;
    private class SString PlayerName;
    private class SString LastHostIP;
    private bool keyboardmode;
    public class SOptions & operator=(class SOptions & );
    public void * __vecDelDtor(unsigned int );
};

class SOptions
{
    public void SOptions(class SOptions & );
    public void SOptions();
    public void ~SOptions();
    public int WriteOptionsIni();
    public void SetMouseScrollSpeed(int );
    public void SetKeyboardScrollSpeed(int );
    public void SetShowTipsAtStartup(int );
    public void SetSubtitles(int );
    public void SetFogOfWarView(int );
    public void SetUnitAcknowledgement(int );
    public void SetOtherUnitVoice(int );
    public float GetMouseScrollSpeed();
    public float GetKeyboardScrollSpeed();
    public int GetShowTipsAtStartup();
    public int GetSubtitles();
    public int GetFogOfWarView();
    public int GetUnitAcknowledgement();
    public int GetOtherUnitVoice();
    public int GetStartSp();
    public int GetPeriodicSp();
    public unsigned int GetGameType();
    public unsigned int GetCountMinute();
    public bool isEquipmentEnabled();
    public bool isLimitedammoEnabled();
    public bool isLimitedFuelEnabled();
    public bool isMovingforceEnabled();
    public bool isBomberEnabled();
    public bool isBuyingingameEnabled();
    public bool isRandomStartPositionEnabled();
    public bool isDominationEnabled();
    public void SetStartSp(int );
    public void SetPeriodicSp(int );
    public void SetGameType(unsigned int );
    public void SetCountMinute(unsigned int );
    public void SetEquipmentEnabled(bool );
    public void SetLimitedammoEnabled(bool );
    public void SetLimitedfuelEnabled(bool );
    public void SetMovingforceEnabled(bool );
    public void SetBomberEnabled(bool );
    public void SetBuyingingameEnabled(bool );
    public void SetRandomStartPositionEnabled(bool );
    public void SetDominationEnabled(bool );
    public void SetPlayerName(char * );
    public void SetLastHostIP(char * );
    public void SetMonitor(int );
    public void SetDisplayMode(int );
    public void SetScreenResolution(int );
    public void SetVSync(int );
    public void SetResolutionScale(float );
    public void SetMouseRestriction(int );
    public void SetCursorMode(int );
    public void SetAntialiasing(int );
    public void SetAnisotropicFiltering(int );
    public void SetShadows(int );
    public void SetTexturesDetail(int );
    public int GetMonitor();
    public int GetDisplayMode();
    public int GetScreenResolution();
    public float GetResolutionScale();
    public int GetVSync();
    public int GetMouseRestriction();
    public int GetCursorMode();
    public int GetAntialiasing();
    public int GetAnisotropicFiltering();
    public int GetShadows();
    public int GetTexturesDetail();
    public void SetMusicVolume(int );
    public void SetSoundEffectVolume(int );
    public void SetVoiceVolume(int );
    public void SetReverseChannels(int );
    public void SetPlaySoundInBackground(int );
    public int GetMusicVolume();
    public int GetSoundEffectVolume();
    public int GetVoiceVolume();
    public int GetReverseChannels();
    public int GetPlaySoundInBackground();
    public char * GetPlayerName();
    public char * GetLastHostIP();
    public void SetKeyboardMode(bool );
    public bool GetKeyboardMode();
    private class SProperties * OptionsIni;
    private float MouseScrollSpeed;
    private float KeyboardScrollSpeed;
    private int ShowTipsAtStartup;
    private int Subtitles;
    private int FogOfWarView;
    private int UnitAcknowledgement;
    private int OtherUnitVoice;
    private int Monitor;
    private int DisplayMode;
    private int ScreenResolution;
    private int ResolutionScale;
    private int VSync;
    private int MouseRestriction;
    private int CursorMode;
    private int Antialiasing;
    private int AnisotropicFiltering;
    private int Shadows;
    private int TexturesDetail;
    private int MusicVolume;
    private int SoundEffectVolume;
    private int VoiceVolume;
    private int ReverseChannels;
    private int PlaySoundInBackGround;
    private int StartSp;
    private int PeriodicSp;
    private unsigned int GameType;
    private unsigned int CountMinute;
    private bool equipment;
    private bool limitedammo;
    private bool limitedfuel;
    private bool movingforce;
    private bool bomber;
    private bool buyingingame;
    private bool randomstartposition;
    private bool domination;
    private class SString PlayerName;
    private class SString LastHostIP;
    private bool keyboardmode;
    public class SOptions & operator=(class SOptions & );
    public void * __vecDelDtor(unsigned int );
};

struct _stat32i64
{
    unsigned int st_dev;
    unsigned int st_ino;
    unsigned int st_mode;
    int st_nlink;
    int st_uid;
    int st_gid;
    unsigned int st_rdev;
    int st_size;
    long st_atime;
    long st_mtime;
    long st_ctime;
};

class SFileStream : public SStream
{
    private unsigned long RefCount;
    private int FileDes;
    private const bool Readable;
    private const bool Writeable;
    public void SFileStream(class SFileStream & );
    public void SFileStream(int ,bool ,bool );
    public void ~SFileStream();
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SFileStream : public SStream
{
    private unsigned long RefCount;
    private int FileDes;
    private const bool Readable;
    private const bool Writeable;
    public void SFileStream(class SFileStream & );
    public void SFileStream(int ,bool ,bool );
    public void ~SFileStream();
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public void * __vecDelDtor(unsigned int );
};

struct _IMAGE_RUNTIME_FUNCTION_ENTRY
{
    unsigned long BeginAddress;
    unsigned long EndAddress;
    unsigned long UnwindInfoAddress;
};

struct tagEMRSCALEVIEWPORTEXTEX
{
    struct tagEMR emr;
    long xNum;
    long xDenom;
    long yNum;
    long yDenom;
};

struct _FILE_IO_PRIORITY_HINT_INFO
{
    enum _PRIORITY_HINT PriorityHint;
};

struct tagREGISTERWORDA
{
    char * lpReading;
    char * lpWord;
};

class STimer
{
    private int hiresFreq;
    private int hiresStartTime;
    public void STimer();
    public void ~STimer();
    public unsigned int GetTickValue();
    public unsigned int GetTickValue24bit();
    public int GetHiresFreq();
    public int GetHiresTime();
    public void * __vecDelDtor(unsigned int );
};

struct _FILE_COMPRESSION_INFO
{
    union _LARGE_INTEGER CompressedFileSize;
    unsigned int CompressionFormat;
    unsigned int CompressionUnitShift;
    unsigned int ChunkShift;
    unsigned int ClusterShift;
    unsigned int Reserved[3];
};

struct tagPAINTSTRUCT
{
    struct HDC__ * hdc;
    int fErase;
    struct tagRECT rcPaint;
    int fRestore;
    int fIncUpdate;
    unsigned int rgbReserved[32];
};

struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE
{
    struct _ACE_HEADER Header;
    unsigned long Mask;
    unsigned long Flags;
    struct _GUID ObjectType;
    struct _GUID InheritedObjectType;
    unsigned long SidStart;
};

struct _RESOURCEMANAGER_BASIC_INFORMATION
{
    struct _GUID ResourceManagerId;
    unsigned long DescriptionLength;
    wchar_t Description[1];
};

struct _IO_COUNTERS
{
    unsigned int ReadOperationCount;
    unsigned int WriteOperationCount;
    unsigned int OtherOperationCount;
    unsigned int ReadTransferCount;
    unsigned int WriteTransferCount;
    unsigned int OtherTransferCount;
};

struct DISPLAYCONFIG_PATH_TARGET_INFO
{
    struct _LUID adapterId;
    unsigned int id;
    unsigned int modeInfoIdx;
    enum DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
    enum DISPLAYCONFIG_ROTATION rotation;
    enum DISPLAYCONFIG_SCALING scaling;
    struct DISPLAYCONFIG_RATIONAL refreshRate;
    enum DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    int targetAvailable;
    unsigned int statusFlags;
};

struct _MODEMSETTINGS
{
    unsigned long dwActualSize;
    unsigned long dwRequiredSize;
    unsigned long dwDevSpecificOffset;
    unsigned long dwDevSpecificSize;
    unsigned long dwCallSetupFailTimer;
    unsigned long dwInactivityTimeout;
    unsigned long dwSpeakerVolume;
    unsigned long dwSpeakerMode;
    unsigned long dwPreferredModemOptions;
    unsigned long dwNegotiatedModemOptions;
    unsigned long dwNegotiatedDCERate;
    unsigned int abVariablePortion[1];
};

struct SSearchPath
{
    struct SArchiveInfo Archive;
    char * Path;
};

class SDArray<SSearchPath>
{
    private int size;
    private int maxsize;
    public struct SSearchPath * array;
    public void SDArray<SSearchPath>(class SDArray<SSearchPath> & );
    public void SDArray<SSearchPath>();
    public void ~SDArray<SSearchPath>();
    public int Add(struct SSearchPath & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSearchPath & operator[](int );
    public void operator=(class SDArray<SSearchPath> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SSearchPath>
{
    private int size;
    private int maxsize;
    public struct SSearchPath * array;
    public void SDArray<SSearchPath>(class SDArray<SSearchPath> & );
    public void SDArray<SSearchPath>();
    public void ~SDArray<SSearchPath>();
    public int Add(struct SSearchPath & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSearchPath & operator[](int );
    public void operator=(class SDArray<SSearchPath> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct _TOKEN_DEFAULT_DACL
{
    struct _ACL * DefaultDacl;
};

struct HMIXEROBJ__
{
    int unused;
};

struct SPoint2
{
    float x;
    float y;
    void SPoint2(float ,float );
    void SPoint2();
    struct SPoint2 operator+(struct SVector2 & );
    struct SPoint2 & operator+=(struct SVector2 & );
    struct SVector2 operator-(struct SPoint2 & );
    struct SPoint2 operator-(struct SVector2 & );
    struct SPoint2 & operator-=(struct SVector2 & );
    float DistanceSqr(struct SPoint2 & );
    float Distance(struct SPoint2 & );
};

struct SVector2
{
    float x;
    float y;
    void SVector2(float ,float );
    void SVector2();
    struct SVector2 operator-(struct SVector2 & );
    struct SVector2 operator-();
    struct SVector2 operator+(struct SVector2 & );
    struct SVector2 operator*(float );
    struct SVector2 & operator+=(struct SVector2 & );
    struct SVector2 & operator-=(struct SVector2 & );
    struct SVector2 & operator*=(float );
    float LengthSqr();
    float Length();
    struct SVector2 & Normalize();
};

struct SPoint2
{
    float x;
    float y;
    void SPoint2(float ,float );
    void SPoint2();
    struct SPoint2 operator+(struct SVector2 & );
    struct SPoint2 & operator+=(struct SVector2 & );
    struct SVector2 operator-(struct SPoint2 & );
    struct SPoint2 operator-(struct SVector2 & );
    struct SPoint2 & operator-=(struct SVector2 & );
    float DistanceSqr(struct SPoint2 & );
    float Distance(struct SPoint2 & );
};

union _IMAGE_LINENUMBER::<unnamed-type-Type>
{
    unsigned long SymbolTableIndex;
    unsigned long VirtualAddress;
};

struct tagGLYPHSET
{
    unsigned long cbThis;
    unsigned long flAccel;
    unsigned long cGlyphsSupported;
    unsigned long cRanges;
    struct tagWCRANGE ranges[1];
};

struct HIMCC__
{
    int unused;
};

struct HMIXER__
{
    int unused;
};

struct midievent_tag
{
    unsigned long dwDeltaTime;
    unsigned long dwStreamID;
    unsigned long dwEvent;
    unsigned long dwParms[1];
};

struct _QUERY_SERVICE_CONFIGA
{
    unsigned long dwServiceType;
    unsigned long dwStartType;
    unsigned long dwErrorControl;
    char * lpBinaryPathName;
    char * lpLoadOrderGroup;
    unsigned long dwTagId;
    char * lpDependencies;
    char * lpServiceStartName;
    char * lpDisplayName;
};

struct HSPRITE__
{
    int unused;
};

struct _POINTL
{
    long x;
    long y;
};

struct tagTPMPARAMS
{
    unsigned int cbSize;
    struct tagRECT rcExclude;
};

struct tagEMRFORMAT
{
    unsigned long dSignature;
    unsigned long nVersion;
    unsigned long cbData;
    unsigned long offData;
};

struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
{
    struct DISPLAYCONFIG_DEVICE_INFO_HEADER header;
    unsigned int width;
    unsigned int height;
    struct DISPLAYCONFIG_TARGET_MODE targetMode;
};

struct HHOOK__
{
    int unused;
};

struct _SERVICE_PREFERRED_NODE_INFO
{
    unsigned int usPreferredNode;
    unsigned int fDelete;
};

union tagMIXERCONTROLA::<unnamed-type-Metrics>
{
    unsigned long cSteps;
    unsigned long cbCustomData;
    unsigned long dwReserved[6];
};

union tagMIXERCONTROLA::<unnamed-type-Bounds>
{
    long lMinimum;
    long lMaximum;
    unsigned long dwMinimum;
    unsigned long dwMaximum;
    unsigned long dwReserved[6];
};

struct _ACE_HEADER
{
    unsigned int AceType;
    unsigned int AceFlags;
    unsigned int AceSize;
};

struct _nlsversioninfo
{
    unsigned long dwNLSVersionInfoSize;
    unsigned long dwNLSVersion;
    unsigned long dwDefinedVersion;
};

class SArchiveStream : public SStream
{
    private unsigned long RefCount;
    private int FileDes;
    private int Pos;
    private int Size;
    private int Offset;
    public void SArchiveStream(class SArchiveStream & );
    public void SArchiveStream(int ,int ,int );
    public void ~SArchiveStream();
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public class SArchiveStream & operator=(class SArchiveStream & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SArchiveStream : public SStream
{
    private unsigned long RefCount;
    private int FileDes;
    private int Pos;
    private int Size;
    private int Offset;
    public void SArchiveStream(class SArchiveStream & );
    public void SArchiveStream(int ,int ,int );
    public void ~SArchiveStream();
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public class SArchiveStream & operator=(class SArchiveStream & );
    public void * __vecDelDtor(unsigned int );
};

struct _MMIOINFO
{
    unsigned long dwFlags;
    unsigned long fccIOProc;
    long  ( * pIOProc)(char * ,unsigned int ,long ,long );
    unsigned int wErrorRet;
    struct HTASK__ * htask;
    long cchBuffer;
    char * pchBuffer;
    char * pchNext;
    char * pchEndRead;
    char * pchEndWrite;
    long lBufOffset;
    long lDiskOffset;
    unsigned long adwInfo[3];
    unsigned long dwReserved1;
    unsigned long dwReserved2;
    struct HMMIO__ * hmmio;
};

struct _GRADIENT_RECT
{
    unsigned long UpperLeft;
    unsigned long LowerRight;
};

struct tagMCI_PLAY_PARMS
{
    unsigned long dwCallback;
    unsigned long dwFrom;
    unsigned long dwTo;
};

struct HMIDIOUT__
{
    int unused;
};

struct HDESK__
{
    int unused;
};

struct _ICONINFO
{
    int fIcon;
    unsigned long xHotspot;
    unsigned long yHotspot;
    struct HBITMAP__ * hbmMask;
    struct HBITMAP__ * hbmColor;
};

struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
{
    unsigned long ElementCount;
    struct _COMPATIBILITY_CONTEXT_ELEMENT Elements[0];
};

struct IMPORT_OBJECT_HEADER
{
    unsigned int Sig1;
    unsigned int Sig2;
    unsigned int Version;
    unsigned int Machine;
    unsigned long TimeDateStamp;
    unsigned long SizeOfData;
    unsigned int Ordinal;
    unsigned int Hint;
    unsigned int Type:2;
    unsigned int NameType:3;
    unsigned int Reserved:11;
};

struct _REPARSE_GUID_DATA_BUFFER::<unnamed-type-GenericReparseBuffer>
{
    unsigned int DataBuffer[1];
};

struct _TRANSACTION_LIST_INFORMATION
{
    unsigned long NumberOfTransactions;
    struct _TRANSACTION_LIST_ENTRY TransactionInformation[1];
};

struct _FILE_REMOTE_PROTOCOL_INFO
{
    unsigned int StructureVersion;
    unsigned int StructureSize;
    unsigned long Protocol;
    unsigned int ProtocolMajorVersion;
    unsigned int ProtocolMinorVersion;
    unsigned int ProtocolRevision;
    unsigned int Reserved;
    unsigned long Flags;
    struct <unnamed-type-GenericReserved>
    {
        unsigned long Reserved[8];
    };
    struct _FILE_REMOTE_PROTOCOL_INFO::<unnamed-type-GenericReserved> GenericReserved;
    struct <unnamed-type-ProtocolSpecificReserved>
    {
        unsigned long Reserved[16];
    };
    struct _FILE_REMOTE_PROTOCOL_INFO::<unnamed-type-ProtocolSpecificReserved> ProtocolSpecificReserved;
};

struct _FILE_REMOTE_PROTOCOL_INFO::<unnamed-type-ProtocolSpecificReserved>
{
    unsigned long Reserved[16];
};

struct _FILE_REMOTE_PROTOCOL_INFO::<unnamed-type-GenericReserved>
{
    unsigned long Reserved[8];
};

struct tagWAVEOUTCAPS2A
{
    unsigned int wMid;
    unsigned int wPid;
    unsigned int vDriverVersion;
    char szPname[32];
    unsigned long dwFormats;
    unsigned int wChannels;
    unsigned int wReserved1;
    unsigned long dwSupport;
    struct _GUID ManufacturerGuid;
    struct _GUID ProductGuid;
    struct _GUID NameGuid;
};

enum __vcrt_va_list_is_reference<wchar_t const * const>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<wchar_t const * const>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct $_s__RTTIBaseClassArray$_extraBytes_16
{
    struct _s__RTTIBaseClassDescriptor * arrayOfBaseClassDescriptors[4];
};

struct tagPANOSE
{
    unsigned int bFamilyType;
    unsigned int bSerifStyle;
    unsigned int bWeight;
    unsigned int bProportion;
    unsigned int bContrast;
    unsigned int bStrokeVariation;
    unsigned int bArmStyle;
    unsigned int bLetterform;
    unsigned int bMidline;
    unsigned int bXHeight;
};

union _WOW64_LDT_ENTRY::<unnamed-type-HighWord>
{
    struct <unnamed-type-Bytes>
    {
        unsigned int BaseMid;
        unsigned int Flags1;
        unsigned int Flags2;
        unsigned int BaseHi;
    };
    struct _WOW64_LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bytes> Bytes;
    struct <unnamed-type-Bits>
    {
        unsigned long BaseMid:8;
        unsigned long Type:5;
        unsigned long Dpl:2;
        unsigned long Pres:1;
        unsigned long LimitHi:4;
        unsigned long Sys:1;
        unsigned long Reserved_0:1;
        unsigned long Default_Big:1;
        unsigned long Granularity:1;
        unsigned long BaseHi:8;
    };
    struct _WOW64_LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bits> Bits;
};

struct _WOW64_LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bits>
{
    unsigned long BaseMid:8;
    unsigned long Type:5;
    unsigned long Dpl:2;
    unsigned long Pres:1;
    unsigned long LimitHi:4;
    unsigned long Sys:1;
    unsigned long Reserved_0:1;
    unsigned long Default_Big:1;
    unsigned long Granularity:1;
    unsigned long BaseHi:8;
};

struct _WOW64_LDT_ENTRY::<unnamed-type-HighWord>::<unnamed-type-Bytes>
{
    unsigned int BaseMid;
    unsigned int Flags1;
    unsigned int Flags2;
    unsigned int BaseHi;
};

struct tagTOGGLEKEYS
{
    unsigned int cbSize;
    unsigned long dwFlags;
};

enum __vcrt_va_list_is_reference<__crt_locale_pointers * const>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<__crt_locale_pointers * const>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct _CONSOLE_FONT_INFOEX
{
    unsigned long cbSize;
    unsigned long nFont;
    struct _COORD dwFontSize;
    unsigned int FontFamily;
    unsigned int FontWeight;
    wchar_t FaceName[32];
};

struct _SERVICE_REQUIRED_PRIVILEGES_INFOW
{
    wchar_t * pmszRequiredPrivileges;
};

struct __std_exception_data
{
    char * _What;
    bool _DoFree;
};

struct _stat64
{
    unsigned int st_dev;
    unsigned int st_ino;
    unsigned int st_mode;
    int st_nlink;
    int st_uid;
    int st_gid;
    unsigned int st_rdev;
    int st_size;
    int st_atime;
    int st_mtime;
    int st_ctime;
};

struct SVector2
{
    float x;
    float y;
    void SVector2(float ,float );
    void SVector2();
    struct SVector2 operator-(struct SVector2 & );
    struct SVector2 operator-();
    struct SVector2 operator+(struct SVector2 & );
    struct SVector2 operator*(float );
    struct SVector2 & operator+=(struct SVector2 & );
    struct SVector2 & operator-=(struct SVector2 & );
    struct SVector2 & operator*=(float );
    float LengthSqr();
    float Length();
    struct SVector2 & Normalize();
};

struct _TRANSACTION_ENLISTMENT_PAIR
{
    struct _GUID EnlistmentId;
    struct _GUID ResourceManagerId;
};

struct tagMENUINFO
{
    unsigned long cbSize;
    unsigned long fMask;
    unsigned long dwStyle;
    unsigned int cyMax;
    struct HBRUSH__ * hbrBack;
    unsigned long dwContextHelpID;
    unsigned long dwMenuData;
};

struct _stat32
{
    unsigned int st_dev;
    unsigned int st_ino;
    unsigned int st_mode;
    int st_nlink;
    int st_uid;
    int st_gid;
    unsigned int st_rdev;
    long st_size;
    long st_atime;
    long st_mtime;
    long st_ctime;
};

struct _PSINJECTDATA
{
    unsigned long DataBytes;
    unsigned int InjectionPoint;
    unsigned int PageNumber;
};

struct _TOKEN_AUDIT_POLICY
{
    unsigned int PerUserPolicy[27];
};

struct _MEMORYSTATUS
{
    unsigned long dwLength;
    unsigned long dwMemoryLoad;
    unsigned long dwTotalPhys;
    unsigned long dwAvailPhys;
    unsigned long dwTotalPageFile;
    unsigned long dwAvailPageFile;
    unsigned long dwTotalVirtual;
    unsigned long dwAvailVirtual;
};

struct IMAGE_COR20_HEADER
{
    unsigned long cb;
    unsigned int MajorRuntimeVersion;
    unsigned int MinorRuntimeVersion;
    struct _IMAGE_DATA_DIRECTORY MetaData;
    unsigned long Flags;
    unsigned long EntryPointToken;
    unsigned long EntryPointRVA;
    struct _IMAGE_DATA_DIRECTORY Resources;
    struct _IMAGE_DATA_DIRECTORY StrongNameSignature;
    struct _IMAGE_DATA_DIRECTORY CodeManagerTable;
    struct _IMAGE_DATA_DIRECTORY VTableFixups;
    struct _IMAGE_DATA_DIRECTORY ExportAddressTableJumps;
    struct _IMAGE_DATA_DIRECTORY ManagedNativeHeader;
};

struct HMIDISTRM__
{
    int unused;
};

struct _SERVICE_PRESHUTDOWN_INFO
{
    unsigned long dwPreshutdownTimeout;
};

struct SMatrix4
{
    float m00;
    float m01;
    float m02;
    float m03;
    float m10;
    float m11;
    float m12;
    float m13;
    float m20;
    float m21;
    float m22;
    float m23;
    float m30;
    float m31;
    float m32;
    float m33;
    float m[4][4];
    void SMatrix4(struct STransform & );
    void SMatrix4();
    struct SMatrix4 Rotation(struct SQuaternion & );
    struct SMatrix4 Translation(struct SPoint3 & );
    struct SMatrix4 Scaling(float );
    struct SMatrix4 PerspectiveFov(float ,float ,float ,float );
    struct SMatrix4 Orthogonal(float ,float ,float );
    float Determinant();
    struct SMatrix4 Inverse();
    struct SMatrix4 & operator*=(struct SMatrix4 & );
    struct SMatrix4 operator*(struct SMatrix4 & );
    struct SPoint3 TransformPoint(struct SPoint3 & );
    struct SVector3 TransformVector(struct SVector3 & );
    struct SPlane TransformPlaneBack(struct SPlane & );
    struct SMatrix4 & Orthonormalize();
    struct SQuaternion GetRotation();
    struct SPoint3 GetTranslation();
    void SetRotation(struct SQuaternion & );
    void SetRotationAndScale(struct SQuaternion & ,float );
    void SetTranslation(struct SPoint3 & );
    void SetLastColumn();
    void SetIdentity();
};

struct SMatrix4
{
    float m00;
    float m01;
    float m02;
    float m03;
    float m10;
    float m11;
    float m12;
    float m13;
    float m20;
    float m21;
    float m22;
    float m23;
    float m30;
    float m31;
    float m32;
    float m33;
    float m[4][4];
    void SMatrix4(struct STransform & );
    void SMatrix4();
    struct SMatrix4 Rotation(struct SQuaternion & );
    struct SMatrix4 Translation(struct SPoint3 & );
    struct SMatrix4 Scaling(float );
    struct SMatrix4 PerspectiveFov(float ,float ,float ,float );
    struct SMatrix4 Orthogonal(float ,float ,float );
    float Determinant();
    struct SMatrix4 Inverse();
    struct SMatrix4 & operator*=(struct SMatrix4 & );
    struct SMatrix4 operator*(struct SMatrix4 & );
    struct SPoint3 TransformPoint(struct SPoint3 & );
    struct SVector3 TransformVector(struct SVector3 & );
    struct SPlane TransformPlaneBack(struct SPlane & );
    struct SMatrix4 & Orthonormalize();
    struct SQuaternion GetRotation();
    struct SPoint3 GetTranslation();
    void SetRotation(struct SQuaternion & );
    void SetRotationAndScale(struct SQuaternion & ,float );
    void SetTranslation(struct SPoint3 & );
    void SetLastColumn();
    void SetIdentity();
};

struct _currencyfmtW
{
    unsigned int NumDigits;
    unsigned int LeadingZero;
    unsigned int Grouping;
    wchar_t * lpDecimalSep;
    wchar_t * lpThousandSep;
    unsigned int NegativeOrder;
    unsigned int PositiveOrder;
    wchar_t * lpCurrencySymbol;
};

struct _Real_widened<double,double>
{
};

struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION
{
    unsigned long dwFlags;
    unsigned long ulFormatVersion;
    unsigned long ulAssemblyCount;
    unsigned long ulRootManifestPathType;
    unsigned long ulRootManifestPathChars;
    unsigned long ulRootConfigurationPathType;
    unsigned long ulRootConfigurationPathChars;
    unsigned long ulAppDirPathType;
    unsigned long ulAppDirPathChars;
    wchar_t * lpRootManifestPath;
    wchar_t * lpRootConfigurationPath;
    wchar_t * lpAppDirPath;
};

struct HWND__
{
    int unused;
};

enum <unnamed-enum-BM_LITE_OBJECT>
{
    BM_LITE_OBJECT=1,
    BM_MEDIUM_OBJECT=2,
    BM_STRONG_OBJECT=4,
    BM_OTHER_UNIT=8,
    BM_TRANSPORT_TARGET=16,
    BM_WATER=32,
    BM_EDGE=64,
    BM_TERRAIN=128
};

enum SAnimType
{
    AT_NONE=0,
    AT_NORMAL=1,
    AT_SAD=2,
    AT_LAUGH=3,
    AT_DEATH=4,
    AT_SPEC=5,
    AT_TRIGGER=6
};

enum <unnamed-enum-EVENT_SELECT>
{
    EVENT_SELECT=0,
    EVENT_SELECT_BADMOOD=1,
    EVENT_COMMAND=2,
    EVENT_COMMAND_MOVE=3,
    EVENT_COMMAND_ATTACK=4,
    EVENT_COMMAND_ATTACK_GROUND=5,
    EVENT_COMMAND_BADMOOD=6,
    EVENT_TYPE_ACKNOLEDGEMENT=7,
    EVENT_ARTILLERY_SETTLE=8,
    EVENT_ARTILLERY_MOBILIZE=9,
    EVENT_TANK_BURROW=10,
    EVENT_TANK_UNBURROW=11,
    EVENT_MORTAR_CLOSE=12,
    EVENT_MORTAR_OPEN=13,
    EVENT_LOAD_FIVE=14,
    EVENT_LOAD_ONE=15,
    EVENT_OUT_OF_AMMO=16,
    EVENT_OUT_OF_FUEL=17,
    EVENT_COMMANDER_AIRSTRIKE=18,
    EVENT_LAY_MINE=19,
    EVENT_TRACTOR_ATTACH=20,
    EVENT_TRACTOR_DETACH=21,
    EVENT_SCOUT_INTO_WATER=22,
    EVENT_SCOUT_OUT_OF_WATER=23,
    EVENT_HARDTANK_AGRESSIVE_ON=24,
    EVENT_HARDTANK_AGRESSIVE_OFF=25,
    EVENT_MOVINGFORCE=26,
    EVENT_SEE_SAME_RACE=27,
    EVENT_SEE_OTHER_RACE=28,
    EVENT_HIT_CANT_SEE_ENEMY=29,
    EVENT_DIMINISHING_AMMO=30,
    EVENT_DIMINISHING_FUEL=31,
    EVENT_STUCKED=32,
    EVENT_CANT_ATTACK_TARGET=33,
    EVENT_LOW_HP=34,
    EVENT_GO_WRECK=35,
    EVENT_AIR_UNIT_ARRIVE=36,
    EVENT_HELICOPTER_START=37,
    EVENT_HELICOPTER_PUT=38,
    EVENT_TYPE_BROADCAST=39,
    EVENT_ATTACK=40,
    EVENT_ATTACK_OTHER_RACE=41,
    EVENT_KILL=42,
    EVENT_KILL_OTHER_RACE=43,
    EVENT_DEATH=44,
    EVENT_DROP_BOMB=45,
    MAX_EVENTS=46
};

class SGameWorld : public SWorld
{
    private class SProperties * TutorialIniLocale;
    public void SGameWorld(class SGameWorld & );
    public void SGameWorld(int ,int ,int );
    public void ~SGameWorld();
    public class SChain<SGenInfo> GeneratedUnits[200];
    public int NumGeneratedUnits;
    public void DeGenerateUnitsToStaticBlockMap(class SUnit * ,bool );
    public bool Rain;
    public int NumGenerates;
    public int NumDeGenerates;
    public void GenAnyHeliFustIfExists();
    private int UpgradePictureGlyphs[9];
    private void PlaceUnits(int ,class SDArray<SUnitDescription> & );
    public int CreateUnit(int ,char * ,float ,float ,float ,int * ,int ,float ,bool ,int );
    public void RemoveUnit(int );
    public int SelectUnit(float ,float ,int );
    public void GetPanelStatus(struct SPanelStatus & );
    public bool HasOnlyMortarFightingUnits;
    protected class SHeap<SProjectile *> Projectiles;
    public class SProjectile * SpawnProjectile(int ,int );
    public void RemoveProjectile(int );
    private void SaveTriggerState(class SStream * );
    private void LoadTriggerState(class SStream * );
    private bool TestLocation(int ,int );
    private bool TestDoodadLocation(int ,int );
    private bool TestLakeLocation(int ,int );
    private bool TestUnit(int ,int ,char * );
    private bool TestPlayer(int ,int ,int );
    private void TestTriggers();
    private struct SUnitGroup CollectUnitGroupForTrigger(class STriggerAction * ,int );
    private bool TriggerSwitches[256];
    private struct SExecutingTrigger ExecutingTriggers[8];
    public void SetSwitchState(int ,bool );
    private struct SUnitGroup GetUnitGroup(class SStreamBuffer * );
    private bool CheckUnitGroupDestination(struct SUnitGroup & ,float ,float );
    private void SendUnitGroupKeepingFormation(struct SUnitGroup & ,float ,float );
    private void SendUnitGroupCompressed(enum SUnitCommandType ,struct SUnitGroup & ,float ,float ,bool );
    private int ServerMode;
    private int ServerFrameCount;
    private int ServerPauseCount;
    private int ServerCountdown;
    private int ServerCountdownVisible;
    private int ServerPaused;
    private class SStreamBuffer * SendQCurrent;
    private class SStreamBuffer * SendQPrevious;
    private unsigned long CRCBuffer[256];
    private class SMulti * Multi;
    private const int ServerMultiPacketBuffer=255;
    private int ServerMultiPacketExecutedCount;
    private int ServerMultiPacketSentCount;
    private int ServerMultiPacketCompressionRatio;
    private int ServerMultiPacketShouldBeExecutedTill[256];
    private int ServerMultiPacketTimeToSend;
    private int ServerMultiPacketSentTime;
    private int PlaySpeed;
    private void QSelection();
    private void ProcessPacket(int ,class SStreamBuffer * );
    public void ServerInit(class SMulti * ,bool );
    public void ServerShutdown();
    public int GetCurrentSPForGameViewPanel();
    public bool ControllingPlayerHasMoneyFor(int );
    public bool TryToBuy(int ,int );
    public void GainMoney(int ,int );
    public void BackupCampaignUnits();
    public void LatencyChanged();
    public bool IsMapRunningForAnyPlayer();
    public bool HasMissingDataFromPlayer(int );
    public bool ServerRefresh();
    public void GetServerTime(int & ,int & );
    public void ClientRefresh(float );
    public void QPlaceCampaignUnits();
    public void QMoveToPoint(float ,float ,bool );
    public void QFollow(int ,bool );
    public void QStop(bool );
    public void QChase(bool );
    public void QRetreat(bool );
    public void QAttackGround(float ,float ,bool );
    public void QAttack(int ,bool );
    public void QAttackDoodad(int ,bool );
    public void QHoldFire(bool );
    public void QReturnFire(bool );
    public void QFireAtWill(bool );
    public void QSpecTargetGround(float ,float ,bool );
    public void QSpecTargetUnit(int ,bool );
    public void QSpecAction(bool );
    public void QBuyUnit(float ,float ,struct SUnitDescription & );
    public void QAddLatency(int );
    public void QAddPacketCompressionRatio(int );
    public bool CanSendHeliForControllingPlayer();
    public void HeliTransport(float ,float ,int ,struct SUnitDescription & ,bool );
    public void AirStrike(float ,float ,int ,int );
    public void StartZeppelin(float ,float ,int );
    public void BoostXP(float );
    public void AdvanceLevel();
    public float DamageMultiplier;
    public float RepairMultiplier;
    public float SpeedMultiplier;
    public bool InvulnerablePlayer;
    public bool UnlimitedAmmo;
    public bool UnlimitedFuel;
    public bool InstantDelivery;
    public int GetPlaySpeed();
    public void SetPlaySpeed(int );
    public int GetServerFrameTime();
    public void LoadGame(class SStream * );
    public void SaveGame(class SStream * );
    protected int PanelBackgroundFrame;
    protected int MessageFrames[5];
    protected int NumMessages;
    protected int MessageCounter;
    protected int EventRandomCounter;
    protected int EventBroadcastRandomCounter;
    protected struct SEventMap EventMap[46][2];
    protected struct SEventFlags EventFlags[46];
    protected int EventTextFrames[3];
    protected int EventAnimFrames[3];
    protected enum SEventPriority CurrentEventPriority;
    protected unsigned long CurrentEventEndTime;
    protected int ClickTargetTextures[9];
    protected int ClickTargetTime;
    protected struct SShader2Info * ClickTargetShader;
    protected void RefreshEventInterface();
    protected void SetEventMap(int ,int ,int ,int ,int ,int );
    protected void SetEventFlags(int ,bool ,enum SAnimType );
    public void InitEventInterface(int * ,int * );
    public void ShutdownEventInterface();
    public void Echo(char * ,<btNoType> );
    public void EchoColor(char * ,unsigned long );
    public void Echo2(bool ,char * ,<btNoType> );
    public void ShowEvent(int ,int );
    public float ShowEventMsg(int ,int ,enum SAnimType ,bool ,bool ,int ,enum SEventPriority );
    public void ShowClickTarget(float ,float ,float ,float ,float );
    protected int VisXSize;
    protected int VisZSize;
    protected float * VisHeightMap;
    protected unsigned int * VisMap[8];
    protected unsigned int * VisMapDet[8];
    protected int FogOfWarMode;
    protected unsigned int * BlockMap[5];
    protected unsigned int * CurrentBlockMap;
    protected int BlockMapSize;
    protected int BlockMapWidth;
    protected int BlockMapHeight;
    public void FixBridges();
    public void CreateVisMap();
    public void RemoveVisMap();
    public void DrawVisMapAid(int ,int ,int ,int ,int );
    public void DrawVisMapDetAid(int ,int ,int ,int ,int );
    public void DrawVisMap(int );
    public bool CanSeeGroundUnit(int ,class SUnit * );
    public int GetFogOfWarMode();
    public void SetFogOfWarMode(int );
    public int GetControllingPlayer();
    public void SetControllingPlayer(int );
    public bool GetGodMode();
    public void SetGodMode(bool );
    public void CreateBlockMap();
    public void RemoveBlockMap();
    public bool IsBlocked(float ,float );
    public class SUnit * GetUnit(class SUnit * ,int );
    public int GetUnitAlignment(int );
    public int SearchTarget(class SUnit * ,bool );
    public int SearchPlayerForAcquireResource(class SUnit * );
    public int SearchPlayerForAcquireRescuable(class SUnit * );
    public void CollectUnits(class SUnit * );
    public bool HasAliveStarterUnit();
    public void GenerateUnitsToStaticBlockMap(class SUnit * ,bool );
    public int CheckProjectileCollision(int ,float ,float ,float );
    public bool CheckProjectileSingleUnitCollision(int ,float ,float ,float );
    public void RadiusDamage(float ,int ,int ,float ,float ,float ,float ,int ,int );
    public void RemoveDoodadSounds(int );
    public void ExplodeDoodad(int );
    public void RemoveDoodadFromGame(int );
    public void RegenerateDoodadBlockMap();
    public void SetDoodadVisMap(int );
    public void ClearDoodadVisMap(int );
    public float KillCollidingDoodads(float ,float ,int );
    public void IncreaseUnitXP(int ,int ,float );
    public void IncreasePlayerScore(int ,int ,float );
    public void IncrementUnitKills(int ,int ,int );
    public void ReachedHugeXP();
    public void WhiteFlag(int );
    public int GetDoodadStatus(int );
    private bool TestPathLine(float ,float ,float ,float );
    private bool TestPathLine2(class SUnit * ,float ,float ,float ,float ,int );
    private class SStack<SWaypoint> * FindPath(class SUnit * ,float ,float );
    private class SVector GetVec(float ,float );
    private float CsuszasCsokkenes;
    private void MarkStaticBlockMap(float ,float ,int ,int ,unsigned int );
    private int CheckStaticBlockMap(float ,float ,int ,unsigned int );
    private void MarkCurrentBlockMap(float ,float ,int ,int );
    private int CheckCurrentBlockMap(float ,float ,int );
    private void FindEmptySpace(float & ,float & ,int ,unsigned int );
    private bool FindEmptySpaceInADir8(float & ,float & ,int ,int ,unsigned int );
    private void FindEmptySpaceInBestDir(class SUnit * ,float & ,float & );
    private int LoadingPicturesFont;
    private int LoadingLeftframe;
    private int LoadingRightframe;
    private int LoadingIcon1;
    private int LoadingIcon2;
    private int LoadingIcon3;
    private int LoadingIcon4;
    public void ShowLoadingPictures(int );
    public void CleanLoadingPictures();
    public bool IsBomberAvailable();
    public int LoadingBackFrame;
    public class SString strTutorialText;
    protected bool IsMinimapInitialized;
    protected float MinimapRotation;
    protected float MinimapTargetRotation;
    protected const float MinimapRotationThreshold;
    protected const float MinimapRotationSpeed;
    protected int MinimapFrame;
    public float GetMinimapRotation();
    public void SetMinimapRotation(float );
    public void PercentToTile(float & ,float & );
    protected int RandomSeed;
    public void SeedRandom(int );
    public int Random(int );
    public float Random(float );
    public int Random();
    public void * __vecDelDtor(unsigned int );
};

enum SEventPriority
{
    None=0,
    Acknoledgement=1,
    Normal=2,
    Broadcast=3,
    Trigger=4
};

class SGameWorld : public SWorld
{
    private class SProperties * TutorialIniLocale;
    public void SGameWorld(class SGameWorld & );
    public void SGameWorld(int ,int ,int );
    public void ~SGameWorld();
    public class SChain<SGenInfo> GeneratedUnits[200];
    public int NumGeneratedUnits;
    public void DeGenerateUnitsToStaticBlockMap(class SUnit * ,bool );
    public bool Rain;
    public int NumGenerates;
    public int NumDeGenerates;
    public void GenAnyHeliFustIfExists();
    private int UpgradePictureGlyphs[9];
    private void PlaceUnits(int ,class SDArray<SUnitDescription> & );
    public int CreateUnit(int ,char * ,float ,float ,float ,int * ,int ,float ,bool ,int );
    public void RemoveUnit(int );
    public int SelectUnit(float ,float ,int );
    public void GetPanelStatus(struct SPanelStatus & );
    public bool HasOnlyMortarFightingUnits;
    protected class SHeap<SProjectile *> Projectiles;
    public class SProjectile * SpawnProjectile(int ,int );
    public void RemoveProjectile(int );
    private void SaveTriggerState(class SStream * );
    private void LoadTriggerState(class SStream * );
    private bool TestLocation(int ,int );
    private bool TestDoodadLocation(int ,int );
    private bool TestLakeLocation(int ,int );
    private bool TestUnit(int ,int ,char * );
    private bool TestPlayer(int ,int ,int );
    private void TestTriggers();
    private struct SUnitGroup CollectUnitGroupForTrigger(class STriggerAction * ,int );
    private bool TriggerSwitches[256];
    private struct SExecutingTrigger ExecutingTriggers[8];
    public void SetSwitchState(int ,bool );
    private struct SUnitGroup GetUnitGroup(class SStreamBuffer * );
    private bool CheckUnitGroupDestination(struct SUnitGroup & ,float ,float );
    private void SendUnitGroupKeepingFormation(struct SUnitGroup & ,float ,float );
    private void SendUnitGroupCompressed(enum SUnitCommandType ,struct SUnitGroup & ,float ,float ,bool );
    private int ServerMode;
    private int ServerFrameCount;
    private int ServerPauseCount;
    private int ServerCountdown;
    private int ServerCountdownVisible;
    private int ServerPaused;
    private class SStreamBuffer * SendQCurrent;
    private class SStreamBuffer * SendQPrevious;
    private unsigned long CRCBuffer[256];
    private class SMulti * Multi;
    private const int ServerMultiPacketBuffer=255;
    private int ServerMultiPacketExecutedCount;
    private int ServerMultiPacketSentCount;
    private int ServerMultiPacketCompressionRatio;
    private int ServerMultiPacketShouldBeExecutedTill[256];
    private int ServerMultiPacketTimeToSend;
    private int ServerMultiPacketSentTime;
    private int PlaySpeed;
    private void QSelection();
    private void ProcessPacket(int ,class SStreamBuffer * );
    public void ServerInit(class SMulti * ,bool );
    public void ServerShutdown();
    public int GetCurrentSPForGameViewPanel();
    public bool ControllingPlayerHasMoneyFor(int );
    public bool TryToBuy(int ,int );
    public void GainMoney(int ,int );
    public void BackupCampaignUnits();
    public void LatencyChanged();
    public bool IsMapRunningForAnyPlayer();
    public bool HasMissingDataFromPlayer(int );
    public bool ServerRefresh();
    public void GetServerTime(int & ,int & );
    public void ClientRefresh(float );
    public void QPlaceCampaignUnits();
    public void QMoveToPoint(float ,float ,bool );
    public void QFollow(int ,bool );
    public void QStop(bool );
    public void QChase(bool );
    public void QRetreat(bool );
    public void QAttackGround(float ,float ,bool );
    public void QAttack(int ,bool );
    public void QAttackDoodad(int ,bool );
    public void QHoldFire(bool );
    public void QReturnFire(bool );
    public void QFireAtWill(bool );
    public void QSpecTargetGround(float ,float ,bool );
    public void QSpecTargetUnit(int ,bool );
    public void QSpecAction(bool );
    public void QBuyUnit(float ,float ,struct SUnitDescription & );
    public void QAddLatency(int );
    public void QAddPacketCompressionRatio(int );
    public bool CanSendHeliForControllingPlayer();
    public void HeliTransport(float ,float ,int ,struct SUnitDescription & ,bool );
    public void AirStrike(float ,float ,int ,int );
    public void StartZeppelin(float ,float ,int );
    public void BoostXP(float );
    public void AdvanceLevel();
    public float DamageMultiplier;
    public float RepairMultiplier;
    public float SpeedMultiplier;
    public bool InvulnerablePlayer;
    public bool UnlimitedAmmo;
    public bool UnlimitedFuel;
    public bool InstantDelivery;
    public int GetPlaySpeed();
    public void SetPlaySpeed(int );
    public int GetServerFrameTime();
    public void LoadGame(class SStream * );
    public void SaveGame(class SStream * );
    protected int PanelBackgroundFrame;
    protected int MessageFrames[5];
    protected int NumMessages;
    protected int MessageCounter;
    protected int EventRandomCounter;
    protected int EventBroadcastRandomCounter;
    protected struct SEventMap EventMap[46][2];
    protected struct SEventFlags EventFlags[46];
    protected int EventTextFrames[3];
    protected int EventAnimFrames[3];
    protected enum SEventPriority CurrentEventPriority;
    protected unsigned long CurrentEventEndTime;
    protected int ClickTargetTextures[9];
    protected int ClickTargetTime;
    protected struct SShader2Info * ClickTargetShader;
    protected void RefreshEventInterface();
    protected void SetEventMap(int ,int ,int ,int ,int ,int );
    protected void SetEventFlags(int ,bool ,enum SAnimType );
    public void InitEventInterface(int * ,int * );
    public void ShutdownEventInterface();
    public void Echo(char * ,<btNoType> );
    public void EchoColor(char * ,unsigned long );
    public void Echo2(bool ,char * ,<btNoType> );
    public void ShowEvent(int ,int );
    public float ShowEventMsg(int ,int ,enum SAnimType ,bool ,bool ,int ,enum SEventPriority );
    public void ShowClickTarget(float ,float ,float ,float ,float );
    protected int VisXSize;
    protected int VisZSize;
    protected float * VisHeightMap;
    protected unsigned int * VisMap[8];
    protected unsigned int * VisMapDet[8];
    protected int FogOfWarMode;
    protected unsigned int * BlockMap[5];
    protected unsigned int * CurrentBlockMap;
    protected int BlockMapSize;
    protected int BlockMapWidth;
    protected int BlockMapHeight;
    public void FixBridges();
    public void CreateVisMap();
    public void RemoveVisMap();
    public void DrawVisMapAid(int ,int ,int ,int ,int );
    public void DrawVisMapDetAid(int ,int ,int ,int ,int );
    public void DrawVisMap(int );
    public bool CanSeeGroundUnit(int ,class SUnit * );
    public int GetFogOfWarMode();
    public void SetFogOfWarMode(int );
    public int GetControllingPlayer();
    public void SetControllingPlayer(int );
    public bool GetGodMode();
    public void SetGodMode(bool );
    public void CreateBlockMap();
    public void RemoveBlockMap();
    public bool IsBlocked(float ,float );
    public class SUnit * GetUnit(class SUnit * ,int );
    public int GetUnitAlignment(int );
    public int SearchTarget(class SUnit * ,bool );
    public int SearchPlayerForAcquireResource(class SUnit * );
    public int SearchPlayerForAcquireRescuable(class SUnit * );
    public void CollectUnits(class SUnit * );
    public bool HasAliveStarterUnit();
    public void GenerateUnitsToStaticBlockMap(class SUnit * ,bool );
    public int CheckProjectileCollision(int ,float ,float ,float );
    public bool CheckProjectileSingleUnitCollision(int ,float ,float ,float );
    public void RadiusDamage(float ,int ,int ,float ,float ,float ,float ,int ,int );
    public void RemoveDoodadSounds(int );
    public void ExplodeDoodad(int );
    public void RemoveDoodadFromGame(int );
    public void RegenerateDoodadBlockMap();
    public void SetDoodadVisMap(int );
    public void ClearDoodadVisMap(int );
    public float KillCollidingDoodads(float ,float ,int );
    public void IncreaseUnitXP(int ,int ,float );
    public void IncreasePlayerScore(int ,int ,float );
    public void IncrementUnitKills(int ,int ,int );
    public void ReachedHugeXP();
    public void WhiteFlag(int );
    public int GetDoodadStatus(int );
    private bool TestPathLine(float ,float ,float ,float );
    private bool TestPathLine2(class SUnit * ,float ,float ,float ,float ,int );
    private class SStack<SWaypoint> * FindPath(class SUnit * ,float ,float );
    private class SVector GetVec(float ,float );
    private float CsuszasCsokkenes;
    private void MarkStaticBlockMap(float ,float ,int ,int ,unsigned int );
    private int CheckStaticBlockMap(float ,float ,int ,unsigned int );
    private void MarkCurrentBlockMap(float ,float ,int ,int );
    private int CheckCurrentBlockMap(float ,float ,int );
    private void FindEmptySpace(float & ,float & ,int ,unsigned int );
    private bool FindEmptySpaceInADir8(float & ,float & ,int ,int ,unsigned int );
    private void FindEmptySpaceInBestDir(class SUnit * ,float & ,float & );
    private int LoadingPicturesFont;
    private int LoadingLeftframe;
    private int LoadingRightframe;
    private int LoadingIcon1;
    private int LoadingIcon2;
    private int LoadingIcon3;
    private int LoadingIcon4;
    public void ShowLoadingPictures(int );
    public void CleanLoadingPictures();
    public bool IsBomberAvailable();
    public int LoadingBackFrame;
    public class SString strTutorialText;
    protected bool IsMinimapInitialized;
    protected float MinimapRotation;
    protected float MinimapTargetRotation;
    protected const float MinimapRotationThreshold;
    protected const float MinimapRotationSpeed;
    protected int MinimapFrame;
    public float GetMinimapRotation();
    public void SetMinimapRotation(float );
    public void PercentToTile(float & ,float & );
    protected int RandomSeed;
    public void SeedRandom(int );
    public int Random(int );
    public float Random(float );
    public int Random();
    public void * __vecDelDtor(unsigned int );
};

struct SGenInfo
{
    struct SGenInfo * next;
    struct SGenInfo * prev;
    float x;
    float z;
    int unitsize;
};

class SChain<SGenInfo>
{
    private struct SGenInfo * first;
    private struct SGenInfo * last;
    private struct SGenInfo * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SGenInfo>();
    public void ~SChain<SGenInfo>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SGenInfo * StepToFirst();
    public struct SGenInfo * StepToLast();
    public struct SGenInfo * GetNext();
    public struct SGenInfo * GetNext2();
    public struct SGenInfo * GetPrev();
    public struct SGenInfo * GetCurrent();
    public struct SGenInfo * StepToNext();
    public struct SGenInfo * StepToPrev();
    public struct SGenInfo * Append(struct SGenInfo * ,bool );
    public struct SGenInfo * AppendNew(bool );
    public struct SGenInfo * GetFirst();
    public struct SGenInfo * GetSecond();
    public struct SGenInfo * GetThird();
    public struct SGenInfo * GetLastButOne();
    public struct SGenInfo * GetLast();
    public struct SGenInfo * InsertOver(struct SGenInfo * ,bool );
    public struct SGenInfo * InsertOverNew(bool );
    public struct SGenInfo * InsertUnder(struct SGenInfo * ,bool );
    public struct SGenInfo * InsertUnderNew(bool );
    public void Delete(struct SGenInfo * );
    public void Delete();
    public void DeleteAll();
    public struct SGenInfo * GetPointer(int );
    public struct SGenInfo * StepToIndex(int );
    public struct SGenInfo & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SGenInfo * );
    public void StepToPointer(struct SGenInfo * );
    public void SendToBack(struct SGenInfo * );
    public void BringToFront(struct SGenInfo * );
    public void Swap(struct SGenInfo * ,struct SGenInfo * );
    public void * __vecDelDtor(unsigned int );
};

struct SPanelStatus
{
    bool EnemyUnit;
    int DriverPresent;
    int Move;
    int Stop;
    int Chase;
    int Retreat;
    int GunnerPresent;
    int Attack;
    int FireAtWill;
    int ReturnFire;
    int HoldFire;
    int SpecialType;
    int SpecialPressed;
    int SingleSelected;
    int SingleUnit;
    float MaxHP;
    float HP;
    float MaxFuel;
    float Fuel;
    float MaxAmmo;
    float Ammo;
    float MaxCargo;
    float Cargo;
    class SString Name;
    int Level;
    float XP;
    float NextXP;
    bool MovingForce;
    bool TowingVehicle;
    int Upgrades[3];
    void SPanelStatus(struct SPanelStatus * );
    void SPanelStatus(struct SPanelStatus & );
    void SPanelStatus();
    void ~SPanelStatus();
    struct SPanelStatus & operator=(struct SPanelStatus * );
    struct SPanelStatus & operator=(struct SPanelStatus & );
    void * __vecDelDtor(unsigned int );
};

struct SPanelStatus
{
    bool EnemyUnit;
    int DriverPresent;
    int Move;
    int Stop;
    int Chase;
    int Retreat;
    int GunnerPresent;
    int Attack;
    int FireAtWill;
    int ReturnFire;
    int HoldFire;
    int SpecialType;
    int SpecialPressed;
    int SingleSelected;
    int SingleUnit;
    float MaxHP;
    float HP;
    float MaxFuel;
    float Fuel;
    float MaxAmmo;
    float Ammo;
    float MaxCargo;
    float Cargo;
    class SString Name;
    int Level;
    float XP;
    float NextXP;
    bool MovingForce;
    bool TowingVehicle;
    int Upgrades[3];
    void SPanelStatus(struct SPanelStatus * );
    void SPanelStatus(struct SPanelStatus & );
    void SPanelStatus();
    void ~SPanelStatus();
    struct SPanelStatus & operator=(struct SPanelStatus * );
    struct SPanelStatus & operator=(struct SPanelStatus & );
    void * __vecDelDtor(unsigned int );
};

class SHeap<SProjectile *>
{
    struct __Tstruct
    {
        int use;
        class SProjectile * data;
    };
    private struct SHeap<SProjectile *>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SProjectile *>();
    public void ~SHeap<SProjectile *>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public class SProjectile &** operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SProjectile *>
{
    struct __Tstruct
    {
        int use;
        class SProjectile * data;
    };
    private struct SHeap<SProjectile *>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SProjectile *>();
    public void ~SHeap<SProjectile *>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public class SProjectile &** operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SProjectile
{
    private class SGameWorld * World;
    private int WorldIdx;
    private char * ClassName;
    private float X;
    private float Y;
    private float Z;
    private float LastX;
    private float LastY;
    private float LastZ;
    private class SIObject * Object;
    private int OwnerUnit;
    private int InflictorUnit;
    private int TargetUnit;
    private float ShotSpeed;
    private int SmokeIdx;
    private int SmokeTexture;
    private bool KellLokeshullam;
    private float SpeedX;
    private float SpeedY;
    private float SpeedZ;
    private float Gravity;
    private float Damage;
    private float DamageRadius;
    private int AddAmmo;
    private int AddFuel;
    private int AddHP;
    private int ExplodeSound;
    private void InitFX();
    public void SProjectile(class SGameWorld * ,int ,int ,int );
    public void ~SProjectile();
    public void Create(char * ,class SVector & ,class SVector & ,bool ,float );
    public void CreateTargeted(char * ,class SVector & ,class SVector & ,float ,float ,bool ,float );
    public void CreateLocked(char * ,class SVector & ,int ,float ,float ,float );
    public void ServerRefresh();
    public void ClientRefresh(float );
    public void * __vecDelDtor(unsigned int );
};

struct SUnitGroupUnit
{
    bool AlreadySent;
    class SUnit * Unit;
};

struct SUnitGroupUnit
{
    bool AlreadySent;
    class SUnit * Unit;
};

class SDArray<SUnitGroupUnit>
{
    private int size;
    private int maxsize;
    public struct SUnitGroupUnit * array;
    public void SDArray<SUnitGroupUnit>(class SDArray<SUnitGroupUnit> & );
    public void SDArray<SUnitGroupUnit>();
    public void ~SDArray<SUnitGroupUnit>();
    public int Add(struct SUnitGroupUnit & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SUnitGroupUnit & operator[](int );
    public void operator=(class SDArray<SUnitGroupUnit> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SUnitGroupUnit>
{
    private int size;
    private int maxsize;
    public struct SUnitGroupUnit * array;
    public void SDArray<SUnitGroupUnit>(class SDArray<SUnitGroupUnit> & );
    public void SDArray<SUnitGroupUnit>();
    public void ~SDArray<SUnitGroupUnit>();
    public int Add(struct SUnitGroupUnit & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SUnitGroupUnit & operator[](int );
    public void operator=(class SDArray<SUnitGroupUnit> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SUnitGroup
{
    float CenterX;
    float CenterZ;
    float DeviationSqr;
    int MovementMask;
    int BestUnitIdx;
    class SDArray<SUnitGroupUnit> Units;
    void SUnitGroup(struct SUnitGroup * );
    void SUnitGroup(struct SUnitGroup & );
    void SUnitGroup();
    void ~SUnitGroup();
    struct SUnitGroup & operator=(struct SUnitGroup * );
    struct SUnitGroup & operator=(struct SUnitGroup & );
    void * __vecDelDtor(unsigned int );
};

struct SExecutingTrigger
{
    int Trigger;
    int Action;
    unsigned long WaitTime;
    unsigned long WaitTime2;
    int Pause;
    int CamLocked;
};

struct SEventMap
{
    int First;
    int Last1;
    int Last2;
    int Last3;
};

struct SEventFlags
{
    bool Whisper;
    enum SAnimType AnimType;
};

class SInputDialog : public SDialog
{
    private class STextButton OKButton;
    private class STextButton YesButton;
    private class STextButton NoButton;
    private class STextButton CancelButton;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private int Type;
    public void SInputDialog(class SInputDialog * );
    public void SInputDialog(class SInputDialog & );
    public void SInputDialog();
    public void Create(char * ,char * ,char * ,int );
    public class SEditBoxWithText EditBox;
    protected void Cancel();
    public void ~SInputDialog();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class SInputDialog : public SDialog
{
    private class STextButton OKButton;
    private class STextButton YesButton;
    private class STextButton NoButton;
    private class STextButton CancelButton;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private int Type;
    public void SInputDialog(class SInputDialog * );
    public void SInputDialog(class SInputDialog & );
    public void SInputDialog();
    public void Create(char * ,char * ,char * ,int );
    public class SEditBoxWithText EditBox;
    protected void Cancel();
    public void ~SInputDialog();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum <unnamed-enum-MAP_STATUS_RUNNING>
{
    MAP_STATUS_RUNNING=0,
    MAP_STATUS_VICTORY=1,
    MAP_STATUS_DEFEAT_NORMAL=2,
    MAP_STATUS_ERROR_INCONSISTENCY=3,
    MAP_STATUS_DEFEAT_COUNTDOWN=4
};

enum <unnamed-enum-DIFFICULTY_EASY>
{
    DIFFICULTY_EASY=0,
    DIFFICULTY_NORMAL=1,
    DIFFICULTY_HARD=2
};

struct WSAData
{
    unsigned int wVersion;
    unsigned int wHighVersion;
    char szDescription[257];
    char szSystemStatus[129];
    unsigned int iMaxSockets;
    unsigned int iMaxUdpDg;
    char * lpVendorInfo;
};

struct hostent
{
    char * h_name;
    char ** h_aliases;
    int h_addrtype;
    int h_length;
    char ** h_addr_list;
};

class ArrayRef<ServerInfo>
{
    public void ArrayRef<ServerInfo>(struct ServerInfo * ,unsigned int );
    public struct ServerInfo * begin();
    public struct ServerInfo * end();
    public struct ServerInfo * array;
    public unsigned int count;
};

class ArrayRef<ServerInfo>
{
    public void ArrayRef<ServerInfo>(struct ServerInfo * ,unsigned int );
    public struct ServerInfo * begin();
    public struct ServerInfo * end();
    public struct ServerInfo * array;
    public unsigned int count;
};

struct SDropLocation
{
    int x;
    int y;
};

enum <unnamed-enum-SPEC_TANK_BURROW>
{
    SPEC_TANK_BURROW=0,
    SPEC_TANK_UNBURROW=1,
    SPEC_RELOAD_FUEL=2,
    SPEC_RELOAD_FUEL_STOP=3,
    SPEC_MORTAR_CLOSE=4,
    SPEC_MORTAR_OPEN=5,
    SPEC_HARDTANK_NORMAL_MODE=6,
    SPEC_HARDTANK_BRUTAL_MODE=7,
    SPEC_TRACTOR_ATTACH=8,
    SPEC_TRACTOR_DETACH=9,
    SPEC_MOVINGFORCE_SHOOT=10,
    SPEC__UNUSED2=11,
    SPEC_LOAD_FIVE=12,
    SPEC_LOAD_ONE=13,
    SPEC_ARTILLERY_SETTLE=14,
    SPEC_ARTILLERY_MOBILIZE=15,
    SPEC_REPAIR=16,
    SPEC_REPAIR_STOP=17,
    SPEC_RELOAD_AMMO=18,
    SPEC_RELOAD_AMMO_STOP=19,
    SPEC_LAY_MINE=20,
    SPEC__UNUSED1=21,
    SPEC_AIR_STRIKE=22
};

enum <unnamed-enum-DRAG_NONE>
{
    DRAG_NONE=0,
    DRAG_SELECT=1,
    DRAG_CAM_ROTATE=2,
    DRAG_CAM_ROTATE_2=3,
    DRAG_COMMAND=4
};

enum <unnamed-enum-COMMAND_DEFAULT>
{
    COMMAND_DEFAULT=0,
    COMMAND_MOVE=1,
    COMMAND_ATTACK=2,
    COMMAND_SPEC=3,
    COMMAND_SPEC_TARGET_UNIT=4,
    COMMAND_SPEC_TARGET_GROUND=5,
    COMMAND_REINFORCEMENT=6
};

enum <unnamed-enum-CONTROL_BLIZZARD>
{
    CONTROL_BLIZZARD=0,
    CONTROL_WESTWOOD=1
};

enum <unnamed-enum-SEL_SELECT_RETAIN>
{
    SEL_SELECT_RETAIN=1,
    SEL_HILITE_RETAIN=2,
    SEL_SELECT_ADD=4,
    SEL_HILITE_ADD=8,
    SEL_SELECT_CHANGE=16,
    SEL_HILITE_CHANGE=32,
    SEL_MASK=3,
    SEL_ADD_SHIFT=2,
    SEL_XOR_SHIFT=4
};

class STipDialog : public SDialog
{
    private class STextButton OKButton;
    private class STextButton NextButton;
    private class STextButton PrevButton;
    private bool OnAction(class SWidget * ,int ,int );
    private bool OnKeyDown(int );
    private class SListBox ListBox;
    private class SProperties * TipsIni;
    private int ActiveTip;
    public void STipDialog(class STipDialog & );
    public void STipDialog();
    public void ~STipDialog();
    public void Create();
    public int LoadTip(int );
    protected void Cancel();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum <unnamed-enum-GAMETYPE_DEATHMATCH>
{
    GAMETYPE_DEATHMATCH=0,
    GAMETYPE_CAPTURETHEFLAG=1
};

enum tagCOINIT
{
    COINIT_APARTMENTTHREADED=2,
    COINIT_MULTITHREADED=0,
    COINIT_DISABLE_OLE1DDE=4,
    COINIT_SPEED_OVER_MEMORY=8
};

enum ADDRESS_MODE
{
    AddrMode1616=0,
    AddrMode1632=1,
    AddrModeReal=2,
    AddrModeFlat=3
};

struct _BLOB
{
    unsigned long cbSize;
    unsigned int * pBlobData;
};

union tagCY
{
    unsigned long Lo;
    long Hi;
    int int64;
};

struct tagDEC
{
    unsigned int wReserved;
    unsigned int scale;
    unsigned int sign;
    unsigned int signscale;
    unsigned long Hi32;
    unsigned long Lo32;
    unsigned long Mid32;
    unsigned int Lo64;
};

struct tagBSTRBLOB
{
    unsigned long cbSize;
    unsigned int * pData;
};

struct tagCLIPDATA
{
    unsigned long cbSize;
    long ulClipFmt;
    unsigned int * pClipData;
};

struct tagSTATSTG
{
    wchar_t * pwcsName;
    unsigned long type;
    union _ULARGE_INTEGER cbSize;
    struct _FILETIME mtime;
    struct _FILETIME ctime;
    struct _FILETIME atime;
    unsigned long grfMode;
    unsigned long grfLocksSupported;
    struct _GUID clsid;
    unsigned long grfStateBits;
    unsigned long reserved;
};

struct tagSAFEARRAYBOUND
{
    unsigned long cElements;
    long lLbound;
};

struct tagSAFEARRAY
{
    unsigned int cDims;
    unsigned int fFeatures;
    unsigned long cbElements;
    unsigned long cLocks;
    void * pvData;
    struct tagSAFEARRAYBOUND rgsabound[1];
};

struct tagVARIANT
{
    unsigned int vt;
    unsigned int wReserved1;
    unsigned int wReserved2;
    unsigned int wReserved3;
    int llVal;
    long lVal;
    unsigned int bVal;
    int iVal;
    float fltVal;
    float dblVal;
    int boolVal;
    long scode;
    union tagCY cyVal;
    float date;
    wchar_t * bstrVal;
    struct IUnknown * punkVal;
    struct IDispatch * pdispVal;
    struct tagSAFEARRAY * parray;
    unsigned int * pbVal;
    int * piVal;
    long * plVal;
    int * pllVal;
    float * pfltVal;
    float * pdblVal;
    int * pboolVal;
    long * pscode;
    union tagCY * pcyVal;
    float * pdate;
    wchar_t ** pbstrVal;
    struct IUnknown ** ppunkVal;
    struct IDispatch ** ppdispVal;
    struct tagSAFEARRAY ** pparray;
    struct tagVARIANT * pvarVal;
    void * byref;
    char cVal;
    unsigned int uiVal;
    unsigned long ulVal;
    unsigned int ullVal;
    int intVal;
    unsigned int uintVal;
    struct tagDEC * pdecVal;
    char * pcVal;
    unsigned int * puiVal;
    unsigned long * pulVal;
    unsigned int * pullVal;
    int * pintVal;
    unsigned int * puintVal;
    void * pvRecord;
    struct IRecordInfo * pRecInfo;
    struct tagDEC decVal;
};

struct tagTYPEDESC
{
    struct tagTYPEDESC * lptdesc;
    struct tagARRAYDESC * lpadesc;
    unsigned long hreftype;
    unsigned int vt;
};

struct tagPARAMDESC
{
    struct tagPARAMDESCEX * pparamdescex;
    unsigned int wParamFlags;
};

struct tagIDLDESC
{
    unsigned long dwReserved;
    unsigned int wIDLFlags;
};

struct tagELEMDESC
{
    struct tagTYPEDESC tdesc;
    struct tagIDLDESC idldesc;
    struct tagPARAMDESC paramdesc;
};

struct tagTYPEATTR
{
    struct _GUID guid;
    unsigned long lcid;
    unsigned long dwReserved;
    long memidConstructor;
    long memidDestructor;
    wchar_t * lpstrSchema;
    unsigned long cbSizeInstance;
    enum tagTYPEKIND typekind;
    unsigned int cFuncs;
    unsigned int cVars;
    unsigned int cImplTypes;
    unsigned int cbSizeVft;
    unsigned int cbAlignment;
    unsigned int wTypeFlags;
    unsigned int wMajorVerNum;
    unsigned int wMinorVerNum;
    struct tagTYPEDESC tdescAlias;
    struct tagIDLDESC idldescType;
};

struct tagDISPPARAMS
{
    struct tagVARIANT * rgvarg;
    long * rgdispidNamedArgs;
    unsigned int cArgs;
    unsigned int cNamedArgs;
};

struct tagEXCEPINFO
{
    unsigned int wCode;
    unsigned int wReserved;
    wchar_t * bstrSource;
    wchar_t * bstrDescription;
    wchar_t * bstrHelpFile;
    unsigned long dwHelpContext;
    void * pvReserved;
    HRESULT  ( * pfnDeferredFillIn)(struct tagEXCEPINFO * );
    long scode;
};

enum tagINVOKEKIND
{
    INVOKE_FUNC=1,
    INVOKE_PROPERTYGET=2,
    INVOKE_PROPERTYPUT=4,
    INVOKE_PROPERTYPUTREF=8
};

struct tagFUNCDESC
{
    long memid;
    long * lprgscode;
    struct tagELEMDESC * lprgelemdescParam;
    enum tagFUNCKIND funckind;
    enum tagINVOKEKIND invkind;
    enum tagCALLCONV callconv;
    int cParams;
    int cParamsOpt;
    int oVft;
    int cScodes;
    struct tagELEMDESC elemdescFunc;
    unsigned int wFuncFlags;
};

struct tagVARDESC
{
    long memid;
    wchar_t * lpstrSchema;
    unsigned long oInst;
    struct tagVARIANT * lpvarValue;
    struct tagELEMDESC elemdescVar;
    unsigned int wVarFlags;
    enum tagVARKIND varkind;
};

union tagBINDPTR
{
    struct tagFUNCDESC * lpfuncdesc;
    struct tagVARDESC * lpvardesc;
    struct ITypeComp * lptcomp;
};

struct tagTLIBATTR
{
    struct _GUID guid;
    unsigned long lcid;
    enum tagSYSKIND syskind;
    unsigned int wMajorVerNum;
    unsigned int wMinorVerNum;
    unsigned int wLibFlags;
};

struct tagPROPVARIANT
{
    unsigned int vt;
    unsigned int wReserved1;
    unsigned int wReserved2;
    unsigned int wReserved3;
    char cVal;
    unsigned int bVal;
    int iVal;
    unsigned int uiVal;
    long lVal;
    unsigned long ulVal;
    int intVal;
    unsigned int uintVal;
    union _LARGE_INTEGER hVal;
    union _ULARGE_INTEGER uhVal;
    float fltVal;
    float dblVal;
    int boolVal;
    long scode;
    union tagCY cyVal;
    float date;
    struct _FILETIME filetime;
    struct _GUID * puuid;
    struct tagCLIPDATA * pclipdata;
    wchar_t * bstrVal;
    struct tagBSTRBLOB bstrblobVal;
    struct _BLOB blob;
    char * pszVal;
    wchar_t * pwszVal;
    struct IUnknown * punkVal;
    struct IDispatch * pdispVal;
    struct IStream * pStream;
    struct IStorage * pStorage;
    struct tagVersionedStream * pVersionedStream;
    struct tagSAFEARRAY * parray;
    struct tagCAC cac;
    struct tagCAUB caub;
    struct tagCAI cai;
    struct tagCAUI caui;
    struct tagCAL cal;
    struct tagCAUL caul;
    struct tagCAH cah;
    struct tagCAUH cauh;
    struct tagCAFLT caflt;
    struct tagCADBL cadbl;
    struct tagCABOOL cabool;
    struct tagCASCODE cascode;
    struct tagCACY cacy;
    struct tagCADATE cadate;
    struct tagCAFILETIME cafiletime;
    struct tagCACLSID cauuid;
    struct tagCACLIPDATA caclipdata;
    struct tagCABSTR cabstr;
    struct tagCABSTRBLOB cabstrblob;
    struct tagCALPSTR calpstr;
    struct tagCALPWSTR calpwstr;
    struct tagCAPROPVARIANT capropvar;
    char * pcVal;
    unsigned int * pbVal;
    int * piVal;
    unsigned int * puiVal;
    long * plVal;
    unsigned long * pulVal;
    int * pintVal;
    unsigned int * puintVal;
    float * pfltVal;
    float * pdblVal;
    int * pboolVal;
    struct tagDEC * pdecVal;
    long * pscode;
    union tagCY * pcyVal;
    float * pdate;
    wchar_t ** pbstrVal;
    struct IUnknown ** ppunkVal;
    struct IDispatch ** ppdispVal;
    struct tagSAFEARRAY ** pparray;
    struct tagPROPVARIANT * pvarVal;
    struct tagDEC decVal;
};

struct tagCAC
{
    unsigned long cElems;
    char * pElems;
};

struct tagCAUB
{
    unsigned long cElems;
    unsigned int * pElems;
};

struct tagCAI
{
    unsigned long cElems;
    int * pElems;
};

struct tagCAUI
{
    unsigned long cElems;
    unsigned int * pElems;
};

struct tagCAL
{
    unsigned long cElems;
    long * pElems;
};

struct tagCAUL
{
    unsigned long cElems;
    unsigned long * pElems;
};

struct tagCAFLT
{
    unsigned long cElems;
    float * pElems;
};

struct tagCADBL
{
    unsigned long cElems;
    float * pElems;
};

struct tagCACY
{
    unsigned long cElems;
    union tagCY * pElems;
};

struct tagCADATE
{
    unsigned long cElems;
    float * pElems;
};

struct tagCABSTR
{
    unsigned long cElems;
    wchar_t ** pElems;
};

struct tagCABSTRBLOB
{
    unsigned long cElems;
    struct tagBSTRBLOB * pElems;
};

struct tagCABOOL
{
    unsigned long cElems;
    int * pElems;
};

struct tagCASCODE
{
    unsigned long cElems;
    long * pElems;
};

struct tagCAPROPVARIANT
{
    unsigned long cElems;
    struct tagPROPVARIANT * pElems;
};

struct tagCAH
{
    unsigned long cElems;
    union _LARGE_INTEGER * pElems;
};

struct tagCAUH
{
    unsigned long cElems;
    union _ULARGE_INTEGER * pElems;
};

struct tagCALPSTR
{
    unsigned long cElems;
    char ** pElems;
};

struct tagCALPWSTR
{
    unsigned long cElems;
    wchar_t ** pElems;
};

struct tagCAFILETIME
{
    unsigned long cElems;
    struct _FILETIME * pElems;
};

struct tagCACLIPDATA
{
    unsigned long cElems;
    struct tagCLIPDATA * pElems;
};

struct tagCACLSID
{
    unsigned long cElems;
    struct _GUID * pElems;
};

struct IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void IUnknown(struct IUnknown * );
    void IUnknown(struct IUnknown & );
    void IUnknown();
    struct IUnknown & operator=(struct IUnknown * );
    struct IUnknown & operator=(struct IUnknown & );
};

struct IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void IUnknown(struct IUnknown * );
    void IUnknown(struct IUnknown & );
    void IUnknown();
    struct IUnknown & operator=(struct IUnknown * );
    struct IUnknown & operator=(struct IUnknown & );
};

struct IDispatch : public IUnknown
{
    HRESULT GetTypeInfoCount(unsigned int * );
    HRESULT GetTypeInfo(unsigned int ,unsigned long ,struct ITypeInfo ** );
    HRESULT GetIDsOfNames(struct _GUID & ,wchar_t ** ,unsigned int ,unsigned long ,long * );
    HRESULT Invoke(long ,struct _GUID & ,unsigned long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    void IDispatch(struct IDispatch * );
    void IDispatch(struct IDispatch & );
    void IDispatch();
    struct IDispatch & operator=(struct IDispatch * );
    struct IDispatch & operator=(struct IDispatch & );
};

struct IDispatch : public IUnknown
{
    HRESULT GetTypeInfoCount(unsigned int * );
    HRESULT GetTypeInfo(unsigned int ,unsigned long ,struct ITypeInfo ** );
    HRESULT GetIDsOfNames(struct _GUID & ,wchar_t ** ,unsigned int ,unsigned long ,long * );
    HRESULT Invoke(long ,struct _GUID & ,unsigned long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    void IDispatch(struct IDispatch * );
    void IDispatch(struct IDispatch & );
    void IDispatch();
    struct IDispatch & operator=(struct IDispatch * );
    struct IDispatch & operator=(struct IDispatch & );
};

struct ISequentialStream : public IUnknown
{
    HRESULT Read(void * ,unsigned long ,unsigned long * );
    HRESULT Write(void * ,unsigned long ,unsigned long * );
    void ISequentialStream(struct ISequentialStream * );
    void ISequentialStream(struct ISequentialStream & );
    void ISequentialStream();
    struct ISequentialStream & operator=(struct ISequentialStream * );
    struct ISequentialStream & operator=(struct ISequentialStream & );
};

struct ISequentialStream : public IUnknown
{
    HRESULT Read(void * ,unsigned long ,unsigned long * );
    HRESULT Write(void * ,unsigned long ,unsigned long * );
    void ISequentialStream(struct ISequentialStream * );
    void ISequentialStream(struct ISequentialStream & );
    void ISequentialStream();
    struct ISequentialStream & operator=(struct ISequentialStream * );
    struct ISequentialStream & operator=(struct ISequentialStream & );
};

struct IStream : public ISequentialStream
{
    HRESULT Seek(union _LARGE_INTEGER ,unsigned long ,union _ULARGE_INTEGER * );
    HRESULT SetSize(union _ULARGE_INTEGER );
    HRESULT CopyTo(struct IStream * ,union _ULARGE_INTEGER ,union _ULARGE_INTEGER * ,union _ULARGE_INTEGER * );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT LockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT UnlockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    HRESULT Clone(struct IStream ** );
    void IStream(struct IStream * );
    void IStream(struct IStream & );
    void IStream();
    struct IStream & operator=(struct IStream * );
    struct IStream & operator=(struct IStream & );
};

struct IStream : public ISequentialStream
{
    HRESULT Seek(union _LARGE_INTEGER ,unsigned long ,union _ULARGE_INTEGER * );
    HRESULT SetSize(union _ULARGE_INTEGER );
    HRESULT CopyTo(struct IStream * ,union _ULARGE_INTEGER ,union _ULARGE_INTEGER * ,union _ULARGE_INTEGER * );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT LockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT UnlockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    HRESULT Clone(struct IStream ** );
    void IStream(struct IStream * );
    void IStream(struct IStream & );
    void IStream();
    struct IStream & operator=(struct IStream * );
    struct IStream & operator=(struct IStream & );
};

struct IEnumSTATSTG : public IUnknown
{
    HRESULT Next(unsigned long ,struct tagSTATSTG * ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumSTATSTG ** );
    void IEnumSTATSTG(struct IEnumSTATSTG * );
    void IEnumSTATSTG(struct IEnumSTATSTG & );
    void IEnumSTATSTG();
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG * );
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG & );
};

struct IEnumSTATSTG : public IUnknown
{
    HRESULT Next(unsigned long ,struct tagSTATSTG * ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumSTATSTG ** );
    void IEnumSTATSTG(struct IEnumSTATSTG * );
    void IEnumSTATSTG(struct IEnumSTATSTG & );
    void IEnumSTATSTG();
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG * );
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG & );
};

struct _FILETIME
{
    unsigned long dwLowDateTime;
    unsigned long dwHighDateTime;
};

struct IStorage : public IUnknown
{
    HRESULT CreateStream(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT OpenStream(wchar_t * ,void * ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT CreateStorage(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStorage ** );
    HRESULT OpenStorage(wchar_t * ,struct IStorage * ,unsigned long ,wchar_t ** ,unsigned long ,struct IStorage ** );
    HRESULT CopyTo(unsigned long ,struct _GUID * ,wchar_t ** ,struct IStorage * );
    HRESULT MoveElementTo(wchar_t * ,struct IStorage * ,wchar_t * ,unsigned long );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT EnumElements(unsigned long ,void * ,unsigned long ,struct IEnumSTATSTG ** );
    HRESULT DestroyElement(wchar_t * );
    HRESULT RenameElement(wchar_t * ,wchar_t * );
    HRESULT SetElementTimes(wchar_t * ,struct _FILETIME * ,struct _FILETIME * ,struct _FILETIME * );
    HRESULT SetClass(struct _GUID & );
    HRESULT SetStateBits(unsigned long ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    void IStorage(struct IStorage * );
    void IStorage(struct IStorage & );
    void IStorage();
    struct IStorage & operator=(struct IStorage * );
    struct IStorage & operator=(struct IStorage & );
};

struct IStorage : public IUnknown
{
    HRESULT CreateStream(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT OpenStream(wchar_t * ,void * ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT CreateStorage(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStorage ** );
    HRESULT OpenStorage(wchar_t * ,struct IStorage * ,unsigned long ,wchar_t ** ,unsigned long ,struct IStorage ** );
    HRESULT CopyTo(unsigned long ,struct _GUID * ,wchar_t ** ,struct IStorage * );
    HRESULT MoveElementTo(wchar_t * ,struct IStorage * ,wchar_t * ,unsigned long );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT EnumElements(unsigned long ,void * ,unsigned long ,struct IEnumSTATSTG ** );
    HRESULT DestroyElement(wchar_t * );
    HRESULT RenameElement(wchar_t * ,wchar_t * );
    HRESULT SetElementTimes(wchar_t * ,struct _FILETIME * ,struct _FILETIME * ,struct _FILETIME * );
    HRESULT SetClass(struct _GUID & );
    HRESULT SetStateBits(unsigned long ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    void IStorage(struct IStorage * );
    void IStorage(struct IStorage & );
    void IStorage();
    struct IStorage & operator=(struct IStorage * );
    struct IStorage & operator=(struct IStorage & );
};

struct tagVersionedStream
{
    struct _GUID guidVersion;
    struct IStream * pStream;
};

struct ITypeComp : public IUnknown
{
    HRESULT Bind(wchar_t * ,unsigned long ,unsigned int ,struct ITypeInfo ** ,enum tagDESCKIND * ,union tagBINDPTR * );
    HRESULT BindType(wchar_t * ,unsigned long ,struct ITypeInfo ** ,struct ITypeComp ** );
    void ITypeComp(struct ITypeComp * );
    void ITypeComp(struct ITypeComp & );
    void ITypeComp();
    struct ITypeComp & operator=(struct ITypeComp * );
    struct ITypeComp & operator=(struct ITypeComp & );
};

struct ITypeComp : public IUnknown
{
    HRESULT Bind(wchar_t * ,unsigned long ,unsigned int ,struct ITypeInfo ** ,enum tagDESCKIND * ,union tagBINDPTR * );
    HRESULT BindType(wchar_t * ,unsigned long ,struct ITypeInfo ** ,struct ITypeComp ** );
    void ITypeComp(struct ITypeComp * );
    void ITypeComp(struct ITypeComp & );
    void ITypeComp();
    struct ITypeComp & operator=(struct ITypeComp * );
    struct ITypeComp & operator=(struct ITypeComp & );
};

struct tagARRAYDESC
{
    struct tagTYPEDESC tdescElem;
    unsigned int cDims;
    struct tagSAFEARRAYBOUND rgbounds[1];
};

struct tagPARAMDESCEX
{
    unsigned long cBytes;
    struct tagVARIANT varDefaultValue;
};

struct ITypeLib : public IUnknown
{
    unsigned int GetTypeInfoCount();
    HRESULT GetTypeInfo(unsigned int ,struct ITypeInfo ** );
    HRESULT GetTypeInfoType(unsigned int ,enum tagTYPEKIND * );
    HRESULT GetTypeInfoOfGuid(struct _GUID & ,struct ITypeInfo ** );
    HRESULT GetLibAttr(struct tagTLIBATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetDocumentation(int ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT IsName(wchar_t * ,unsigned long ,int * );
    HRESULT FindName(wchar_t * ,unsigned long ,struct ITypeInfo ** ,long * ,unsigned int * );
    void ReleaseTLibAttr(struct tagTLIBATTR * );
    void ITypeLib(struct ITypeLib * );
    void ITypeLib(struct ITypeLib & );
    void ITypeLib();
    struct ITypeLib & operator=(struct ITypeLib * );
    struct ITypeLib & operator=(struct ITypeLib & );
};

struct ITypeLib : public IUnknown
{
    unsigned int GetTypeInfoCount();
    HRESULT GetTypeInfo(unsigned int ,struct ITypeInfo ** );
    HRESULT GetTypeInfoType(unsigned int ,enum tagTYPEKIND * );
    HRESULT GetTypeInfoOfGuid(struct _GUID & ,struct ITypeInfo ** );
    HRESULT GetLibAttr(struct tagTLIBATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetDocumentation(int ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT IsName(wchar_t * ,unsigned long ,int * );
    HRESULT FindName(wchar_t * ,unsigned long ,struct ITypeInfo ** ,long * ,unsigned int * );
    void ReleaseTLibAttr(struct tagTLIBATTR * );
    void ITypeLib(struct ITypeLib * );
    void ITypeLib(struct ITypeLib & );
    void ITypeLib();
    struct ITypeLib & operator=(struct ITypeLib * );
    struct ITypeLib & operator=(struct ITypeLib & );
};

struct ITypeInfo : public IUnknown
{
    HRESULT GetTypeAttr(struct tagTYPEATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetFuncDesc(unsigned int ,struct tagFUNCDESC ** );
    HRESULT GetVarDesc(unsigned int ,struct tagVARDESC ** );
    HRESULT GetNames(long ,wchar_t ** ,unsigned int ,unsigned int * );
    HRESULT GetRefTypeOfImplType(unsigned int ,unsigned long * );
    HRESULT GetImplTypeFlags(unsigned int ,int * );
    HRESULT GetIDsOfNames(wchar_t ** ,unsigned int ,long * );
    HRESULT Invoke(void * ,long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    HRESULT GetDocumentation(long ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT GetDllEntry(long ,enum tagINVOKEKIND ,wchar_t ** ,wchar_t ** ,unsigned int * );
    HRESULT GetRefTypeInfo(unsigned long ,struct ITypeInfo ** );
    HRESULT AddressOfMember(long ,enum tagINVOKEKIND ,void ** );
    HRESULT CreateInstance(struct IUnknown * ,struct _GUID & ,void ** );
    HRESULT GetMops(long ,wchar_t ** );
    HRESULT GetContainingTypeLib(struct ITypeLib ** ,unsigned int * );
    void ReleaseTypeAttr(struct tagTYPEATTR * );
    void ReleaseFuncDesc(struct tagFUNCDESC * );
    void ReleaseVarDesc(struct tagVARDESC * );
    void ITypeInfo(struct ITypeInfo * );
    void ITypeInfo(struct ITypeInfo & );
    void ITypeInfo();
    struct ITypeInfo & operator=(struct ITypeInfo * );
    struct ITypeInfo & operator=(struct ITypeInfo & );
};

struct ITypeInfo : public IUnknown
{
    HRESULT GetTypeAttr(struct tagTYPEATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetFuncDesc(unsigned int ,struct tagFUNCDESC ** );
    HRESULT GetVarDesc(unsigned int ,struct tagVARDESC ** );
    HRESULT GetNames(long ,wchar_t ** ,unsigned int ,unsigned int * );
    HRESULT GetRefTypeOfImplType(unsigned int ,unsigned long * );
    HRESULT GetImplTypeFlags(unsigned int ,int * );
    HRESULT GetIDsOfNames(wchar_t ** ,unsigned int ,long * );
    HRESULT Invoke(void * ,long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    HRESULT GetDocumentation(long ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT GetDllEntry(long ,enum tagINVOKEKIND ,wchar_t ** ,wchar_t ** ,unsigned int * );
    HRESULT GetRefTypeInfo(unsigned long ,struct ITypeInfo ** );
    HRESULT AddressOfMember(long ,enum tagINVOKEKIND ,void ** );
    HRESULT CreateInstance(struct IUnknown * ,struct _GUID & ,void ** );
    HRESULT GetMops(long ,wchar_t ** );
    HRESULT GetContainingTypeLib(struct ITypeLib ** ,unsigned int * );
    void ReleaseTypeAttr(struct tagTYPEATTR * );
    void ReleaseFuncDesc(struct tagFUNCDESC * );
    void ReleaseVarDesc(struct tagVARDESC * );
    void ITypeInfo(struct ITypeInfo * );
    void ITypeInfo(struct ITypeInfo & );
    void ITypeInfo();
    struct ITypeInfo & operator=(struct ITypeInfo * );
    struct ITypeInfo & operator=(struct ITypeInfo & );
};

struct IRecordInfo : public IUnknown
{
    HRESULT RecordInit(void * );
    HRESULT RecordClear(void * );
    HRESULT RecordCopy(void * ,void * );
    HRESULT GetGuid(struct _GUID * );
    HRESULT GetName(wchar_t ** );
    HRESULT GetSize(unsigned long * );
    HRESULT GetTypeInfo(struct ITypeInfo ** );
    HRESULT GetField(void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNoCopy(void * ,wchar_t * ,struct tagVARIANT * ,void ** );
    HRESULT PutField(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT PutFieldNoCopy(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNames(unsigned long * ,wchar_t ** );
    int IsMatchingType(struct IRecordInfo * );
    void * RecordCreate();
    HRESULT RecordCreateCopy(void * ,void ** );
    HRESULT RecordDestroy(void * );
    void IRecordInfo(struct IRecordInfo * );
    void IRecordInfo(struct IRecordInfo & );
    void IRecordInfo();
    struct IRecordInfo & operator=(struct IRecordInfo * );
    struct IRecordInfo & operator=(struct IRecordInfo & );
};

struct IRecordInfo : public IUnknown
{
    HRESULT RecordInit(void * );
    HRESULT RecordClear(void * );
    HRESULT RecordCopy(void * ,void * );
    HRESULT GetGuid(struct _GUID * );
    HRESULT GetName(wchar_t ** );
    HRESULT GetSize(unsigned long * );
    HRESULT GetTypeInfo(struct ITypeInfo ** );
    HRESULT GetField(void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNoCopy(void * ,wchar_t * ,struct tagVARIANT * ,void ** );
    HRESULT PutField(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT PutFieldNoCopy(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNames(unsigned long * ,wchar_t ** );
    int IsMatchingType(struct IRecordInfo * );
    void * RecordCreate();
    HRESULT RecordCreateCopy(void * ,void ** );
    HRESULT RecordDestroy(void * );
    void IRecordInfo(struct IRecordInfo * );
    void IRecordInfo(struct IRecordInfo & );
    void IRecordInfo();
    struct IRecordInfo & operator=(struct IRecordInfo * );
    struct IRecordInfo & operator=(struct IRecordInfo & );
};

struct _tagADDRESS64
{
    unsigned int Offset;
    unsigned int Segment;
    enum ADDRESS_MODE Mode;
};

struct _tagADDRESS
{
    unsigned long Offset;
    unsigned int Segment;
    enum ADDRESS_MODE Mode;
};

struct _KDHELP64
{
    unsigned int Thread;
    unsigned long ThCallbackStack;
    unsigned long ThCallbackBStore;
    unsigned long NextCallback;
    unsigned long FramePointer;
    unsigned int KiCallUserMode;
    unsigned int KeUserCallbackDispatcher;
    unsigned int SystemRangeStart;
    unsigned int KiUserExceptionDispatcher;
    unsigned int StackBase;
    unsigned int StackLimit;
    unsigned int Reserved[5];
};

struct _KDHELP
{
    unsigned long Thread;
    unsigned long ThCallbackStack;
    unsigned long NextCallback;
    unsigned long FramePointer;
    unsigned long KiCallUserMode;
    unsigned long KeUserCallbackDispatcher;
    unsigned long SystemRangeStart;
    unsigned long ThCallbackBStore;
    unsigned long KiUserExceptionDispatcher;
    unsigned long StackBase;
    unsigned long StackLimit;
    unsigned long Reserved[5];
};

struct _tagSTACKFRAME64
{
    struct _tagADDRESS64 AddrPC;
    struct _tagADDRESS64 AddrReturn;
    struct _tagADDRESS64 AddrFrame;
    struct _tagADDRESS64 AddrStack;
    struct _tagADDRESS64 AddrBStore;
    void * FuncTableEntry;
    unsigned int Params[4];
    int Far;
    int Virtual;
    unsigned int Reserved[3];
    struct _KDHELP64 KdHelp;
};

struct _IMAGEHLP_SYMBOL64
{
    unsigned long SizeOfStruct;
    unsigned int Address;
    unsigned long Size;
    unsigned long Flags;
    unsigned long MaxNameLength;
    char Name[1];
};

struct _IMAGEHLP_LINE64
{
    unsigned long SizeOfStruct;
    void * Key;
    unsigned long LineNumber;
    char * FileName;
    unsigned int Address;
};

class SDArray<SString>
{
    private int size;
    private int maxsize;
    public class SString * array;
    public void SDArray<SString>(class SDArray<SString> & );
    public void SDArray<SString>();
    public void ~SDArray<SString>();
    public int Add(class SString & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SString & operator[](int );
    public void operator=(class SDArray<SString> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SString>
{
    private int size;
    private int maxsize;
    public class SString * array;
    public void SDArray<SString>(class SDArray<SString> & );
    public void SDArray<SString>();
    public void ~SDArray<SString>();
    public int Add(class SString & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SString & operator[](int );
    public void operator=(class SDArray<SString> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

enum <unnamed-enum-AI_TARGET_NONE>
{
    AI_TARGET_NONE=0,
    AI_TARGET_POINT=1,
    AI_TARGET_UNIT=2,
    AI_TARGET_DOODAD=3
};

enum <unnamed-enum-TILESET_NORMAL>
{
    TILESET_NORMAL=0,
    TILESET_DESERT=1,
    TILESET_SNOW=2,
    TILESET_ROCK=3,
    TILESET_JUNGLE=4
};

enum <unnamed-enum-SOUND_GROUP_AMBIENT>
{
    SOUND_GROUP_AMBIENT=0,
    SOUND_GROUP_ENGINE=1,
    NUM_SOUND_GROUPS=2
};

class SIObject
{
    public void AddRef();
    public void Release();
    public void GetPosition(float & ,float & ,float & );
    public void SetPosition(float ,float ,float );
    public void SetRotation(float ,float ,float );
    public void SetRotation2(float ,float ,float );
    public void SetRelativeRotation(float ,float ,float ,float );
    public void SetScale(float );
    public void SetMatrix(struct D3DXMATRIX );
    public void Show(bool );
    public void SaveStatus();
    public void LogTransforms(struct _iobuf * );
    public int GetMeshIndex(char * );
    public int GetMeshIndex2(char * );
    public char * GetMeshName(int );
    public class SDArray<SString> GetMeshNames();
    public void SetMeshProperties(int ,float ,float ,float ,float ,float ,float );
    public void SetMeshPosition(int ,float ,float ,float );
    public void SetMeshRotation(int ,float ,float ,float );
    public void SetMeshRotation2(int ,float ,float );
    public void SetMeshUVTransformActive(int ,bool );
    public void SetMeshUVTransformValue(int ,float );
    public void GetMeshProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshProperties(int ,float & ,float & ,float & );
    public void GetMeshProperties(int ,struct D3DXMATRIX & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,struct D3DXMATRIX & );
    public void SetMeshVisible(int ,bool );
    public void SetMeshCanCastShadows(int ,bool );
    public void SetFlags(unsigned long );
    public void ComputeTransformedBounding(float & ,float & ,float & ,float & ,float & ,float & ,float ,float );
    public void SetAmbient(float );
    public void SetColorizeProperties(int ,float ,float );
    public void SetTreeParams(float ,float );
    public void GetScreenPos(float & ,float & ,float & );
    public float GetClickDistanceSquare(float ,float );
    public bool CheckClickBox(float ,float ,float ,float );
    public void GetInterpolatedPosition(float & ,float & ,float & );
    public void SetVisClass(int );
    public void SetSelection(int );
    public void * SetEffect(void * );
    public void ClearEffect(void * );
    public void GetInternalIndex(bool & ,int & );
    public bool GetActivationState();
    public void SetActivationState(bool );
    public void SIObject(class SIObject * );
    public void SIObject(class SIObject & );
    public void SIObject();
    public class SIObject & operator=(class SIObject * );
    public class SIObject & operator=(class SIObject & );
};

class SIObject
{
    public void AddRef();
    public void Release();
    public void GetPosition(float & ,float & ,float & );
    public void SetPosition(float ,float ,float );
    public void SetRotation(float ,float ,float );
    public void SetRotation2(float ,float ,float );
    public void SetRelativeRotation(float ,float ,float ,float );
    public void SetScale(float );
    public void SetMatrix(struct D3DXMATRIX );
    public void Show(bool );
    public void SaveStatus();
    public void LogTransforms(struct _iobuf * );
    public int GetMeshIndex(char * );
    public int GetMeshIndex2(char * );
    public char * GetMeshName(int );
    public class SDArray<SString> GetMeshNames();
    public void SetMeshProperties(int ,float ,float ,float ,float ,float ,float );
    public void SetMeshPosition(int ,float ,float ,float );
    public void SetMeshRotation(int ,float ,float ,float );
    public void SetMeshRotation2(int ,float ,float );
    public void SetMeshUVTransformActive(int ,bool );
    public void SetMeshUVTransformValue(int ,float );
    public void GetMeshProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshProperties(int ,float & ,float & ,float & );
    public void GetMeshProperties(int ,struct D3DXMATRIX & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,struct D3DXMATRIX & );
    public void SetMeshVisible(int ,bool );
    public void SetMeshCanCastShadows(int ,bool );
    public void SetFlags(unsigned long );
    public void ComputeTransformedBounding(float & ,float & ,float & ,float & ,float & ,float & ,float ,float );
    public void SetAmbient(float );
    public void SetColorizeProperties(int ,float ,float );
    public void SetTreeParams(float ,float );
    public void GetScreenPos(float & ,float & ,float & );
    public float GetClickDistanceSquare(float ,float );
    public bool CheckClickBox(float ,float ,float ,float );
    public void GetInterpolatedPosition(float & ,float & ,float & );
    public void SetVisClass(int );
    public void SetSelection(int );
    public void * SetEffect(void * );
    public void ClearEffect(void * );
    public void GetInternalIndex(bool & ,int & );
    public bool GetActivationState();
    public void SetActivationState(bool );
    public void SIObject(class SIObject * );
    public void SIObject(class SIObject & );
    public void SIObject();
    public class SIObject & operator=(class SIObject * );
    public class SIObject & operator=(class SIObject & );
};

struct SHeap<SDoodad>::__Tstruct
{
    int use;
    struct SDoodad data;
    void __Tstruct(struct SHeap<SDoodad>::__Tstruct * );
    void __Tstruct(struct SHeap<SDoodad>::__Tstruct & );
    void __Tstruct();
    void ~__Tstruct();
    struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct * );
    struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct & );
    void * __vecDelDtor(unsigned int );
};

struct SHeap<SDoodad>::__Tstruct
{
    int use;
    struct SDoodad data;
    void __Tstruct(struct SHeap<SDoodad>::__Tstruct * );
    void __Tstruct(struct SHeap<SDoodad>::__Tstruct & );
    void __Tstruct();
    void ~__Tstruct();
    struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct * );
    struct SHeap<SDoodad>::__Tstruct & operator=(struct SHeap<SDoodad>::__Tstruct & );
    void * __vecDelDtor(unsigned int );
};

struct SHeap<SUnit *>::__Tstruct
{
    int use;
    class SUnit * data;
};

struct SHeap<SAmbient>::__Tstruct
{
    int use;
    struct SAmbient data;
};

struct SHeap<SLake>::__Tstruct
{
    int use;
    struct SLake data;
};

struct SHeap<SLocation>::__Tstruct
{
    int use;
    struct SLocation data;
    void ~__Tstruct();
    void * __vecDelDtor(unsigned int );
};

struct SAblak
{
    int meshidx;
    int type;
    float param;
    float variable;
    bool active;
};

class SDArray<SAblak>
{
    private int size;
    private int maxsize;
    public struct SAblak * array;
    public void SDArray<SAblak>(class SDArray<SAblak> & );
    public void SDArray<SAblak>();
    public void ~SDArray<SAblak>();
    public int Add(struct SAblak & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SAblak & operator[](int );
    public void operator=(class SDArray<SAblak> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SAblak>
{
    private int size;
    private int maxsize;
    public struct SAblak * array;
    public void SDArray<SAblak>(class SDArray<SAblak> & );
    public void SDArray<SAblak>();
    public void ~SDArray<SAblak>();
    public int Add(struct SAblak & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SAblak & operator[](int );
    public void operator=(class SDArray<SAblak> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SAblak
{
    int meshidx;
    int type;
    float param;
    float variable;
    bool active;
};

enum <unnamed-enum-AI_MODE_STOP>
{
    AI_MODE_STOP=0,
    AI_MODE_CHASE=1,
    AI_MODE_RETREAT=2,
    AI_MODE_HOLD_FIRE=3,
    AI_MODE_RETURN_FIRE=4,
    AI_MODE_FIRE_AT_WILL=5
};

enum <unnamed-enum-DAMAGE_GROUND>
{
    DAMAGE_GROUND=0,
    DAMAGE_AIR=1,
    DAMAGE_MINE=2
};

enum <unnamed-enum-UNITTYPE_VEHICLE>
{
    UNITTYPE_VEHICLE=0,
    UNITTYPE_AIR=1,
    UNITTYPE_UNDERGROUND=2,
    UNITTYPE_BUILDING=3,
    UNITTYPE_POWERUP=4
};

enum <unnamed-enum-DA_NINCS>
{
    DA_NINCS=0,
    DA_CELRATARTAS=1,
    DA_KIKERULES=2,
    DA_FRUSZTRACIO=3,
    DA_TOLATAS=4,
    DA_FEKEZES=5,
    DA_WAITWHILENEAR=6,
    DA_INDULAS=7,
    DA_DETACHING=9,
    DA_ATTACHING=10,
    DA_LASSITAS=11,
    NA_CONTINUEMOVING=12,
    DA_FACETOPOINT=13
};

enum <unnamed-enum-GT_FIXPOINT>
{
    GT_FIXPOINT=0,
    GT_UNIT=1
};

enum _D3DXCLEANTYPE
{
    D3DXCLEAN_BACKFACING=1,
    D3DXCLEAN_BOWTIES=2,
    D3DXCLEAN_SKINNING=1,
    D3DXCLEAN_OPTIMIZATION=1,
    D3DXCLEAN_SIMPLIFICATION=3
};

enum _MAX_FVF_DECL_SIZE
{
    MAX_FVF_DECL_SIZE=65
};

enum _D3DRESOURCETYPE
{
    D3DRTYPE_SURFACE=1,
    D3DRTYPE_VOLUME=2,
    D3DRTYPE_TEXTURE=3,
    D3DRTYPE_VOLUMETEXTURE=4,
    D3DRTYPE_CUBETEXTURE=5,
    D3DRTYPE_VERTEXBUFFER=6,
    D3DRTYPE_INDEXBUFFER=7,
    D3DRTYPE_FORCE_DWORD=2147483647
};

class SStack<SWaypoint>
{
    private struct SWaypoint * array;
    private int size;
    private int maxsize;
    public float userdata;
    public void SStack<SWaypoint>();
    public void ~SStack<SWaypoint>();
    public void Push(struct SWaypoint );
    public struct SWaypoint & Pop();
    public struct SWaypoint & GetFirst();
    public struct SWaypoint & Peek();
    public void SetData(struct SWaypoint * ,int ,int );
    public int GetSize();
    public bool IsEmpty();
    public void * __vecDelDtor(unsigned int );
};

struct tagBLOB
{
    unsigned long cbSize;
    unsigned int * pBlobData;
};

struct tagPROPVARIANT
{
    unsigned int vt;
    unsigned int wReserved1;
    unsigned int wReserved2;
    unsigned int wReserved3;
    char cVal;
    unsigned int bVal;
    int iVal;
    unsigned int uiVal;
    long lVal;
    unsigned long ulVal;
    int intVal;
    unsigned int uintVal;
    union _LARGE_INTEGER hVal;
    union _ULARGE_INTEGER uhVal;
    float fltVal;
    float dblVal;
    int boolVal;
    long scode;
    union tagCY cyVal;
    float date;
    struct _FILETIME filetime;
    struct _GUID * puuid;
    struct tagCLIPDATA * pclipdata;
    wchar_t * bstrVal;
    struct tagBSTRBLOB bstrblobVal;
    struct tagBLOB blob;
    char * pszVal;
    wchar_t * pwszVal;
    struct IUnknown * punkVal;
    struct IDispatch * pdispVal;
    struct IStream * pStream;
    struct IStorage * pStorage;
    struct tagVersionedStream * pVersionedStream;
    struct tagSAFEARRAY * parray;
    struct tagCAC cac;
    struct tagCAUB caub;
    struct tagCAI cai;
    struct tagCAUI caui;
    struct tagCAL cal;
    struct tagCAUL caul;
    struct tagCAH cah;
    struct tagCAUH cauh;
    struct tagCAFLT caflt;
    struct tagCADBL cadbl;
    struct tagCABOOL cabool;
    struct tagCASCODE cascode;
    struct tagCACY cacy;
    struct tagCADATE cadate;
    struct tagCAFILETIME cafiletime;
    struct tagCACLSID cauuid;
    struct tagCACLIPDATA caclipdata;
    struct tagCABSTR cabstr;
    struct tagCABSTRBLOB cabstrblob;
    struct tagCALPSTR calpstr;
    struct tagCALPWSTR calpwstr;
    struct tagCAPROPVARIANT capropvar;
    char * pcVal;
    unsigned int * pbVal;
    int * piVal;
    unsigned int * puiVal;
    long * plVal;
    unsigned long * pulVal;
    int * pintVal;
    unsigned int * puintVal;
    float * pfltVal;
    float * pdblVal;
    int * pboolVal;
    struct tagDEC * pdecVal;
    long * pscode;
    union tagCY * pcyVal;
    float * pdate;
    wchar_t ** pbstrVal;
    struct IUnknown ** ppunkVal;
    struct IDispatch ** ppdispVal;
    struct tagSAFEARRAY ** pparray;
    struct tagPROPVARIANT * pvarVal;
    struct tagDEC decVal;
};

struct _D3DVECTOR
{
    float x;
    float y;
    float z;
};

struct _D3DCOLORVALUE
{
    float r;
    float g;
    float b;
    float a;
};

struct _D3DRECT
{
    long x1;
    long y1;
    long x2;
    long y2;
};

struct _D3DMATRIX
{
    float _11;
    float _12;
    float _13;
    float _14;
    float _21;
    float _22;
    float _23;
    float _24;
    float _31;
    float _32;
    float _33;
    float _34;
    float _41;
    float _42;
    float _43;
    float _44;
    float m[4][4];
};

struct _D3DVIEWPORT9
{
    unsigned long X;
    unsigned long Y;
    unsigned long Width;
    unsigned long Height;
    float MinZ;
    float MaxZ;
};

struct _D3DCLIPSTATUS9
{
    unsigned long ClipUnion;
    unsigned long ClipIntersection;
};

struct _D3DMATERIAL9
{
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Emissive;
    float Power;
};

enum _D3DLIGHTTYPE
{
    D3DLIGHT_POINT=1,
    D3DLIGHT_SPOT=2,
    D3DLIGHT_DIRECTIONAL=3,
    D3DLIGHT_FORCE_DWORD=2147483647
};

struct _D3DLIGHT9
{
    enum _D3DLIGHTTYPE Type;
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DVECTOR Position;
    struct _D3DVECTOR Direction;
    float Range;
    float Falloff;
    float Attenuation0;
    float Attenuation1;
    float Attenuation2;
    float Theta;
    float Phi;
};

enum _D3DPRIMITIVETYPE
{
    D3DPT_POINTLIST=1,
    D3DPT_LINELIST=2,
    D3DPT_LINESTRIP=3,
    D3DPT_TRIANGLELIST=4,
    D3DPT_TRIANGLESTRIP=5,
    D3DPT_TRIANGLEFAN=6,
    D3DPT_FORCE_DWORD=2147483647
};

enum _D3DTRANSFORMSTATETYPE
{
    D3DTS_VIEW=2,
    D3DTS_PROJECTION=3,
    D3DTS_TEXTURE0=16,
    D3DTS_TEXTURE1=17,
    D3DTS_TEXTURE2=18,
    D3DTS_TEXTURE3=19,
    D3DTS_TEXTURE4=20,
    D3DTS_TEXTURE5=21,
    D3DTS_TEXTURE6=22,
    D3DTS_TEXTURE7=23,
    D3DTS_FORCE_DWORD=2147483647
};

enum _D3DRENDERSTATETYPE
{
    D3DRS_ZENABLE=7,
    D3DRS_FILLMODE=8,
    D3DRS_SHADEMODE=9,
    D3DRS_ZWRITEENABLE=14,
    D3DRS_ALPHATESTENABLE=15,
    D3DRS_LASTPIXEL=16,
    D3DRS_SRCBLEND=19,
    D3DRS_DESTBLEND=20,
    D3DRS_CULLMODE=22,
    D3DRS_ZFUNC=23,
    D3DRS_ALPHAREF=24,
    D3DRS_ALPHAFUNC=25,
    D3DRS_DITHERENABLE=26,
    D3DRS_ALPHABLENDENABLE=27,
    D3DRS_FOGENABLE=28,
    D3DRS_SPECULARENABLE=29,
    D3DRS_FOGCOLOR=34,
    D3DRS_FOGTABLEMODE=35,
    D3DRS_FOGSTART=36,
    D3DRS_FOGEND=37,
    D3DRS_FOGDENSITY=38,
    D3DRS_RANGEFOGENABLE=48,
    D3DRS_STENCILENABLE=52,
    D3DRS_STENCILFAIL=53,
    D3DRS_STENCILZFAIL=54,
    D3DRS_STENCILPASS=55,
    D3DRS_STENCILFUNC=56,
    D3DRS_STENCILREF=57,
    D3DRS_STENCILMASK=58,
    D3DRS_STENCILWRITEMASK=59,
    D3DRS_TEXTUREFACTOR=60,
    D3DRS_WRAP0=128,
    D3DRS_WRAP1=129,
    D3DRS_WRAP2=130,
    D3DRS_WRAP3=131,
    D3DRS_WRAP4=132,
    D3DRS_WRAP5=133,
    D3DRS_WRAP6=134,
    D3DRS_WRAP7=135,
    D3DRS_CLIPPING=136,
    D3DRS_LIGHTING=137,
    D3DRS_AMBIENT=139,
    D3DRS_FOGVERTEXMODE=140,
    D3DRS_COLORVERTEX=141,
    D3DRS_LOCALVIEWER=142,
    D3DRS_NORMALIZENORMALS=143,
    D3DRS_DIFFUSEMATERIALSOURCE=145,
    D3DRS_SPECULARMATERIALSOURCE=146,
    D3DRS_AMBIENTMATERIALSOURCE=147,
    D3DRS_EMISSIVEMATERIALSOURCE=148,
    D3DRS_VERTEXBLEND=151,
    D3DRS_CLIPPLANEENABLE=152,
    D3DRS_POINTSIZE=154,
    D3DRS_POINTSIZE_MIN=155,
    D3DRS_POINTSPRITEENABLE=156,
    D3DRS_POINTSCALEENABLE=157,
    D3DRS_POINTSCALE_A=158,
    D3DRS_POINTSCALE_B=159,
    D3DRS_POINTSCALE_C=160,
    D3DRS_MULTISAMPLEANTIALIAS=161,
    D3DRS_MULTISAMPLEMASK=162,
    D3DRS_PATCHEDGESTYLE=163,
    D3DRS_DEBUGMONITORTOKEN=165,
    D3DRS_POINTSIZE_MAX=166,
    D3DRS_INDEXEDVERTEXBLENDENABLE=167,
    D3DRS_COLORWRITEENABLE=168,
    D3DRS_TWEENFACTOR=170,
    D3DRS_BLENDOP=171,
    D3DRS_POSITIONDEGREE=172,
    D3DRS_NORMALDEGREE=173,
    D3DRS_SCISSORTESTENABLE=174,
    D3DRS_SLOPESCALEDEPTHBIAS=175,
    D3DRS_ANTIALIASEDLINEENABLE=176,
    D3DRS_MINTESSELLATIONLEVEL=178,
    D3DRS_MAXTESSELLATIONLEVEL=179,
    D3DRS_ADAPTIVETESS_X=180,
    D3DRS_ADAPTIVETESS_Y=181,
    D3DRS_ADAPTIVETESS_Z=182,
    D3DRS_ADAPTIVETESS_W=183,
    D3DRS_ENABLEADAPTIVETESSELLATION=184,
    D3DRS_TWOSIDEDSTENCILMODE=185,
    D3DRS_CCW_STENCILFAIL=186,
    D3DRS_CCW_STENCILZFAIL=187,
    D3DRS_CCW_STENCILPASS=188,
    D3DRS_CCW_STENCILFUNC=189,
    D3DRS_COLORWRITEENABLE1=190,
    D3DRS_COLORWRITEENABLE2=191,
    D3DRS_COLORWRITEENABLE3=192,
    D3DRS_BLENDFACTOR=193,
    D3DRS_SRGBWRITEENABLE=194,
    D3DRS_DEPTHBIAS=195,
    D3DRS_WRAP8=198,
    D3DRS_WRAP9=199,
    D3DRS_WRAP10=200,
    D3DRS_WRAP11=201,
    D3DRS_WRAP12=202,
    D3DRS_WRAP13=203,
    D3DRS_WRAP14=204,
    D3DRS_WRAP15=205,
    D3DRS_SEPARATEALPHABLENDENABLE=206,
    D3DRS_SRCBLENDALPHA=207,
    D3DRS_DESTBLENDALPHA=208,
    D3DRS_BLENDOPALPHA=209,
    D3DRS_FORCE_DWORD=2147483647
};

enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP=1,
    D3DTSS_COLORARG1=2,
    D3DTSS_COLORARG2=3,
    D3DTSS_ALPHAOP=4,
    D3DTSS_ALPHAARG1=5,
    D3DTSS_ALPHAARG2=6,
    D3DTSS_BUMPENVMAT00=7,
    D3DTSS_BUMPENVMAT01=8,
    D3DTSS_BUMPENVMAT10=9,
    D3DTSS_BUMPENVMAT11=10,
    D3DTSS_TEXCOORDINDEX=11,
    D3DTSS_BUMPENVLSCALE=22,
    D3DTSS_BUMPENVLOFFSET=23,
    D3DTSS_TEXTURETRANSFORMFLAGS=24,
    D3DTSS_COLORARG0=26,
    D3DTSS_ALPHAARG0=27,
    D3DTSS_RESULTARG=28,
    D3DTSS_CONSTANT=32,
    D3DTSS_FORCE_DWORD=2147483647
};

enum _D3DSAMPLERSTATETYPE
{
    D3DSAMP_ADDRESSU=1,
    D3DSAMP_ADDRESSV=2,
    D3DSAMP_ADDRESSW=3,
    D3DSAMP_BORDERCOLOR=4,
    D3DSAMP_MAGFILTER=5,
    D3DSAMP_MINFILTER=6,
    D3DSAMP_MIPFILTER=7,
    D3DSAMP_MIPMAPLODBIAS=8,
    D3DSAMP_MAXMIPLEVEL=9,
    D3DSAMP_MAXANISOTROPY=10,
    D3DSAMP_SRGBTEXTURE=11,
    D3DSAMP_ELEMENTINDEX=12,
    D3DSAMP_DMAPOFFSET=13,
    D3DSAMP_FORCE_DWORD=2147483647
};

enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE=0,
    D3DTEXF_POINT=1,
    D3DTEXF_LINEAR=2,
    D3DTEXF_ANISOTROPIC=3,
    D3DTEXF_PYRAMIDALQUAD=6,
    D3DTEXF_GAUSSIANQUAD=7,
    D3DTEXF_CONVOLUTIONMONO=8,
    D3DTEXF_FORCE_DWORD=2147483647
};

struct _D3DVERTEXELEMENT9
{
    unsigned int Stream;
    unsigned int Offset;
    unsigned int Type;
    unsigned int Method;
    unsigned int Usage;
    unsigned int UsageIndex;
};

enum _D3DBASISTYPE
{
    D3DBASIS_BEZIER=0,
    D3DBASIS_BSPLINE=1,
    D3DBASIS_CATMULL_ROM=2,
    D3DBASIS_FORCE_DWORD=2147483647
};

enum _D3DDEGREETYPE
{
    D3DDEGREE_LINEAR=1,
    D3DDEGREE_QUADRATIC=2,
    D3DDEGREE_CUBIC=3,
    D3DDEGREE_QUINTIC=5,
    D3DDEGREE_FORCE_DWORD=2147483647
};

enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL=1,
    D3DSBT_PIXELSTATE=2,
    D3DSBT_VERTEXSTATE=3,
    D3DSBT_FORCE_DWORD=2147483647
};

enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL=1,
    D3DDEVTYPE_REF=2,
    D3DDEVTYPE_SW=3,
    D3DDEVTYPE_NULLREF=4,
    D3DDEVTYPE_FORCE_DWORD=2147483647
};

enum _D3DMULTISAMPLE_TYPE
{
    D3DMULTISAMPLE_NONE=0,
    D3DMULTISAMPLE_NONMASKABLE=1,
    D3DMULTISAMPLE_2_SAMPLES=2,
    D3DMULTISAMPLE_3_SAMPLES=3,
    D3DMULTISAMPLE_4_SAMPLES=4,
    D3DMULTISAMPLE_5_SAMPLES=5,
    D3DMULTISAMPLE_6_SAMPLES=6,
    D3DMULTISAMPLE_7_SAMPLES=7,
    D3DMULTISAMPLE_8_SAMPLES=8,
    D3DMULTISAMPLE_9_SAMPLES=9,
    D3DMULTISAMPLE_10_SAMPLES=10,
    D3DMULTISAMPLE_11_SAMPLES=11,
    D3DMULTISAMPLE_12_SAMPLES=12,
    D3DMULTISAMPLE_13_SAMPLES=13,
    D3DMULTISAMPLE_14_SAMPLES=14,
    D3DMULTISAMPLE_15_SAMPLES=15,
    D3DMULTISAMPLE_16_SAMPLES=16,
    D3DMULTISAMPLE_FORCE_DWORD=2147483647
};

enum _D3DFORMAT
{
    D3DFMT_UNKNOWN=0,
    D3DFMT_R8G8B8=20,
    D3DFMT_A8R8G8B8=21,
    D3DFMT_X8R8G8B8=22,
    D3DFMT_R5G6B5=23,
    D3DFMT_X1R5G5B5=24,
    D3DFMT_A1R5G5B5=25,
    D3DFMT_A4R4G4B4=26,
    D3DFMT_R3G3B2=27,
    D3DFMT_A8=28,
    D3DFMT_A8R3G3B2=29,
    D3DFMT_X4R4G4B4=30,
    D3DFMT_A2B10G10R10=31,
    D3DFMT_A8B8G8R8=32,
    D3DFMT_X8B8G8R8=33,
    D3DFMT_G16R16=34,
    D3DFMT_A2R10G10B10=35,
    D3DFMT_A16B16G16R16=36,
    D3DFMT_A8P8=40,
    D3DFMT_P8=41,
    D3DFMT_L8=50,
    D3DFMT_A8L8=51,
    D3DFMT_A4L4=52,
    D3DFMT_V8U8=60,
    D3DFMT_L6V5U5=61,
    D3DFMT_X8L8V8U8=62,
    D3DFMT_Q8W8V8U8=63,
    D3DFMT_V16U16=64,
    D3DFMT_A2W10V10U10=67,
    D3DFMT_UYVY=1498831189,
    D3DFMT_R8G8_B8G8=1195525970,
    D3DFMT_YUY2=844715353,
    D3DFMT_G8R8_G8B8=1111970375,
    D3DFMT_DXT1=827611204,
    D3DFMT_DXT2=844388420,
    D3DFMT_DXT3=861165636,
    D3DFMT_DXT4=877942852,
    D3DFMT_DXT5=894720068,
    D3DFMT_D16_LOCKABLE=70,
    D3DFMT_D32=71,
    D3DFMT_D15S1=73,
    D3DFMT_D24S8=75,
    D3DFMT_D24X8=77,
    D3DFMT_D24X4S4=79,
    D3DFMT_D16=80,
    D3DFMT_D32F_LOCKABLE=82,
    D3DFMT_D24FS8=83,
    D3DFMT_D32_LOCKABLE=84,
    D3DFMT_S8_LOCKABLE=85,
    D3DFMT_L16=81,
    D3DFMT_VERTEXDATA=100,
    D3DFMT_INDEX16=101,
    D3DFMT_INDEX32=102,
    D3DFMT_Q16W16V16U16=110,
    D3DFMT_MULTI2_ARGB8=827606349,
    D3DFMT_R16F=111,
    D3DFMT_G16R16F=112,
    D3DFMT_A16B16G16R16F=113,
    D3DFMT_R32F=114,
    D3DFMT_G32R32F=115,
    D3DFMT_A32B32G32R32F=116,
    D3DFMT_CxV8U8=117,
    D3DFMT_A1=118,
    D3DFMT_A2B10G10R10_XR_BIAS=119,
    D3DFMT_BINARYBUFFER=199,
    D3DFMT_FORCE_DWORD=2147483647
};

struct _D3DDISPLAYMODE
{
    unsigned int Width;
    unsigned int Height;
    unsigned int RefreshRate;
    enum _D3DFORMAT Format;
};

struct _D3DDEVICE_CREATION_PARAMETERS
{
    unsigned int AdapterOrdinal;
    enum _D3DDEVTYPE DeviceType;
    struct HWND__ * hFocusWindow;
    unsigned long BehaviorFlags;
};

enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD=1,
    D3DSWAPEFFECT_FLIP=2,
    D3DSWAPEFFECT_COPY=3,
    D3DSWAPEFFECT_OVERLAY=4,
    D3DSWAPEFFECT_FLIPEX=5,
    D3DSWAPEFFECT_FORCE_DWORD=2147483647
};

enum _D3DPOOL
{
    D3DPOOL_DEFAULT=0,
    D3DPOOL_MANAGED=1,
    D3DPOOL_SYSTEMMEM=2,
    D3DPOOL_SCRATCH=3,
    D3DPOOL_FORCE_DWORD=2147483647
};

struct _D3DPRESENT_PARAMETERS_
{
    unsigned int BackBufferWidth;
    unsigned int BackBufferHeight;
    enum _D3DFORMAT BackBufferFormat;
    unsigned int BackBufferCount;
    enum _D3DMULTISAMPLE_TYPE MultiSampleType;
    unsigned long MultiSampleQuality;
    enum _D3DSWAPEFFECT SwapEffect;
    struct HWND__ * hDeviceWindow;
    int Windowed;
    int EnableAutoDepthStencil;
    enum _D3DFORMAT AutoDepthStencilFormat;
    unsigned long Flags;
    unsigned int FullScreen_RefreshRateInHz;
    unsigned int PresentationInterval;
};

struct _D3DGAMMARAMP
{
    unsigned int red[256];
    unsigned int green[256];
    unsigned int blue[256];
};

enum _D3DBACKBUFFER_TYPE
{
    D3DBACKBUFFER_TYPE_MONO=0,
    D3DBACKBUFFER_TYPE_LEFT=1,
    D3DBACKBUFFER_TYPE_RIGHT=2,
    D3DBACKBUFFER_TYPE_FORCE_DWORD=2147483647
};

enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X=0,
    D3DCUBEMAP_FACE_NEGATIVE_X=1,
    D3DCUBEMAP_FACE_POSITIVE_Y=2,
    D3DCUBEMAP_FACE_NEGATIVE_Y=3,
    D3DCUBEMAP_FACE_POSITIVE_Z=4,
    D3DCUBEMAP_FACE_NEGATIVE_Z=5,
    D3DCUBEMAP_FACE_FORCE_DWORD=2147483647
};

struct _D3DVERTEXBUFFER_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    unsigned int Size;
    unsigned long FVF;
};

struct _D3DINDEXBUFFER_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    unsigned int Size;
};

struct _D3DSURFACE_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    enum _D3DMULTISAMPLE_TYPE MultiSampleType;
    unsigned long MultiSampleQuality;
    unsigned int Width;
    unsigned int Height;
};

struct _D3DVOLUME_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
};

struct _D3DLOCKED_RECT
{
    int Pitch;
    void * pBits;
};

struct _D3DBOX
{
    unsigned int Left;
    unsigned int Top;
    unsigned int Right;
    unsigned int Bottom;
    unsigned int Front;
    unsigned int Back;
};

struct _D3DLOCKED_BOX
{
    int RowPitch;
    int SlicePitch;
    void * pBits;
};

struct _D3DRECTPATCH_INFO
{
    unsigned int StartVertexOffsetWidth;
    unsigned int StartVertexOffsetHeight;
    unsigned int Width;
    unsigned int Height;
    unsigned int Stride;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct _D3DTRIPATCH_INFO
{
    unsigned int StartVertexOffset;
    unsigned int NumVertices;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct _D3DADAPTER_IDENTIFIER9
{
    char Driver[512];
    char Description[512];
    char DeviceName[32];
    union _LARGE_INTEGER DriverVersion;
    unsigned long VendorId;
    unsigned long DeviceId;
    unsigned long SubSysId;
    unsigned long Revision;
    struct _GUID DeviceIdentifier;
    unsigned long WHQLLevel;
};

struct _D3DRASTER_STATUS
{
    int InVBlank;
    unsigned int ScanLine;
};

enum _D3DQUERYTYPE
{
    D3DQUERYTYPE_VCACHE=4,
    D3DQUERYTYPE_RESOURCEMANAGER=5,
    D3DQUERYTYPE_VERTEXSTATS=6,
    D3DQUERYTYPE_EVENT=8,
    D3DQUERYTYPE_OCCLUSION=9,
    D3DQUERYTYPE_TIMESTAMP=10,
    D3DQUERYTYPE_TIMESTAMPDISJOINT=11,
    D3DQUERYTYPE_TIMESTAMPFREQ=12,
    D3DQUERYTYPE_PIPELINETIMINGS=13,
    D3DQUERYTYPE_INTERFACETIMINGS=14,
    D3DQUERYTYPE_VERTEXTIMINGS=15,
    D3DQUERYTYPE_PIXELTIMINGS=16,
    D3DQUERYTYPE_BANDWIDTHTIMINGS=17,
    D3DQUERYTYPE_CACHEUTILIZATION=18,
    D3DQUERYTYPE_MEMORYPRESSURE=19
};

struct _D3DVSHADERCAPS2_0
{
    unsigned long Caps;
    int DynamicFlowControlDepth;
    int NumTemps;
    int StaticFlowControlDepth;
};

struct _D3DPSHADERCAPS2_0
{
    unsigned long Caps;
    int DynamicFlowControlDepth;
    int NumTemps;
    int StaticFlowControlDepth;
    int NumInstructionSlots;
};

struct _D3DCAPS9
{
    enum _D3DDEVTYPE DeviceType;
    unsigned int AdapterOrdinal;
    unsigned long Caps;
    unsigned long Caps2;
    unsigned long Caps3;
    unsigned long PresentationIntervals;
    unsigned long CursorCaps;
    unsigned long DevCaps;
    unsigned long PrimitiveMiscCaps;
    unsigned long RasterCaps;
    unsigned long ZCmpCaps;
    unsigned long SrcBlendCaps;
    unsigned long DestBlendCaps;
    unsigned long AlphaCmpCaps;
    unsigned long ShadeCaps;
    unsigned long TextureCaps;
    unsigned long TextureFilterCaps;
    unsigned long CubeTextureFilterCaps;
    unsigned long VolumeTextureFilterCaps;
    unsigned long TextureAddressCaps;
    unsigned long VolumeTextureAddressCaps;
    unsigned long LineCaps;
    unsigned long MaxTextureWidth;
    unsigned long MaxTextureHeight;
    unsigned long MaxVolumeExtent;
    unsigned long MaxTextureRepeat;
    unsigned long MaxTextureAspectRatio;
    unsigned long MaxAnisotropy;
    float MaxVertexW;
    float GuardBandLeft;
    float GuardBandTop;
    float GuardBandRight;
    float GuardBandBottom;
    float ExtentsAdjust;
    unsigned long StencilCaps;
    unsigned long FVFCaps;
    unsigned long TextureOpCaps;
    unsigned long MaxTextureBlendStages;
    unsigned long MaxSimultaneousTextures;
    unsigned long VertexProcessingCaps;
    unsigned long MaxActiveLights;
    unsigned long MaxUserClipPlanes;
    unsigned long MaxVertexBlendMatrices;
    unsigned long MaxVertexBlendMatrixIndex;
    float MaxPointSize;
    unsigned long MaxPrimitiveCount;
    unsigned long MaxVertexIndex;
    unsigned long MaxStreams;
    unsigned long MaxStreamStride;
    unsigned long VertexShaderVersion;
    unsigned long MaxVertexShaderConst;
    unsigned long PixelShaderVersion;
    float PixelShader1xMaxValue;
    unsigned long DevCaps2;
    float MaxNpatchTessellationLevel;
    unsigned long Reserved5;
    unsigned int MasterAdapterOrdinal;
    unsigned int AdapterOrdinalInGroup;
    unsigned int NumberOfAdaptersInGroup;
    unsigned long DeclTypes;
    unsigned long NumSimultaneousRTs;
    unsigned long StretchRectFilterCaps;
    struct _D3DVSHADERCAPS2_0 VS20Caps;
    struct _D3DPSHADERCAPS2_0 PS20Caps;
    unsigned long VertexTextureFilterCaps;
    unsigned long MaxVShaderInstructionsExecuted;
    unsigned long MaxPShaderInstructionsExecuted;
    unsigned long MaxVertexShader30InstructionSlots;
    unsigned long MaxPixelShader30InstructionSlots;
};

struct D3DXFLOAT16
{
    void D3DXFLOAT16(struct D3DXFLOAT16 & );
    void D3DXFLOAT16(float );
    void D3DXFLOAT16();
    float operator float();
    int operator==(struct D3DXFLOAT16 & );
    int operator!=(struct D3DXFLOAT16 & );
    unsigned int value;
};

struct D3DXFLOAT16
{
    void D3DXFLOAT16(struct D3DXFLOAT16 & );
    void D3DXFLOAT16(float );
    void D3DXFLOAT16();
    float operator float();
    int operator==(struct D3DXFLOAT16 & );
    int operator!=(struct D3DXFLOAT16 & );
    unsigned int value;
};

struct D3DXVECTOR2
{
    void D3DXVECTOR2(float ,float );
    void D3DXVECTOR2(struct D3DXFLOAT16 * );
    void D3DXVECTOR2(float * );
    void D3DXVECTOR2();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR2 & operator+=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator-=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator*=(float );
    struct D3DXVECTOR2 & operator/=(float );
    struct D3DXVECTOR2 operator+(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator+();
    struct D3DXVECTOR2 operator-(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator-();
    struct D3DXVECTOR2 operator*(float );
    struct D3DXVECTOR2 operator/(float );
    int operator==(struct D3DXVECTOR2 & );
    int operator!=(struct D3DXVECTOR2 & );
    float x;
    float y;
};

struct D3DXVECTOR2
{
    void D3DXVECTOR2(float ,float );
    void D3DXVECTOR2(struct D3DXFLOAT16 * );
    void D3DXVECTOR2(float * );
    void D3DXVECTOR2();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR2 & operator+=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator-=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator*=(float );
    struct D3DXVECTOR2 & operator/=(float );
    struct D3DXVECTOR2 operator+(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator+();
    struct D3DXVECTOR2 operator-(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator-();
    struct D3DXVECTOR2 operator*(float );
    struct D3DXVECTOR2 operator/(float );
    int operator==(struct D3DXVECTOR2 & );
    int operator!=(struct D3DXVECTOR2 & );
    float x;
    float y;
};

struct D3DXVECTOR2_16F
{
    void D3DXVECTOR2_16F(struct D3DXVECTOR2_16F & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR2_16F(float * );
    void D3DXVECTOR2_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR2_16F & );
    int operator!=(struct D3DXVECTOR2_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
};

struct D3DXVECTOR2_16F
{
    void D3DXVECTOR2_16F(struct D3DXVECTOR2_16F * );
    void D3DXVECTOR2_16F(struct D3DXVECTOR2_16F & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR2_16F(float * );
    void D3DXVECTOR2_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR2_16F & );
    int operator!=(struct D3DXVECTOR2_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
};

struct _D3DVECTOR
{
    float x;
    float y;
    float z;
};

struct D3DXVECTOR3 : public _D3DVECTOR
{
    void D3DXVECTOR3(float ,float ,float );
    void D3DXVECTOR3(struct D3DXFLOAT16 * );
    void D3DXVECTOR3(struct _D3DVECTOR & );
    void D3DXVECTOR3(float * );
    void D3DXVECTOR3();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR3 & operator+=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator-=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator*=(float );
    struct D3DXVECTOR3 & operator/=(float );
    struct D3DXVECTOR3 operator+(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator+();
    struct D3DXVECTOR3 operator-(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator-();
    struct D3DXVECTOR3 operator*(float );
    struct D3DXVECTOR3 operator/(float );
    int operator==(struct D3DXVECTOR3 & );
    int operator!=(struct D3DXVECTOR3 & );
};

struct D3DXVECTOR3 : public _D3DVECTOR
{
    void D3DXVECTOR3(float ,float ,float );
    void D3DXVECTOR3(struct D3DXFLOAT16 * );
    void D3DXVECTOR3(struct _D3DVECTOR & );
    void D3DXVECTOR3(float * );
    void D3DXVECTOR3();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR3 & operator+=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator-=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator*=(float );
    struct D3DXVECTOR3 & operator/=(float );
    struct D3DXVECTOR3 operator+(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator+();
    struct D3DXVECTOR3 operator-(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator-();
    struct D3DXVECTOR3 operator*(float );
    struct D3DXVECTOR3 operator/(float );
    int operator==(struct D3DXVECTOR3 & );
    int operator!=(struct D3DXVECTOR3 & );
};

struct D3DXVECTOR3_16F
{
    void D3DXVECTOR3_16F(struct D3DXVECTOR3_16F & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR3_16F(struct _D3DVECTOR & );
    void D3DXVECTOR3_16F(float * );
    void D3DXVECTOR3_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR3_16F & );
    int operator!=(struct D3DXVECTOR3_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
};

struct D3DXVECTOR3_16F
{
    void D3DXVECTOR3_16F(struct D3DXVECTOR3_16F * );
    void D3DXVECTOR3_16F(struct D3DXVECTOR3_16F & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR3_16F(struct _D3DVECTOR & );
    void D3DXVECTOR3_16F(float * );
    void D3DXVECTOR3_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR3_16F & );
    int operator!=(struct D3DXVECTOR3_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
};

struct D3DXVECTOR4
{
    void D3DXVECTOR4(float ,float ,float ,float );
    void D3DXVECTOR4(struct _D3DVECTOR & ,float );
    void D3DXVECTOR4(struct D3DXFLOAT16 * );
    void D3DXVECTOR4(float * );
    void D3DXVECTOR4();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR4 & operator+=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator-=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator*=(float );
    struct D3DXVECTOR4 & operator/=(float );
    struct D3DXVECTOR4 operator+(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator+();
    struct D3DXVECTOR4 operator-(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator-();
    struct D3DXVECTOR4 operator*(float );
    struct D3DXVECTOR4 operator/(float );
    int operator==(struct D3DXVECTOR4 & );
    int operator!=(struct D3DXVECTOR4 & );
    float x;
    float y;
    float z;
    float w;
};

struct D3DXVECTOR4
{
    void D3DXVECTOR4(float ,float ,float ,float );
    void D3DXVECTOR4(struct _D3DVECTOR & ,float );
    void D3DXVECTOR4(struct D3DXFLOAT16 * );
    void D3DXVECTOR4(float * );
    void D3DXVECTOR4();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR4 & operator+=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator-=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator*=(float );
    struct D3DXVECTOR4 & operator/=(float );
    struct D3DXVECTOR4 operator+(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator+();
    struct D3DXVECTOR4 operator-(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator-();
    struct D3DXVECTOR4 operator*(float );
    struct D3DXVECTOR4 operator/(float );
    int operator==(struct D3DXVECTOR4 & );
    int operator!=(struct D3DXVECTOR4 & );
    float x;
    float y;
    float z;
    float w;
};

struct D3DXVECTOR4_16F
{
    void D3DXVECTOR4_16F(struct D3DXVECTOR4_16F & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXVECTOR3_16F & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR4_16F(float * );
    void D3DXVECTOR4_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR4_16F & );
    int operator!=(struct D3DXVECTOR4_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
    struct D3DXFLOAT16 w;
};

struct D3DXVECTOR4_16F
{
    void D3DXVECTOR4_16F(struct D3DXVECTOR4_16F * );
    void D3DXVECTOR4_16F(struct D3DXVECTOR4_16F & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXVECTOR3_16F & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR4_16F(float * );
    void D3DXVECTOR4_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR4_16F & );
    int operator!=(struct D3DXVECTOR4_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
    struct D3DXFLOAT16 w;
};

struct _D3DMATRIX
{
    float _11;
    float _12;
    float _13;
    float _14;
    float _21;
    float _22;
    float _23;
    float _24;
    float _31;
    float _32;
    float _33;
    float _34;
    float _41;
    float _42;
    float _43;
    float _44;
    float m[4][4];
};

struct D3DXMATRIX : public _D3DMATRIX
{
    void D3DXMATRIX(float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    void D3DXMATRIX(struct D3DXFLOAT16 * );
    void D3DXMATRIX(struct _D3DMATRIX & );
    void D3DXMATRIX(float * );
    void D3DXMATRIX();
    float operator()(unsigned int ,unsigned int );
    float & operator()(unsigned int ,unsigned int );
    float * operator float *();
    float * operator const float *();
    struct D3DXMATRIX & operator*=(float );
    struct D3DXMATRIX & operator*=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator+=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator-=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator/=(float );
    struct D3DXMATRIX operator+(struct D3DXMATRIX & );
    struct D3DXMATRIX operator+();
    struct D3DXMATRIX operator-(struct D3DXMATRIX & );
    struct D3DXMATRIX operator-();
    struct D3DXMATRIX operator*(float );
    struct D3DXMATRIX operator*(struct D3DXMATRIX & );
    struct D3DXMATRIX operator/(float );
    int operator==(struct D3DXMATRIX & );
    int operator!=(struct D3DXMATRIX & );
};

struct D3DXMATRIX : public _D3DMATRIX
{
    void D3DXMATRIX(float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    void D3DXMATRIX(struct D3DXFLOAT16 * );
    void D3DXMATRIX(struct _D3DMATRIX & );
    void D3DXMATRIX(float * );
    void D3DXMATRIX();
    float operator()(unsigned int ,unsigned int );
    float & operator()(unsigned int ,unsigned int );
    float * operator float *();
    float * operator const float *();
    struct D3DXMATRIX & operator*=(float );
    struct D3DXMATRIX & operator*=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator+=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator-=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator/=(float );
    struct D3DXMATRIX operator+(struct D3DXMATRIX & );
    struct D3DXMATRIX operator+();
    struct D3DXMATRIX operator-(struct D3DXMATRIX & );
    struct D3DXMATRIX operator-();
    struct D3DXMATRIX operator*(float );
    struct D3DXMATRIX operator*(struct D3DXMATRIX & );
    struct D3DXMATRIX operator/(float );
    int operator==(struct D3DXMATRIX & );
    int operator!=(struct D3DXMATRIX & );
};

struct _D3DXMATRIXA16 : public D3DXMATRIX
{
    void _D3DXMATRIXA16(float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    void _D3DXMATRIXA16(struct D3DXFLOAT16 * );
    void _D3DXMATRIXA16(struct _D3DMATRIX & );
    void _D3DXMATRIXA16(float * );
    void _D3DXMATRIXA16();
    void * operator new(unsigned int );
    void * operator new[](unsigned int );
    void operator delete(void * );
    void operator delete[](void * );
};

struct D3DXQUATERNION
{
    void D3DXQUATERNION(float ,float ,float ,float );
    void D3DXQUATERNION(struct D3DXFLOAT16 * );
    void D3DXQUATERNION(float * );
    void D3DXQUATERNION();
    float * operator float *();
    float * operator const float *();
    struct D3DXQUATERNION & operator+=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator-=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator*=(float );
    struct D3DXQUATERNION & operator*=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator/=(float );
    struct D3DXQUATERNION operator+(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator+();
    struct D3DXQUATERNION operator-(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator-();
    struct D3DXQUATERNION operator*(float );
    struct D3DXQUATERNION operator*(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator/(float );
    int operator==(struct D3DXQUATERNION & );
    int operator!=(struct D3DXQUATERNION & );
    float x;
    float y;
    float z;
    float w;
};

struct D3DXQUATERNION
{
    void D3DXQUATERNION(float ,float ,float ,float );
    void D3DXQUATERNION(struct D3DXFLOAT16 * );
    void D3DXQUATERNION(float * );
    void D3DXQUATERNION();
    float * operator float *();
    float * operator const float *();
    struct D3DXQUATERNION & operator+=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator-=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator*=(float );
    struct D3DXQUATERNION & operator*=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator/=(float );
    struct D3DXQUATERNION operator+(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator+();
    struct D3DXQUATERNION operator-(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator-();
    struct D3DXQUATERNION operator*(float );
    struct D3DXQUATERNION operator*(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator/(float );
    int operator==(struct D3DXQUATERNION & );
    int operator!=(struct D3DXQUATERNION & );
    float x;
    float y;
    float z;
    float w;
};

struct D3DXPLANE
{
    void D3DXPLANE(float ,float ,float ,float );
    void D3DXPLANE(struct D3DXFLOAT16 * );
    void D3DXPLANE(float * );
    void D3DXPLANE();
    float * operator float *();
    float * operator const float *();
    struct D3DXPLANE & operator*=(float );
    struct D3DXPLANE & operator/=(float );
    struct D3DXPLANE operator+();
    struct D3DXPLANE operator-();
    struct D3DXPLANE operator*(float );
    struct D3DXPLANE operator/(float );
    int operator==(struct D3DXPLANE & );
    int operator!=(struct D3DXPLANE & );
    float a;
    float b;
    float c;
    float d;
};

struct D3DXPLANE
{
    void D3DXPLANE(float ,float ,float ,float );
    void D3DXPLANE(struct D3DXFLOAT16 * );
    void D3DXPLANE(float * );
    void D3DXPLANE();
    float * operator float *();
    float * operator const float *();
    struct D3DXPLANE & operator*=(float );
    struct D3DXPLANE & operator/=(float );
    struct D3DXPLANE operator+();
    struct D3DXPLANE operator-();
    struct D3DXPLANE operator*(float );
    struct D3DXPLANE operator/(float );
    int operator==(struct D3DXPLANE & );
    int operator!=(struct D3DXPLANE & );
    float a;
    float b;
    float c;
    float d;
};

struct _D3DCOLORVALUE
{
    float r;
    float g;
    float b;
    float a;
};

struct D3DXCOLOR
{
    void D3DXCOLOR(float ,float ,float ,float );
    void D3DXCOLOR(struct _D3DCOLORVALUE & );
    void D3DXCOLOR(struct D3DXFLOAT16 * );
    void D3DXCOLOR(float * );
    void D3DXCOLOR(unsigned long );
    void D3DXCOLOR();
    unsigned long operator unsigned long();
    float * operator float *();
    float * operator const float *();
    struct _D3DCOLORVALUE * operator struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE * operator const struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE & operator struct _D3DCOLORVALUE &();
    struct _D3DCOLORVALUE & operator const struct _D3DCOLORVALUE &();
    struct D3DXCOLOR & operator+=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator-=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator*=(float );
    struct D3DXCOLOR & operator/=(float );
    struct D3DXCOLOR operator+(struct D3DXCOLOR & );
    struct D3DXCOLOR operator+();
    struct D3DXCOLOR operator-(struct D3DXCOLOR & );
    struct D3DXCOLOR operator-();
    struct D3DXCOLOR operator*(float );
    struct D3DXCOLOR operator/(float );
    int operator==(struct D3DXCOLOR & );
    int operator!=(struct D3DXCOLOR & );
    float r;
    float g;
    float b;
    float a;
};

struct D3DXCOLOR
{
    void D3DXCOLOR(float ,float ,float ,float );
    void D3DXCOLOR(struct _D3DCOLORVALUE & );
    void D3DXCOLOR(struct D3DXFLOAT16 * );
    void D3DXCOLOR(float * );
    void D3DXCOLOR(unsigned long );
    void D3DXCOLOR();
    unsigned long operator unsigned long();
    float * operator float *();
    float * operator const float *();
    struct _D3DCOLORVALUE * operator struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE * operator const struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE & operator struct _D3DCOLORVALUE &();
    struct _D3DCOLORVALUE & operator const struct _D3DCOLORVALUE &();
    struct D3DXCOLOR & operator+=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator-=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator*=(float );
    struct D3DXCOLOR & operator/=(float );
    struct D3DXCOLOR operator+(struct D3DXCOLOR & );
    struct D3DXCOLOR operator+();
    struct D3DXCOLOR operator-(struct D3DXCOLOR & );
    struct D3DXCOLOR operator-();
    struct D3DXCOLOR operator*(float );
    struct D3DXCOLOR operator/(float );
    int operator==(struct D3DXCOLOR & );
    int operator!=(struct D3DXCOLOR & );
    float r;
    float g;
    float b;
    float a;
};

struct _D3DXFONT_DESCA
{
    int Height;
    unsigned int Width;
    unsigned int Weight;
    unsigned int MipLevels;
    int Italic;
    unsigned int CharSet;
    unsigned int OutputPrecision;
    unsigned int Quality;
    unsigned int PitchAndFamily;
    char FaceName[32];
};

struct _D3DXFONT_DESCW
{
    int Height;
    unsigned int Width;
    unsigned int Weight;
    unsigned int MipLevels;
    int Italic;
    unsigned int CharSet;
    unsigned int OutputPrecision;
    unsigned int Quality;
    unsigned int PitchAndFamily;
    wchar_t FaceName[32];
};

struct ID3DXFont : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDescA(struct _D3DXFONT_DESCA * );
    HRESULT GetDescW(struct _D3DXFONT_DESCW * );
    int GetTextMetricsA(struct tagTEXTMETRICA * );
    int GetTextMetricsW(struct tagTEXTMETRICW * );
    struct HDC__ * GetDC();
    HRESULT GetGlyphData(unsigned int ,struct IDirect3DTexture9 ** ,struct tagRECT * ,struct tagPOINT * );
    HRESULT PreloadCharacters(unsigned int ,unsigned int );
    HRESULT PreloadGlyphs(unsigned int ,unsigned int );
    HRESULT PreloadTextA(char * ,int );
    HRESULT PreloadTextW(wchar_t * ,int );
    int DrawTextA(struct ID3DXSprite * ,char * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    int DrawTextW(struct ID3DXSprite * ,wchar_t * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    HRESULT GetDesc(struct _D3DXFONT_DESCA * );
    HRESULT PreloadText(char * ,int );
    void ID3DXFont(struct ID3DXFont & );
    void ID3DXFont();
    struct ID3DXFont & operator=(struct ID3DXFont & );
};

struct ID3DXFont : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDescA(struct _D3DXFONT_DESCA * );
    HRESULT GetDescW(struct _D3DXFONT_DESCW * );
    int GetTextMetricsA(struct tagTEXTMETRICA * );
    int GetTextMetricsW(struct tagTEXTMETRICW * );
    struct HDC__ * GetDC();
    HRESULT GetGlyphData(unsigned int ,struct IDirect3DTexture9 ** ,struct tagRECT * ,struct tagPOINT * );
    HRESULT PreloadCharacters(unsigned int ,unsigned int );
    HRESULT PreloadGlyphs(unsigned int ,unsigned int );
    HRESULT PreloadTextA(char * ,int );
    HRESULT PreloadTextW(wchar_t * ,int );
    int DrawTextA(struct ID3DXSprite * ,char * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    int DrawTextW(struct ID3DXSprite * ,wchar_t * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    HRESULT GetDesc(struct _D3DXFONT_DESCA * );
    HRESULT PreloadText(char * ,int );
    void ID3DXFont(struct ID3DXFont * );
    void ID3DXFont(struct ID3DXFont & );
    void ID3DXFont();
    struct ID3DXFont & operator=(struct ID3DXFont * );
    struct ID3DXFont & operator=(struct ID3DXFont & );
};

struct IDirect3D9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT RegisterSoftwareDevice(void * );
    unsigned int GetAdapterCount();
    HRESULT GetAdapterIdentifier(unsigned int ,unsigned long ,struct _D3DADAPTER_IDENTIFIER9 * );
    unsigned int GetAdapterModeCount(unsigned int ,enum _D3DFORMAT );
    HRESULT EnumAdapterModes(unsigned int ,enum _D3DFORMAT ,unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetAdapterDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT CheckDeviceType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,int );
    HRESULT CheckDeviceFormat(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,unsigned long ,enum _D3DRESOURCETYPE ,enum _D3DFORMAT );
    HRESULT CheckDeviceMultiSampleType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,int ,enum _D3DMULTISAMPLE_TYPE ,unsigned long * );
    HRESULT CheckDepthStencilMatch(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT CheckDeviceFormatConversion(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT GetDeviceCaps(unsigned int ,enum _D3DDEVTYPE ,struct _D3DCAPS9 * );
    struct HMONITOR__ * GetAdapterMonitor(unsigned int );
    HRESULT CreateDevice(unsigned int ,enum _D3DDEVTYPE ,struct HWND__ * ,unsigned long ,struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DDevice9 ** );
    void IDirect3D9(struct IDirect3D9 & );
    void IDirect3D9();
    struct IDirect3D9 & operator=(struct IDirect3D9 & );
};

struct IDirect3D9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT RegisterSoftwareDevice(void * );
    unsigned int GetAdapterCount();
    HRESULT GetAdapterIdentifier(unsigned int ,unsigned long ,struct _D3DADAPTER_IDENTIFIER9 * );
    unsigned int GetAdapterModeCount(unsigned int ,enum _D3DFORMAT );
    HRESULT EnumAdapterModes(unsigned int ,enum _D3DFORMAT ,unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetAdapterDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT CheckDeviceType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,int );
    HRESULT CheckDeviceFormat(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,unsigned long ,enum _D3DRESOURCETYPE ,enum _D3DFORMAT );
    HRESULT CheckDeviceMultiSampleType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,int ,enum _D3DMULTISAMPLE_TYPE ,unsigned long * );
    HRESULT CheckDepthStencilMatch(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT CheckDeviceFormatConversion(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT GetDeviceCaps(unsigned int ,enum _D3DDEVTYPE ,struct _D3DCAPS9 * );
    struct HMONITOR__ * GetAdapterMonitor(unsigned int );
    HRESULT CreateDevice(unsigned int ,enum _D3DDEVTYPE ,struct HWND__ * ,unsigned long ,struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DDevice9 ** );
    void IDirect3D9(struct IDirect3D9 * );
    void IDirect3D9(struct IDirect3D9 & );
    void IDirect3D9();
    struct IDirect3D9 & operator=(struct IDirect3D9 * );
    struct IDirect3D9 & operator=(struct IDirect3D9 & );
};

struct _RGNDATA
{
    struct _RGNDATAHEADER rdh;
    char Buffer[1];
};

struct IDirect3DSwapChain9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * ,unsigned long );
    HRESULT GetFrontBufferData(struct IDirect3DSurface9 * );
    HRESULT GetBackBuffer(unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(struct _D3DRASTER_STATUS * );
    HRESULT GetDisplayMode(struct _D3DDISPLAYMODE * );
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetPresentParameters(struct _D3DPRESENT_PARAMETERS_ * );
    void IDirect3DSwapChain9(struct IDirect3DSwapChain9 & );
    void IDirect3DSwapChain9();
    struct IDirect3DSwapChain9 & operator=(struct IDirect3DSwapChain9 & );
};

struct IDirect3DSwapChain9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * ,unsigned long );
    HRESULT GetFrontBufferData(struct IDirect3DSurface9 * );
    HRESULT GetBackBuffer(unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(struct _D3DRASTER_STATUS * );
    HRESULT GetDisplayMode(struct _D3DDISPLAYMODE * );
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetPresentParameters(struct _D3DPRESENT_PARAMETERS_ * );
    void IDirect3DSwapChain9(struct IDirect3DSwapChain9 * );
    void IDirect3DSwapChain9(struct IDirect3DSwapChain9 & );
    void IDirect3DSwapChain9();
    struct IDirect3DSwapChain9 & operator=(struct IDirect3DSwapChain9 * );
    struct IDirect3DSwapChain9 & operator=(struct IDirect3DSwapChain9 & );
};

struct _D3DBOX
{
    unsigned int Left;
    unsigned int Top;
    unsigned int Right;
    unsigned int Bottom;
    unsigned int Front;
    unsigned int Back;
};

struct IDirect3DVolume9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DVOLUME_DESC * );
    HRESULT LockBox(struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox();
    void IDirect3DVolume9(struct IDirect3DVolume9 & );
    void IDirect3DVolume9();
    struct IDirect3DVolume9 & operator=(struct IDirect3DVolume9 & );
};

struct IDirect3DVolume9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DVOLUME_DESC * );
    HRESULT LockBox(struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox();
    void IDirect3DVolume9(struct IDirect3DVolume9 * );
    void IDirect3DVolume9(struct IDirect3DVolume9 & );
    void IDirect3DVolume9();
    struct IDirect3DVolume9 & operator=(struct IDirect3DVolume9 * );
    struct IDirect3DVolume9 & operator=(struct IDirect3DVolume9 & );
};

struct IDirect3DVolumeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DVOLUME_DESC * );
    HRESULT GetVolumeLevel(unsigned int ,struct IDirect3DVolume9 ** );
    HRESULT LockBox(unsigned int ,struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox(unsigned int );
    HRESULT AddDirtyBox(struct _D3DBOX * );
    void IDirect3DVolumeTexture9(struct IDirect3DVolumeTexture9 & );
    void IDirect3DVolumeTexture9();
    struct IDirect3DVolumeTexture9 & operator=(struct IDirect3DVolumeTexture9 & );
};

struct IDirect3DVolumeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DVOLUME_DESC * );
    HRESULT GetVolumeLevel(unsigned int ,struct IDirect3DVolume9 ** );
    HRESULT LockBox(unsigned int ,struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox(unsigned int );
    HRESULT AddDirtyBox(struct _D3DBOX * );
    void IDirect3DVolumeTexture9(struct IDirect3DVolumeTexture9 * );
    void IDirect3DVolumeTexture9(struct IDirect3DVolumeTexture9 & );
    void IDirect3DVolumeTexture9();
    struct IDirect3DVolumeTexture9 & operator=(struct IDirect3DVolumeTexture9 * );
    struct IDirect3DVolumeTexture9 & operator=(struct IDirect3DVolumeTexture9 & );
};

struct IDirect3DCubeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetCubeMapSurface(enum _D3DCUBEMAP_FACES ,unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(enum _D3DCUBEMAP_FACES ,unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(enum _D3DCUBEMAP_FACES ,unsigned int );
    HRESULT AddDirtyRect(enum _D3DCUBEMAP_FACES ,struct tagRECT * );
    void IDirect3DCubeTexture9(struct IDirect3DCubeTexture9 & );
    void IDirect3DCubeTexture9();
    struct IDirect3DCubeTexture9 & operator=(struct IDirect3DCubeTexture9 & );
};

struct IDirect3DCubeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetCubeMapSurface(enum _D3DCUBEMAP_FACES ,unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(enum _D3DCUBEMAP_FACES ,unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(enum _D3DCUBEMAP_FACES ,unsigned int );
    HRESULT AddDirtyRect(enum _D3DCUBEMAP_FACES ,struct tagRECT * );
    void IDirect3DCubeTexture9(struct IDirect3DCubeTexture9 * );
    void IDirect3DCubeTexture9(struct IDirect3DCubeTexture9 & );
    void IDirect3DCubeTexture9();
    struct IDirect3DCubeTexture9 & operator=(struct IDirect3DCubeTexture9 * );
    struct IDirect3DCubeTexture9 & operator=(struct IDirect3DCubeTexture9 & );
};

struct IDirect3DVertexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DVERTEXBUFFER_DESC * );
    void IDirect3DVertexBuffer9(struct IDirect3DVertexBuffer9 & );
    void IDirect3DVertexBuffer9();
    struct IDirect3DVertexBuffer9 & operator=(struct IDirect3DVertexBuffer9 & );
};

struct IDirect3DVertexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DVERTEXBUFFER_DESC * );
    void IDirect3DVertexBuffer9(struct IDirect3DVertexBuffer9 * );
    void IDirect3DVertexBuffer9(struct IDirect3DVertexBuffer9 & );
    void IDirect3DVertexBuffer9();
    struct IDirect3DVertexBuffer9 & operator=(struct IDirect3DVertexBuffer9 * );
    struct IDirect3DVertexBuffer9 & operator=(struct IDirect3DVertexBuffer9 & );
};

struct IDirect3DIndexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DINDEXBUFFER_DESC * );
    void IDirect3DIndexBuffer9(struct IDirect3DIndexBuffer9 & );
    void IDirect3DIndexBuffer9();
    struct IDirect3DIndexBuffer9 & operator=(struct IDirect3DIndexBuffer9 & );
};

struct IDirect3DIndexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DINDEXBUFFER_DESC * );
    void IDirect3DIndexBuffer9(struct IDirect3DIndexBuffer9 * );
    void IDirect3DIndexBuffer9(struct IDirect3DIndexBuffer9 & );
    void IDirect3DIndexBuffer9();
    struct IDirect3DIndexBuffer9 & operator=(struct IDirect3DIndexBuffer9 * );
    struct IDirect3DIndexBuffer9 & operator=(struct IDirect3DIndexBuffer9 & );
};

struct IDirect3DStateBlock9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT Capture();
    HRESULT Apply();
    void IDirect3DStateBlock9(struct IDirect3DStateBlock9 & );
    void IDirect3DStateBlock9();
    struct IDirect3DStateBlock9 & operator=(struct IDirect3DStateBlock9 & );
};

struct IDirect3DStateBlock9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT Capture();
    HRESULT Apply();
    void IDirect3DStateBlock9(struct IDirect3DStateBlock9 * );
    void IDirect3DStateBlock9(struct IDirect3DStateBlock9 & );
    void IDirect3DStateBlock9();
    struct IDirect3DStateBlock9 & operator=(struct IDirect3DStateBlock9 * );
    struct IDirect3DStateBlock9 & operator=(struct IDirect3DStateBlock9 & );
};

struct IDirect3DVertexDeclaration9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDeclaration(struct _D3DVERTEXELEMENT9 * ,unsigned int * );
    void IDirect3DVertexDeclaration9(struct IDirect3DVertexDeclaration9 & );
    void IDirect3DVertexDeclaration9();
    struct IDirect3DVertexDeclaration9 & operator=(struct IDirect3DVertexDeclaration9 & );
};

struct IDirect3DVertexDeclaration9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDeclaration(struct _D3DVERTEXELEMENT9 * ,unsigned int * );
    void IDirect3DVertexDeclaration9(struct IDirect3DVertexDeclaration9 * );
    void IDirect3DVertexDeclaration9(struct IDirect3DVertexDeclaration9 & );
    void IDirect3DVertexDeclaration9();
    struct IDirect3DVertexDeclaration9 & operator=(struct IDirect3DVertexDeclaration9 * );
    struct IDirect3DVertexDeclaration9 & operator=(struct IDirect3DVertexDeclaration9 & );
};

struct IDirect3DVertexShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DVertexShader9(struct IDirect3DVertexShader9 & );
    void IDirect3DVertexShader9();
    struct IDirect3DVertexShader9 & operator=(struct IDirect3DVertexShader9 & );
};

struct IDirect3DVertexShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DVertexShader9(struct IDirect3DVertexShader9 * );
    void IDirect3DVertexShader9(struct IDirect3DVertexShader9 & );
    void IDirect3DVertexShader9();
    struct IDirect3DVertexShader9 & operator=(struct IDirect3DVertexShader9 * );
    struct IDirect3DVertexShader9 & operator=(struct IDirect3DVertexShader9 & );
};

struct IDirect3DPixelShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DPixelShader9(struct IDirect3DPixelShader9 & );
    void IDirect3DPixelShader9();
    struct IDirect3DPixelShader9 & operator=(struct IDirect3DPixelShader9 & );
};

struct IDirect3DPixelShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DPixelShader9(struct IDirect3DPixelShader9 * );
    void IDirect3DPixelShader9(struct IDirect3DPixelShader9 & );
    void IDirect3DPixelShader9();
    struct IDirect3DPixelShader9 & operator=(struct IDirect3DPixelShader9 * );
    struct IDirect3DPixelShader9 & operator=(struct IDirect3DPixelShader9 & );
};

struct IDirect3DQuery9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    enum _D3DQUERYTYPE GetType();
    unsigned long GetDataSize();
    HRESULT Issue(unsigned long );
    HRESULT GetData(void * ,unsigned long ,unsigned long );
    void IDirect3DQuery9(struct IDirect3DQuery9 & );
    void IDirect3DQuery9();
    struct IDirect3DQuery9 & operator=(struct IDirect3DQuery9 & );
};

struct IDirect3DQuery9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    enum _D3DQUERYTYPE GetType();
    unsigned long GetDataSize();
    HRESULT Issue(unsigned long );
    HRESULT GetData(void * ,unsigned long ,unsigned long );
    void IDirect3DQuery9(struct IDirect3DQuery9 * );
    void IDirect3DQuery9(struct IDirect3DQuery9 & );
    void IDirect3DQuery9();
    struct IDirect3DQuery9 & operator=(struct IDirect3DQuery9 * );
    struct IDirect3DQuery9 & operator=(struct IDirect3DQuery9 & );
};

struct _D3DGAMMARAMP
{
    unsigned int red[256];
    unsigned int green[256];
    unsigned int blue[256];
};

struct _D3DRECT
{
    long x1;
    long y1;
    long x2;
    long y2;
};

struct _D3DVIEWPORT9
{
    unsigned long X;
    unsigned long Y;
    unsigned long Width;
    unsigned long Height;
    float MinZ;
    float MaxZ;
};

struct _D3DMATERIAL9
{
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Emissive;
    float Power;
};

struct _D3DLIGHT9
{
    enum _D3DLIGHTTYPE Type;
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DVECTOR Position;
    struct _D3DVECTOR Direction;
    float Range;
    float Falloff;
    float Attenuation0;
    float Attenuation1;
    float Attenuation2;
    float Theta;
    float Phi;
};

struct _D3DCLIPSTATUS9
{
    unsigned long ClipUnion;
    unsigned long ClipIntersection;
};

struct tagPALETTEENTRY
{
    unsigned int peRed;
    unsigned int peGreen;
    unsigned int peBlue;
    unsigned int peFlags;
};

struct _D3DVERTEXELEMENT9
{
    unsigned int Stream;
    unsigned int Offset;
    unsigned int Type;
    unsigned int Method;
    unsigned int Usage;
    unsigned int UsageIndex;
};

struct _D3DRECTPATCH_INFO
{
    unsigned int StartVertexOffsetWidth;
    unsigned int StartVertexOffsetHeight;
    unsigned int Width;
    unsigned int Height;
    unsigned int Stride;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct _D3DTRIPATCH_INFO
{
    unsigned int StartVertexOffset;
    unsigned int NumVertices;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct IDirect3DDevice9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT TestCooperativeLevel();
    unsigned int GetAvailableTextureMem();
    HRESULT EvictManagedResources();
    HRESULT GetDirect3D(struct IDirect3D9 ** );
    HRESULT GetDeviceCaps(struct _D3DCAPS9 * );
    HRESULT GetDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetCreationParameters(struct _D3DDEVICE_CREATION_PARAMETERS * );
    HRESULT SetCursorProperties(unsigned int ,unsigned int ,struct IDirect3DSurface9 * );
    void SetCursorPosition(int ,int ,unsigned long );
    int ShowCursor(int );
    HRESULT CreateAdditionalSwapChain(struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DSwapChain9 ** );
    HRESULT GetSwapChain(unsigned int ,struct IDirect3DSwapChain9 ** );
    unsigned int GetNumberOfSwapChains();
    HRESULT Reset(struct _D3DPRESENT_PARAMETERS_ * );
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * );
    HRESULT GetBackBuffer(unsigned int ,unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(unsigned int ,struct _D3DRASTER_STATUS * );
    HRESULT SetDialogBoxMode(int );
    void SetGammaRamp(unsigned int ,unsigned long ,struct _D3DGAMMARAMP * );
    void GetGammaRamp(unsigned int ,struct _D3DGAMMARAMP * );
    HRESULT CreateTexture(unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DTexture9 ** ,void ** );
    HRESULT CreateVolumeTexture(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DVolumeTexture9 ** ,void ** );
    HRESULT CreateCubeTexture(unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DCubeTexture9 ** ,void ** );
    HRESULT CreateVertexBuffer(unsigned int ,unsigned long ,unsigned long ,enum _D3DPOOL ,struct IDirect3DVertexBuffer9 ** ,void ** );
    HRESULT CreateIndexBuffer(unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DIndexBuffer9 ** ,void ** );
    HRESULT CreateRenderTarget(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT CreateDepthStencilSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT UpdateSurface(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagPOINT * );
    HRESULT UpdateTexture(struct IDirect3DBaseTexture9 * ,struct IDirect3DBaseTexture9 * );
    HRESULT GetRenderTargetData(struct IDirect3DSurface9 * ,struct IDirect3DSurface9 * );
    HRESULT GetFrontBufferData(unsigned int ,struct IDirect3DSurface9 * );
    HRESULT StretchRect(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagRECT * ,enum _D3DTEXTUREFILTERTYPE );
    HRESULT ColorFill(struct IDirect3DSurface9 * ,struct tagRECT * ,unsigned long );
    HRESULT CreateOffscreenPlainSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT SetRenderTarget(unsigned long ,struct IDirect3DSurface9 * );
    HRESULT GetRenderTarget(unsigned long ,struct IDirect3DSurface9 ** );
    HRESULT SetDepthStencilSurface(struct IDirect3DSurface9 * );
    HRESULT GetDepthStencilSurface(struct IDirect3DSurface9 ** );
    HRESULT BeginScene();
    HRESULT EndScene();
    HRESULT Clear(unsigned long ,struct _D3DRECT * ,unsigned long ,unsigned long ,float ,unsigned long );
    HRESULT SetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT GetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT MultiplyTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT SetViewport(struct _D3DVIEWPORT9 * );
    HRESULT GetViewport(struct _D3DVIEWPORT9 * );
    HRESULT SetMaterial(struct _D3DMATERIAL9 * );
    HRESULT GetMaterial(struct _D3DMATERIAL9 * );
    HRESULT SetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT GetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT LightEnable(unsigned long ,int );
    HRESULT GetLightEnable(unsigned long ,int * );
    HRESULT SetClipPlane(unsigned long ,float * );
    HRESULT GetClipPlane(unsigned long ,float * );
    HRESULT SetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long );
    HRESULT GetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long * );
    HRESULT CreateStateBlock(enum _D3DSTATEBLOCKTYPE ,struct IDirect3DStateBlock9 ** );
    HRESULT BeginStateBlock();
    HRESULT EndStateBlock(struct IDirect3DStateBlock9 ** );
    HRESULT SetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetTexture(unsigned long ,struct IDirect3DBaseTexture9 ** );
    HRESULT SetTexture(unsigned long ,struct IDirect3DBaseTexture9 * );
    HRESULT GetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long * );
    HRESULT SetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long );
    HRESULT GetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long * );
    HRESULT SetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long );
    HRESULT ValidateDevice(unsigned long * );
    HRESULT SetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT GetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT SetCurrentTexturePalette(unsigned int );
    HRESULT GetCurrentTexturePalette(unsigned int * );
    HRESULT SetScissorRect(struct tagRECT * );
    HRESULT GetScissorRect(struct tagRECT * );
    HRESULT SetSoftwareVertexProcessing(int );
    int GetSoftwareVertexProcessing();
    HRESULT SetNPatchMode(float );
    float GetNPatchMode();
    HRESULT DrawPrimitive(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int );
    HRESULT DrawIndexedPrimitive(enum _D3DPRIMITIVETYPE ,int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    HRESULT DrawPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,void * ,unsigned int );
    HRESULT DrawIndexedPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int ,unsigned int ,void * ,enum _D3DFORMAT ,void * ,unsigned int );
    HRESULT ProcessVertices(unsigned int ,unsigned int ,unsigned int ,struct IDirect3DVertexBuffer9 * ,struct IDirect3DVertexDeclaration9 * ,unsigned long );
    HRESULT CreateVertexDeclaration(struct _D3DVERTEXELEMENT9 * ,struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetVertexDeclaration(struct IDirect3DVertexDeclaration9 * );
    HRESULT GetVertexDeclaration(struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetFVF(unsigned long );
    HRESULT GetFVF(unsigned long * );
    HRESULT CreateVertexShader(unsigned long * ,struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShader(struct IDirect3DVertexShader9 * );
    HRESULT GetVertexShader(struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT SetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 * ,unsigned int ,unsigned int );
    HRESULT GetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 ** ,unsigned int * ,unsigned int * );
    HRESULT SetStreamSourceFreq(unsigned int ,unsigned int );
    HRESULT GetStreamSourceFreq(unsigned int ,unsigned int * );
    HRESULT SetIndices(struct IDirect3DIndexBuffer9 * );
    HRESULT GetIndices(struct IDirect3DIndexBuffer9 ** );
    HRESULT CreatePixelShader(unsigned long * ,struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShader(struct IDirect3DPixelShader9 * );
    HRESULT GetPixelShader(struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT DrawRectPatch(unsigned int ,float * ,struct _D3DRECTPATCH_INFO * );
    HRESULT DrawTriPatch(unsigned int ,float * ,struct _D3DTRIPATCH_INFO * );
    HRESULT DeletePatch(unsigned int );
    HRESULT CreateQuery(enum _D3DQUERYTYPE ,struct IDirect3DQuery9 ** );
    void IDirect3DDevice9(struct IDirect3DDevice9 & );
    void IDirect3DDevice9();
    struct IDirect3DDevice9 & operator=(struct IDirect3DDevice9 & );
};

struct IDirect3DDevice9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT TestCooperativeLevel();
    unsigned int GetAvailableTextureMem();
    HRESULT EvictManagedResources();
    HRESULT GetDirect3D(struct IDirect3D9 ** );
    HRESULT GetDeviceCaps(struct _D3DCAPS9 * );
    HRESULT GetDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetCreationParameters(struct _D3DDEVICE_CREATION_PARAMETERS * );
    HRESULT SetCursorProperties(unsigned int ,unsigned int ,struct IDirect3DSurface9 * );
    void SetCursorPosition(int ,int ,unsigned long );
    int ShowCursor(int );
    HRESULT CreateAdditionalSwapChain(struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DSwapChain9 ** );
    HRESULT GetSwapChain(unsigned int ,struct IDirect3DSwapChain9 ** );
    unsigned int GetNumberOfSwapChains();
    HRESULT Reset(struct _D3DPRESENT_PARAMETERS_ * );
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * );
    HRESULT GetBackBuffer(unsigned int ,unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(unsigned int ,struct _D3DRASTER_STATUS * );
    HRESULT SetDialogBoxMode(int );
    void SetGammaRamp(unsigned int ,unsigned long ,struct _D3DGAMMARAMP * );
    void GetGammaRamp(unsigned int ,struct _D3DGAMMARAMP * );
    HRESULT CreateTexture(unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DTexture9 ** ,void ** );
    HRESULT CreateVolumeTexture(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DVolumeTexture9 ** ,void ** );
    HRESULT CreateCubeTexture(unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DCubeTexture9 ** ,void ** );
    HRESULT CreateVertexBuffer(unsigned int ,unsigned long ,unsigned long ,enum _D3DPOOL ,struct IDirect3DVertexBuffer9 ** ,void ** );
    HRESULT CreateIndexBuffer(unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DIndexBuffer9 ** ,void ** );
    HRESULT CreateRenderTarget(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT CreateDepthStencilSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT UpdateSurface(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagPOINT * );
    HRESULT UpdateTexture(struct IDirect3DBaseTexture9 * ,struct IDirect3DBaseTexture9 * );
    HRESULT GetRenderTargetData(struct IDirect3DSurface9 * ,struct IDirect3DSurface9 * );
    HRESULT GetFrontBufferData(unsigned int ,struct IDirect3DSurface9 * );
    HRESULT StretchRect(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagRECT * ,enum _D3DTEXTUREFILTERTYPE );
    HRESULT ColorFill(struct IDirect3DSurface9 * ,struct tagRECT * ,unsigned long );
    HRESULT CreateOffscreenPlainSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT SetRenderTarget(unsigned long ,struct IDirect3DSurface9 * );
    HRESULT GetRenderTarget(unsigned long ,struct IDirect3DSurface9 ** );
    HRESULT SetDepthStencilSurface(struct IDirect3DSurface9 * );
    HRESULT GetDepthStencilSurface(struct IDirect3DSurface9 ** );
    HRESULT BeginScene();
    HRESULT EndScene();
    HRESULT Clear(unsigned long ,struct _D3DRECT * ,unsigned long ,unsigned long ,float ,unsigned long );
    HRESULT SetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT GetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT MultiplyTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT SetViewport(struct _D3DVIEWPORT9 * );
    HRESULT GetViewport(struct _D3DVIEWPORT9 * );
    HRESULT SetMaterial(struct _D3DMATERIAL9 * );
    HRESULT GetMaterial(struct _D3DMATERIAL9 * );
    HRESULT SetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT GetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT LightEnable(unsigned long ,int );
    HRESULT GetLightEnable(unsigned long ,int * );
    HRESULT SetClipPlane(unsigned long ,float * );
    HRESULT GetClipPlane(unsigned long ,float * );
    HRESULT SetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long );
    HRESULT GetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long * );
    HRESULT CreateStateBlock(enum _D3DSTATEBLOCKTYPE ,struct IDirect3DStateBlock9 ** );
    HRESULT BeginStateBlock();
    HRESULT EndStateBlock(struct IDirect3DStateBlock9 ** );
    HRESULT SetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetTexture(unsigned long ,struct IDirect3DBaseTexture9 ** );
    HRESULT SetTexture(unsigned long ,struct IDirect3DBaseTexture9 * );
    HRESULT GetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long * );
    HRESULT SetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long );
    HRESULT GetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long * );
    HRESULT SetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long );
    HRESULT ValidateDevice(unsigned long * );
    HRESULT SetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT GetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT SetCurrentTexturePalette(unsigned int );
    HRESULT GetCurrentTexturePalette(unsigned int * );
    HRESULT SetScissorRect(struct tagRECT * );
    HRESULT GetScissorRect(struct tagRECT * );
    HRESULT SetSoftwareVertexProcessing(int );
    int GetSoftwareVertexProcessing();
    HRESULT SetNPatchMode(float );
    float GetNPatchMode();
    HRESULT DrawPrimitive(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int );
    HRESULT DrawIndexedPrimitive(enum _D3DPRIMITIVETYPE ,int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    HRESULT DrawPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,void * ,unsigned int );
    HRESULT DrawIndexedPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int ,unsigned int ,void * ,enum _D3DFORMAT ,void * ,unsigned int );
    HRESULT ProcessVertices(unsigned int ,unsigned int ,unsigned int ,struct IDirect3DVertexBuffer9 * ,struct IDirect3DVertexDeclaration9 * ,unsigned long );
    HRESULT CreateVertexDeclaration(struct _D3DVERTEXELEMENT9 * ,struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetVertexDeclaration(struct IDirect3DVertexDeclaration9 * );
    HRESULT GetVertexDeclaration(struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetFVF(unsigned long );
    HRESULT GetFVF(unsigned long * );
    HRESULT CreateVertexShader(unsigned long * ,struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShader(struct IDirect3DVertexShader9 * );
    HRESULT GetVertexShader(struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT SetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 * ,unsigned int ,unsigned int );
    HRESULT GetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 ** ,unsigned int * ,unsigned int * );
    HRESULT SetStreamSourceFreq(unsigned int ,unsigned int );
    HRESULT GetStreamSourceFreq(unsigned int ,unsigned int * );
    HRESULT SetIndices(struct IDirect3DIndexBuffer9 * );
    HRESULT GetIndices(struct IDirect3DIndexBuffer9 ** );
    HRESULT CreatePixelShader(unsigned long * ,struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShader(struct IDirect3DPixelShader9 * );
    HRESULT GetPixelShader(struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT DrawRectPatch(unsigned int ,float * ,struct _D3DRECTPATCH_INFO * );
    HRESULT DrawTriPatch(unsigned int ,float * ,struct _D3DTRIPATCH_INFO * );
    HRESULT DeletePatch(unsigned int );
    HRESULT CreateQuery(enum _D3DQUERYTYPE ,struct IDirect3DQuery9 ** );
    void IDirect3DDevice9(struct IDirect3DDevice9 * );
    void IDirect3DDevice9(struct IDirect3DDevice9 & );
    void IDirect3DDevice9();
    struct IDirect3DDevice9 & operator=(struct IDirect3DDevice9 * );
    struct IDirect3DDevice9 & operator=(struct IDirect3DDevice9 & );
};

struct IDirect3DBaseTexture9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    void IDirect3DBaseTexture9(struct IDirect3DBaseTexture9 & );
    void IDirect3DBaseTexture9();
    struct IDirect3DBaseTexture9 & operator=(struct IDirect3DBaseTexture9 & );
};

struct IDirect3DBaseTexture9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    void IDirect3DBaseTexture9(struct IDirect3DBaseTexture9 * );
    void IDirect3DBaseTexture9(struct IDirect3DBaseTexture9 & );
    void IDirect3DBaseTexture9();
    struct IDirect3DBaseTexture9 & operator=(struct IDirect3DBaseTexture9 * );
    struct IDirect3DBaseTexture9 & operator=(struct IDirect3DBaseTexture9 & );
};

struct IDirect3DResource9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    void IDirect3DResource9(struct IDirect3DResource9 & );
    void IDirect3DResource9();
    struct IDirect3DResource9 & operator=(struct IDirect3DResource9 & );
};

struct IDirect3DResource9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    void IDirect3DResource9(struct IDirect3DResource9 * );
    void IDirect3DResource9(struct IDirect3DResource9 & );
    void IDirect3DResource9();
    struct IDirect3DResource9 & operator=(struct IDirect3DResource9 * );
    struct IDirect3DResource9 & operator=(struct IDirect3DResource9 & );
};

struct IDirect3DSurface9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DSURFACE_DESC * );
    HRESULT LockRect(struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect();
    HRESULT GetDC(struct HDC__ ** );
    HRESULT ReleaseDC(struct HDC__ * );
    void IDirect3DSurface9(struct IDirect3DSurface9 & );
    void IDirect3DSurface9();
    struct IDirect3DSurface9 & operator=(struct IDirect3DSurface9 & );
};

struct IDirect3DSurface9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DSURFACE_DESC * );
    HRESULT LockRect(struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect();
    HRESULT GetDC(struct HDC__ ** );
    HRESULT ReleaseDC(struct HDC__ * );
    void IDirect3DSurface9(struct IDirect3DSurface9 * );
    void IDirect3DSurface9(struct IDirect3DSurface9 & );
    void IDirect3DSurface9();
    struct IDirect3DSurface9 & operator=(struct IDirect3DSurface9 * );
    struct IDirect3DSurface9 & operator=(struct IDirect3DSurface9 & );
};

struct IDirect3DTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetSurfaceLevel(unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(unsigned int );
    HRESULT AddDirtyRect(struct tagRECT * );
    void IDirect3DTexture9(struct IDirect3DTexture9 & );
    void IDirect3DTexture9();
    struct IDirect3DTexture9 & operator=(struct IDirect3DTexture9 & );
};

struct IDirect3DTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetSurfaceLevel(unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(unsigned int );
    HRESULT AddDirtyRect(struct tagRECT * );
    void IDirect3DTexture9(struct IDirect3DTexture9 * );
    void IDirect3DTexture9(struct IDirect3DTexture9 & );
    void IDirect3DTexture9();
    struct IDirect3DTexture9 & operator=(struct IDirect3DTexture9 * );
    struct IDirect3DTexture9 & operator=(struct IDirect3DTexture9 & );
};

struct ID3DXSprite : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetTransform(struct D3DXMATRIX * );
    HRESULT SetTransform(struct D3DXMATRIX * );
    HRESULT SetWorldViewRH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT SetWorldViewLH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT Begin(unsigned long );
    HRESULT Draw(struct IDirect3DTexture9 * ,struct tagRECT * ,struct D3DXVECTOR3 * ,struct D3DXVECTOR3 * ,unsigned long );
    HRESULT Flush();
    HRESULT End();
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    void ID3DXSprite(struct ID3DXSprite & );
    void ID3DXSprite();
    struct ID3DXSprite & operator=(struct ID3DXSprite & );
};

struct ID3DXSprite : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetTransform(struct D3DXMATRIX * );
    HRESULT SetTransform(struct D3DXMATRIX * );
    HRESULT SetWorldViewRH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT SetWorldViewLH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT Begin(unsigned long );
    HRESULT Draw(struct IDirect3DTexture9 * ,struct tagRECT * ,struct D3DXVECTOR3 * ,struct D3DXVECTOR3 * ,unsigned long );
    HRESULT Flush();
    HRESULT End();
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    void ID3DXSprite(struct ID3DXSprite * );
    void ID3DXSprite(struct ID3DXSprite & );
    void ID3DXSprite();
    struct ID3DXSprite & operator=(struct ID3DXSprite * );
    struct ID3DXSprite & operator=(struct ID3DXSprite & );
};

struct SWaypoint
{
    float x;
    float z;
};

enum <unnamed-enum-TM_PLAYER>
{
    TM_PLAYER=1,
    TM_QUANTITY=2,
    TM_LOCATION=4,
    TM_UNITTYPE=8,
    TM_NEWUNIT=16,
    TM_DESTINATION=32,
    TM_SWITCH_COND=64,
    TM_SWITCH_ACT=128,
    TM_NUMBER=256
};

enum <unnamed-enum-CONDITION_ALWAYS>
{
    CONDITION_ALWAYS=0,
    CONDITION_NEVER=1,
    CONDITION_BRING=2,
    CONDITION_COMMAND=3,
    CONDITION_ELAPSED_TIME=4,
    CONDITION_SWITCH=5,
    CONDITION_COUNTDOWN=6,
    CONDITION_COMMAND_ACTIVE=7,
    CONDITION_BRING_ACTIVE=8,
    CONDITION_OBJECT=9,
    CONDITION_AMMO=10,
    CONDITION_FUEL=11,
    CONDITION_NOT_HIGHEST_SCORE=12,
    CONDITION_PULLER_ATTACHED=13,
    CONDITION_T_SELECTED_UNIT=14,
    CONDITION_T_UNIT_SPECIAL_MODE=15,
    CONDITION_HP=16,
    NUM_TRIGGER_CONDITION_TYPES=17
};

enum <unnamed-enum-ACTION_PAUSE_GAME>
{
    ACTION_PAUSE_GAME=0,
    ACTION_REMOVE_UNIT=1,
    ACTION_KILL_UNIT=2,
    ACTION_PRESERVE=3,
    ACTION_CREATE_UNIT=4,
    ACTION_MOVE_UNIT=5,
    ACTION_SET_SWITCH=6,
    ACTION_SPEECH=7,
    ACTION_WAIT=8,
    ACTION_START_COUNTDOWN=9,
    ACTION_VICTORY=10,
    ACTION_DEFEAT_NORMAL=11,
    ACTION_AIRSTRIKE=12,
    ACTION_PATROL_UNIT=13,
    ACTION_ACTIVATE_OBJECT=14,
    ACTION_ATTACK_OBJECT=15,
    ACTION_TRANSPORT=16,
    ACTION_PULL_ATTACH=17,
    ACTION_PULL_DETACH=18,
    ACTION_FOCUS_CAMERA=19,
    ACTION_SET_PLAYER=20,
    ACTION_DEMOLISH_OBJECT=21,
    ACTION_PREPARE_FLOOD=22,
    ACTION_RAISE_FLOOD=23,
    ACTION_HIDE_COUNTDOWN=24,
    ACTION_NUCLEAR_ATTACK=25,
    ACTION_START_ZEPPELIN=26,
    ACTION_T_SET_SP=27,
    ACTION_T_SET_UNIT_HP=28,
    ACTION_T_SET_UNIT_AMMO=29,
    ACTION_T_SET_UNIT_FUEL=30,
    ACTION_T_PLAY_SPEECH=31,
    ACTION_T_SHOW_TEXT=32,
    ACTION_T_HIDE_TEXT=33,
    ACTION_LOAD_UNIT=34,
    ACTION_DEFEAT_COUNTDOWN=35,
    ACTION_CTF_ADD_POINT=36,
    NUM_TRIGGER_ACTION_TYPES=37
};

enum <unnamed-enum-PK_MOVE_TO_POINT>
{
    PK_MOVE_TO_POINT=0,
    PK_FOLLOW=1,
    PK_STOP=2,
    PK_CHASE=3,
    PK_RETREAT=4,
    PK_ATTACK_GROUND=5,
    PK_ATTACK=6,
    PK_HOLD_FIRE=7,
    PK_RETURN_FIRE=8,
    PK_FIRE_AT_WILL=9,
    PK_SPEC_ACTION=10,
    PK_SPEC_TARGET_GROUND=11,
    PK_SPEC_TARGET_UNIT=12,
    PK_PLACE_UNITS=13,
    PK_BUY_UNIT=14,
    PK_ATTACK_DOODAD=15,
    PK_SET_LATENCY=16,
    PK_SET_COMPRESSRATIO=17,
    PK_ENDCRC=128
};

enum <unnamed-enum-SERVER_NONE>
{
    SERVER_NONE=0,
    SERVER_SINGLE=1,
    SERVER_MULTI=2
};

struct SHeap<SProjectile *>::__Tstruct
{
    int use;
    class SProjectile * data;
};

struct SExecutingTriggerOld
{
    int Trigger;
    int Action;
    unsigned long WaitTime;
    int Pause;
    int CamLocked;
};

struct SSentUnit
{
    float X;
    float Z;
    class SUnit * Unit;
};

class SDArray<SSentUnit>
{
    private int size;
    private int maxsize;
    public struct SSentUnit * array;
    public void SDArray<SSentUnit>(class SDArray<SSentUnit> & );
    public void SDArray<SSentUnit>();
    public void ~SDArray<SSentUnit>();
    public int Add(struct SSentUnit & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSentUnit & operator[](int );
    public void operator=(class SDArray<SSentUnit> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SSentUnit>
{
    private int size;
    private int maxsize;
    public struct SSentUnit * array;
    public void SDArray<SSentUnit>(class SDArray<SSentUnit> & );
    public void SDArray<SSentUnit>();
    public void ~SDArray<SSentUnit>();
    public int Add(struct SSentUnit & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSentUnit & operator[](int );
    public void operator=(class SDArray<SSentUnit> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SSentUnit
{
    float X;
    float Z;
    class SUnit * Unit;
};

struct <unnamed-type-PathBuffer2>
{
    int X;
    int Z;
    int Value;
    float Angle;
    float Dist;
};

class Array<SWaypoint>
{
    public void Array<SWaypoint>(class Array<SWaypoint> * );
    public void Array<SWaypoint>(class Array<SWaypoint> & );
    public void Array<SWaypoint>();
    public void ~Array<SWaypoint>();
    public void operator=(class ArrayRef<SWaypoint> & );
    public void operator=(class Array<SWaypoint> * );
    public void operator=(class Array<SWaypoint> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SWaypoint & operator[](unsigned int );
    public struct SWaypoint & operator[](unsigned int );
    public struct SWaypoint & GetLast();
    public struct SWaypoint & GetLast();
    public void Add(struct SWaypoint * );
    public void Add(struct SWaypoint & );
    public void Insert(unsigned int ,struct SWaypoint * );
    public void Insert(unsigned int ,struct SWaypoint & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SWaypoint & );
    public void RemoveLast();
    public struct SWaypoint * begin();
    public struct SWaypoint * begin();
    public struct SWaypoint * end();
    public struct SWaypoint * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SWaypoint> operator class ArrayRef<struct SWaypoint>();
    private struct SWaypoint * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SWaypoint * Allocate(unsigned int );
    private void Deallocate(struct SWaypoint * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ArrayRef<SWaypoint>
{
};

struct SWaypoint
{
    float x;
    float z;
};

class Array<SWaypoint>
{
    public void Array<SWaypoint>(class Array<SWaypoint> * );
    public void Array<SWaypoint>(class Array<SWaypoint> & );
    public void Array<SWaypoint>();
    public void ~Array<SWaypoint>();
    public void operator=(class ArrayRef<SWaypoint> & );
    public void operator=(class Array<SWaypoint> * );
    public void operator=(class Array<SWaypoint> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SWaypoint & operator[](unsigned int );
    public struct SWaypoint & operator[](unsigned int );
    public struct SWaypoint & GetLast();
    public struct SWaypoint & GetLast();
    public void Add(struct SWaypoint * );
    public void Add(struct SWaypoint & );
    public void Insert(unsigned int ,struct SWaypoint * );
    public void Insert(unsigned int ,struct SWaypoint & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SWaypoint & );
    public void RemoveLast();
    public struct SWaypoint * begin();
    public struct SWaypoint * begin();
    public struct SWaypoint * end();
    public struct SWaypoint * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SWaypoint> operator class ArrayRef<struct SWaypoint>();
    private struct SWaypoint * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SWaypoint * Allocate(unsigned int );
    private void Deallocate(struct SWaypoint * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

enum SGameWorld::GetPanelStatus::__l2::<unnamed-enum-SPEC_UNSET>
{
    SPEC_UNSET=-1,
    SPEC_NOT_PRESENT=-2,
    SPEC_INCONSISTENT=-3
};

enum <unnamed-enum-GAMEMODE_NONE>
{
    GAMEMODE_NONE=0,
    GAMEMODE_SCENARIO=1,
    GAMEMODE_CAMPAIGN=2,
    GAMEMODE_MULTI=3,
    GAMEMODE_TUTORIAL=4
};

struct _SYSTEMTIME
{
    unsigned int wYear;
    unsigned int wMonth;
    unsigned int wDayOfWeek;
    unsigned int wDay;
    unsigned int wHour;
    unsigned int wMinute;
    unsigned int wSecond;
    unsigned int wMilliseconds;
};

enum <unnamed-enum-EVENT_RECORDING>
{
    EVENT_RECORDING=1,
    EVENT_PLAYBACK=2
};

struct SHeap<UserEventProp>::__Tstruct
{
    int use;
    struct UserEventProp data;
};

struct tagWNDCLASSEXW
{
    unsigned int cbSize;
    unsigned int style;
    long  ( * lpfnWndProc)(struct HWND__ * ,unsigned int ,unsigned int ,long );
    int cbClsExtra;
    int cbWndExtra;
    struct HINSTANCE__ * hInstance;
    struct HICON__ * hIcon;
    struct HICON__ * hCursor;
    struct HBRUSH__ * hbrBackground;
    wchar_t * lpszMenuName;
    wchar_t * lpszClassName;
    struct HICON__ * hIconSm;
};

struct tagMSG
{
    struct HWND__ * hwnd;
    unsigned int message;
    unsigned int wParam;
    long lParam;
    unsigned long time;
    struct tagPOINT pt;
};

struct tagPAINTSTRUCT
{
    struct HDC__ * hdc;
    int fErase;
    struct tagRECT rcPaint;
    int fRestore;
    int fIncUpdate;
    unsigned int rgbReserved[32];
};

class SHeap<STimerProp>
{
    struct __Tstruct
    {
        int use;
        struct STimerProp data;
    };
    private struct SHeap<STimerProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<STimerProp>();
    public void ~SHeap<STimerProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct STimerProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<STimerProp>
{
    struct __Tstruct
    {
        int use;
        struct STimerProp data;
    };
    private struct SHeap<STimerProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<STimerProp>();
    public void ~SHeap<STimerProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct STimerProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SHeap<STimerProp>::__Tstruct
{
    int use;
    struct STimerProp data;
};

struct STimerProp
{
    unsigned long IDEvent;
    class SWidget * Target;
};

enum tagExtentMode
{
    DVEXTENT_CONTENT=0,
    DVEXTENT_INTEGRAL=1
};

enum _com_error::<unnamed-enum-WCODE_HRESULT_FIRST>
{
    WCODE_HRESULT_FIRST=-2147220992,
    WCODE_HRESULT_LAST=-2147155969
};

struct _DSCAPS
{
    unsigned long dwSize;
    unsigned long dwFlags;
    unsigned long dwMinSecondarySampleRate;
    unsigned long dwMaxSecondarySampleRate;
    unsigned long dwPrimaryBuffers;
    unsigned long dwMaxHwMixingAllBuffers;
    unsigned long dwMaxHwMixingStaticBuffers;
    unsigned long dwMaxHwMixingStreamingBuffers;
    unsigned long dwFreeHwMixingAllBuffers;
    unsigned long dwFreeHwMixingStaticBuffers;
    unsigned long dwFreeHwMixingStreamingBuffers;
    unsigned long dwMaxHw3DAllBuffers;
    unsigned long dwMaxHw3DStaticBuffers;
    unsigned long dwMaxHw3DStreamingBuffers;
    unsigned long dwFreeHw3DAllBuffers;
    unsigned long dwFreeHw3DStaticBuffers;
    unsigned long dwFreeHw3DStreamingBuffers;
    unsigned long dwTotalHwMemBytes;
    unsigned long dwFreeHwMemBytes;
    unsigned long dwMaxContigFreeHwMemBytes;
    unsigned long dwUnlockTransferRateHwBuffers;
    unsigned long dwPlayCpuOverheadSwBuffers;
    unsigned long dwReserved1;
    unsigned long dwReserved2;
};

struct _DSBUFFERDESC
{
    unsigned long dwSize;
    unsigned long dwFlags;
    unsigned long dwBufferBytes;
    unsigned long dwReserved;
    struct tWAVEFORMATEX * lpwfxFormat;
    struct _GUID guid3DAlgorithm;
};

struct _DSBUFFERDESC
{
    unsigned long dwSize;
    unsigned long dwFlags;
    unsigned long dwBufferBytes;
    unsigned long dwReserved;
    struct tWAVEFORMATEX * lpwfxFormat;
    struct _GUID guid3DAlgorithm;
};

struct _DS3DBUFFER
{
    unsigned long dwSize;
    struct _D3DVECTOR vPosition;
    struct _D3DVECTOR vVelocity;
    unsigned long dwInsideConeAngle;
    unsigned long dwOutsideConeAngle;
    struct _D3DVECTOR vConeOrientation;
    long lConeOutsideVolume;
    float flMinDistance;
    float flMaxDistance;
    unsigned long dwMode;
};

struct _DS3DBUFFER
{
    unsigned long dwSize;
    struct _D3DVECTOR vPosition;
    struct _D3DVECTOR vVelocity;
    unsigned long dwInsideConeAngle;
    unsigned long dwOutsideConeAngle;
    struct _D3DVECTOR vConeOrientation;
    long lConeOutsideVolume;
    float flMinDistance;
    float flMaxDistance;
    unsigned long dwMode;
};

struct _DS3DLISTENER
{
    unsigned long dwSize;
    struct _D3DVECTOR vPosition;
    struct _D3DVECTOR vVelocity;
    struct _D3DVECTOR vOrientFront;
    struct _D3DVECTOR vOrientTop;
    float flDistanceFactor;
    float flRolloffFactor;
    float flDopplerFactor;
};

struct _DS3DLISTENER
{
    unsigned long dwSize;
    struct _D3DVECTOR vPosition;
    struct _D3DVECTOR vVelocity;
    struct _D3DVECTOR vOrientFront;
    struct _D3DVECTOR vOrientTop;
    float flDistanceFactor;
    float flRolloffFactor;
    float flDopplerFactor;
};

struct SMpegAudioFrame
{
    int version;
    int lay;
    int error_protection;
    int bitrate_index;
    int sampling_frequency;
    int padding;
    int extension;
    int mode;
    int mode_ext;
    int copyright;
    int original;
    int emphasis;
    int stereo;
    int size;
    int real_freq;
    int num;
};

class _variant_t : public tagVARIANT
{
    public void _variant_t(unsigned int );
    public void _variant_t(int );
    public void _variant_t(unsigned int );
    public void _variant_t(int );
    public void _variant_t(unsigned long );
    public void _variant_t(unsigned int );
    public void _variant_t(char );
    public void _variant_t(unsigned int );
    public void _variant_t(struct tagDEC & );
    public void _variant_t(struct IUnknown * ,bool );
    public void _variant_t(bool );
    public void _variant_t(struct IDispatch * ,bool );
    public void _variant_t(char * );
    public void _variant_t(wchar_t * );
    public void _variant_t(class _bstr_t & );
    public void _variant_t(union tagCY & );
    public void _variant_t(float ,unsigned int );
    public void _variant_t(float );
    public void _variant_t(long ,unsigned int );
    public void _variant_t(int ,unsigned int );
    public void _variant_t(struct tagVARIANT & ,bool );
    public void _variant_t(class _variant_t & );
    public void _variant_t(struct tagVARIANT * );
    public void _variant_t(struct tagVARIANT & );
    public void _variant_t();
    public void ~_variant_t();
    public int operator short();
    public long operator long();
    public float operator float();
    public float operator double();
    public union tagCY operator union tagCY();
    public class _bstr_t operator class _bstr_t();
    public struct IDispatch * operator struct IDispatch *();
    public bool operator bool();
    public struct IUnknown * operator struct IUnknown *();
    public struct tagDEC operator struct tagDEC();
    public unsigned int operator unsigned char();
    public struct tagVARIANT operator struct tagVARIANT();
    public char operator char();
    public unsigned int operator unsigned short();
    public unsigned long operator unsigned long();
    public int operator int();
    public unsigned int operator unsigned int();
    public int operator __int64();
    public unsigned int operator unsigned __int64();
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(int );
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(int );
    public class _variant_t & operator=(unsigned long );
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(char );
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(struct tagDEC & );
    public class _variant_t & operator=(struct IUnknown * );
    public class _variant_t & operator=(bool );
    public class _variant_t & operator=(struct IDispatch * );
    public class _variant_t & operator=(char * );
    public class _variant_t & operator=(wchar_t * );
    public class _variant_t & operator=(class _bstr_t & );
    public class _variant_t & operator=(union tagCY & );
    public class _variant_t & operator=(float );
    public class _variant_t & operator=(float );
    public class _variant_t & operator=(long );
    public class _variant_t & operator=(int );
    public class _variant_t & operator=(class _variant_t & );
    public class _variant_t & operator=(struct tagVARIANT * );
    public class _variant_t & operator=(struct tagVARIANT & );
    public bool operator==(struct tagVARIANT * );
    public bool operator==(struct tagVARIANT & );
    public bool operator!=(struct tagVARIANT * );
    public bool operator!=(struct tagVARIANT & );
    public void Clear();
    public void Attach(struct tagVARIANT & );
    public struct tagVARIANT Detach();
    public struct tagVARIANT & GetVARIANT();
    public struct tagVARIANT * GetAddress();
    public void ChangeType(unsigned int ,class _variant_t * );
    public void SetString(char * );
    public void * __vecDelDtor(unsigned int );
};

class _bstr_t
{
    public void _bstr_t(wchar_t * ,bool );
    public void _bstr_t(class _variant_t & );
    public void _bstr_t(wchar_t * );
    public void _bstr_t(char * );
    public void _bstr_t(class _bstr_t & );
    public void _bstr_t();
    public void ~_bstr_t();
    public class _bstr_t & operator=(class _variant_t & );
    public class _bstr_t & operator=(wchar_t * );
    public class _bstr_t & operator=(char * );
    public class _bstr_t & operator=(class _bstr_t & );
    public class _bstr_t & operator+=(class _bstr_t & );
    public class _bstr_t operator+(class _bstr_t & );
    public wchar_t * operator const wchar_t *();
    public wchar_t * operator wchar_t *();
    public char * operator const char *();
    public char * operator char *();
    public bool operator!();
    public bool operator==(class _bstr_t & );
    public bool operator!=(class _bstr_t & );
    public bool operator<(class _bstr_t & );
    public bool operator>(class _bstr_t & );
    public bool operator<=(class _bstr_t & );
    public bool operator>=(class _bstr_t & );
    public wchar_t * copy(bool );
    public unsigned int length();
    public void Assign(wchar_t * );
    public wchar_t &** GetBSTR();
    public wchar_t ** GetAddress();
    public void Attach(wchar_t * );
    public wchar_t * Detach();
    class Data_t
    {
        private void Data_t(class _bstr_t::Data_t & );
        private void Data_t();
        public void Data_t(class _bstr_t & ,class _bstr_t & );
        public void Data_t(wchar_t * ,bool );
        public void Data_t(wchar_t * );
        public void Data_t(char * );
        public unsigned long AddRef();
        public unsigned long Release();
        public unsigned long RefCount();
        public wchar_t * operator const wchar_t *();
        public char * operator const char *();
        public wchar_t &** GetWString();
        public wchar_t * GetWString();
        public char * GetString();
        public wchar_t * Copy();
        public void Assign(wchar_t * );
        public void Attach(wchar_t * );
        public unsigned int Length();
        public int Compare(class _bstr_t::Data_t & );
        public void * operator new(unsigned int );
        private wchar_t * m_wstr;
        private char * m_str;
        private unsigned long m_RefCount;
        private void ~Data_t();
        private void _Free();
        private void * __vecDelDtor(unsigned int );
    };
    private class _bstr_t::Data_t * m_Data;
    private void _AddRef();
    private void _Free();
    private int _Compare(class _bstr_t & );
    public void * __vecDelDtor(unsigned int );
};

class _bstr_t
{
    public void _bstr_t(wchar_t * ,bool );
    public void _bstr_t(class _variant_t & );
    public void _bstr_t(wchar_t * );
    public void _bstr_t(char * );
    public void _bstr_t(class _bstr_t & );
    public void _bstr_t();
    public void ~_bstr_t();
    public class _bstr_t & operator=(class _variant_t & );
    public class _bstr_t & operator=(wchar_t * );
    public class _bstr_t & operator=(char * );
    public class _bstr_t & operator=(class _bstr_t & );
    public class _bstr_t & operator+=(class _bstr_t & );
    public class _bstr_t operator+(class _bstr_t & );
    public wchar_t * operator const wchar_t *();
    public wchar_t * operator wchar_t *();
    public char * operator const char *();
    public char * operator char *();
    public bool operator!();
    public bool operator==(class _bstr_t & );
    public bool operator!=(class _bstr_t & );
    public bool operator<(class _bstr_t & );
    public bool operator>(class _bstr_t & );
    public bool operator<=(class _bstr_t & );
    public bool operator>=(class _bstr_t & );
    public wchar_t * copy(bool );
    public unsigned int length();
    public void Assign(wchar_t * );
    public wchar_t &** GetBSTR();
    public wchar_t ** GetAddress();
    public void Attach(wchar_t * );
    public wchar_t * Detach();
    class Data_t
    {
        private void Data_t(class _bstr_t::Data_t & );
        private void Data_t();
        public void Data_t(class _bstr_t & ,class _bstr_t & );
        public void Data_t(wchar_t * ,bool );
        public void Data_t(wchar_t * );
        public void Data_t(char * );
        public unsigned long AddRef();
        public unsigned long Release();
        public unsigned long RefCount();
        public wchar_t * operator const wchar_t *();
        public char * operator const char *();
        public wchar_t &** GetWString();
        public wchar_t * GetWString();
        public char * GetString();
        public wchar_t * Copy();
        public void Assign(wchar_t * );
        public void Attach(wchar_t * );
        public unsigned int Length();
        public int Compare(class _bstr_t::Data_t & );
        public void * operator new(unsigned int );
        private wchar_t * m_wstr;
        private char * m_str;
        private unsigned long m_RefCount;
        private void ~Data_t();
        private void _Free();
        private void * __vecDelDtor(unsigned int );
    };
    private class _bstr_t::Data_t * m_Data;
    private void _AddRef();
    private void _Free();
    private int _Compare(class _bstr_t & );
    public void * __vecDelDtor(unsigned int );
};

struct tagDEC
{
    unsigned int wReserved;
    unsigned int scale;
    unsigned int sign;
    unsigned int signscale;
    unsigned long Hi32;
    unsigned long Lo32;
    unsigned long Mid32;
    unsigned int Lo64;
};

union tagCY
{
    unsigned long Lo;
    long Hi;
    int int64;
};

struct tagVARIANT
{
    unsigned int vt;
    unsigned int wReserved1;
    unsigned int wReserved2;
    unsigned int wReserved3;
    int llVal;
    long lVal;
    unsigned int bVal;
    int iVal;
    float fltVal;
    float dblVal;
    int boolVal;
    long scode;
    union tagCY cyVal;
    float date;
    wchar_t * bstrVal;
    struct IUnknown * punkVal;
    struct IDispatch * pdispVal;
    struct tagSAFEARRAY * parray;
    unsigned int * pbVal;
    int * piVal;
    long * plVal;
    int * pllVal;
    float * pfltVal;
    float * pdblVal;
    int * pboolVal;
    long * pscode;
    union tagCY * pcyVal;
    float * pdate;
    wchar_t ** pbstrVal;
    struct IUnknown ** ppunkVal;
    struct IDispatch ** ppdispVal;
    struct tagSAFEARRAY ** pparray;
    struct tagVARIANT * pvarVal;
    void * byref;
    char cVal;
    unsigned int uiVal;
    unsigned long ulVal;
    unsigned int ullVal;
    int intVal;
    unsigned int uintVal;
    struct tagDEC * pdecVal;
    char * pcVal;
    unsigned int * puiVal;
    unsigned long * pulVal;
    unsigned int * pullVal;
    int * pintVal;
    unsigned int * puintVal;
    void * pvRecord;
    struct IRecordInfo * pRecInfo;
    struct tagDEC decVal;
};

class _variant_t : public tagVARIANT
{
    public void _variant_t(unsigned int );
    public void _variant_t(int );
    public void _variant_t(unsigned int );
    public void _variant_t(int );
    public void _variant_t(unsigned long );
    public void _variant_t(unsigned int );
    public void _variant_t(char );
    public void _variant_t(unsigned int );
    public void _variant_t(struct tagDEC & );
    public void _variant_t(struct IUnknown * ,bool );
    public void _variant_t(bool );
    public void _variant_t(struct IDispatch * ,bool );
    public void _variant_t(char * );
    public void _variant_t(wchar_t * );
    public void _variant_t(class _bstr_t & );
    public void _variant_t(union tagCY & );
    public void _variant_t(float ,unsigned int );
    public void _variant_t(float );
    public void _variant_t(long ,unsigned int );
    public void _variant_t(int ,unsigned int );
    public void _variant_t(struct tagVARIANT & ,bool );
    public void _variant_t(class _variant_t & );
    public void _variant_t(struct tagVARIANT * );
    public void _variant_t(struct tagVARIANT & );
    public void _variant_t();
    public void ~_variant_t();
    public int operator short();
    public long operator long();
    public float operator float();
    public float operator double();
    public union tagCY operator union tagCY();
    public class _bstr_t operator class _bstr_t();
    public struct IDispatch * operator struct IDispatch *();
    public bool operator bool();
    public struct IUnknown * operator struct IUnknown *();
    public struct tagDEC operator struct tagDEC();
    public unsigned int operator unsigned char();
    public struct tagVARIANT operator struct tagVARIANT();
    public char operator char();
    public unsigned int operator unsigned short();
    public unsigned long operator unsigned long();
    public int operator int();
    public unsigned int operator unsigned int();
    public int operator __int64();
    public unsigned int operator unsigned __int64();
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(int );
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(int );
    public class _variant_t & operator=(unsigned long );
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(char );
    public class _variant_t & operator=(unsigned int );
    public class _variant_t & operator=(struct tagDEC & );
    public class _variant_t & operator=(struct IUnknown * );
    public class _variant_t & operator=(bool );
    public class _variant_t & operator=(struct IDispatch * );
    public class _variant_t & operator=(char * );
    public class _variant_t & operator=(wchar_t * );
    public class _variant_t & operator=(class _bstr_t & );
    public class _variant_t & operator=(union tagCY & );
    public class _variant_t & operator=(float );
    public class _variant_t & operator=(float );
    public class _variant_t & operator=(long );
    public class _variant_t & operator=(int );
    public class _variant_t & operator=(class _variant_t & );
    public class _variant_t & operator=(struct tagVARIANT * );
    public class _variant_t & operator=(struct tagVARIANT & );
    public bool operator==(struct tagVARIANT * );
    public bool operator==(struct tagVARIANT & );
    public bool operator!=(struct tagVARIANT * );
    public bool operator!=(struct tagVARIANT & );
    public void Clear();
    public void Attach(struct tagVARIANT & );
    public struct tagVARIANT Detach();
    public struct tagVARIANT & GetVARIANT();
    public struct tagVARIANT * GetAddress();
    public void ChangeType(unsigned int ,class _variant_t * );
    public void SetString(char * );
    public void * __vecDelDtor(unsigned int );
};

class _bstr_t::Data_t
{
    private void Data_t(class _bstr_t::Data_t & );
    private void Data_t();
    public void Data_t(class _bstr_t & ,class _bstr_t & );
    public void Data_t(wchar_t * ,bool );
    public void Data_t(wchar_t * );
    public void Data_t(char * );
    public unsigned long AddRef();
    public unsigned long Release();
    public unsigned long RefCount();
    public wchar_t * operator const wchar_t *();
    public char * operator const char *();
    public wchar_t &** GetWString();
    public wchar_t * GetWString();
    public char * GetString();
    public wchar_t * Copy();
    public void Assign(wchar_t * );
    public void Attach(wchar_t * );
    public unsigned int Length();
    public int Compare(class _bstr_t::Data_t & );
    public void * operator new(unsigned int );
    private wchar_t * m_wstr;
    private char * m_str;
    private unsigned long m_RefCount;
    private void ~Data_t();
    private void _Free();
    private void * __vecDelDtor(unsigned int );
};

class _bstr_t::Data_t
{
    private void Data_t(class _bstr_t::Data_t & );
    private void Data_t();
    public void Data_t(class _bstr_t & ,class _bstr_t & );
    public void Data_t(wchar_t * ,bool );
    public void Data_t(wchar_t * );
    public void Data_t(char * );
    public unsigned long AddRef();
    public unsigned long Release();
    public unsigned long RefCount();
    public wchar_t * operator const wchar_t *();
    public char * operator const char *();
    public wchar_t &** GetWString();
    public wchar_t * GetWString();
    public char * GetString();
    public wchar_t * Copy();
    public void Assign(wchar_t * );
    public void Attach(wchar_t * );
    public unsigned int Length();
    public int Compare(class _bstr_t::Data_t & );
    public void * operator new(unsigned int );
    private wchar_t * m_wstr;
    private char * m_str;
    private unsigned long m_RefCount;
    private void ~Data_t();
    private void _Free();
    private void * __vecDelDtor(unsigned int );
};

class _com_error
{
    public void _com_error(class _com_error & );
    public void _com_error(HRESULT ,struct IErrorInfo * ,bool );
    public void ~_com_error();
    public class _com_error & operator=(class _com_error & );
    public HRESULT Error();
    public unsigned int WCode();
    public struct IErrorInfo * ErrorInfo();
    public class _bstr_t Description();
    public unsigned long HelpContext();
    public class _bstr_t HelpFile();
    public class _bstr_t Source();
    public struct _GUID GUID();
    public char * ErrorMessage();
    public HRESULT WCodeToHRESULT(unsigned int );
    public unsigned int HRESULTToWCode(HRESULT );
    enum <unnamed-enum-WCODE_HRESULT_FIRST>
    {
        WCODE_HRESULT_FIRST=-2147220992,
        WCODE_HRESULT_LAST=-2147155969
    };
    private const HRESULT m_hresult;
    private struct IErrorInfo * m_perrinfo;
    private char * m_pszMsg;
    public void * __vecDelDtor(unsigned int );
};

class _com_error
{
    public void _com_error(class _com_error & );
    public void _com_error(HRESULT ,struct IErrorInfo * ,bool );
    public void ~_com_error();
    public class _com_error & operator=(class _com_error & );
    public HRESULT Error();
    public unsigned int WCode();
    public struct IErrorInfo * ErrorInfo();
    public class _bstr_t Description();
    public unsigned long HelpContext();
    public class _bstr_t HelpFile();
    public class _bstr_t Source();
    public struct _GUID GUID();
    public char * ErrorMessage();
    public HRESULT WCodeToHRESULT(unsigned int );
    public unsigned int HRESULTToWCode(HRESULT );
    enum <unnamed-enum-WCODE_HRESULT_FIRST>
    {
        WCODE_HRESULT_FIRST=-2147220992,
        WCODE_HRESULT_LAST=-2147155969
    };
    private const HRESULT m_hresult;
    private struct IErrorInfo * m_perrinfo;
    private char * m_pszMsg;
    public void * __vecDelDtor(unsigned int );
};

struct IErrorInfo : public IUnknown
{
    HRESULT GetGUID(struct _GUID * );
    HRESULT GetSource(wchar_t ** );
    HRESULT GetDescription(wchar_t ** );
    HRESULT GetHelpFile(wchar_t ** );
    HRESULT GetHelpContext(unsigned long * );
    void IErrorInfo(struct IErrorInfo * );
    void IErrorInfo(struct IErrorInfo & );
    void IErrorInfo();
    struct IErrorInfo & operator=(struct IErrorInfo * );
    struct IErrorInfo & operator=(struct IErrorInfo & );
};

struct IErrorInfo : public IUnknown
{
    HRESULT GetGUID(struct _GUID * );
    HRESULT GetSource(wchar_t ** );
    HRESULT GetDescription(wchar_t ** );
    HRESULT GetHelpFile(wchar_t ** );
    HRESULT GetHelpContext(unsigned long * );
    void IErrorInfo(struct IErrorInfo * );
    void IErrorInfo(struct IErrorInfo & );
    void IErrorInfo();
    struct IErrorInfo & operator=(struct IErrorInfo * );
    struct IErrorInfo & operator=(struct IErrorInfo & );
};

class SConcert : public SIConcert, private SMpegAudioCallBack
{
    public void SConcert(class SConcert & );
    public void SConcert(struct HWND__ * );
    public void ~SConcert();
    public void AddRef();
    public void Release();
    public void InitDirectSound();
    public void HandleDirectSoundDeviceChange();
    public void SetListener(float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void Update(bool );
    public void SetVolume(int ,int );
    public void SetReverseStereo(bool );
    public int PrecacheSound(char * ,bool );
    public bool LoadSoundInternal(int );
    public void AddRefToCachedSound(int );
    public void ReleaseCachedSound(int );
    public int CleanupSoundCache();
    public void ReleaseSoundCacheBuffers();
    public void ReclaimSoundCacheBuffers();
    public int CreateSound(char * ,float ,float );
    public int CreateSound(int ,float ,float );
    public int CreateSound(char * ,int ,float ,float ,float ,float );
    public int CreateSound(int ,int ,float ,float ,float ,float );
    public void RemoveSound(int );
    public void SetSoundPosition(int ,float ,float ,float );
    public void SetSoundFrequency(int ,unsigned long );
    public void SetSoundMinDistance(int ,float );
    public void ReleasePlayingSounds();
    public void ReclaimPlayingSounds();
    public float PlaySound(char * ,float ,float ,int );
    public float PlaySound(int ,float ,float ,int );
    public float PlaySound(char * ,float ,float ,float ,float );
    public float PlaySound(int ,float ,float ,float ,float );
    public void StartStreamingPlayback(char * ,char * );
    public void CreateStreamBuffer();
    public void StopStreamingPlayback();
    public bool CheckStreamPlayback();
    public void NextTrack();
    public void DataCallback(int * ,int * ,int ,int ,int );
    public void DumpChannels();
    private unsigned long RefCount;
    private struct HWND__ * hWnd;
    private struct _GUID DefaultDeviceGuid;
    private class SString DeviceDescription;
    private class SString DeviceModule;
    private bool TerratecHack;
    private struct IDirectSound8 * DSound;
    private struct IDirectSound3DListener * Listener;
    private class SHeap<SSoundCacheProp> SoundCache;
    private class SHeap<SSoundProp> Sounds;
    private class SVector ListenerPosition;
    private int SpawnSound(int ,bool );
    private void OptimizeSoundGroup(int );
    private class SString StreamFile1;
    private class SString StreamFile2;
    private struct IDirectSoundBuffer * StreamBuffer;
    private struct _RTL_CRITICAL_SECTION StreamBufferCriticalSection;
    private unsigned long WriteCursor;
    private bool StreamStarted;
    private int Volume[3];
    private float MinDistanceMultiplier;
    private float ReverseStereo;
    private int TransientSounds;
    public class SConcert & operator=(class SConcert & );
    public void * __vecDelDtor(unsigned int );
};

class SConcert : public SIConcert, private SMpegAudioCallBack
{
    public void SConcert(class SConcert & );
    public void SConcert(struct HWND__ * );
    public void ~SConcert();
    public void AddRef();
    public void Release();
    public void InitDirectSound();
    public void HandleDirectSoundDeviceChange();
    public void SetListener(float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void Update(bool );
    public void SetVolume(int ,int );
    public void SetReverseStereo(bool );
    public int PrecacheSound(char * ,bool );
    public bool LoadSoundInternal(int );
    public void AddRefToCachedSound(int );
    public void ReleaseCachedSound(int );
    public int CleanupSoundCache();
    public void ReleaseSoundCacheBuffers();
    public void ReclaimSoundCacheBuffers();
    public int CreateSound(char * ,float ,float );
    public int CreateSound(int ,float ,float );
    public int CreateSound(char * ,int ,float ,float ,float ,float );
    public int CreateSound(int ,int ,float ,float ,float ,float );
    public void RemoveSound(int );
    public void SetSoundPosition(int ,float ,float ,float );
    public void SetSoundFrequency(int ,unsigned long );
    public void SetSoundMinDistance(int ,float );
    public void ReleasePlayingSounds();
    public void ReclaimPlayingSounds();
    public float PlaySound(char * ,float ,float ,int );
    public float PlaySound(int ,float ,float ,int );
    public float PlaySound(char * ,float ,float ,float ,float );
    public float PlaySound(int ,float ,float ,float ,float );
    public void StartStreamingPlayback(char * ,char * );
    public void CreateStreamBuffer();
    public void StopStreamingPlayback();
    public bool CheckStreamPlayback();
    public void NextTrack();
    public void DataCallback(int * ,int * ,int ,int ,int );
    public void DumpChannels();
    private unsigned long RefCount;
    private struct HWND__ * hWnd;
    private struct _GUID DefaultDeviceGuid;
    private class SString DeviceDescription;
    private class SString DeviceModule;
    private bool TerratecHack;
    private struct IDirectSound8 * DSound;
    private struct IDirectSound3DListener * Listener;
    private class SHeap<SSoundCacheProp> SoundCache;
    private class SHeap<SSoundProp> Sounds;
    private class SVector ListenerPosition;
    private int SpawnSound(int ,bool );
    private void OptimizeSoundGroup(int );
    private class SString StreamFile1;
    private class SString StreamFile2;
    private struct IDirectSoundBuffer * StreamBuffer;
    private struct _RTL_CRITICAL_SECTION StreamBufferCriticalSection;
    private unsigned long WriteCursor;
    private bool StreamStarted;
    private int Volume[3];
    private float MinDistanceMultiplier;
    private float ReverseStereo;
    private int TransientSounds;
    public class SConcert & operator=(class SConcert & );
    public void * __vecDelDtor(unsigned int );
};

class SMpegAudioCallBack
{
    public void DataCallback(int * ,int * ,int ,int ,int );
    public void SMpegAudioCallBack(class SMpegAudioCallBack * );
    public void SMpegAudioCallBack(class SMpegAudioCallBack & );
    public void SMpegAudioCallBack();
    public class SMpegAudioCallBack & operator=(class SMpegAudioCallBack * );
    public class SMpegAudioCallBack & operator=(class SMpegAudioCallBack & );
};

class SMpegAudioCallBack
{
    public void DataCallback(int * ,int * ,int ,int ,int );
    public void SMpegAudioCallBack(class SMpegAudioCallBack * );
    public void SMpegAudioCallBack(class SMpegAudioCallBack & );
    public void SMpegAudioCallBack();
    public class SMpegAudioCallBack & operator=(class SMpegAudioCallBack * );
    public class SMpegAudioCallBack & operator=(class SMpegAudioCallBack & );
};

struct IDirectSound8 : public IDirectSound
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT CreateSoundBuffer(struct _DSBUFFERDESC * ,struct IDirectSoundBuffer ** ,struct IUnknown * );
    HRESULT GetCaps(struct _DSCAPS * );
    HRESULT DuplicateSoundBuffer(struct IDirectSoundBuffer * ,struct IDirectSoundBuffer ** );
    HRESULT SetCooperativeLevel(struct HWND__ * ,unsigned long );
    HRESULT Compact();
    HRESULT GetSpeakerConfig(unsigned long * );
    HRESULT SetSpeakerConfig(unsigned long );
    HRESULT Initialize(struct _GUID * );
    HRESULT VerifyCertification(unsigned long * );
    void IDirectSound8(struct IDirectSound8 * );
    void IDirectSound8(struct IDirectSound8 & );
    void IDirectSound8();
    struct IDirectSound8 & operator=(struct IDirectSound8 * );
    struct IDirectSound8 & operator=(struct IDirectSound8 & );
};

struct IDirectSound8 : public IDirectSound
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT CreateSoundBuffer(struct _DSBUFFERDESC * ,struct IDirectSoundBuffer ** ,struct IUnknown * );
    HRESULT GetCaps(struct _DSCAPS * );
    HRESULT DuplicateSoundBuffer(struct IDirectSoundBuffer * ,struct IDirectSoundBuffer ** );
    HRESULT SetCooperativeLevel(struct HWND__ * ,unsigned long );
    HRESULT Compact();
    HRESULT GetSpeakerConfig(unsigned long * );
    HRESULT SetSpeakerConfig(unsigned long );
    HRESULT Initialize(struct _GUID * );
    HRESULT VerifyCertification(unsigned long * );
    void IDirectSound8(struct IDirectSound8 * );
    void IDirectSound8(struct IDirectSound8 & );
    void IDirectSound8();
    struct IDirectSound8 & operator=(struct IDirectSound8 * );
    struct IDirectSound8 & operator=(struct IDirectSound8 & );
};

struct IDirectSound3DListener : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetAllParameters(struct _DS3DLISTENER * );
    HRESULT GetDistanceFactor(float * );
    HRESULT GetDopplerFactor(float * );
    HRESULT GetOrientation(struct _D3DVECTOR * ,struct _D3DVECTOR * );
    HRESULT GetPosition(struct _D3DVECTOR * );
    HRESULT GetRolloffFactor(float * );
    HRESULT GetVelocity(struct _D3DVECTOR * );
    HRESULT SetAllParameters(struct _DS3DLISTENER * ,unsigned long );
    HRESULT SetDistanceFactor(float ,unsigned long );
    HRESULT SetDopplerFactor(float ,unsigned long );
    HRESULT SetOrientation(float ,float ,float ,float ,float ,float ,unsigned long );
    HRESULT SetPosition(float ,float ,float ,unsigned long );
    HRESULT SetRolloffFactor(float ,unsigned long );
    HRESULT SetVelocity(float ,float ,float ,unsigned long );
    HRESULT CommitDeferredSettings();
    void IDirectSound3DListener(struct IDirectSound3DListener * );
    void IDirectSound3DListener(struct IDirectSound3DListener & );
    void IDirectSound3DListener();
    struct IDirectSound3DListener & operator=(struct IDirectSound3DListener * );
    struct IDirectSound3DListener & operator=(struct IDirectSound3DListener & );
};

struct IDirectSound3DListener : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetAllParameters(struct _DS3DLISTENER * );
    HRESULT GetDistanceFactor(float * );
    HRESULT GetDopplerFactor(float * );
    HRESULT GetOrientation(struct _D3DVECTOR * ,struct _D3DVECTOR * );
    HRESULT GetPosition(struct _D3DVECTOR * );
    HRESULT GetRolloffFactor(float * );
    HRESULT GetVelocity(struct _D3DVECTOR * );
    HRESULT SetAllParameters(struct _DS3DLISTENER * ,unsigned long );
    HRESULT SetDistanceFactor(float ,unsigned long );
    HRESULT SetDopplerFactor(float ,unsigned long );
    HRESULT SetOrientation(float ,float ,float ,float ,float ,float ,unsigned long );
    HRESULT SetPosition(float ,float ,float ,unsigned long );
    HRESULT SetRolloffFactor(float ,unsigned long );
    HRESULT SetVelocity(float ,float ,float ,unsigned long );
    HRESULT CommitDeferredSettings();
    void IDirectSound3DListener(struct IDirectSound3DListener * );
    void IDirectSound3DListener(struct IDirectSound3DListener & );
    void IDirectSound3DListener();
    struct IDirectSound3DListener & operator=(struct IDirectSound3DListener * );
    struct IDirectSound3DListener & operator=(struct IDirectSound3DListener & );
};

class SHeap<SSoundCacheProp>
{
    struct __Tstruct
    {
        int use;
        struct SSoundCacheProp data;
    };
    private struct SHeap<SSoundCacheProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SSoundCacheProp>();
    public void ~SHeap<SSoundCacheProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SSoundCacheProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SSoundCacheProp>
{
    struct __Tstruct
    {
        int use;
        struct SSoundCacheProp data;
    };
    private struct SHeap<SSoundCacheProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SSoundCacheProp>();
    public void ~SHeap<SSoundCacheProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SSoundCacheProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SSoundProp>
{
    struct __Tstruct
    {
        int use;
        struct SSoundProp data;
        void __Tstruct();
    };
    private struct SHeap<SSoundProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SSoundProp>();
    public void ~SHeap<SSoundProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SSoundProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SSoundProp>
{
    struct __Tstruct
    {
        int use;
        struct SSoundProp data;
        void __Tstruct();
    };
    private struct SHeap<SSoundProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SSoundProp>();
    public void ~SHeap<SSoundProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SSoundProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct IDirectSoundBuffer : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetCaps(struct _DSBCAPS * );
    HRESULT GetCurrentPosition(unsigned long * ,unsigned long * );
    HRESULT GetFormat(struct tWAVEFORMATEX * ,unsigned long ,unsigned long * );
    HRESULT GetVolume(long * );
    HRESULT GetPan(long * );
    HRESULT GetFrequency(unsigned long * );
    HRESULT GetStatus(unsigned long * );
    HRESULT Initialize(struct IDirectSound * ,struct _DSBUFFERDESC * );
    HRESULT Lock(unsigned long ,unsigned long ,void ** ,unsigned long * ,void ** ,unsigned long * ,unsigned long );
    HRESULT Play(unsigned long ,unsigned long ,unsigned long );
    HRESULT SetCurrentPosition(unsigned long );
    HRESULT SetFormat(struct tWAVEFORMATEX * );
    HRESULT SetVolume(long );
    HRESULT SetPan(long );
    HRESULT SetFrequency(unsigned long );
    HRESULT Stop();
    HRESULT Unlock(void * ,unsigned long ,void * ,unsigned long );
    HRESULT Restore();
    void IDirectSoundBuffer(struct IDirectSoundBuffer * );
    void IDirectSoundBuffer(struct IDirectSoundBuffer & );
    void IDirectSoundBuffer();
    struct IDirectSoundBuffer & operator=(struct IDirectSoundBuffer * );
    struct IDirectSoundBuffer & operator=(struct IDirectSoundBuffer & );
};

struct IDirectSoundBuffer : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetCaps(struct _DSBCAPS * );
    HRESULT GetCurrentPosition(unsigned long * ,unsigned long * );
    HRESULT GetFormat(struct tWAVEFORMATEX * ,unsigned long ,unsigned long * );
    HRESULT GetVolume(long * );
    HRESULT GetPan(long * );
    HRESULT GetFrequency(unsigned long * );
    HRESULT GetStatus(unsigned long * );
    HRESULT Initialize(struct IDirectSound * ,struct _DSBUFFERDESC * );
    HRESULT Lock(unsigned long ,unsigned long ,void ** ,unsigned long * ,void ** ,unsigned long * ,unsigned long );
    HRESULT Play(unsigned long ,unsigned long ,unsigned long );
    HRESULT SetCurrentPosition(unsigned long );
    HRESULT SetFormat(struct tWAVEFORMATEX * );
    HRESULT SetVolume(long );
    HRESULT SetPan(long );
    HRESULT SetFrequency(unsigned long );
    HRESULT Stop();
    HRESULT Unlock(void * ,unsigned long ,void * ,unsigned long );
    HRESULT Restore();
    void IDirectSoundBuffer(struct IDirectSoundBuffer * );
    void IDirectSoundBuffer(struct IDirectSoundBuffer & );
    void IDirectSoundBuffer();
    struct IDirectSoundBuffer & operator=(struct IDirectSoundBuffer * );
    struct IDirectSoundBuffer & operator=(struct IDirectSoundBuffer & );
};

struct IDirectSound : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT CreateSoundBuffer(struct _DSBUFFERDESC * ,struct IDirectSoundBuffer ** ,struct IUnknown * );
    HRESULT GetCaps(struct _DSCAPS * );
    HRESULT DuplicateSoundBuffer(struct IDirectSoundBuffer * ,struct IDirectSoundBuffer ** );
    HRESULT SetCooperativeLevel(struct HWND__ * ,unsigned long );
    HRESULT Compact();
    HRESULT GetSpeakerConfig(unsigned long * );
    HRESULT SetSpeakerConfig(unsigned long );
    HRESULT Initialize(struct _GUID * );
    void IDirectSound(struct IDirectSound * );
    void IDirectSound(struct IDirectSound & );
    void IDirectSound();
    struct IDirectSound & operator=(struct IDirectSound * );
    struct IDirectSound & operator=(struct IDirectSound & );
};

struct IDirectSound : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT CreateSoundBuffer(struct _DSBUFFERDESC * ,struct IDirectSoundBuffer ** ,struct IUnknown * );
    HRESULT GetCaps(struct _DSCAPS * );
    HRESULT DuplicateSoundBuffer(struct IDirectSoundBuffer * ,struct IDirectSoundBuffer ** );
    HRESULT SetCooperativeLevel(struct HWND__ * ,unsigned long );
    HRESULT Compact();
    HRESULT GetSpeakerConfig(unsigned long * );
    HRESULT SetSpeakerConfig(unsigned long );
    HRESULT Initialize(struct _GUID * );
    void IDirectSound(struct IDirectSound * );
    void IDirectSound(struct IDirectSound & );
    void IDirectSound();
    struct IDirectSound & operator=(struct IDirectSound * );
    struct IDirectSound & operator=(struct IDirectSound & );
};

struct SHeap<SSoundCacheProp>::__Tstruct
{
    int use;
    struct SSoundCacheProp data;
};

struct SSoundCacheProp
{
    char * FileName;
    struct IDirectSoundBuffer * Buffer;
    int RefCount;
    bool Positional;
    float Duration;
    unsigned long Size;
};

struct SHeap<SSoundProp>::__Tstruct
{
    int use;
    struct SSoundProp data;
    void __Tstruct();
};

struct SSoundProp
{
    int CacheIdx;
    struct IDirectSoundBuffer * Buffer;
    struct IDirectSound3DBuffer * Buffer3d;
    bool Looped;
    float MinDistance;
    int Volume;
    int Panning;
    unsigned long PlaybackPosition;
    class SVector Position;
    int SoundGroup;
    bool Enabled;
    bool HasBeenDucked;
    int ChannelID;
    void SSoundProp();
};

struct _DSBCAPS
{
    unsigned long dwSize;
    unsigned long dwFlags;
    unsigned long dwBufferBytes;
    unsigned long dwUnlockTransferRate;
    unsigned long dwPlayCpuOverhead;
};

struct SWave : private SMpegAudioCallBack
{
    void SWave(struct SWave & );
    void SWave();
    void ~SWave();
    bool LoadWAV(char * ,char * );
    bool LoadMP3(char * ,char * );
    void DataCallback(int * ,int * ,int ,int ,int );
    struct tWAVEFORMATEX WaveFMT;
    unsigned long Size;
    unsigned int * Data;
    class SStreamBuffer * DecodeBuffer;
    struct SWave & operator=(struct SWave & );
    void * __vecDelDtor(unsigned int );
};

struct SWave : private SMpegAudioCallBack
{
    void SWave(struct SWave & );
    void SWave();
    void ~SWave();
    bool LoadWAV(char * ,char * );
    bool LoadMP3(char * ,char * );
    void DataCallback(int * ,int * ,int ,int ,int );
    struct tWAVEFORMATEX WaveFMT;
    unsigned long Size;
    unsigned int * Data;
    class SStreamBuffer * DecodeBuffer;
    struct SWave & operator=(struct SWave & );
    void * __vecDelDtor(unsigned int );
};

struct SWaveHeader
{
    char riff[4];
    unsigned long fsize;
    char wavefmt[8];
    unsigned long wsize;
    unsigned int wFormatTag;
    unsigned int nChannels;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
    unsigned int wBitsPerSample;
};

struct SWaveDataHeader
{
    char data[4];
    unsigned long dsize;
};

class SMpegAudioDecoder
{
    private struct SMpegAudioFrame Frame;
    private class SMpegAudioCallBack * Callback;
    public void SMpegAudioDecoder(class SStream * ,class SMpegAudioCallBack * );
    public void ~SMpegAudioDecoder();
    public int DecodeFrame();
    private int sfreq;
    struct <unnamed-type-si>
    {
        unsigned int main_data_begin;
        unsigned int private_bits;
        struct <unnamed-type-ch>
        {
            unsigned int scfsi[4];
            struct SGrInfo gr[2];
        };
        struct SMpegAudioDecoder::<unnamed-type-si>::<unnamed-type-ch> ch[2];
    };
    private struct SMpegAudioDecoder::<unnamed-type-si> si;
    struct <unnamed-type-scalefac>
    {
        int l[22];
        int s[3][13];
    };
    private struct SMpegAudioDecoder::<unnamed-type-scalefac> scalefac[2];
    private long is[578];
    private float dq[2][576];
    private float lr[2][576];
    private float hybridOut[32][18];
    private float polyPhaseIn[32];
    private int pcmsample[2][18][32];
    private void L3_GetSideInfo();
    private void L3_GetMPEG1ScaleFactors(int ,int );
    private void L3_GetMPEG2ScaleFactors(int ,int );
    private void L3_HuffmanDecode(int ,int ,long );
    private void L3_DequantizeSample(int ,int );
    private void L3_Stereo(int );
    private void L3_Antialias(int ,int );
    private int L3_DecodeFrame();
    private class SStream * in_file;
    private unsigned int in_buf[16384];
    private int in_p;
    private int in_end;
    private int in_bits;
    private unsigned long in_bitbuf;
    private unsigned int s2_buf[4096];
    private int s2_p;
    private int s2_end;
    private int s2_bits;
    private unsigned long s2_bitbuf;
    private void in_open(class SStream * );
    private int in_fillbuf(int );
    private int in_seeksync();
    private void in_close();
    private int in_getbits(int );
    private void s2_init();
    private int s2_fillbuf(int );
    private int s2_getbits(int );
    private int s2_prebits(int );
    private void s2_dropbits(int );
    private void s2_flushbits();
    private long s2_getpos();
    private void s2_setpos(long );
    private void HuffmanDecode(int ,int * ,int * ,int * ,int * );
    private float sb_buf[2][544];
    private int sb_buf_ofs[2];
    private void SubbandInitialize();
    private int SubbandSynthesis(float * ,int ,int * );
    private float hm_buf[2][32][18];
    private void L3_HybridInitialize();
    private void L3_Hybrid(float * ,float * ,int ,int ,int );
    public void * __vecDelDtor(unsigned int );
};

struct SGrInfo
{
    unsigned int part2_3_length;
    unsigned int big_values;
    unsigned int global_gain;
    unsigned int scalefac_compress;
    unsigned int window_switching_flag;
    unsigned int block_type;
    unsigned int mixed_block_flag;
    unsigned int table_select[3];
    unsigned int subblock_gain[3];
    unsigned int region0_count;
    unsigned int region1_count;
    unsigned int preflag;
    unsigned int scalefac_scale;
    unsigned int count1table_select;
};

struct SMpegAudioDecoder::<unnamed-type-si>
{
    unsigned int main_data_begin;
    unsigned int private_bits;
    struct <unnamed-type-ch>
    {
        unsigned int scfsi[4];
        struct SGrInfo gr[2];
    };
    struct SMpegAudioDecoder::<unnamed-type-si>::<unnamed-type-ch> ch[2];
};

struct SMpegAudioDecoder::<unnamed-type-si>::<unnamed-type-ch>
{
    unsigned int scfsi[4];
    struct SGrInfo gr[2];
};

struct SMpegAudioDecoder::<unnamed-type-scalefac>
{
    int l[22];
    int s[3][13];
};

struct IDirectSound3DBuffer : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetAllParameters(struct _DS3DBUFFER * );
    HRESULT GetConeAngles(unsigned long * ,unsigned long * );
    HRESULT GetConeOrientation(struct _D3DVECTOR * );
    HRESULT GetConeOutsideVolume(long * );
    HRESULT GetMaxDistance(float * );
    HRESULT GetMinDistance(float * );
    HRESULT GetMode(unsigned long * );
    HRESULT GetPosition(struct _D3DVECTOR * );
    HRESULT GetVelocity(struct _D3DVECTOR * );
    HRESULT SetAllParameters(struct _DS3DBUFFER * ,unsigned long );
    HRESULT SetConeAngles(unsigned long ,unsigned long ,unsigned long );
    HRESULT SetConeOrientation(float ,float ,float ,unsigned long );
    HRESULT SetConeOutsideVolume(long ,unsigned long );
    HRESULT SetMaxDistance(float ,unsigned long );
    HRESULT SetMinDistance(float ,unsigned long );
    HRESULT SetMode(unsigned long ,unsigned long );
    HRESULT SetPosition(float ,float ,float ,unsigned long );
    HRESULT SetVelocity(float ,float ,float ,unsigned long );
    void IDirectSound3DBuffer(struct IDirectSound3DBuffer * );
    void IDirectSound3DBuffer(struct IDirectSound3DBuffer & );
    void IDirectSound3DBuffer();
    struct IDirectSound3DBuffer & operator=(struct IDirectSound3DBuffer * );
    struct IDirectSound3DBuffer & operator=(struct IDirectSound3DBuffer & );
};

struct IDirectSound3DBuffer : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetAllParameters(struct _DS3DBUFFER * );
    HRESULT GetConeAngles(unsigned long * ,unsigned long * );
    HRESULT GetConeOrientation(struct _D3DVECTOR * );
    HRESULT GetConeOutsideVolume(long * );
    HRESULT GetMaxDistance(float * );
    HRESULT GetMinDistance(float * );
    HRESULT GetMode(unsigned long * );
    HRESULT GetPosition(struct _D3DVECTOR * );
    HRESULT GetVelocity(struct _D3DVECTOR * );
    HRESULT SetAllParameters(struct _DS3DBUFFER * ,unsigned long );
    HRESULT SetConeAngles(unsigned long ,unsigned long ,unsigned long );
    HRESULT SetConeOrientation(float ,float ,float ,unsigned long );
    HRESULT SetConeOutsideVolume(long ,unsigned long );
    HRESULT SetMaxDistance(float ,unsigned long );
    HRESULT SetMinDistance(float ,unsigned long );
    HRESULT SetMode(unsigned long ,unsigned long );
    HRESULT SetPosition(float ,float ,float ,unsigned long );
    HRESULT SetVelocity(float ,float ,float ,unsigned long );
    void IDirectSound3DBuffer(struct IDirectSound3DBuffer * );
    void IDirectSound3DBuffer(struct IDirectSound3DBuffer & );
    void IDirectSound3DBuffer();
    struct IDirectSound3DBuffer & operator=(struct IDirectSound3DBuffer * );
    struct IDirectSound3DBuffer & operator=(struct IDirectSound3DBuffer & );
};

struct SConcert::OptimizeSoundGroup::__l2::elem_t
{
    int idx;
    float volume;
};

enum EUniverse
{
    k_EUniverseInvalid=0,
    k_EUniversePublic=1,
    k_EUniverseBeta=2,
    k_EUniverseInternal=3,
    k_EUniverseDev=4,
    k_EUniverseMax=5
};

enum EResult
{
    k_EResultOK=1,
    k_EResultFail=2,
    k_EResultNoConnection=3,
    k_EResultInvalidPassword=5,
    k_EResultLoggedInElsewhere=6,
    k_EResultInvalidProtocolVer=7,
    k_EResultInvalidParam=8,
    k_EResultFileNotFound=9,
    k_EResultBusy=10,
    k_EResultInvalidState=11,
    k_EResultInvalidName=12,
    k_EResultInvalidEmail=13,
    k_EResultDuplicateName=14,
    k_EResultAccessDenied=15,
    k_EResultTimeout=16,
    k_EResultBanned=17,
    k_EResultAccountNotFound=18,
    k_EResultInvalidSteamID=19,
    k_EResultServiceUnavailable=20,
    k_EResultNotLoggedOn=21,
    k_EResultPending=22,
    k_EResultEncryptionFailure=23,
    k_EResultInsufficientPrivilege=24,
    k_EResultLimitExceeded=25,
    k_EResultRevoked=26,
    k_EResultExpired=27,
    k_EResultAlreadyRedeemed=28,
    k_EResultDuplicateRequest=29,
    k_EResultAlreadyOwned=30,
    k_EResultIPNotFound=31,
    k_EResultPersistFailed=32,
    k_EResultLockingFailed=33,
    k_EResultLogonSessionReplaced=34,
    k_EResultConnectFailed=35,
    k_EResultHandshakeFailed=36,
    k_EResultIOFailure=37,
    k_EResultRemoteDisconnect=38,
    k_EResultShoppingCartNotFound=39,
    k_EResultBlocked=40,
    k_EResultIgnored=41,
    k_EResultNoMatch=42,
    k_EResultAccountDisabled=43,
    k_EResultServiceReadOnly=44,
    k_EResultAccountNotFeatured=45,
    k_EResultAdministratorOK=46,
    k_EResultContentVersion=47,
    k_EResultTryAnotherCM=48,
    k_EResultPasswordRequiredToKickSession=49,
    k_EResultAlreadyLoggedInElsewhere=50,
    k_EResultSuspended=51,
    k_EResultCancelled=52,
    k_EResultDataCorruption=53,
    k_EResultDiskFull=54,
    k_EResultRemoteCallFailed=55,
    k_EResultPasswordUnset=56,
    k_EResultExternalAccountUnlinked=57,
    k_EResultPSNTicketInvalid=58,
    k_EResultExternalAccountAlreadyLinked=59,
    k_EResultRemoteFileConflict=60,
    k_EResultIllegalPassword=61,
    k_EResultSameAsPreviousValue=62,
    k_EResultAccountLogonDenied=63,
    k_EResultCannotUseOldPassword=64,
    k_EResultInvalidLoginAuthCode=65,
    k_EResultAccountLogonDeniedNoMail=66,
    k_EResultHardwareNotCapableOfIPT=67,
    k_EResultIPTInitError=68,
    k_EResultParentalControlRestricted=69,
    k_EResultFacebookQueryError=70,
    k_EResultExpiredLoginAuthCode=71,
    k_EResultIPLoginRestrictionFailed=72,
    k_EResultAccountLockedDown=73,
    k_EResultAccountLogonDeniedVerifiedEmailRequired=74,
    k_EResultNoMatchingURL=75,
    k_EResultBadResponse=76,
    k_EResultRequirePasswordReEntry=77,
    k_EResultValueOutOfRange=78,
    k_EResultUnexpectedError=79,
    k_EResultDisabled=80,
    k_EResultInvalidCEGSubmission=81,
    k_EResultRestrictedDevice=82,
    k_EResultRegionLocked=83,
    k_EResultRateLimitExceeded=84,
    k_EResultAccountLoginDeniedNeedTwoFactor=85,
    k_EResultItemDeleted=86,
    k_EResultAccountLoginDeniedThrottle=87,
    k_EResultTwoFactorCodeMismatch=88,
    k_EResultTwoFactorActivationCodeMismatch=89,
    k_EResultAccountAssociatedToMultiplePartners=90,
    k_EResultNotModified=91,
    k_EResultNoMobileDevice=92,
    k_EResultTimeNotSynced=93,
    k_EResultSmsCodeFailed=94,
    k_EResultAccountLimitExceeded=95,
    k_EResultAccountActivityLimitExceeded=96,
    k_EResultPhoneActivityLimitExceeded=97,
    k_EResultRefundToWallet=98,
    k_EResultEmailSendFailure=99,
    k_EResultNotSettled=100,
    k_EResultNeedCaptcha=101,
    k_EResultGSLTDenied=102,
    k_EResultGSOwnerDenied=103,
    k_EResultInvalidItemType=104,
    k_EResultIPBanned=105,
    k_EResultGSLTExpired=106,
    k_EResultInsufficientFunds=107,
    k_EResultTooManyPending=108,
    k_EResultNoSiteLicensesFound=109,
    k_EResultWGNetworkSendExceeded=110,
    k_EResultAccountNotFriends=111,
    k_EResultLimitedUserAccount=112,
    k_EResultCantRemoveItem=113
};

enum EAccountType
{
    k_EAccountTypeInvalid=0,
    k_EAccountTypeIndividual=1,
    k_EAccountTypeMultiseat=2,
    k_EAccountTypeGameServer=3,
    k_EAccountTypeAnonGameServer=4,
    k_EAccountTypePending=5,
    k_EAccountTypeContentServer=6,
    k_EAccountTypeClan=7,
    k_EAccountTypeChat=8,
    k_EAccountTypeConsoleUser=9,
    k_EAccountTypeAnonUser=10,
    k_EAccountTypeMax=11
};

enum EChatSteamIDInstanceFlags
{
    k_EChatAccountInstanceMask=4095,
    k_EChatInstanceFlagClan=524288,
    k_EChatInstanceFlagLobby=262144,
    k_EChatInstanceFlagMMSLobby=131072
};

enum EMarketingMessageFlags
{
    k_EMarketingMessageFlagsNone=0,
    k_EMarketingMessageFlagsHighPriority=1,
    k_EMarketingMessageFlagsPlatformWindows=2,
    k_EMarketingMessageFlagsPlatformMac=4,
    k_EMarketingMessageFlagsPlatformLinux=8,
    k_EMarketingMessageFlagsPlatformRestrictions=14
};

enum ENotificationPosition
{
    k_EPositionTopLeft=0,
    k_EPositionTopRight=1,
    k_EPositionBottomLeft=2,
    k_EPositionBottomRight=3
};

enum ELaunchOptionType
{
    k_ELaunchOptionType_None=0,
    k_ELaunchOptionType_Default=1,
    k_ELaunchOptionType_SafeMode=2,
    k_ELaunchOptionType_Multiplayer=3,
    k_ELaunchOptionType_Config=4,
    k_ELaunchOptionType_OpenVR=5,
    k_ELaunchOptionType_Server=6,
    k_ELaunchOptionType_Editor=7,
    k_ELaunchOptionType_Manual=8,
    k_ELaunchOptionType_Benchmark=9,
    k_ELaunchOptionType_Option1=10,
    k_ELaunchOptionType_Option2=11,
    k_ELaunchOptionType_Option3=12,
    k_ELaunchOptionType_OculusVR=13,
    k_ELaunchOptionType_OpenVROverlay=14,
    k_ELaunchOptionType_OSVR=15,
    k_ELaunchOptionType_Dialog=1000
};

enum EVRHMDType
{
    k_eEVRHMDType_None=-1,
    k_eEVRHMDType_Unknown=0,
    k_eEVRHMDType_HTC_Dev=1,
    k_eEVRHMDType_HTC_VivePre=2,
    k_eEVRHMDType_HTC_Vive=3,
    k_eEVRHMDType_HTC_VivePro=4,
    k_eEVRHMDType_HTC_Unknown=20,
    k_eEVRHMDType_Oculus_DK1=21,
    k_eEVRHMDType_Oculus_DK2=22,
    k_eEVRHMDType_Oculus_Rift=23,
    k_eEVRHMDType_Oculus_Unknown=40,
    k_eEVRHMDType_Acer_Unknown=50,
    k_eEVRHMDType_Acer_WindowsMR=51,
    k_eEVRHMDType_Dell_Unknown=60,
    k_eEVRHMDType_Dell_Visor=61,
    k_eEVRHMDType_Lenovo_Unknown=70,
    k_eEVRHMDType_Lenovo_Explorer=71,
    k_eEVRHMDType_HP_Unknown=80,
    k_eEVRHMDType_HP_WindowsMR=81,
    k_eEVRHMDType_Samsung_Unknown=90,
    k_eEVRHMDType_Samsung_Odyssey=91,
    k_eEVRHMDType_Unannounced_Unknown=100,
    k_eEVRHMDType_Unannounced_WindowsMR=101,
    k_eEVRHMDType_vridge=110,
    k_eEVRHMDType_Huawei_Unknown=120,
    k_eEVRHMDType_Huawei_VR2=121,
    k_eEVRHMDType_Huawei_EndOfRange=129
};

enum CGameID::EGameIDType
{
    k_EGameIDTypeApp=0,
    k_EGameIDTypeGameMod=1,
    k_EGameIDTypeShortcut=2,
    k_EGameIDTypeP2P=3
};

enum CCallbackBase::<unnamed-enum-k_ECallbackFlagsRegistered>
{
    k_ECallbackFlagsRegistered=1,
    k_ECallbackFlagsGameServer=2
};

enum <unnamed-enum-k_iSteamUserCallbacks>
{
    k_iSteamUserCallbacks=100
};

enum <unnamed-enum-k_iSteamFriendsCallbacks>
{
    k_iSteamFriendsCallbacks=300
};

enum <unnamed-enum-k_iSteamMatchmakingCallbacks>
{
    k_iSteamMatchmakingCallbacks=500
};

enum <unnamed-enum-k_iSteamUtilsCallbacks>
{
    k_iSteamUtilsCallbacks=700
};

enum <unnamed-enum-k_iSteamAppsCallbacks>
{
    k_iSteamAppsCallbacks=1000
};

enum <unnamed-enum-k_iSteamUserStatsCallbacks>
{
    k_iSteamUserStatsCallbacks=1100
};

enum <unnamed-enum-k_iSteamNetworkingCallbacks>
{
    k_iSteamNetworkingCallbacks=1200
};

enum <unnamed-enum-k_iClientRemoteStorageCallbacks>
{
    k_iClientRemoteStorageCallbacks=1300
};

enum <unnamed-enum-k_iClientHTTPCallbacks>
{
    k_iClientHTTPCallbacks=2100
};

enum <unnamed-enum-k_iSteamScreenshotsCallbacks>
{
    k_iSteamScreenshotsCallbacks=2300
};

enum <unnamed-enum-k_iClientUGCCallbacks>
{
    k_iClientUGCCallbacks=3400
};

enum <unnamed-enum-k_iSteamAppListCallbacks>
{
    k_iSteamAppListCallbacks=3900
};

enum <unnamed-enum-k_iSteamMusicCallbacks>
{
    k_iSteamMusicCallbacks=4000
};

enum <unnamed-enum-k_iSteamMusicRemoteCallbacks>
{
    k_iSteamMusicRemoteCallbacks=4100
};

enum <unnamed-enum-k_iSteamHTMLSurfaceCallbacks>
{
    k_iSteamHTMLSurfaceCallbacks=4500
};

enum <unnamed-enum-k_iClientVideoCallbacks>
{
    k_iClientVideoCallbacks=4600
};

enum <unnamed-enum-k_iClientInventoryCallbacks>
{
    k_iClientInventoryCallbacks=4700
};

enum <unnamed-enum-k_ISteamParentalSettingsCallbacks>
{
    k_ISteamParentalSettingsCallbacks=5000
};

enum <unnamed-enum-k_iSteamGameSearchCallbacks>
{
    k_iSteamGameSearchCallbacks=5200
};

enum <unnamed-enum-k_iSteamPartiesCallbacks>
{
    k_iSteamPartiesCallbacks=5300
};

enum <unnamed-enum-k_cchMaxRichPresenceValueLength>
{
    k_cchMaxRichPresenceValueLength=256
};

enum EActivateGameOverlayToWebPageMode
{
    k_EActivateGameOverlayToWebPageMode_Default=0,
    k_EActivateGameOverlayToWebPageMode_Modal=1
};

enum GameOverlayActivated_t::<unnamed-enum-k_iCallback>
{
    k_iCallback=331
};

enum <unnamed-enum-k_cchStatNameMax>
{
    k_cchStatNameMax=128
};

enum UserStatsReceived_t::<unnamed-enum-k_iCallback>
{
    k_iCallback=1101
};

enum UserStatsStored_t::<unnamed-enum-k_iCallback>
{
    k_iCallback=1102
};

enum UserAchievementStored_t::<unnamed-enum-k_iCallback>
{
    k_iCallback=1103
};

class CSteamID
{
    private void CSteamID(int );
    private void CSteamID(unsigned int );
    public void CSteamID(char * ,enum EUniverse );
    public void CSteamID(unsigned int );
    public void CSteamID(unsigned int ,unsigned int ,enum EUniverse ,enum EAccountType );
    public void CSteamID(unsigned int ,enum EUniverse ,enum EAccountType );
    public void CSteamID();
    public void Set(unsigned int ,enum EUniverse ,enum EAccountType );
    public void InstancedSet(unsigned int ,unsigned int ,enum EUniverse ,enum EAccountType );
    public void FullSet(unsigned int ,enum EUniverse ,enum EAccountType );
    public void SetFromUint64(unsigned int );
    public void Clear();
    public unsigned int ConvertToUint64();
    public unsigned int GetStaticAccountKey();
    public void CreateBlankAnonLogon(enum EUniverse );
    public void CreateBlankAnonUserLogon(enum EUniverse );
    public bool BBlankAnonAccount();
    public bool BGameServerAccount();
    public bool BPersistentGameServerAccount();
    public bool BAnonGameServerAccount();
    public bool BContentServerAccount();
    public bool BClanAccount();
    public bool BChatAccount();
    public bool IsLobby();
    public bool BIndividualAccount();
    public bool BAnonAccount();
    public bool BAnonUserAccount();
    public bool BConsoleUserAccount();
    public void SetAccountID(unsigned int );
    public void SetAccountInstance(unsigned int );
    public void ClearIndividualInstance();
    public bool HasNoIndividualInstance();
    public unsigned int GetAccountID();
    public unsigned int GetUnAccountInstance();
    public enum EAccountType GetEAccountType();
    public enum EUniverse GetEUniverse();
    public void SetEUniverse(enum EUniverse );
    public bool IsValid();
    public char * Render(unsigned int );
    public char * Render();
    public void SetFromString(char * ,enum EUniverse );
    public bool SetFromStringStrict(char * ,enum EUniverse );
    public bool SetFromSteam2String(char * ,enum EUniverse );
    public bool operator==(class CSteamID & );
    public bool operator!=(class CSteamID & );
    public bool operator<(class CSteamID & );
    public bool operator>(class CSteamID & );
    public bool BValidExternalSteamID();
    union SteamID_t
    {
        struct SteamIDComponent_t
        {
            unsigned int m_unAccountID:32;
            unsigned int m_unAccountInstance:20;
            unsigned int m_EAccountType:4;
            enum EUniverse m_EUniverse:8;
        };
        struct CSteamID::SteamID_t::SteamIDComponent_t m_comp;
        unsigned int m_unAll64Bits;
    };
    private union CSteamID::SteamID_t m_steamid;
};

class CSteamID
{
    private void CSteamID(int );
    private void CSteamID(unsigned int );
    public void CSteamID(char * ,enum EUniverse );
    public void CSteamID(unsigned int );
    public void CSteamID(unsigned int ,unsigned int ,enum EUniverse ,enum EAccountType );
    public void CSteamID(unsigned int ,enum EUniverse ,enum EAccountType );
    public void CSteamID();
    public void Set(unsigned int ,enum EUniverse ,enum EAccountType );
    public void InstancedSet(unsigned int ,unsigned int ,enum EUniverse ,enum EAccountType );
    public void FullSet(unsigned int ,enum EUniverse ,enum EAccountType );
    public void SetFromUint64(unsigned int );
    public void Clear();
    public unsigned int ConvertToUint64();
    public unsigned int GetStaticAccountKey();
    public void CreateBlankAnonLogon(enum EUniverse );
    public void CreateBlankAnonUserLogon(enum EUniverse );
    public bool BBlankAnonAccount();
    public bool BGameServerAccount();
    public bool BPersistentGameServerAccount();
    public bool BAnonGameServerAccount();
    public bool BContentServerAccount();
    public bool BClanAccount();
    public bool BChatAccount();
    public bool IsLobby();
    public bool BIndividualAccount();
    public bool BAnonAccount();
    public bool BAnonUserAccount();
    public bool BConsoleUserAccount();
    public void SetAccountID(unsigned int );
    public void SetAccountInstance(unsigned int );
    public void ClearIndividualInstance();
    public bool HasNoIndividualInstance();
    public unsigned int GetAccountID();
    public unsigned int GetUnAccountInstance();
    public enum EAccountType GetEAccountType();
    public enum EUniverse GetEUniverse();
    public void SetEUniverse(enum EUniverse );
    public bool IsValid();
    public char * Render(unsigned int );
    public char * Render();
    public void SetFromString(char * ,enum EUniverse );
    public bool SetFromStringStrict(char * ,enum EUniverse );
    public bool SetFromSteam2String(char * ,enum EUniverse );
    public bool operator==(class CSteamID & );
    public bool operator!=(class CSteamID & );
    public bool operator<(class CSteamID & );
    public bool operator>(class CSteamID & );
    public bool BValidExternalSteamID();
    union SteamID_t
    {
        struct SteamIDComponent_t
        {
            unsigned int m_unAccountID:32;
            unsigned int m_unAccountInstance:20;
            unsigned int m_EAccountType:4;
            enum EUniverse m_EUniverse:8;
        };
        struct CSteamID::SteamID_t::SteamIDComponent_t m_comp;
        unsigned int m_unAll64Bits;
    };
    private union CSteamID::SteamID_t m_steamid;
};

union CSteamID::SteamID_t
{
    struct SteamIDComponent_t
    {
        unsigned int m_unAccountID:32;
        unsigned int m_unAccountInstance:20;
        unsigned int m_EAccountType:4;
        enum EUniverse m_EUniverse:8;
    };
    struct CSteamID::SteamID_t::SteamIDComponent_t m_comp;
    unsigned int m_unAll64Bits;
};

struct CSteamID::SteamID_t::SteamIDComponent_t
{
    unsigned int m_unAccountID:32;
    unsigned int m_unAccountInstance:20;
    unsigned int m_EAccountType:4;
    enum EUniverse m_EUniverse:8;
};

class CGameID
{
    public void CGameID(char * );
    public void CGameID(unsigned int ,unsigned int );
    public void CGameID(unsigned int );
    public void CGameID(int );
    public void CGameID(unsigned int );
    public void CGameID();
    public char * Render(unsigned int );
    public char * Render();
    public unsigned int ToUint64();
    public unsigned int * GetUint64Ptr();
    public void Set(unsigned int );
    public bool IsMod();
    public bool IsShortcut();
    public bool IsP2PFile();
    public bool IsSteamApp();
    public unsigned int ModID();
    public unsigned int AppID();
    public bool operator==(class CGameID & );
    public bool operator!=(class CGameID & );
    public bool operator<(class CGameID & );
    public bool IsValid();
    public void Reset();
    enum EGameIDType
    {
        k_EGameIDTypeApp=0,
        k_EGameIDTypeGameMod=1,
        k_EGameIDTypeShortcut=2,
        k_EGameIDTypeP2P=3
    };
    struct GameID_t
    {
        unsigned int m_nAppID:24;
        unsigned int m_nType:8;
        unsigned int m_nModID:32;
    };
    private unsigned int m_ulGameID;
    private struct CGameID::GameID_t m_gameID;
};

class CGameID
{
    public void CGameID(char * );
    public void CGameID(unsigned int ,unsigned int );
    public void CGameID(unsigned int );
    public void CGameID(int );
    public void CGameID(unsigned int );
    public void CGameID();
    public char * Render(unsigned int );
    public char * Render();
    public unsigned int ToUint64();
    public unsigned int * GetUint64Ptr();
    public void Set(unsigned int );
    public bool IsMod();
    public bool IsShortcut();
    public bool IsP2PFile();
    public bool IsSteamApp();
    public unsigned int ModID();
    public unsigned int AppID();
    public bool operator==(class CGameID & );
    public bool operator!=(class CGameID & );
    public bool operator<(class CGameID & );
    public bool IsValid();
    public void Reset();
    enum EGameIDType
    {
        k_EGameIDTypeApp=0,
        k_EGameIDTypeGameMod=1,
        k_EGameIDTypeShortcut=2,
        k_EGameIDTypeP2P=3
    };
    struct GameID_t
    {
        unsigned int m_nAppID:24;
        unsigned int m_nType:8;
        unsigned int m_nModID:32;
    };
    private unsigned int m_ulGameID;
    private struct CGameID::GameID_t m_gameID;
};

struct CGameID::GameID_t
{
    unsigned int m_nAppID:24;
    unsigned int m_nType:8;
    unsigned int m_nModID:32;
};

class CCallbackBase
{
    private void CCallbackBase(class CCallbackBase & );
    public void CCallbackBase();
    public void Run(void * ,bool ,unsigned int );
    public void Run(void * );
    public int GetICallback();
    public int GetCallbackSizeBytes();
    enum <unnamed-enum-k_ECallbackFlagsRegistered>
    {
        k_ECallbackFlagsRegistered=1,
        k_ECallbackFlagsGameServer=2
    };
    protected unsigned int m_nCallbackFlags;
    protected int m_iCallback;
    private class CCallbackBase & operator=(class CCallbackBase & );
};

class CCallbackBase
{
    private void CCallbackBase(class CCallbackBase & );
    public void CCallbackBase();
    public void Run(void * ,bool ,unsigned int );
    public void Run(void * );
    public int GetICallback();
    public int GetCallbackSizeBytes();
    enum <unnamed-enum-k_ECallbackFlagsRegistered>
    {
        k_ECallbackFlagsRegistered=1,
        k_ECallbackFlagsGameServer=2
    };
    protected unsigned int m_nCallbackFlags;
    protected int m_iCallback;
    private class CCallbackBase & operator=(class CCallbackBase & );
};

class CSteamAPIContext
{
    public void CSteamAPIContext();
    public void Clear();
    public bool Init();
    public class ISteamClient * SteamClient();
    public class ISteamUser * SteamUser();
    public class ISteamFriends * SteamFriends();
    public class ISteamUtils * SteamUtils();
    public class ISteamMatchmaking * SteamMatchmaking();
    public class ISteamGameSearch * SteamGameSearch();
    public class ISteamUserStats * SteamUserStats();
    public class ISteamApps * SteamApps();
    public class ISteamMatchmakingServers * SteamMatchmakingServers();
    public class ISteamNetworking * SteamNetworking();
    public class ISteamRemoteStorage * SteamRemoteStorage();
    public class ISteamScreenshots * SteamScreenshots();
    public class ISteamHTTP * SteamHTTP();
    public class ISteamController * SteamController();
    public class ISteamUGC * SteamUGC();
    public class ISteamAppList * SteamAppList();
    public class ISteamMusic * SteamMusic();
    public class ISteamMusicRemote * SteamMusicRemote();
    public class ISteamHTMLSurface * SteamHTMLSurface();
    public class ISteamInventory * SteamInventory();
    public class ISteamVideo * SteamVideo();
    public class ISteamParentalSettings * SteamParentalSettings();
    public class ISteamInput * SteamInput();
    private class ISteamClient * m_pSteamClient;
    private class ISteamUser * m_pSteamUser;
    private class ISteamFriends * m_pSteamFriends;
    private class ISteamUtils * m_pSteamUtils;
    private class ISteamMatchmaking * m_pSteamMatchmaking;
    private class ISteamGameSearch * m_pSteamGameSearch;
    private class ISteamUserStats * m_pSteamUserStats;
    private class ISteamApps * m_pSteamApps;
    private class ISteamMatchmakingServers * m_pSteamMatchmakingServers;
    private class ISteamNetworking * m_pSteamNetworking;
    private class ISteamRemoteStorage * m_pSteamRemoteStorage;
    private class ISteamScreenshots * m_pSteamScreenshots;
    private class ISteamHTTP * m_pSteamHTTP;
    private class ISteamController * m_pController;
    private class ISteamUGC * m_pSteamUGC;
    private class ISteamAppList * m_pSteamAppList;
    private class ISteamMusic * m_pSteamMusic;
    private class ISteamMusicRemote * m_pSteamMusicRemote;
    private class ISteamHTMLSurface * m_pSteamHTMLSurface;
    private class ISteamInventory * m_pSteamInventory;
    private class ISteamVideo * m_pSteamVideo;
    private class ISteamParentalSettings * m_pSteamParentalSettings;
    private class ISteamInput * m_pSteamInput;
};

class CSteamAPIContext
{
    public void CSteamAPIContext();
    public void Clear();
    public bool Init();
    public class ISteamClient * SteamClient();
    public class ISteamUser * SteamUser();
    public class ISteamFriends * SteamFriends();
    public class ISteamUtils * SteamUtils();
    public class ISteamMatchmaking * SteamMatchmaking();
    public class ISteamGameSearch * SteamGameSearch();
    public class ISteamUserStats * SteamUserStats();
    public class ISteamApps * SteamApps();
    public class ISteamMatchmakingServers * SteamMatchmakingServers();
    public class ISteamNetworking * SteamNetworking();
    public class ISteamRemoteStorage * SteamRemoteStorage();
    public class ISteamScreenshots * SteamScreenshots();
    public class ISteamHTTP * SteamHTTP();
    public class ISteamController * SteamController();
    public class ISteamUGC * SteamUGC();
    public class ISteamAppList * SteamAppList();
    public class ISteamMusic * SteamMusic();
    public class ISteamMusicRemote * SteamMusicRemote();
    public class ISteamHTMLSurface * SteamHTMLSurface();
    public class ISteamInventory * SteamInventory();
    public class ISteamVideo * SteamVideo();
    public class ISteamParentalSettings * SteamParentalSettings();
    public class ISteamInput * SteamInput();
    private class ISteamClient * m_pSteamClient;
    private class ISteamUser * m_pSteamUser;
    private class ISteamFriends * m_pSteamFriends;
    private class ISteamUtils * m_pSteamUtils;
    private class ISteamMatchmaking * m_pSteamMatchmaking;
    private class ISteamGameSearch * m_pSteamGameSearch;
    private class ISteamUserStats * m_pSteamUserStats;
    private class ISteamApps * m_pSteamApps;
    private class ISteamMatchmakingServers * m_pSteamMatchmakingServers;
    private class ISteamNetworking * m_pSteamNetworking;
    private class ISteamRemoteStorage * m_pSteamRemoteStorage;
    private class ISteamScreenshots * m_pSteamScreenshots;
    private class ISteamHTTP * m_pSteamHTTP;
    private class ISteamController * m_pController;
    private class ISteamUGC * m_pSteamUGC;
    private class ISteamAppList * m_pSteamAppList;
    private class ISteamMusic * m_pSteamMusic;
    private class ISteamMusicRemote * m_pSteamMusicRemote;
    private class ISteamHTMLSurface * m_pSteamHTMLSurface;
    private class ISteamInventory * m_pSteamInventory;
    private class ISteamVideo * m_pSteamVideo;
    private class ISteamParentalSettings * m_pSteamParentalSettings;
    private class ISteamInput * m_pSteamInput;
};

class ISteamGameServer
{
};

class ISteamGameServerStats
{
};

class ISteamClient
{
    public int CreateSteamPipe();
    public bool BReleaseSteamPipe(int );
    public int ConnectToGlobalUser(int );
    public int CreateLocalUser(int * ,enum EAccountType );
    public void ReleaseUser(int ,int );
    public class ISteamUser * GetISteamUser(int ,int ,char * );
    public class ISteamGameServer * GetISteamGameServer(int ,int ,char * );
    public void SetLocalIPBinding(unsigned int ,unsigned int );
    public class ISteamFriends * GetISteamFriends(int ,int ,char * );
    public class ISteamUtils * GetISteamUtils(int ,char * );
    public class ISteamMatchmaking * GetISteamMatchmaking(int ,int ,char * );
    public class ISteamMatchmakingServers * GetISteamMatchmakingServers(int ,int ,char * );
    public void * GetISteamGenericInterface(int ,int ,char * );
    public class ISteamUserStats * GetISteamUserStats(int ,int ,char * );
    public class ISteamGameServerStats * GetISteamGameServerStats(int ,int ,char * );
    public class ISteamApps * GetISteamApps(int ,int ,char * );
    public class ISteamNetworking * GetISteamNetworking(int ,int ,char * );
    public class ISteamRemoteStorage * GetISteamRemoteStorage(int ,int ,char * );
    public class ISteamScreenshots * GetISteamScreenshots(int ,int ,char * );
    public class ISteamGameSearch * GetISteamGameSearch(int ,int ,char * );
    protected void RunFrame();
    public unsigned int GetIPCCallCount();
    public void SetWarningMessageHook(void  ( * )(int ,char * ));
    public bool BShutdownIfAllPipesClosed();
    public class ISteamHTTP * GetISteamHTTP(int ,int ,char * );
    protected void * DEPRECATED_GetISteamUnifiedMessages(int ,int ,char * );
    public class ISteamController * GetISteamController(int ,int ,char * );
    public class ISteamUGC * GetISteamUGC(int ,int ,char * );
    public class ISteamAppList * GetISteamAppList(int ,int ,char * );
    public class ISteamMusic * GetISteamMusic(int ,int ,char * );
    public class ISteamMusicRemote * GetISteamMusicRemote(int ,int ,char * );
    public class ISteamHTMLSurface * GetISteamHTMLSurface(int ,int ,char * );
    protected void DEPRECATED_Set_SteamAPI_CPostAPIResultInProcess(void  ( * )());
    protected void DEPRECATED_Remove_SteamAPI_CPostAPIResultInProcess(void  ( * )());
    protected void Set_SteamAPI_CCheckCallbackRegisteredInProcess(unsigned int  ( * )(int ));
    public class ISteamInventory * GetISteamInventory(int ,int ,char * );
    public class ISteamVideo * GetISteamVideo(int ,int ,char * );
    public class ISteamParentalSettings * GetISteamParentalSettings(int ,int ,char * );
    public class ISteamInput * GetISteamInput(int ,int ,char * );
    public class ISteamParties * GetISteamParties(int ,int ,char * );
    public void ISteamClient(class ISteamClient * );
    public void ISteamClient(class ISteamClient & );
    public void ISteamClient();
    public class ISteamClient & operator=(class ISteamClient * );
    public class ISteamClient & operator=(class ISteamClient & );
};

class ISteamClient
{
    public int CreateSteamPipe();
    public bool BReleaseSteamPipe(int );
    public int ConnectToGlobalUser(int );
    public int CreateLocalUser(int * ,enum EAccountType );
    public void ReleaseUser(int ,int );
    public class ISteamUser * GetISteamUser(int ,int ,char * );
    public class ISteamGameServer * GetISteamGameServer(int ,int ,char * );
    public void SetLocalIPBinding(unsigned int ,unsigned int );
    public class ISteamFriends * GetISteamFriends(int ,int ,char * );
    public class ISteamUtils * GetISteamUtils(int ,char * );
    public class ISteamMatchmaking * GetISteamMatchmaking(int ,int ,char * );
    public class ISteamMatchmakingServers * GetISteamMatchmakingServers(int ,int ,char * );
    public void * GetISteamGenericInterface(int ,int ,char * );
    public class ISteamUserStats * GetISteamUserStats(int ,int ,char * );
    public class ISteamGameServerStats * GetISteamGameServerStats(int ,int ,char * );
    public class ISteamApps * GetISteamApps(int ,int ,char * );
    public class ISteamNetworking * GetISteamNetworking(int ,int ,char * );
    public class ISteamRemoteStorage * GetISteamRemoteStorage(int ,int ,char * );
    public class ISteamScreenshots * GetISteamScreenshots(int ,int ,char * );
    public class ISteamGameSearch * GetISteamGameSearch(int ,int ,char * );
    protected void RunFrame();
    public unsigned int GetIPCCallCount();
    public void SetWarningMessageHook(void  ( * )(int ,char * ));
    public bool BShutdownIfAllPipesClosed();
    public class ISteamHTTP * GetISteamHTTP(int ,int ,char * );
    protected void * DEPRECATED_GetISteamUnifiedMessages(int ,int ,char * );
    public class ISteamController * GetISteamController(int ,int ,char * );
    public class ISteamUGC * GetISteamUGC(int ,int ,char * );
    public class ISteamAppList * GetISteamAppList(int ,int ,char * );
    public class ISteamMusic * GetISteamMusic(int ,int ,char * );
    public class ISteamMusicRemote * GetISteamMusicRemote(int ,int ,char * );
    public class ISteamHTMLSurface * GetISteamHTMLSurface(int ,int ,char * );
    protected void DEPRECATED_Set_SteamAPI_CPostAPIResultInProcess(void  ( * )());
    protected void DEPRECATED_Remove_SteamAPI_CPostAPIResultInProcess(void  ( * )());
    protected void Set_SteamAPI_CCheckCallbackRegisteredInProcess(unsigned int  ( * )(int ));
    public class ISteamInventory * GetISteamInventory(int ,int ,char * );
    public class ISteamVideo * GetISteamVideo(int ,int ,char * );
    public class ISteamParentalSettings * GetISteamParentalSettings(int ,int ,char * );
    public class ISteamInput * GetISteamInput(int ,int ,char * );
    public class ISteamParties * GetISteamParties(int ,int ,char * );
    public void ISteamClient(class ISteamClient * );
    public void ISteamClient(class ISteamClient & );
    public void ISteamClient();
    public class ISteamClient & operator=(class ISteamClient * );
    public class ISteamClient & operator=(class ISteamClient & );
};

enum EVoiceResult
{
    k_EVoiceResultOK=0,
    k_EVoiceResultNotInitialized=1,
    k_EVoiceResultNotRecording=2,
    k_EVoiceResultNoData=3,
    k_EVoiceResultBufferTooSmall=4,
    k_EVoiceResultDataCorrupted=5,
    k_EVoiceResultRestricted=6,
    k_EVoiceResultUnsupportedCodec=7,
    k_EVoiceResultReceiverOutOfDate=8,
    k_EVoiceResultReceiverDidNotAnswer=9
};

enum EBeginAuthSessionResult
{
    k_EBeginAuthSessionResultOK=0,
    k_EBeginAuthSessionResultInvalidTicket=1,
    k_EBeginAuthSessionResultDuplicateRequest=2,
    k_EBeginAuthSessionResultInvalidVersion=3,
    k_EBeginAuthSessionResultGameMismatch=4,
    k_EBeginAuthSessionResultExpiredTicket=5
};

enum EUserHasLicenseForAppResult
{
    k_EUserHasLicenseResultHasLicense=0,
    k_EUserHasLicenseResultDoesNotHaveLicense=1,
    k_EUserHasLicenseResultNoAuth=2
};

class ISteamUser
{
    public int GetHSteamUser();
    public bool BLoggedOn();
    public class CSteamID GetSteamID();
    public int InitiateGameConnection(void * ,int ,class CSteamID ,unsigned int ,unsigned int ,bool );
    public void TerminateGameConnection(unsigned int ,unsigned int );
    public void TrackAppUsageEvent(class CGameID ,int ,char * );
    public bool GetUserDataFolder(char * ,int );
    public void StartVoiceRecording();
    public void StopVoiceRecording();
    public enum EVoiceResult GetAvailableVoice(unsigned int * ,unsigned int * ,unsigned int );
    public enum EVoiceResult GetVoice(bool ,void * ,unsigned int ,unsigned int * ,bool ,void * ,unsigned int ,unsigned int * ,unsigned int );
    public enum EVoiceResult DecompressVoice(void * ,unsigned int ,void * ,unsigned int ,unsigned int * ,unsigned int );
    public unsigned int GetVoiceOptimalSampleRate();
    public unsigned int GetAuthSessionTicket(void * ,int ,unsigned int * );
    public enum EBeginAuthSessionResult BeginAuthSession(void * ,int ,class CSteamID );
    public void EndAuthSession(class CSteamID );
    public void CancelAuthTicket(unsigned int );
    public enum EUserHasLicenseForAppResult UserHasLicenseForApp(class CSteamID ,unsigned int );
    public bool BIsBehindNAT();
    public void AdvertiseGame(class CSteamID ,unsigned int ,unsigned int );
    public unsigned int RequestEncryptedAppTicket(void * ,int );
    public bool GetEncryptedAppTicket(void * ,int ,unsigned int * );
    public int GetGameBadgeLevel(int ,bool );
    public int GetPlayerSteamLevel();
    public unsigned int RequestStoreAuthURL(char * );
    public bool BIsPhoneVerified();
    public bool BIsTwoFactorEnabled();
    public bool BIsPhoneIdentifying();
    public bool BIsPhoneRequiringVerification();
    public unsigned int GetMarketEligibility();
    public void ISteamUser(class ISteamUser * );
    public void ISteamUser(class ISteamUser & );
    public void ISteamUser();
    public class ISteamUser & operator=(class ISteamUser * );
    public class ISteamUser & operator=(class ISteamUser & );
};

class ISteamUser
{
    public int GetHSteamUser();
    public bool BLoggedOn();
    public class CSteamID GetSteamID();
    public int InitiateGameConnection(void * ,int ,class CSteamID ,unsigned int ,unsigned int ,bool );
    public void TerminateGameConnection(unsigned int ,unsigned int );
    public void TrackAppUsageEvent(class CGameID ,int ,char * );
    public bool GetUserDataFolder(char * ,int );
    public void StartVoiceRecording();
    public void StopVoiceRecording();
    public enum EVoiceResult GetAvailableVoice(unsigned int * ,unsigned int * ,unsigned int );
    public enum EVoiceResult GetVoice(bool ,void * ,unsigned int ,unsigned int * ,bool ,void * ,unsigned int ,unsigned int * ,unsigned int );
    public enum EVoiceResult DecompressVoice(void * ,unsigned int ,void * ,unsigned int ,unsigned int * ,unsigned int );
    public unsigned int GetVoiceOptimalSampleRate();
    public unsigned int GetAuthSessionTicket(void * ,int ,unsigned int * );
    public enum EBeginAuthSessionResult BeginAuthSession(void * ,int ,class CSteamID );
    public void EndAuthSession(class CSteamID );
    public void CancelAuthTicket(unsigned int );
    public enum EUserHasLicenseForAppResult UserHasLicenseForApp(class CSteamID ,unsigned int );
    public bool BIsBehindNAT();
    public void AdvertiseGame(class CSteamID ,unsigned int ,unsigned int );
    public unsigned int RequestEncryptedAppTicket(void * ,int );
    public bool GetEncryptedAppTicket(void * ,int ,unsigned int * );
    public int GetGameBadgeLevel(int ,bool );
    public int GetPlayerSteamLevel();
    public unsigned int RequestStoreAuthURL(char * );
    public bool BIsPhoneVerified();
    public bool BIsTwoFactorEnabled();
    public bool BIsPhoneIdentifying();
    public bool BIsPhoneRequiringVerification();
    public unsigned int GetMarketEligibility();
    public void ISteamUser(class ISteamUser * );
    public void ISteamUser(class ISteamUser & );
    public void ISteamUser();
    public class ISteamUser & operator=(class ISteamUser * );
    public class ISteamUser & operator=(class ISteamUser & );
};

enum EPersonaState
{
    k_EPersonaStateOffline=0,
    k_EPersonaStateOnline=1,
    k_EPersonaStateBusy=2,
    k_EPersonaStateAway=3,
    k_EPersonaStateSnooze=4,
    k_EPersonaStateLookingToTrade=5,
    k_EPersonaStateLookingToPlay=6,
    k_EPersonaStateInvisible=7,
    k_EPersonaStateMax=8
};

enum EFriendRelationship
{
    k_EFriendRelationshipNone=0,
    k_EFriendRelationshipBlocked=1,
    k_EFriendRelationshipRequestRecipient=2,
    k_EFriendRelationshipFriend=3,
    k_EFriendRelationshipRequestInitiator=4,
    k_EFriendRelationshipIgnored=5,
    k_EFriendRelationshipIgnoredFriend=6,
    k_EFriendRelationshipSuggested_DEPRECATED=7,
    k_EFriendRelationshipMax=8
};

enum EOverlayToStoreFlag
{
    k_EOverlayToStoreFlag_None=0,
    k_EOverlayToStoreFlag_AddToCart=1,
    k_EOverlayToStoreFlag_AddToCartAndShow=2
};

enum EChatEntryType
{
    k_EChatEntryTypeInvalid=0,
    k_EChatEntryTypeChatMsg=1,
    k_EChatEntryTypeTyping=2,
    k_EChatEntryTypeInviteGame=3,
    k_EChatEntryTypeEmote=4,
    k_EChatEntryTypeLeftConversation=6,
    k_EChatEntryTypeEntered=7,
    k_EChatEntryTypeWasKicked=8,
    k_EChatEntryTypeWasBanned=9,
    k_EChatEntryTypeDisconnected=10,
    k_EChatEntryTypeHistoricalChat=11,
    k_EChatEntryTypeLinkBlocked=14
};

class ISteamFriends
{
    public char * GetPersonaName();
    public unsigned int SetPersonaName(char * );
    public enum EPersonaState GetPersonaState();
    public int GetFriendCount(int );
    public class CSteamID GetFriendByIndex(int ,int );
    public enum EFriendRelationship GetFriendRelationship(class CSteamID );
    public enum EPersonaState GetFriendPersonaState(class CSteamID );
    public char * GetFriendPersonaName(class CSteamID );
    public bool GetFriendGamePlayed(class CSteamID ,struct FriendGameInfo_t * );
    public char * GetFriendPersonaNameHistory(class CSteamID ,int );
    public int GetFriendSteamLevel(class CSteamID );
    public char * GetPlayerNickname(class CSteamID );
    public int GetFriendsGroupCount();
    public int GetFriendsGroupIDByIndex(int );
    public char * GetFriendsGroupName(int );
    public int GetFriendsGroupMembersCount(int );
    public void GetFriendsGroupMembersList(int ,class CSteamID * ,int );
    public bool HasFriend(class CSteamID ,int );
    public int GetClanCount();
    public class CSteamID GetClanByIndex(int );
    public char * GetClanName(class CSteamID );
    public char * GetClanTag(class CSteamID );
    public bool GetClanActivityCounts(class CSteamID ,int * ,int * ,int * );
    public unsigned int DownloadClanActivityCounts(class CSteamID * ,int );
    public int GetFriendCountFromSource(class CSteamID );
    public class CSteamID GetFriendFromSourceByIndex(class CSteamID ,int );
    public bool IsUserInSource(class CSteamID ,class CSteamID );
    public void SetInGameVoiceSpeaking(class CSteamID ,bool );
    public void ActivateGameOverlay(char * );
    public void ActivateGameOverlayToUser(char * ,class CSteamID );
    public void ActivateGameOverlayToWebPage(char * ,enum EActivateGameOverlayToWebPageMode );
    public void ActivateGameOverlayToStore(unsigned int ,enum EOverlayToStoreFlag );
    public void SetPlayedWith(class CSteamID );
    public void ActivateGameOverlayInviteDialog(class CSteamID );
    public int GetSmallFriendAvatar(class CSteamID );
    public int GetMediumFriendAvatar(class CSteamID );
    public int GetLargeFriendAvatar(class CSteamID );
    public bool RequestUserInformation(class CSteamID ,bool );
    public unsigned int RequestClanOfficerList(class CSteamID );
    public class CSteamID GetClanOwner(class CSteamID );
    public int GetClanOfficerCount(class CSteamID );
    public class CSteamID GetClanOfficerByIndex(class CSteamID ,int );
    public unsigned int GetUserRestrictions();
    public bool SetRichPresence(char * ,char * );
    public void ClearRichPresence();
    public char * GetFriendRichPresence(class CSteamID ,char * );
    public int GetFriendRichPresenceKeyCount(class CSteamID );
    public char * GetFriendRichPresenceKeyByIndex(class CSteamID ,int );
    public void RequestFriendRichPresence(class CSteamID );
    public bool InviteUserToGame(class CSteamID ,char * );
    public int GetCoplayFriendCount();
    public class CSteamID GetCoplayFriend(int );
    public int GetFriendCoplayTime(class CSteamID );
    public unsigned int GetFriendCoplayGame(class CSteamID );
    public unsigned int JoinClanChatRoom(class CSteamID );
    public bool LeaveClanChatRoom(class CSteamID );
    public int GetClanChatMemberCount(class CSteamID );
    public class CSteamID GetChatMemberByIndex(class CSteamID ,int );
    public bool SendClanChatMessage(class CSteamID ,char * );
    public int GetClanChatMessage(class CSteamID ,int ,void * ,int ,enum EChatEntryType * ,class CSteamID * );
    public bool IsClanChatAdmin(class CSteamID ,class CSteamID );
    public bool IsClanChatWindowOpenInSteam(class CSteamID );
    public bool OpenClanChatWindowInSteam(class CSteamID );
    public bool CloseClanChatWindowInSteam(class CSteamID );
    public bool SetListenForFriendsMessages(bool );
    public bool ReplyToFriendMessage(class CSteamID ,char * );
    public int GetFriendMessage(class CSteamID ,int ,void * ,int ,enum EChatEntryType * );
    public unsigned int GetFollowerCount(class CSteamID );
    public unsigned int IsFollowing(class CSteamID );
    public unsigned int EnumerateFollowingList(unsigned int );
    public bool IsClanPublic(class CSteamID );
    public bool IsClanOfficialGameGroup(class CSteamID );
    public int GetNumChatsWithUnreadPriorityMessages();
    public void ISteamFriends(class ISteamFriends * );
    public void ISteamFriends(class ISteamFriends & );
    public void ISteamFriends();
    public class ISteamFriends & operator=(class ISteamFriends * );
    public class ISteamFriends & operator=(class ISteamFriends & );
};

class ISteamFriends
{
    public char * GetPersonaName();
    public unsigned int SetPersonaName(char * );
    public enum EPersonaState GetPersonaState();
    public int GetFriendCount(int );
    public class CSteamID GetFriendByIndex(int ,int );
    public enum EFriendRelationship GetFriendRelationship(class CSteamID );
    public enum EPersonaState GetFriendPersonaState(class CSteamID );
    public char * GetFriendPersonaName(class CSteamID );
    public bool GetFriendGamePlayed(class CSteamID ,struct FriendGameInfo_t * );
    public char * GetFriendPersonaNameHistory(class CSteamID ,int );
    public int GetFriendSteamLevel(class CSteamID );
    public char * GetPlayerNickname(class CSteamID );
    public int GetFriendsGroupCount();
    public int GetFriendsGroupIDByIndex(int );
    public char * GetFriendsGroupName(int );
    public int GetFriendsGroupMembersCount(int );
    public void GetFriendsGroupMembersList(int ,class CSteamID * ,int );
    public bool HasFriend(class CSteamID ,int );
    public int GetClanCount();
    public class CSteamID GetClanByIndex(int );
    public char * GetClanName(class CSteamID );
    public char * GetClanTag(class CSteamID );
    public bool GetClanActivityCounts(class CSteamID ,int * ,int * ,int * );
    public unsigned int DownloadClanActivityCounts(class CSteamID * ,int );
    public int GetFriendCountFromSource(class CSteamID );
    public class CSteamID GetFriendFromSourceByIndex(class CSteamID ,int );
    public bool IsUserInSource(class CSteamID ,class CSteamID );
    public void SetInGameVoiceSpeaking(class CSteamID ,bool );
    public void ActivateGameOverlay(char * );
    public void ActivateGameOverlayToUser(char * ,class CSteamID );
    public void ActivateGameOverlayToWebPage(char * ,enum EActivateGameOverlayToWebPageMode );
    public void ActivateGameOverlayToStore(unsigned int ,enum EOverlayToStoreFlag );
    public void SetPlayedWith(class CSteamID );
    public void ActivateGameOverlayInviteDialog(class CSteamID );
    public int GetSmallFriendAvatar(class CSteamID );
    public int GetMediumFriendAvatar(class CSteamID );
    public int GetLargeFriendAvatar(class CSteamID );
    public bool RequestUserInformation(class CSteamID ,bool );
    public unsigned int RequestClanOfficerList(class CSteamID );
    public class CSteamID GetClanOwner(class CSteamID );
    public int GetClanOfficerCount(class CSteamID );
    public class CSteamID GetClanOfficerByIndex(class CSteamID ,int );
    public unsigned int GetUserRestrictions();
    public bool SetRichPresence(char * ,char * );
    public void ClearRichPresence();
    public char * GetFriendRichPresence(class CSteamID ,char * );
    public int GetFriendRichPresenceKeyCount(class CSteamID );
    public char * GetFriendRichPresenceKeyByIndex(class CSteamID ,int );
    public void RequestFriendRichPresence(class CSteamID );
    public bool InviteUserToGame(class CSteamID ,char * );
    public int GetCoplayFriendCount();
    public class CSteamID GetCoplayFriend(int );
    public int GetFriendCoplayTime(class CSteamID );
    public unsigned int GetFriendCoplayGame(class CSteamID );
    public unsigned int JoinClanChatRoom(class CSteamID );
    public bool LeaveClanChatRoom(class CSteamID );
    public int GetClanChatMemberCount(class CSteamID );
    public class CSteamID GetChatMemberByIndex(class CSteamID ,int );
    public bool SendClanChatMessage(class CSteamID ,char * );
    public int GetClanChatMessage(class CSteamID ,int ,void * ,int ,enum EChatEntryType * ,class CSteamID * );
    public bool IsClanChatAdmin(class CSteamID ,class CSteamID );
    public bool IsClanChatWindowOpenInSteam(class CSteamID );
    public bool OpenClanChatWindowInSteam(class CSteamID );
    public bool CloseClanChatWindowInSteam(class CSteamID );
    public bool SetListenForFriendsMessages(bool );
    public bool ReplyToFriendMessage(class CSteamID ,char * );
    public int GetFriendMessage(class CSteamID ,int ,void * ,int ,enum EChatEntryType * );
    public unsigned int GetFollowerCount(class CSteamID );
    public unsigned int IsFollowing(class CSteamID );
    public unsigned int EnumerateFollowingList(unsigned int );
    public bool IsClanPublic(class CSteamID );
    public bool IsClanOfficialGameGroup(class CSteamID );
    public int GetNumChatsWithUnreadPriorityMessages();
    public void ISteamFriends(class ISteamFriends * );
    public void ISteamFriends(class ISteamFriends & );
    public void ISteamFriends();
    public class ISteamFriends & operator=(class ISteamFriends * );
    public class ISteamFriends & operator=(class ISteamFriends & );
};

enum ESteamAPICallFailure
{
    k_ESteamAPICallFailureNone=-1,
    k_ESteamAPICallFailureSteamGone=0,
    k_ESteamAPICallFailureNetworkFailure=1,
    k_ESteamAPICallFailureInvalidHandle=2,
    k_ESteamAPICallFailureMismatchedCallback=3
};

enum EGamepadTextInputMode
{
    k_EGamepadTextInputModeNormal=0,
    k_EGamepadTextInputModePassword=1
};

enum EGamepadTextInputLineMode
{
    k_EGamepadTextInputLineModeSingleLine=0,
    k_EGamepadTextInputLineModeMultipleLines=1
};

class ISteamUtils
{
    public unsigned int GetSecondsSinceAppActive();
    public unsigned int GetSecondsSinceComputerActive();
    public enum EUniverse GetConnectedUniverse();
    public unsigned int GetServerRealTime();
    public char * GetIPCountry();
    public bool GetImageSize(int ,unsigned int * ,unsigned int * );
    public bool GetImageRGBA(int ,unsigned int * ,int );
    public bool GetCSERIPPort(unsigned int * ,unsigned int * );
    public unsigned int GetCurrentBatteryPower();
    public unsigned int GetAppID();
    public void SetOverlayNotificationPosition(enum ENotificationPosition );
    public bool IsAPICallCompleted(unsigned int ,bool * );
    public enum ESteamAPICallFailure GetAPICallFailureReason(unsigned int );
    public bool GetAPICallResult(unsigned int ,void * ,int ,int ,bool * );
    protected void RunFrame();
    public unsigned int GetIPCCallCount();
    public void SetWarningMessageHook(void  ( * )(int ,char * ));
    public bool IsOverlayEnabled();
    public bool BOverlayNeedsPresent();
    public unsigned int CheckFileSignature(char * );
    public bool ShowGamepadTextInput(enum EGamepadTextInputMode ,enum EGamepadTextInputLineMode ,char * ,unsigned int ,char * );
    public unsigned int GetEnteredGamepadTextLength();
    public bool GetEnteredGamepadTextInput(char * ,unsigned int );
    public char * GetSteamUILanguage();
    public bool IsSteamRunningInVR();
    public void SetOverlayNotificationInset(int ,int );
    public bool IsSteamInBigPictureMode();
    public void StartVRDashboard();
    public bool IsVRHeadsetStreamingEnabled();
    public void SetVRHeadsetStreamingEnabled(bool );
    public void ISteamUtils(class ISteamUtils * );
    public void ISteamUtils(class ISteamUtils & );
    public void ISteamUtils();
    public class ISteamUtils & operator=(class ISteamUtils * );
    public class ISteamUtils & operator=(class ISteamUtils & );
};

class ISteamUtils
{
    public unsigned int GetSecondsSinceAppActive();
    public unsigned int GetSecondsSinceComputerActive();
    public enum EUniverse GetConnectedUniverse();
    public unsigned int GetServerRealTime();
    public char * GetIPCountry();
    public bool GetImageSize(int ,unsigned int * ,unsigned int * );
    public bool GetImageRGBA(int ,unsigned int * ,int );
    public bool GetCSERIPPort(unsigned int * ,unsigned int * );
    public unsigned int GetCurrentBatteryPower();
    public unsigned int GetAppID();
    public void SetOverlayNotificationPosition(enum ENotificationPosition );
    public bool IsAPICallCompleted(unsigned int ,bool * );
    public enum ESteamAPICallFailure GetAPICallFailureReason(unsigned int );
    public bool GetAPICallResult(unsigned int ,void * ,int ,int ,bool * );
    protected void RunFrame();
    public unsigned int GetIPCCallCount();
    public void SetWarningMessageHook(void  ( * )(int ,char * ));
    public bool IsOverlayEnabled();
    public bool BOverlayNeedsPresent();
    public unsigned int CheckFileSignature(char * );
    public bool ShowGamepadTextInput(enum EGamepadTextInputMode ,enum EGamepadTextInputLineMode ,char * ,unsigned int ,char * );
    public unsigned int GetEnteredGamepadTextLength();
    public bool GetEnteredGamepadTextInput(char * ,unsigned int );
    public char * GetSteamUILanguage();
    public bool IsSteamRunningInVR();
    public void SetOverlayNotificationInset(int ,int );
    public bool IsSteamInBigPictureMode();
    public void StartVRDashboard();
    public bool IsVRHeadsetStreamingEnabled();
    public void SetVRHeadsetStreamingEnabled(bool );
    public void ISteamUtils(class ISteamUtils * );
    public void ISteamUtils(class ISteamUtils & );
    public void ISteamUtils();
    public class ISteamUtils & operator=(class ISteamUtils * );
    public class ISteamUtils & operator=(class ISteamUtils & );
};

enum ELobbyComparison
{
    k_ELobbyComparisonEqualToOrLessThan=-2,
    k_ELobbyComparisonLessThan=-1,
    k_ELobbyComparisonEqual=0,
    k_ELobbyComparisonGreaterThan=1,
    k_ELobbyComparisonEqualToOrGreaterThan=2,
    k_ELobbyComparisonNotEqual=3
};

enum ELobbyDistanceFilter
{
    k_ELobbyDistanceFilterClose=0,
    k_ELobbyDistanceFilterDefault=1,
    k_ELobbyDistanceFilterFar=2,
    k_ELobbyDistanceFilterWorldwide=3
};

enum ELobbyType
{
    k_ELobbyTypePrivate=0,
    k_ELobbyTypeFriendsOnly=1,
    k_ELobbyTypePublic=2,
    k_ELobbyTypeInvisible=3
};

class ISteamMatchmaking
{
    public int GetFavoriteGameCount();
    public bool GetFavoriteGame(int ,unsigned int * ,unsigned int * ,unsigned int * ,unsigned int * ,unsigned int * ,unsigned int * );
    public int AddFavoriteGame(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public bool RemoveFavoriteGame(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public unsigned int RequestLobbyList();
    public void AddRequestLobbyListStringFilter(char * ,char * ,enum ELobbyComparison );
    public void AddRequestLobbyListNumericalFilter(char * ,int ,enum ELobbyComparison );
    public void AddRequestLobbyListNearValueFilter(char * ,int );
    public void AddRequestLobbyListFilterSlotsAvailable(int );
    public void AddRequestLobbyListDistanceFilter(enum ELobbyDistanceFilter );
    public void AddRequestLobbyListResultCountFilter(int );
    public void AddRequestLobbyListCompatibleMembersFilter(class CSteamID );
    public class CSteamID GetLobbyByIndex(int );
    public unsigned int CreateLobby(enum ELobbyType ,int );
    public unsigned int JoinLobby(class CSteamID );
    public void LeaveLobby(class CSteamID );
    public bool InviteUserToLobby(class CSteamID ,class CSteamID );
    public int GetNumLobbyMembers(class CSteamID );
    public class CSteamID GetLobbyMemberByIndex(class CSteamID ,int );
    public char * GetLobbyData(class CSteamID ,char * );
    public bool SetLobbyData(class CSteamID ,char * ,char * );
    public int GetLobbyDataCount(class CSteamID );
    public bool GetLobbyDataByIndex(class CSteamID ,int ,char * ,int ,char * ,int );
    public bool DeleteLobbyData(class CSteamID ,char * );
    public char * GetLobbyMemberData(class CSteamID ,class CSteamID ,char * );
    public void SetLobbyMemberData(class CSteamID ,char * ,char * );
    public bool SendLobbyChatMsg(class CSteamID ,void * ,int );
    public int GetLobbyChatEntry(class CSteamID ,int ,class CSteamID * ,void * ,int ,enum EChatEntryType * );
    public bool RequestLobbyData(class CSteamID );
    public void SetLobbyGameServer(class CSteamID ,unsigned int ,unsigned int ,class CSteamID );
    public bool GetLobbyGameServer(class CSteamID ,unsigned int * ,unsigned int * ,class CSteamID * );
    public bool SetLobbyMemberLimit(class CSteamID ,int );
    public int GetLobbyMemberLimit(class CSteamID );
    public bool SetLobbyType(class CSteamID ,enum ELobbyType );
    public bool SetLobbyJoinable(class CSteamID ,bool );
    public class CSteamID GetLobbyOwner(class CSteamID );
    public bool SetLobbyOwner(class CSteamID ,class CSteamID );
    public bool SetLinkedLobby(class CSteamID ,class CSteamID );
    public void ISteamMatchmaking(class ISteamMatchmaking * );
    public void ISteamMatchmaking(class ISteamMatchmaking & );
    public void ISteamMatchmaking();
    public class ISteamMatchmaking & operator=(class ISteamMatchmaking * );
    public class ISteamMatchmaking & operator=(class ISteamMatchmaking & );
};

class ISteamMatchmaking
{
    public int GetFavoriteGameCount();
    public bool GetFavoriteGame(int ,unsigned int * ,unsigned int * ,unsigned int * ,unsigned int * ,unsigned int * ,unsigned int * );
    public int AddFavoriteGame(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public bool RemoveFavoriteGame(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public unsigned int RequestLobbyList();
    public void AddRequestLobbyListStringFilter(char * ,char * ,enum ELobbyComparison );
    public void AddRequestLobbyListNumericalFilter(char * ,int ,enum ELobbyComparison );
    public void AddRequestLobbyListNearValueFilter(char * ,int );
    public void AddRequestLobbyListFilterSlotsAvailable(int );
    public void AddRequestLobbyListDistanceFilter(enum ELobbyDistanceFilter );
    public void AddRequestLobbyListResultCountFilter(int );
    public void AddRequestLobbyListCompatibleMembersFilter(class CSteamID );
    public class CSteamID GetLobbyByIndex(int );
    public unsigned int CreateLobby(enum ELobbyType ,int );
    public unsigned int JoinLobby(class CSteamID );
    public void LeaveLobby(class CSteamID );
    public bool InviteUserToLobby(class CSteamID ,class CSteamID );
    public int GetNumLobbyMembers(class CSteamID );
    public class CSteamID GetLobbyMemberByIndex(class CSteamID ,int );
    public char * GetLobbyData(class CSteamID ,char * );
    public bool SetLobbyData(class CSteamID ,char * ,char * );
    public int GetLobbyDataCount(class CSteamID );
    public bool GetLobbyDataByIndex(class CSteamID ,int ,char * ,int ,char * ,int );
    public bool DeleteLobbyData(class CSteamID ,char * );
    public char * GetLobbyMemberData(class CSteamID ,class CSteamID ,char * );
    public void SetLobbyMemberData(class CSteamID ,char * ,char * );
    public bool SendLobbyChatMsg(class CSteamID ,void * ,int );
    public int GetLobbyChatEntry(class CSteamID ,int ,class CSteamID * ,void * ,int ,enum EChatEntryType * );
    public bool RequestLobbyData(class CSteamID );
    public void SetLobbyGameServer(class CSteamID ,unsigned int ,unsigned int ,class CSteamID );
    public bool GetLobbyGameServer(class CSteamID ,unsigned int * ,unsigned int * ,class CSteamID * );
    public bool SetLobbyMemberLimit(class CSteamID ,int );
    public int GetLobbyMemberLimit(class CSteamID );
    public bool SetLobbyType(class CSteamID ,enum ELobbyType );
    public bool SetLobbyJoinable(class CSteamID ,bool );
    public class CSteamID GetLobbyOwner(class CSteamID );
    public bool SetLobbyOwner(class CSteamID ,class CSteamID );
    public bool SetLinkedLobby(class CSteamID ,class CSteamID );
    public void ISteamMatchmaking(class ISteamMatchmaking * );
    public void ISteamMatchmaking(class ISteamMatchmaking & );
    public void ISteamMatchmaking();
    public class ISteamMatchmaking & operator=(class ISteamMatchmaking * );
    public class ISteamMatchmaking & operator=(class ISteamMatchmaking & );
};

enum EGameSearchErrorCode_t
{
    k_EGameSearchErrorCode_OK=1,
    k_EGameSearchErrorCode_Failed_Search_Already_In_Progress=2,
    k_EGameSearchErrorCode_Failed_No_Search_In_Progress=3,
    k_EGameSearchErrorCode_Failed_Not_Lobby_Leader=4,
    k_EGameSearchErrorCode_Failed_No_Host_Available=5,
    k_EGameSearchErrorCode_Failed_Search_Params_Invalid=6,
    k_EGameSearchErrorCode_Failed_Offline=7,
    k_EGameSearchErrorCode_Failed_NotAuthorized=8,
    k_EGameSearchErrorCode_Failed_Unknown_Error=9
};

enum EPlayerResult_t
{
    k_EPlayerResultFailedToConnect=1,
    k_EPlayerResultAbandoned=2,
    k_EPlayerResultKicked=3,
    k_EPlayerResultIncomplete=4,
    k_EPlayerResultCompleted=5
};

class ISteamGameSearch
{
    public enum EGameSearchErrorCode_t AddGameSearchParams(char * ,char * );
    public enum EGameSearchErrorCode_t SearchForGameWithLobby(class CSteamID ,int ,int );
    public enum EGameSearchErrorCode_t SearchForGameSolo(int ,int );
    public enum EGameSearchErrorCode_t AcceptGame();
    public enum EGameSearchErrorCode_t DeclineGame();
    public enum EGameSearchErrorCode_t RetrieveConnectionDetails(class CSteamID ,char * ,int );
    public enum EGameSearchErrorCode_t EndGameSearch();
    public enum EGameSearchErrorCode_t SetGameHostParams(char * ,char * );
    public enum EGameSearchErrorCode_t SetConnectionDetails(char * ,int );
    public enum EGameSearchErrorCode_t RequestPlayersForGame(int ,int ,int );
    public enum EGameSearchErrorCode_t HostConfirmGameStart(unsigned int );
    public enum EGameSearchErrorCode_t CancelRequestPlayersForGame();
    public enum EGameSearchErrorCode_t SubmitPlayerResult(unsigned int ,class CSteamID ,enum EPlayerResult_t );
    public enum EGameSearchErrorCode_t EndGame(unsigned int );
    public void ISteamGameSearch(class ISteamGameSearch * );
    public void ISteamGameSearch(class ISteamGameSearch & );
    public void ISteamGameSearch();
    public class ISteamGameSearch & operator=(class ISteamGameSearch * );
    public class ISteamGameSearch & operator=(class ISteamGameSearch & );
};

class ISteamGameSearch
{
    public enum EGameSearchErrorCode_t AddGameSearchParams(char * ,char * );
    public enum EGameSearchErrorCode_t SearchForGameWithLobby(class CSteamID ,int ,int );
    public enum EGameSearchErrorCode_t SearchForGameSolo(int ,int );
    public enum EGameSearchErrorCode_t AcceptGame();
    public enum EGameSearchErrorCode_t DeclineGame();
    public enum EGameSearchErrorCode_t RetrieveConnectionDetails(class CSteamID ,char * ,int );
    public enum EGameSearchErrorCode_t EndGameSearch();
    public enum EGameSearchErrorCode_t SetGameHostParams(char * ,char * );
    public enum EGameSearchErrorCode_t SetConnectionDetails(char * ,int );
    public enum EGameSearchErrorCode_t RequestPlayersForGame(int ,int ,int );
    public enum EGameSearchErrorCode_t HostConfirmGameStart(unsigned int );
    public enum EGameSearchErrorCode_t CancelRequestPlayersForGame();
    public enum EGameSearchErrorCode_t SubmitPlayerResult(unsigned int ,class CSteamID ,enum EPlayerResult_t );
    public enum EGameSearchErrorCode_t EndGame(unsigned int );
    public void ISteamGameSearch(class ISteamGameSearch * );
    public void ISteamGameSearch(class ISteamGameSearch & );
    public void ISteamGameSearch();
    public class ISteamGameSearch & operator=(class ISteamGameSearch * );
    public class ISteamGameSearch & operator=(class ISteamGameSearch & );
};

enum ELeaderboardSortMethod
{
    k_ELeaderboardSortMethodNone=0,
    k_ELeaderboardSortMethodAscending=1,
    k_ELeaderboardSortMethodDescending=2
};

enum ELeaderboardDisplayType
{
    k_ELeaderboardDisplayTypeNone=0,
    k_ELeaderboardDisplayTypeNumeric=1,
    k_ELeaderboardDisplayTypeTimeSeconds=2,
    k_ELeaderboardDisplayTypeTimeMilliSeconds=3
};

enum ELeaderboardDataRequest
{
    k_ELeaderboardDataRequestGlobal=0,
    k_ELeaderboardDataRequestGlobalAroundUser=1,
    k_ELeaderboardDataRequestFriends=2,
    k_ELeaderboardDataRequestUsers=3
};

enum ELeaderboardUploadScoreMethod
{
    k_ELeaderboardUploadScoreMethodNone=0,
    k_ELeaderboardUploadScoreMethodKeepBest=1,
    k_ELeaderboardUploadScoreMethodForceUpdate=2
};

class ISteamUserStats
{
    public bool RequestCurrentStats();
    public bool GetStat(char * ,float * );
    public bool GetStat(char * ,int * );
    public bool SetStat(char * ,float );
    public bool SetStat(char * ,int );
    public bool UpdateAvgRateStat(char * ,float ,float );
    public bool GetAchievement(char * ,bool * );
    public bool SetAchievement(char * );
    public bool ClearAchievement(char * );
    public bool GetAchievementAndUnlockTime(char * ,bool * ,unsigned int * );
    public bool StoreStats();
    public int GetAchievementIcon(char * );
    public char * GetAchievementDisplayAttribute(char * ,char * );
    public bool IndicateAchievementProgress(char * ,unsigned int ,unsigned int );
    public unsigned int GetNumAchievements();
    public char * GetAchievementName(unsigned int );
    public unsigned int RequestUserStats(class CSteamID );
    public bool GetUserStat(class CSteamID ,char * ,float * );
    public bool GetUserStat(class CSteamID ,char * ,int * );
    public bool GetUserAchievement(class CSteamID ,char * ,bool * );
    public bool GetUserAchievementAndUnlockTime(class CSteamID ,char * ,bool * ,unsigned int * );
    public bool ResetAllStats(bool );
    public unsigned int FindOrCreateLeaderboard(char * ,enum ELeaderboardSortMethod ,enum ELeaderboardDisplayType );
    public unsigned int FindLeaderboard(char * );
    public char * GetLeaderboardName(unsigned int );
    public int GetLeaderboardEntryCount(unsigned int );
    public enum ELeaderboardSortMethod GetLeaderboardSortMethod(unsigned int );
    public enum ELeaderboardDisplayType GetLeaderboardDisplayType(unsigned int );
    public unsigned int DownloadLeaderboardEntries(unsigned int ,enum ELeaderboardDataRequest ,int ,int );
    public unsigned int DownloadLeaderboardEntriesForUsers(unsigned int ,class CSteamID * ,int );
    public bool GetDownloadedLeaderboardEntry(unsigned int ,int ,struct LeaderboardEntry_t * ,int * ,int );
    public unsigned int UploadLeaderboardScore(unsigned int ,enum ELeaderboardUploadScoreMethod ,int ,int * ,int );
    public unsigned int AttachLeaderboardUGC(unsigned int ,unsigned int );
    public unsigned int GetNumberOfCurrentPlayers();
    public unsigned int RequestGlobalAchievementPercentages();
    public int GetMostAchievedAchievementInfo(char * ,unsigned int ,float * ,bool * );
    public int GetNextMostAchievedAchievementInfo(int ,char * ,unsigned int ,float * ,bool * );
    public bool GetAchievementAchievedPercent(char * ,float * );
    public unsigned int RequestGlobalStats(int );
    public bool GetGlobalStat(char * ,float * );
    public bool GetGlobalStat(char * ,int * );
    public int GetGlobalStatHistory(char * ,float * ,unsigned int );
    public int GetGlobalStatHistory(char * ,int * ,unsigned int );
    public void ISteamUserStats(class ISteamUserStats * );
    public void ISteamUserStats(class ISteamUserStats & );
    public void ISteamUserStats();
    public class ISteamUserStats & operator=(class ISteamUserStats * );
    public class ISteamUserStats & operator=(class ISteamUserStats & );
};

class ISteamUserStats
{
    public bool RequestCurrentStats();
    public bool GetStat(char * ,float * );
    public bool GetStat(char * ,int * );
    public bool SetStat(char * ,float );
    public bool SetStat(char * ,int );
    public bool UpdateAvgRateStat(char * ,float ,float );
    public bool GetAchievement(char * ,bool * );
    public bool SetAchievement(char * );
    public bool ClearAchievement(char * );
    public bool GetAchievementAndUnlockTime(char * ,bool * ,unsigned int * );
    public bool StoreStats();
    public int GetAchievementIcon(char * );
    public char * GetAchievementDisplayAttribute(char * ,char * );
    public bool IndicateAchievementProgress(char * ,unsigned int ,unsigned int );
    public unsigned int GetNumAchievements();
    public char * GetAchievementName(unsigned int );
    public unsigned int RequestUserStats(class CSteamID );
    public bool GetUserStat(class CSteamID ,char * ,float * );
    public bool GetUserStat(class CSteamID ,char * ,int * );
    public bool GetUserAchievement(class CSteamID ,char * ,bool * );
    public bool GetUserAchievementAndUnlockTime(class CSteamID ,char * ,bool * ,unsigned int * );
    public bool ResetAllStats(bool );
    public unsigned int FindOrCreateLeaderboard(char * ,enum ELeaderboardSortMethod ,enum ELeaderboardDisplayType );
    public unsigned int FindLeaderboard(char * );
    public char * GetLeaderboardName(unsigned int );
    public int GetLeaderboardEntryCount(unsigned int );
    public enum ELeaderboardSortMethod GetLeaderboardSortMethod(unsigned int );
    public enum ELeaderboardDisplayType GetLeaderboardDisplayType(unsigned int );
    public unsigned int DownloadLeaderboardEntries(unsigned int ,enum ELeaderboardDataRequest ,int ,int );
    public unsigned int DownloadLeaderboardEntriesForUsers(unsigned int ,class CSteamID * ,int );
    public bool GetDownloadedLeaderboardEntry(unsigned int ,int ,struct LeaderboardEntry_t * ,int * ,int );
    public unsigned int UploadLeaderboardScore(unsigned int ,enum ELeaderboardUploadScoreMethod ,int ,int * ,int );
    public unsigned int AttachLeaderboardUGC(unsigned int ,unsigned int );
    public unsigned int GetNumberOfCurrentPlayers();
    public unsigned int RequestGlobalAchievementPercentages();
    public int GetMostAchievedAchievementInfo(char * ,unsigned int ,float * ,bool * );
    public int GetNextMostAchievedAchievementInfo(int ,char * ,unsigned int ,float * ,bool * );
    public bool GetAchievementAchievedPercent(char * ,float * );
    public unsigned int RequestGlobalStats(int );
    public bool GetGlobalStat(char * ,float * );
    public bool GetGlobalStat(char * ,int * );
    public int GetGlobalStatHistory(char * ,float * ,unsigned int );
    public int GetGlobalStatHistory(char * ,int * ,unsigned int );
    public void ISteamUserStats(class ISteamUserStats * );
    public void ISteamUserStats(class ISteamUserStats & );
    public void ISteamUserStats();
    public class ISteamUserStats & operator=(class ISteamUserStats * );
    public class ISteamUserStats & operator=(class ISteamUserStats & );
};

class ISteamApps
{
    public bool BIsSubscribed();
    public bool BIsLowViolence();
    public bool BIsCybercafe();
    public bool BIsVACBanned();
    public char * GetCurrentGameLanguage();
    public char * GetAvailableGameLanguages();
    public bool BIsSubscribedApp(unsigned int );
    public bool BIsDlcInstalled(unsigned int );
    public unsigned int GetEarliestPurchaseUnixTime(unsigned int );
    public bool BIsSubscribedFromFreeWeekend();
    public int GetDLCCount();
    public bool BGetDLCDataByIndex(int ,unsigned int * ,bool * ,char * ,int );
    public void InstallDLC(unsigned int );
    public void UninstallDLC(unsigned int );
    public void RequestAppProofOfPurchaseKey(unsigned int );
    public bool GetCurrentBetaName(char * ,int );
    public bool MarkContentCorrupt(bool );
    public unsigned int GetInstalledDepots(unsigned int ,unsigned int * ,unsigned int );
    public unsigned int GetAppInstallDir(unsigned int ,char * ,unsigned int );
    public bool BIsAppInstalled(unsigned int );
    public class CSteamID GetAppOwner();
    public char * GetLaunchQueryParam(char * );
    public bool GetDlcDownloadProgress(unsigned int ,unsigned int * ,unsigned int * );
    public int GetAppBuildId();
    public void RequestAllProofOfPurchaseKeys();
    public unsigned int GetFileDetails(char * );
    public int GetLaunchCommandLine(char * ,int );
    public bool BIsSubscribedFromFamilySharing();
    public void ISteamApps(class ISteamApps * );
    public void ISteamApps(class ISteamApps & );
    public void ISteamApps();
    public class ISteamApps & operator=(class ISteamApps * );
    public class ISteamApps & operator=(class ISteamApps & );
};

class ISteamApps
{
    public bool BIsSubscribed();
    public bool BIsLowViolence();
    public bool BIsCybercafe();
    public bool BIsVACBanned();
    public char * GetCurrentGameLanguage();
    public char * GetAvailableGameLanguages();
    public bool BIsSubscribedApp(unsigned int );
    public bool BIsDlcInstalled(unsigned int );
    public unsigned int GetEarliestPurchaseUnixTime(unsigned int );
    public bool BIsSubscribedFromFreeWeekend();
    public int GetDLCCount();
    public bool BGetDLCDataByIndex(int ,unsigned int * ,bool * ,char * ,int );
    public void InstallDLC(unsigned int );
    public void UninstallDLC(unsigned int );
    public void RequestAppProofOfPurchaseKey(unsigned int );
    public bool GetCurrentBetaName(char * ,int );
    public bool MarkContentCorrupt(bool );
    public unsigned int GetInstalledDepots(unsigned int ,unsigned int * ,unsigned int );
    public unsigned int GetAppInstallDir(unsigned int ,char * ,unsigned int );
    public bool BIsAppInstalled(unsigned int );
    public class CSteamID GetAppOwner();
    public char * GetLaunchQueryParam(char * );
    public bool GetDlcDownloadProgress(unsigned int ,unsigned int * ,unsigned int * );
    public int GetAppBuildId();
    public void RequestAllProofOfPurchaseKeys();
    public unsigned int GetFileDetails(char * );
    public int GetLaunchCommandLine(char * ,int );
    public bool BIsSubscribedFromFamilySharing();
    public void ISteamApps(class ISteamApps * );
    public void ISteamApps(class ISteamApps & );
    public void ISteamApps();
    public class ISteamApps & operator=(class ISteamApps * );
    public class ISteamApps & operator=(class ISteamApps & );
};

class ISteamMatchmakingServers
{
    public void * RequestInternetServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestLANServerList(unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestFriendsServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestFavoritesServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestHistoryServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestSpectatorServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void ReleaseRequest(void * );
    public class gameserveritem_t * GetServerDetails(void * ,int );
    public void CancelQuery(void * );
    public void RefreshQuery(void * );
    public bool IsRefreshing(void * );
    public int GetServerCount(void * );
    public void RefreshServer(void * ,int );
    public int PingServer(unsigned int ,unsigned int ,class ISteamMatchmakingPingResponse * );
    public int PlayerDetails(unsigned int ,unsigned int ,class ISteamMatchmakingPlayersResponse * );
    public int ServerRules(unsigned int ,unsigned int ,class ISteamMatchmakingRulesResponse * );
    public void CancelServerQuery(int );
    public void ISteamMatchmakingServers(class ISteamMatchmakingServers * );
    public void ISteamMatchmakingServers(class ISteamMatchmakingServers & );
    public void ISteamMatchmakingServers();
    public class ISteamMatchmakingServers & operator=(class ISteamMatchmakingServers * );
    public class ISteamMatchmakingServers & operator=(class ISteamMatchmakingServers & );
};

class ISteamMatchmakingServers
{
    public void * RequestInternetServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestLANServerList(unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestFriendsServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestFavoritesServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestHistoryServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void * RequestSpectatorServerList(unsigned int ,struct MatchMakingKeyValuePair_t ** ,unsigned int ,class ISteamMatchmakingServerListResponse * );
    public void ReleaseRequest(void * );
    public class gameserveritem_t * GetServerDetails(void * ,int );
    public void CancelQuery(void * );
    public void RefreshQuery(void * );
    public bool IsRefreshing(void * );
    public int GetServerCount(void * );
    public void RefreshServer(void * ,int );
    public int PingServer(unsigned int ,unsigned int ,class ISteamMatchmakingPingResponse * );
    public int PlayerDetails(unsigned int ,unsigned int ,class ISteamMatchmakingPlayersResponse * );
    public int ServerRules(unsigned int ,unsigned int ,class ISteamMatchmakingRulesResponse * );
    public void CancelServerQuery(int );
    public void ISteamMatchmakingServers(class ISteamMatchmakingServers * );
    public void ISteamMatchmakingServers(class ISteamMatchmakingServers & );
    public void ISteamMatchmakingServers();
    public class ISteamMatchmakingServers & operator=(class ISteamMatchmakingServers * );
    public class ISteamMatchmakingServers & operator=(class ISteamMatchmakingServers & );
};

enum EP2PSend
{
    k_EP2PSendUnreliable=0,
    k_EP2PSendUnreliableNoDelay=1,
    k_EP2PSendReliable=2,
    k_EP2PSendReliableWithBuffering=3
};

enum ESNetSocketConnectionType
{
    k_ESNetSocketConnectionTypeNotConnected=0,
    k_ESNetSocketConnectionTypeUDP=1,
    k_ESNetSocketConnectionTypeUDPRelay=2
};

class ISteamNetworking
{
    public bool SendP2PPacket(class CSteamID ,void * ,unsigned int ,enum EP2PSend ,int );
    public bool IsP2PPacketAvailable(unsigned int * ,int );
    public bool ReadP2PPacket(void * ,unsigned int ,unsigned int * ,class CSteamID * ,int );
    public bool AcceptP2PSessionWithUser(class CSteamID );
    public bool CloseP2PSessionWithUser(class CSteamID );
    public bool CloseP2PChannelWithUser(class CSteamID ,int );
    public bool GetP2PSessionState(class CSteamID ,struct P2PSessionState_t * );
    public bool AllowP2PPacketRelay(bool );
    public unsigned int CreateListenSocket(int ,unsigned int ,unsigned int ,bool );
    public unsigned int CreateP2PConnectionSocket(class CSteamID ,int ,int ,bool );
    public unsigned int CreateConnectionSocket(unsigned int ,unsigned int ,int );
    public bool DestroySocket(unsigned int ,bool );
    public bool DestroyListenSocket(unsigned int ,bool );
    public bool SendDataOnSocket(unsigned int ,void * ,unsigned int ,bool );
    public bool IsDataAvailableOnSocket(unsigned int ,unsigned int * );
    public bool RetrieveDataFromSocket(unsigned int ,void * ,unsigned int ,unsigned int * );
    public bool IsDataAvailable(unsigned int ,unsigned int * ,unsigned int * );
    public bool RetrieveData(unsigned int ,void * ,unsigned int ,unsigned int * ,unsigned int * );
    public bool GetSocketInfo(unsigned int ,class CSteamID * ,int * ,unsigned int * ,unsigned int * );
    public bool GetListenSocketInfo(unsigned int ,unsigned int * ,unsigned int * );
    public enum ESNetSocketConnectionType GetSocketConnectionType(unsigned int );
    public int GetMaxPacketSize(unsigned int );
    public void ISteamNetworking(class ISteamNetworking * );
    public void ISteamNetworking(class ISteamNetworking & );
    public void ISteamNetworking();
    public class ISteamNetworking & operator=(class ISteamNetworking * );
    public class ISteamNetworking & operator=(class ISteamNetworking & );
};

class ISteamNetworking
{
    public bool SendP2PPacket(class CSteamID ,void * ,unsigned int ,enum EP2PSend ,int );
    public bool IsP2PPacketAvailable(unsigned int * ,int );
    public bool ReadP2PPacket(void * ,unsigned int ,unsigned int * ,class CSteamID * ,int );
    public bool AcceptP2PSessionWithUser(class CSteamID );
    public bool CloseP2PSessionWithUser(class CSteamID );
    public bool CloseP2PChannelWithUser(class CSteamID ,int );
    public bool GetP2PSessionState(class CSteamID ,struct P2PSessionState_t * );
    public bool AllowP2PPacketRelay(bool );
    public unsigned int CreateListenSocket(int ,unsigned int ,unsigned int ,bool );
    public unsigned int CreateP2PConnectionSocket(class CSteamID ,int ,int ,bool );
    public unsigned int CreateConnectionSocket(unsigned int ,unsigned int ,int );
    public bool DestroySocket(unsigned int ,bool );
    public bool DestroyListenSocket(unsigned int ,bool );
    public bool SendDataOnSocket(unsigned int ,void * ,unsigned int ,bool );
    public bool IsDataAvailableOnSocket(unsigned int ,unsigned int * );
    public bool RetrieveDataFromSocket(unsigned int ,void * ,unsigned int ,unsigned int * );
    public bool IsDataAvailable(unsigned int ,unsigned int * ,unsigned int * );
    public bool RetrieveData(unsigned int ,void * ,unsigned int ,unsigned int * ,unsigned int * );
    public bool GetSocketInfo(unsigned int ,class CSteamID * ,int * ,unsigned int * ,unsigned int * );
    public bool GetListenSocketInfo(unsigned int ,unsigned int * ,unsigned int * );
    public enum ESNetSocketConnectionType GetSocketConnectionType(unsigned int );
    public int GetMaxPacketSize(unsigned int );
    public void ISteamNetworking(class ISteamNetworking * );
    public void ISteamNetworking(class ISteamNetworking & );
    public void ISteamNetworking();
    public class ISteamNetworking & operator=(class ISteamNetworking * );
    public class ISteamNetworking & operator=(class ISteamNetworking & );
};

enum ERemoteStoragePlatform
{
    k_ERemoteStoragePlatformNone=0,
    k_ERemoteStoragePlatformWindows=1,
    k_ERemoteStoragePlatformOSX=2,
    k_ERemoteStoragePlatformPS3=4,
    k_ERemoteStoragePlatformLinux=8,
    k_ERemoteStoragePlatformReserved2=16,
    k_ERemoteStoragePlatformAndroid=32,
    k_ERemoteStoragePlatformAll=-1
};

enum EUGCReadAction
{
    k_EUGCRead_ContinueReadingUntilFinished=0,
    k_EUGCRead_ContinueReading=1,
    k_EUGCRead_Close=2
};

enum ERemoteStoragePublishedFileVisibility
{
    k_ERemoteStoragePublishedFileVisibilityPublic=0,
    k_ERemoteStoragePublishedFileVisibilityFriendsOnly=1,
    k_ERemoteStoragePublishedFileVisibilityPrivate=2
};

enum EWorkshopFileType
{
    k_EWorkshopFileTypeFirst=0,
    k_EWorkshopFileTypeCommunity=0,
    k_EWorkshopFileTypeMicrotransaction=1,
    k_EWorkshopFileTypeCollection=2,
    k_EWorkshopFileTypeArt=3,
    k_EWorkshopFileTypeVideo=4,
    k_EWorkshopFileTypeScreenshot=5,
    k_EWorkshopFileTypeGame=6,
    k_EWorkshopFileTypeSoftware=7,
    k_EWorkshopFileTypeConcept=8,
    k_EWorkshopFileTypeWebGuide=9,
    k_EWorkshopFileTypeIntegratedGuide=10,
    k_EWorkshopFileTypeMerch=11,
    k_EWorkshopFileTypeControllerBinding=12,
    k_EWorkshopFileTypeSteamworksAccessInvite=13,
    k_EWorkshopFileTypeSteamVideo=14,
    k_EWorkshopFileTypeGameManagedItem=15,
    k_EWorkshopFileTypeMax=16
};

enum EWorkshopVideoProvider
{
    k_EWorkshopVideoProviderNone=0,
    k_EWorkshopVideoProviderYoutube=1
};

enum EWorkshopFileAction
{
    k_EWorkshopFileActionPlayed=0,
    k_EWorkshopFileActionCompleted=1
};

enum EWorkshopEnumerationType
{
    k_EWorkshopEnumerationTypeRankedByVote=0,
    k_EWorkshopEnumerationTypeRecent=1,
    k_EWorkshopEnumerationTypeTrending=2,
    k_EWorkshopEnumerationTypeFavoritesOfFriends=3,
    k_EWorkshopEnumerationTypeVotedByFriends=4,
    k_EWorkshopEnumerationTypeContentByFriends=5,
    k_EWorkshopEnumerationTypeRecentFromFollowedUsers=6
};

class ISteamRemoteStorage
{
    public bool FileWrite(char * ,void * ,int );
    public int FileRead(char * ,void * ,int );
    public unsigned int FileWriteAsync(char * ,void * ,unsigned int );
    public unsigned int FileReadAsync(char * ,unsigned int ,unsigned int );
    public bool FileReadAsyncComplete(unsigned int ,void * ,unsigned int );
    public bool FileForget(char * );
    public bool FileDelete(char * );
    public unsigned int FileShare(char * );
    public bool SetSyncPlatforms(char * ,enum ERemoteStoragePlatform );
    public unsigned int FileWriteStreamOpen(char * );
    public bool FileWriteStreamWriteChunk(unsigned int ,void * ,int );
    public bool FileWriteStreamClose(unsigned int );
    public bool FileWriteStreamCancel(unsigned int );
    public bool FileExists(char * );
    public bool FilePersisted(char * );
    public int GetFileSize(char * );
    public int GetFileTimestamp(char * );
    public enum ERemoteStoragePlatform GetSyncPlatforms(char * );
    public int GetFileCount();
    public char * GetFileNameAndSize(int ,int * );
    public bool GetQuota(unsigned int * ,unsigned int * );
    public bool IsCloudEnabledForAccount();
    public bool IsCloudEnabledForApp();
    public void SetCloudEnabledForApp(bool );
    public unsigned int UGCDownload(unsigned int ,unsigned int );
    public bool GetUGCDownloadProgress(unsigned int ,int * ,int * );
    public bool GetUGCDetails(unsigned int ,unsigned int * ,char ** ,int * ,class CSteamID * );
    public int UGCRead(unsigned int ,void * ,int ,unsigned int ,enum EUGCReadAction );
    public int GetCachedUGCCount();
    public unsigned int GetCachedUGCHandle(int );
    public unsigned int PublishWorkshopFile(char * ,char * ,unsigned int ,char * ,char * ,enum ERemoteStoragePublishedFileVisibility ,struct SteamParamStringArray_t * ,enum EWorkshopFileType );
    public unsigned int CreatePublishedFileUpdateRequest(unsigned int );
    public bool UpdatePublishedFileFile(unsigned int ,char * );
    public bool UpdatePublishedFilePreviewFile(unsigned int ,char * );
    public bool UpdatePublishedFileTitle(unsigned int ,char * );
    public bool UpdatePublishedFileDescription(unsigned int ,char * );
    public bool UpdatePublishedFileVisibility(unsigned int ,enum ERemoteStoragePublishedFileVisibility );
    public bool UpdatePublishedFileTags(unsigned int ,struct SteamParamStringArray_t * );
    public unsigned int CommitPublishedFileUpdate(unsigned int );
    public unsigned int GetPublishedFileDetails(unsigned int ,unsigned int );
    public unsigned int DeletePublishedFile(unsigned int );
    public unsigned int EnumerateUserPublishedFiles(unsigned int );
    public unsigned int SubscribePublishedFile(unsigned int );
    public unsigned int EnumerateUserSubscribedFiles(unsigned int );
    public unsigned int UnsubscribePublishedFile(unsigned int );
    public bool UpdatePublishedFileSetChangeDescription(unsigned int ,char * );
    public unsigned int GetPublishedItemVoteDetails(unsigned int );
    public unsigned int UpdateUserPublishedItemVote(unsigned int ,bool );
    public unsigned int GetUserPublishedItemVoteDetails(unsigned int );
    public unsigned int EnumerateUserSharedWorkshopFiles(class CSteamID ,unsigned int ,struct SteamParamStringArray_t * ,struct SteamParamStringArray_t * );
    public unsigned int PublishVideo(enum EWorkshopVideoProvider ,char * ,char * ,char * ,unsigned int ,char * ,char * ,enum ERemoteStoragePublishedFileVisibility ,struct SteamParamStringArray_t * );
    public unsigned int SetUserPublishedFileAction(unsigned int ,enum EWorkshopFileAction );
    public unsigned int EnumeratePublishedFilesByUserAction(enum EWorkshopFileAction ,unsigned int );
    public unsigned int EnumeratePublishedWorkshopFiles(enum EWorkshopEnumerationType ,unsigned int ,unsigned int ,unsigned int ,struct SteamParamStringArray_t * ,struct SteamParamStringArray_t * );
    public unsigned int UGCDownloadToLocation(unsigned int ,char * ,unsigned int );
    public void ISteamRemoteStorage(class ISteamRemoteStorage * );
    public void ISteamRemoteStorage(class ISteamRemoteStorage & );
    public void ISteamRemoteStorage();
    public class ISteamRemoteStorage & operator=(class ISteamRemoteStorage * );
    public class ISteamRemoteStorage & operator=(class ISteamRemoteStorage & );
};

class ISteamRemoteStorage
{
    public bool FileWrite(char * ,void * ,int );
    public int FileRead(char * ,void * ,int );
    public unsigned int FileWriteAsync(char * ,void * ,unsigned int );
    public unsigned int FileReadAsync(char * ,unsigned int ,unsigned int );
    public bool FileReadAsyncComplete(unsigned int ,void * ,unsigned int );
    public bool FileForget(char * );
    public bool FileDelete(char * );
    public unsigned int FileShare(char * );
    public bool SetSyncPlatforms(char * ,enum ERemoteStoragePlatform );
    public unsigned int FileWriteStreamOpen(char * );
    public bool FileWriteStreamWriteChunk(unsigned int ,void * ,int );
    public bool FileWriteStreamClose(unsigned int );
    public bool FileWriteStreamCancel(unsigned int );
    public bool FileExists(char * );
    public bool FilePersisted(char * );
    public int GetFileSize(char * );
    public int GetFileTimestamp(char * );
    public enum ERemoteStoragePlatform GetSyncPlatforms(char * );
    public int GetFileCount();
    public char * GetFileNameAndSize(int ,int * );
    public bool GetQuota(unsigned int * ,unsigned int * );
    public bool IsCloudEnabledForAccount();
    public bool IsCloudEnabledForApp();
    public void SetCloudEnabledForApp(bool );
    public unsigned int UGCDownload(unsigned int ,unsigned int );
    public bool GetUGCDownloadProgress(unsigned int ,int * ,int * );
    public bool GetUGCDetails(unsigned int ,unsigned int * ,char ** ,int * ,class CSteamID * );
    public int UGCRead(unsigned int ,void * ,int ,unsigned int ,enum EUGCReadAction );
    public int GetCachedUGCCount();
    public unsigned int GetCachedUGCHandle(int );
    public unsigned int PublishWorkshopFile(char * ,char * ,unsigned int ,char * ,char * ,enum ERemoteStoragePublishedFileVisibility ,struct SteamParamStringArray_t * ,enum EWorkshopFileType );
    public unsigned int CreatePublishedFileUpdateRequest(unsigned int );
    public bool UpdatePublishedFileFile(unsigned int ,char * );
    public bool UpdatePublishedFilePreviewFile(unsigned int ,char * );
    public bool UpdatePublishedFileTitle(unsigned int ,char * );
    public bool UpdatePublishedFileDescription(unsigned int ,char * );
    public bool UpdatePublishedFileVisibility(unsigned int ,enum ERemoteStoragePublishedFileVisibility );
    public bool UpdatePublishedFileTags(unsigned int ,struct SteamParamStringArray_t * );
    public unsigned int CommitPublishedFileUpdate(unsigned int );
    public unsigned int GetPublishedFileDetails(unsigned int ,unsigned int );
    public unsigned int DeletePublishedFile(unsigned int );
    public unsigned int EnumerateUserPublishedFiles(unsigned int );
    public unsigned int SubscribePublishedFile(unsigned int );
    public unsigned int EnumerateUserSubscribedFiles(unsigned int );
    public unsigned int UnsubscribePublishedFile(unsigned int );
    public bool UpdatePublishedFileSetChangeDescription(unsigned int ,char * );
    public unsigned int GetPublishedItemVoteDetails(unsigned int );
    public unsigned int UpdateUserPublishedItemVote(unsigned int ,bool );
    public unsigned int GetUserPublishedItemVoteDetails(unsigned int );
    public unsigned int EnumerateUserSharedWorkshopFiles(class CSteamID ,unsigned int ,struct SteamParamStringArray_t * ,struct SteamParamStringArray_t * );
    public unsigned int PublishVideo(enum EWorkshopVideoProvider ,char * ,char * ,char * ,unsigned int ,char * ,char * ,enum ERemoteStoragePublishedFileVisibility ,struct SteamParamStringArray_t * );
    public unsigned int SetUserPublishedFileAction(unsigned int ,enum EWorkshopFileAction );
    public unsigned int EnumeratePublishedFilesByUserAction(enum EWorkshopFileAction ,unsigned int );
    public unsigned int EnumeratePublishedWorkshopFiles(enum EWorkshopEnumerationType ,unsigned int ,unsigned int ,unsigned int ,struct SteamParamStringArray_t * ,struct SteamParamStringArray_t * );
    public unsigned int UGCDownloadToLocation(unsigned int ,char * ,unsigned int );
    public void ISteamRemoteStorage(class ISteamRemoteStorage * );
    public void ISteamRemoteStorage(class ISteamRemoteStorage & );
    public void ISteamRemoteStorage();
    public class ISteamRemoteStorage & operator=(class ISteamRemoteStorage * );
    public class ISteamRemoteStorage & operator=(class ISteamRemoteStorage & );
};

enum EVRScreenshotType
{
    k_EVRScreenshotType_None=0,
    k_EVRScreenshotType_Mono=1,
    k_EVRScreenshotType_Stereo=2,
    k_EVRScreenshotType_MonoCubemap=3,
    k_EVRScreenshotType_MonoPanorama=4,
    k_EVRScreenshotType_StereoPanorama=5
};

class ISteamScreenshots
{
    public unsigned int WriteScreenshot(void * ,unsigned int ,int ,int );
    public unsigned int AddScreenshotToLibrary(char * ,char * ,int ,int );
    public void TriggerScreenshot();
    public void HookScreenshots(bool );
    public bool SetLocation(unsigned int ,char * );
    public bool TagUser(unsigned int ,class CSteamID );
    public bool TagPublishedFile(unsigned int ,unsigned int );
    public bool IsScreenshotsHooked();
    public unsigned int AddVRScreenshotToLibrary(enum EVRScreenshotType ,char * ,char * );
    public void ISteamScreenshots(class ISteamScreenshots * );
    public void ISteamScreenshots(class ISteamScreenshots & );
    public void ISteamScreenshots();
    public class ISteamScreenshots & operator=(class ISteamScreenshots * );
    public class ISteamScreenshots & operator=(class ISteamScreenshots & );
};

class ISteamScreenshots
{
    public unsigned int WriteScreenshot(void * ,unsigned int ,int ,int );
    public unsigned int AddScreenshotToLibrary(char * ,char * ,int ,int );
    public void TriggerScreenshot();
    public void HookScreenshots(bool );
    public bool SetLocation(unsigned int ,char * );
    public bool TagUser(unsigned int ,class CSteamID );
    public bool TagPublishedFile(unsigned int ,unsigned int );
    public bool IsScreenshotsHooked();
    public unsigned int AddVRScreenshotToLibrary(enum EVRScreenshotType ,char * ,char * );
    public void ISteamScreenshots(class ISteamScreenshots * );
    public void ISteamScreenshots(class ISteamScreenshots & );
    public void ISteamScreenshots();
    public class ISteamScreenshots & operator=(class ISteamScreenshots * );
    public class ISteamScreenshots & operator=(class ISteamScreenshots & );
};

enum EHTTPMethod
{
    k_EHTTPMethodInvalid=0,
    k_EHTTPMethodGET=1,
    k_EHTTPMethodHEAD=2,
    k_EHTTPMethodPOST=3,
    k_EHTTPMethodPUT=4,
    k_EHTTPMethodDELETE=5,
    k_EHTTPMethodOPTIONS=6,
    k_EHTTPMethodPATCH=7
};

class ISteamHTTP
{
    public unsigned int CreateHTTPRequest(enum EHTTPMethod ,char * );
    public bool SetHTTPRequestContextValue(unsigned int ,unsigned int );
    public bool SetHTTPRequestNetworkActivityTimeout(unsigned int ,unsigned int );
    public bool SetHTTPRequestHeaderValue(unsigned int ,char * ,char * );
    public bool SetHTTPRequestGetOrPostParameter(unsigned int ,char * ,char * );
    public bool SendHTTPRequest(unsigned int ,unsigned int * );
    public bool SendHTTPRequestAndStreamResponse(unsigned int ,unsigned int * );
    public bool DeferHTTPRequest(unsigned int );
    public bool PrioritizeHTTPRequest(unsigned int );
    public bool GetHTTPResponseHeaderSize(unsigned int ,char * ,unsigned int * );
    public bool GetHTTPResponseHeaderValue(unsigned int ,char * ,unsigned int * ,unsigned int );
    public bool GetHTTPResponseBodySize(unsigned int ,unsigned int * );
    public bool GetHTTPResponseBodyData(unsigned int ,unsigned int * ,unsigned int );
    public bool GetHTTPStreamingResponseBodyData(unsigned int ,unsigned int ,unsigned int * ,unsigned int );
    public bool ReleaseHTTPRequest(unsigned int );
    public bool GetHTTPDownloadProgressPct(unsigned int ,float * );
    public bool SetHTTPRequestRawPostBody(unsigned int ,char * ,unsigned int * ,unsigned int );
    public unsigned int CreateCookieContainer(bool );
    public bool ReleaseCookieContainer(unsigned int );
    public bool SetCookie(unsigned int ,char * ,char * ,char * );
    public bool SetHTTPRequestCookieContainer(unsigned int ,unsigned int );
    public bool SetHTTPRequestUserAgentInfo(unsigned int ,char * );
    public bool SetHTTPRequestRequiresVerifiedCertificate(unsigned int ,bool );
    public bool SetHTTPRequestAbsoluteTimeoutMS(unsigned int ,unsigned int );
    public bool GetHTTPRequestWasTimedOut(unsigned int ,bool * );
    public void ISteamHTTP(class ISteamHTTP * );
    public void ISteamHTTP(class ISteamHTTP & );
    public void ISteamHTTP();
    public class ISteamHTTP & operator=(class ISteamHTTP * );
    public class ISteamHTTP & operator=(class ISteamHTTP & );
};

class ISteamHTTP
{
    public unsigned int CreateHTTPRequest(enum EHTTPMethod ,char * );
    public bool SetHTTPRequestContextValue(unsigned int ,unsigned int );
    public bool SetHTTPRequestNetworkActivityTimeout(unsigned int ,unsigned int );
    public bool SetHTTPRequestHeaderValue(unsigned int ,char * ,char * );
    public bool SetHTTPRequestGetOrPostParameter(unsigned int ,char * ,char * );
    public bool SendHTTPRequest(unsigned int ,unsigned int * );
    public bool SendHTTPRequestAndStreamResponse(unsigned int ,unsigned int * );
    public bool DeferHTTPRequest(unsigned int );
    public bool PrioritizeHTTPRequest(unsigned int );
    public bool GetHTTPResponseHeaderSize(unsigned int ,char * ,unsigned int * );
    public bool GetHTTPResponseHeaderValue(unsigned int ,char * ,unsigned int * ,unsigned int );
    public bool GetHTTPResponseBodySize(unsigned int ,unsigned int * );
    public bool GetHTTPResponseBodyData(unsigned int ,unsigned int * ,unsigned int );
    public bool GetHTTPStreamingResponseBodyData(unsigned int ,unsigned int ,unsigned int * ,unsigned int );
    public bool ReleaseHTTPRequest(unsigned int );
    public bool GetHTTPDownloadProgressPct(unsigned int ,float * );
    public bool SetHTTPRequestRawPostBody(unsigned int ,char * ,unsigned int * ,unsigned int );
    public unsigned int CreateCookieContainer(bool );
    public bool ReleaseCookieContainer(unsigned int );
    public bool SetCookie(unsigned int ,char * ,char * ,char * );
    public bool SetHTTPRequestCookieContainer(unsigned int ,unsigned int );
    public bool SetHTTPRequestUserAgentInfo(unsigned int ,char * );
    public bool SetHTTPRequestRequiresVerifiedCertificate(unsigned int ,bool );
    public bool SetHTTPRequestAbsoluteTimeoutMS(unsigned int ,unsigned int );
    public bool GetHTTPRequestWasTimedOut(unsigned int ,bool * );
    public void ISteamHTTP(class ISteamHTTP * );
    public void ISteamHTTP(class ISteamHTTP & );
    public void ISteamHTTP();
    public class ISteamHTTP & operator=(class ISteamHTTP * );
    public class ISteamHTTP & operator=(class ISteamHTTP & );
};

enum EControllerActionOrigin
{
    k_EControllerActionOrigin_None=0,
    k_EControllerActionOrigin_A=1,
    k_EControllerActionOrigin_B=2,
    k_EControllerActionOrigin_X=3,
    k_EControllerActionOrigin_Y=4,
    k_EControllerActionOrigin_LeftBumper=5,
    k_EControllerActionOrigin_RightBumper=6,
    k_EControllerActionOrigin_LeftGrip=7,
    k_EControllerActionOrigin_RightGrip=8,
    k_EControllerActionOrigin_Start=9,
    k_EControllerActionOrigin_Back=10,
    k_EControllerActionOrigin_LeftPad_Touch=11,
    k_EControllerActionOrigin_LeftPad_Swipe=12,
    k_EControllerActionOrigin_LeftPad_Click=13,
    k_EControllerActionOrigin_LeftPad_DPadNorth=14,
    k_EControllerActionOrigin_LeftPad_DPadSouth=15,
    k_EControllerActionOrigin_LeftPad_DPadWest=16,
    k_EControllerActionOrigin_LeftPad_DPadEast=17,
    k_EControllerActionOrigin_RightPad_Touch=18,
    k_EControllerActionOrigin_RightPad_Swipe=19,
    k_EControllerActionOrigin_RightPad_Click=20,
    k_EControllerActionOrigin_RightPad_DPadNorth=21,
    k_EControllerActionOrigin_RightPad_DPadSouth=22,
    k_EControllerActionOrigin_RightPad_DPadWest=23,
    k_EControllerActionOrigin_RightPad_DPadEast=24,
    k_EControllerActionOrigin_LeftTrigger_Pull=25,
    k_EControllerActionOrigin_LeftTrigger_Click=26,
    k_EControllerActionOrigin_RightTrigger_Pull=27,
    k_EControllerActionOrigin_RightTrigger_Click=28,
    k_EControllerActionOrigin_LeftStick_Move=29,
    k_EControllerActionOrigin_LeftStick_Click=30,
    k_EControllerActionOrigin_LeftStick_DPadNorth=31,
    k_EControllerActionOrigin_LeftStick_DPadSouth=32,
    k_EControllerActionOrigin_LeftStick_DPadWest=33,
    k_EControllerActionOrigin_LeftStick_DPadEast=34,
    k_EControllerActionOrigin_Gyro_Move=35,
    k_EControllerActionOrigin_Gyro_Pitch=36,
    k_EControllerActionOrigin_Gyro_Yaw=37,
    k_EControllerActionOrigin_Gyro_Roll=38,
    k_EControllerActionOrigin_PS4_X=39,
    k_EControllerActionOrigin_PS4_Circle=40,
    k_EControllerActionOrigin_PS4_Triangle=41,
    k_EControllerActionOrigin_PS4_Square=42,
    k_EControllerActionOrigin_PS4_LeftBumper=43,
    k_EControllerActionOrigin_PS4_RightBumper=44,
    k_EControllerActionOrigin_PS4_Options=45,
    k_EControllerActionOrigin_PS4_Share=46,
    k_EControllerActionOrigin_PS4_LeftPad_Touch=47,
    k_EControllerActionOrigin_PS4_LeftPad_Swipe=48,
    k_EControllerActionOrigin_PS4_LeftPad_Click=49,
    k_EControllerActionOrigin_PS4_LeftPad_DPadNorth=50,
    k_EControllerActionOrigin_PS4_LeftPad_DPadSouth=51,
    k_EControllerActionOrigin_PS4_LeftPad_DPadWest=52,
    k_EControllerActionOrigin_PS4_LeftPad_DPadEast=53,
    k_EControllerActionOrigin_PS4_RightPad_Touch=54,
    k_EControllerActionOrigin_PS4_RightPad_Swipe=55,
    k_EControllerActionOrigin_PS4_RightPad_Click=56,
    k_EControllerActionOrigin_PS4_RightPad_DPadNorth=57,
    k_EControllerActionOrigin_PS4_RightPad_DPadSouth=58,
    k_EControllerActionOrigin_PS4_RightPad_DPadWest=59,
    k_EControllerActionOrigin_PS4_RightPad_DPadEast=60,
    k_EControllerActionOrigin_PS4_CenterPad_Touch=61,
    k_EControllerActionOrigin_PS4_CenterPad_Swipe=62,
    k_EControllerActionOrigin_PS4_CenterPad_Click=63,
    k_EControllerActionOrigin_PS4_CenterPad_DPadNorth=64,
    k_EControllerActionOrigin_PS4_CenterPad_DPadSouth=65,
    k_EControllerActionOrigin_PS4_CenterPad_DPadWest=66,
    k_EControllerActionOrigin_PS4_CenterPad_DPadEast=67,
    k_EControllerActionOrigin_PS4_LeftTrigger_Pull=68,
    k_EControllerActionOrigin_PS4_LeftTrigger_Click=69,
    k_EControllerActionOrigin_PS4_RightTrigger_Pull=70,
    k_EControllerActionOrigin_PS4_RightTrigger_Click=71,
    k_EControllerActionOrigin_PS4_LeftStick_Move=72,
    k_EControllerActionOrigin_PS4_LeftStick_Click=73,
    k_EControllerActionOrigin_PS4_LeftStick_DPadNorth=74,
    k_EControllerActionOrigin_PS4_LeftStick_DPadSouth=75,
    k_EControllerActionOrigin_PS4_LeftStick_DPadWest=76,
    k_EControllerActionOrigin_PS4_LeftStick_DPadEast=77,
    k_EControllerActionOrigin_PS4_RightStick_Move=78,
    k_EControllerActionOrigin_PS4_RightStick_Click=79,
    k_EControllerActionOrigin_PS4_RightStick_DPadNorth=80,
    k_EControllerActionOrigin_PS4_RightStick_DPadSouth=81,
    k_EControllerActionOrigin_PS4_RightStick_DPadWest=82,
    k_EControllerActionOrigin_PS4_RightStick_DPadEast=83,
    k_EControllerActionOrigin_PS4_DPad_North=84,
    k_EControllerActionOrigin_PS4_DPad_South=85,
    k_EControllerActionOrigin_PS4_DPad_West=86,
    k_EControllerActionOrigin_PS4_DPad_East=87,
    k_EControllerActionOrigin_PS4_Gyro_Move=88,
    k_EControllerActionOrigin_PS4_Gyro_Pitch=89,
    k_EControllerActionOrigin_PS4_Gyro_Yaw=90,
    k_EControllerActionOrigin_PS4_Gyro_Roll=91,
    k_EControllerActionOrigin_XBoxOne_A=92,
    k_EControllerActionOrigin_XBoxOne_B=93,
    k_EControllerActionOrigin_XBoxOne_X=94,
    k_EControllerActionOrigin_XBoxOne_Y=95,
    k_EControllerActionOrigin_XBoxOne_LeftBumper=96,
    k_EControllerActionOrigin_XBoxOne_RightBumper=97,
    k_EControllerActionOrigin_XBoxOne_Menu=98,
    k_EControllerActionOrigin_XBoxOne_View=99,
    k_EControllerActionOrigin_XBoxOne_LeftTrigger_Pull=100,
    k_EControllerActionOrigin_XBoxOne_LeftTrigger_Click=101,
    k_EControllerActionOrigin_XBoxOne_RightTrigger_Pull=102,
    k_EControllerActionOrigin_XBoxOne_RightTrigger_Click=103,
    k_EControllerActionOrigin_XBoxOne_LeftStick_Move=104,
    k_EControllerActionOrigin_XBoxOne_LeftStick_Click=105,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadNorth=106,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadSouth=107,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadWest=108,
    k_EControllerActionOrigin_XBoxOne_LeftStick_DPadEast=109,
    k_EControllerActionOrigin_XBoxOne_RightStick_Move=110,
    k_EControllerActionOrigin_XBoxOne_RightStick_Click=111,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadNorth=112,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadSouth=113,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadWest=114,
    k_EControllerActionOrigin_XBoxOne_RightStick_DPadEast=115,
    k_EControllerActionOrigin_XBoxOne_DPad_North=116,
    k_EControllerActionOrigin_XBoxOne_DPad_South=117,
    k_EControllerActionOrigin_XBoxOne_DPad_West=118,
    k_EControllerActionOrigin_XBoxOne_DPad_East=119,
    k_EControllerActionOrigin_XBox360_A=120,
    k_EControllerActionOrigin_XBox360_B=121,
    k_EControllerActionOrigin_XBox360_X=122,
    k_EControllerActionOrigin_XBox360_Y=123,
    k_EControllerActionOrigin_XBox360_LeftBumper=124,
    k_EControllerActionOrigin_XBox360_RightBumper=125,
    k_EControllerActionOrigin_XBox360_Start=126,
    k_EControllerActionOrigin_XBox360_Back=127,
    k_EControllerActionOrigin_XBox360_LeftTrigger_Pull=128,
    k_EControllerActionOrigin_XBox360_LeftTrigger_Click=129,
    k_EControllerActionOrigin_XBox360_RightTrigger_Pull=130,
    k_EControllerActionOrigin_XBox360_RightTrigger_Click=131,
    k_EControllerActionOrigin_XBox360_LeftStick_Move=132,
    k_EControllerActionOrigin_XBox360_LeftStick_Click=133,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadNorth=134,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadSouth=135,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadWest=136,
    k_EControllerActionOrigin_XBox360_LeftStick_DPadEast=137,
    k_EControllerActionOrigin_XBox360_RightStick_Move=138,
    k_EControllerActionOrigin_XBox360_RightStick_Click=139,
    k_EControllerActionOrigin_XBox360_RightStick_DPadNorth=140,
    k_EControllerActionOrigin_XBox360_RightStick_DPadSouth=141,
    k_EControllerActionOrigin_XBox360_RightStick_DPadWest=142,
    k_EControllerActionOrigin_XBox360_RightStick_DPadEast=143,
    k_EControllerActionOrigin_XBox360_DPad_North=144,
    k_EControllerActionOrigin_XBox360_DPad_South=145,
    k_EControllerActionOrigin_XBox360_DPad_West=146,
    k_EControllerActionOrigin_XBox360_DPad_East=147,
    k_EControllerActionOrigin_SteamV2_A=148,
    k_EControllerActionOrigin_SteamV2_B=149,
    k_EControllerActionOrigin_SteamV2_X=150,
    k_EControllerActionOrigin_SteamV2_Y=151,
    k_EControllerActionOrigin_SteamV2_LeftBumper=152,
    k_EControllerActionOrigin_SteamV2_RightBumper=153,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Lower=154,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Upper=155,
    k_EControllerActionOrigin_SteamV2_RightGrip_Lower=156,
    k_EControllerActionOrigin_SteamV2_RightGrip_Upper=157,
    k_EControllerActionOrigin_SteamV2_LeftBumper_Pressure=158,
    k_EControllerActionOrigin_SteamV2_RightBumper_Pressure=159,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Pressure=160,
    k_EControllerActionOrigin_SteamV2_RightGrip_Pressure=161,
    k_EControllerActionOrigin_SteamV2_LeftGrip_Upper_Pressure=162,
    k_EControllerActionOrigin_SteamV2_RightGrip_Upper_Pressure=163,
    k_EControllerActionOrigin_SteamV2_Start=164,
    k_EControllerActionOrigin_SteamV2_Back=165,
    k_EControllerActionOrigin_SteamV2_LeftPad_Touch=166,
    k_EControllerActionOrigin_SteamV2_LeftPad_Swipe=167,
    k_EControllerActionOrigin_SteamV2_LeftPad_Click=168,
    k_EControllerActionOrigin_SteamV2_LeftPad_Pressure=169,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadNorth=170,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadSouth=171,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadWest=172,
    k_EControllerActionOrigin_SteamV2_LeftPad_DPadEast=173,
    k_EControllerActionOrigin_SteamV2_RightPad_Touch=174,
    k_EControllerActionOrigin_SteamV2_RightPad_Swipe=175,
    k_EControllerActionOrigin_SteamV2_RightPad_Click=176,
    k_EControllerActionOrigin_SteamV2_RightPad_Pressure=177,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadNorth=178,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadSouth=179,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadWest=180,
    k_EControllerActionOrigin_SteamV2_RightPad_DPadEast=181,
    k_EControllerActionOrigin_SteamV2_LeftTrigger_Pull=182,
    k_EControllerActionOrigin_SteamV2_LeftTrigger_Click=183,
    k_EControllerActionOrigin_SteamV2_RightTrigger_Pull=184,
    k_EControllerActionOrigin_SteamV2_RightTrigger_Click=185,
    k_EControllerActionOrigin_SteamV2_LeftStick_Move=186,
    k_EControllerActionOrigin_SteamV2_LeftStick_Click=187,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadNorth=188,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadSouth=189,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadWest=190,
    k_EControllerActionOrigin_SteamV2_LeftStick_DPadEast=191,
    k_EControllerActionOrigin_SteamV2_Gyro_Move=192,
    k_EControllerActionOrigin_SteamV2_Gyro_Pitch=193,
    k_EControllerActionOrigin_SteamV2_Gyro_Yaw=194,
    k_EControllerActionOrigin_SteamV2_Gyro_Roll=195,
    k_EControllerActionOrigin_Switch_A=196,
    k_EControllerActionOrigin_Switch_B=197,
    k_EControllerActionOrigin_Switch_X=198,
    k_EControllerActionOrigin_Switch_Y=199,
    k_EControllerActionOrigin_Switch_LeftBumper=200,
    k_EControllerActionOrigin_Switch_RightBumper=201,
    k_EControllerActionOrigin_Switch_Plus=202,
    k_EControllerActionOrigin_Switch_Minus=203,
    k_EControllerActionOrigin_Switch_Capture=204,
    k_EControllerActionOrigin_Switch_LeftTrigger_Pull=205,
    k_EControllerActionOrigin_Switch_LeftTrigger_Click=206,
    k_EControllerActionOrigin_Switch_RightTrigger_Pull=207,
    k_EControllerActionOrigin_Switch_RightTrigger_Click=208,
    k_EControllerActionOrigin_Switch_LeftStick_Move=209,
    k_EControllerActionOrigin_Switch_LeftStick_Click=210,
    k_EControllerActionOrigin_Switch_LeftStick_DPadNorth=211,
    k_EControllerActionOrigin_Switch_LeftStick_DPadSouth=212,
    k_EControllerActionOrigin_Switch_LeftStick_DPadWest=213,
    k_EControllerActionOrigin_Switch_LeftStick_DPadEast=214,
    k_EControllerActionOrigin_Switch_RightStick_Move=215,
    k_EControllerActionOrigin_Switch_RightStick_Click=216,
    k_EControllerActionOrigin_Switch_RightStick_DPadNorth=217,
    k_EControllerActionOrigin_Switch_RightStick_DPadSouth=218,
    k_EControllerActionOrigin_Switch_RightStick_DPadWest=219,
    k_EControllerActionOrigin_Switch_RightStick_DPadEast=220,
    k_EControllerActionOrigin_Switch_DPad_North=221,
    k_EControllerActionOrigin_Switch_DPad_South=222,
    k_EControllerActionOrigin_Switch_DPad_West=223,
    k_EControllerActionOrigin_Switch_DPad_East=224,
    k_EControllerActionOrigin_Switch_ProGyro_Move=225,
    k_EControllerActionOrigin_Switch_ProGyro_Pitch=226,
    k_EControllerActionOrigin_Switch_ProGyro_Yaw=227,
    k_EControllerActionOrigin_Switch_ProGyro_Roll=228,
    k_EControllerActionOrigin_Switch_RightGyro_Move=229,
    k_EControllerActionOrigin_Switch_RightGyro_Pitch=230,
    k_EControllerActionOrigin_Switch_RightGyro_Yaw=231,
    k_EControllerActionOrigin_Switch_RightGyro_Roll=232,
    k_EControllerActionOrigin_Switch_LeftGyro_Move=233,
    k_EControllerActionOrigin_Switch_LeftGyro_Pitch=234,
    k_EControllerActionOrigin_Switch_LeftGyro_Yaw=235,
    k_EControllerActionOrigin_Switch_LeftGyro_Roll=236,
    k_EControllerActionOrigin_Switch_LeftGrip_Lower=237,
    k_EControllerActionOrigin_Switch_LeftGrip_Upper=238,
    k_EControllerActionOrigin_Switch_RightGrip_Lower=239,
    k_EControllerActionOrigin_Switch_RightGrip_Upper=240,
    k_EControllerActionOrigin_Count=241,
    k_EControllerActionOrigin_MaximumPossibleValue=32767
};

enum ESteamControllerPad
{
    k_ESteamControllerPad_Left=0,
    k_ESteamControllerPad_Right=1
};

enum ESteamInputType
{
    k_ESteamInputType_Unknown=0,
    k_ESteamInputType_SteamController=1,
    k_ESteamInputType_XBox360Controller=2,
    k_ESteamInputType_XBoxOneController=3,
    k_ESteamInputType_GenericGamepad=4,
    k_ESteamInputType_PS4Controller=5,
    k_ESteamInputType_AppleMFiController=6,
    k_ESteamInputType_AndroidController=7,
    k_ESteamInputType_SwitchJoyConPair=8,
    k_ESteamInputType_SwitchJoyConSingle=9,
    k_ESteamInputType_SwitchProController=10,
    k_ESteamInputType_MobileTouch=11,
    k_ESteamInputType_PS3Controller=12,
    k_ESteamInputType_Count=13,
    k_ESteamInputType_MaximumPossibleValue=255
};

enum EXboxOrigin
{
    k_EXboxOrigin_A=0,
    k_EXboxOrigin_B=1,
    k_EXboxOrigin_X=2,
    k_EXboxOrigin_Y=3,
    k_EXboxOrigin_LeftBumper=4,
    k_EXboxOrigin_RightBumper=5,
    k_EXboxOrigin_Menu=6,
    k_EXboxOrigin_View=7,
    k_EXboxOrigin_LeftTrigger_Pull=8,
    k_EXboxOrigin_LeftTrigger_Click=9,
    k_EXboxOrigin_RightTrigger_Pull=10,
    k_EXboxOrigin_RightTrigger_Click=11,
    k_EXboxOrigin_LeftStick_Move=12,
    k_EXboxOrigin_LeftStick_Click=13,
    k_EXboxOrigin_LeftStick_DPadNorth=14,
    k_EXboxOrigin_LeftStick_DPadSouth=15,
    k_EXboxOrigin_LeftStick_DPadWest=16,
    k_EXboxOrigin_LeftStick_DPadEast=17,
    k_EXboxOrigin_RightStick_Move=18,
    k_EXboxOrigin_RightStick_Click=19,
    k_EXboxOrigin_RightStick_DPadNorth=20,
    k_EXboxOrigin_RightStick_DPadSouth=21,
    k_EXboxOrigin_RightStick_DPadWest=22,
    k_EXboxOrigin_RightStick_DPadEast=23,
    k_EXboxOrigin_DPad_North=24,
    k_EXboxOrigin_DPad_South=25,
    k_EXboxOrigin_DPad_West=26,
    k_EXboxOrigin_DPad_East=27,
    k_EXboxOrigin_Count=28
};

class ISteamController
{
    public bool Init();
    public bool Shutdown();
    public void RunFrame();
    public int GetConnectedControllers(unsigned int * );
    public unsigned int GetActionSetHandle(char * );
    public void ActivateActionSet(unsigned int ,unsigned int );
    public unsigned int GetCurrentActionSet(unsigned int );
    public void ActivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateAllActionSetLayers(unsigned int );
    public int GetActiveActionSetLayers(unsigned int ,unsigned int * );
    public unsigned int GetDigitalActionHandle(char * );
    public struct InputDigitalActionData_t GetDigitalActionData(unsigned int ,unsigned int );
    public int GetDigitalActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EControllerActionOrigin * );
    public unsigned int GetAnalogActionHandle(char * );
    public struct InputAnalogActionData_t GetAnalogActionData(unsigned int ,unsigned int );
    public int GetAnalogActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EControllerActionOrigin * );
    public char * GetGlyphForActionOrigin(enum EControllerActionOrigin );
    public char * GetStringForActionOrigin(enum EControllerActionOrigin );
    public void StopAnalogActionMomentum(unsigned int ,unsigned int );
    public struct InputMotionData_t GetMotionData(unsigned int );
    public void TriggerHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int );
    public void TriggerRepeatedHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void TriggerVibration(unsigned int ,unsigned int ,unsigned int );
    public void SetLEDColor(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public bool ShowBindingPanel(unsigned int );
    public enum ESteamInputType GetInputTypeForHandle(unsigned int );
    public unsigned int GetControllerForGamepadIndex(int );
    public int GetGamepadIndexForController(unsigned int );
    public char * GetStringForXboxOrigin(enum EXboxOrigin );
    public char * GetGlyphForXboxOrigin(enum EXboxOrigin );
    public enum EControllerActionOrigin GetActionOriginFromXboxOrigin(unsigned int ,enum EXboxOrigin );
    public enum EControllerActionOrigin TranslateActionOrigin(enum ESteamInputType ,enum EControllerActionOrigin );
    public void ISteamController(class ISteamController * );
    public void ISteamController(class ISteamController & );
    public void ISteamController();
    public class ISteamController & operator=(class ISteamController * );
    public class ISteamController & operator=(class ISteamController & );
};

class ISteamController
{
    public bool Init();
    public bool Shutdown();
    public void RunFrame();
    public int GetConnectedControllers(unsigned int * );
    public unsigned int GetActionSetHandle(char * );
    public void ActivateActionSet(unsigned int ,unsigned int );
    public unsigned int GetCurrentActionSet(unsigned int );
    public void ActivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateAllActionSetLayers(unsigned int );
    public int GetActiveActionSetLayers(unsigned int ,unsigned int * );
    public unsigned int GetDigitalActionHandle(char * );
    public struct InputDigitalActionData_t GetDigitalActionData(unsigned int ,unsigned int );
    public int GetDigitalActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EControllerActionOrigin * );
    public unsigned int GetAnalogActionHandle(char * );
    public struct InputAnalogActionData_t GetAnalogActionData(unsigned int ,unsigned int );
    public int GetAnalogActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EControllerActionOrigin * );
    public char * GetGlyphForActionOrigin(enum EControllerActionOrigin );
    public char * GetStringForActionOrigin(enum EControllerActionOrigin );
    public void StopAnalogActionMomentum(unsigned int ,unsigned int );
    public struct InputMotionData_t GetMotionData(unsigned int );
    public void TriggerHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int );
    public void TriggerRepeatedHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void TriggerVibration(unsigned int ,unsigned int ,unsigned int );
    public void SetLEDColor(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public bool ShowBindingPanel(unsigned int );
    public enum ESteamInputType GetInputTypeForHandle(unsigned int );
    public unsigned int GetControllerForGamepadIndex(int );
    public int GetGamepadIndexForController(unsigned int );
    public char * GetStringForXboxOrigin(enum EXboxOrigin );
    public char * GetGlyphForXboxOrigin(enum EXboxOrigin );
    public enum EControllerActionOrigin GetActionOriginFromXboxOrigin(unsigned int ,enum EXboxOrigin );
    public enum EControllerActionOrigin TranslateActionOrigin(enum ESteamInputType ,enum EControllerActionOrigin );
    public void ISteamController(class ISteamController * );
    public void ISteamController(class ISteamController & );
    public void ISteamController();
    public class ISteamController & operator=(class ISteamController * );
    public class ISteamController & operator=(class ISteamController & );
};

enum EUserUGCList
{
    k_EUserUGCList_Published=0,
    k_EUserUGCList_VotedOn=1,
    k_EUserUGCList_VotedUp=2,
    k_EUserUGCList_VotedDown=3,
    k_EUserUGCList_WillVoteLater=4,
    k_EUserUGCList_Favorited=5,
    k_EUserUGCList_Subscribed=6,
    k_EUserUGCList_UsedOrPlayed=7,
    k_EUserUGCList_Followed=8
};

enum EUGCMatchingUGCType
{
    k_EUGCMatchingUGCType_Items=0,
    k_EUGCMatchingUGCType_Items_Mtx=1,
    k_EUGCMatchingUGCType_Items_ReadyToUse=2,
    k_EUGCMatchingUGCType_Collections=3,
    k_EUGCMatchingUGCType_Artwork=4,
    k_EUGCMatchingUGCType_Videos=5,
    k_EUGCMatchingUGCType_Screenshots=6,
    k_EUGCMatchingUGCType_AllGuides=7,
    k_EUGCMatchingUGCType_WebGuides=8,
    k_EUGCMatchingUGCType_IntegratedGuides=9,
    k_EUGCMatchingUGCType_UsableInGame=10,
    k_EUGCMatchingUGCType_ControllerBindings=11,
    k_EUGCMatchingUGCType_GameManagedItems=12,
    k_EUGCMatchingUGCType_All=-1
};

enum EUserUGCListSortOrder
{
    k_EUserUGCListSortOrder_CreationOrderDesc=0,
    k_EUserUGCListSortOrder_CreationOrderAsc=1,
    k_EUserUGCListSortOrder_TitleAsc=2,
    k_EUserUGCListSortOrder_LastUpdatedDesc=3,
    k_EUserUGCListSortOrder_SubscriptionDateDesc=4,
    k_EUserUGCListSortOrder_VoteScoreDesc=5,
    k_EUserUGCListSortOrder_ForModeration=6
};

enum EUGCQuery
{
    k_EUGCQuery_RankedByVote=0,
    k_EUGCQuery_RankedByPublicationDate=1,
    k_EUGCQuery_AcceptedForGameRankedByAcceptanceDate=2,
    k_EUGCQuery_RankedByTrend=3,
    k_EUGCQuery_FavoritedByFriendsRankedByPublicationDate=4,
    k_EUGCQuery_CreatedByFriendsRankedByPublicationDate=5,
    k_EUGCQuery_RankedByNumTimesReported=6,
    k_EUGCQuery_CreatedByFollowedUsersRankedByPublicationDate=7,
    k_EUGCQuery_NotYetRated=8,
    k_EUGCQuery_RankedByTotalVotesAsc=9,
    k_EUGCQuery_RankedByVotesUp=10,
    k_EUGCQuery_RankedByTextSearch=11,
    k_EUGCQuery_RankedByTotalUniqueSubscriptions=12,
    k_EUGCQuery_RankedByPlaytimeTrend=13,
    k_EUGCQuery_RankedByTotalPlaytime=14,
    k_EUGCQuery_RankedByAveragePlaytimeTrend=15,
    k_EUGCQuery_RankedByLifetimeAveragePlaytime=16,
    k_EUGCQuery_RankedByPlaytimeSessionsTrend=17,
    k_EUGCQuery_RankedByLifetimePlaytimeSessions=18
};

enum EItemStatistic
{
    k_EItemStatistic_NumSubscriptions=0,
    k_EItemStatistic_NumFavorites=1,
    k_EItemStatistic_NumFollowers=2,
    k_EItemStatistic_NumUniqueSubscriptions=3,
    k_EItemStatistic_NumUniqueFavorites=4,
    k_EItemStatistic_NumUniqueFollowers=5,
    k_EItemStatistic_NumUniqueWebsiteViews=6,
    k_EItemStatistic_ReportScore=7,
    k_EItemStatistic_NumSecondsPlayed=8,
    k_EItemStatistic_NumPlaytimeSessions=9,
    k_EItemStatistic_NumComments=10,
    k_EItemStatistic_NumSecondsPlayedDuringTimePeriod=11,
    k_EItemStatistic_NumPlaytimeSessionsDuringTimePeriod=12
};

enum EItemPreviewType
{
    k_EItemPreviewType_Image=0,
    k_EItemPreviewType_YouTubeVideo=1,
    k_EItemPreviewType_Sketchfab=2,
    k_EItemPreviewType_EnvironmentMap_HorizontalCross=3,
    k_EItemPreviewType_EnvironmentMap_LatLong=4,
    k_EItemPreviewType_ReservedMax=255
};

struct SteamParamStringArray_t
{
    char ** m_ppStrings;
    int m_nNumStrings;
};

enum EItemUpdateStatus
{
    k_EItemUpdateStatusInvalid=0,
    k_EItemUpdateStatusPreparingConfig=1,
    k_EItemUpdateStatusPreparingContent=2,
    k_EItemUpdateStatusUploadingContent=3,
    k_EItemUpdateStatusUploadingPreviewFile=4,
    k_EItemUpdateStatusCommittingChanges=5
};

class ISteamUGC
{
    public unsigned int CreateQueryUserUGCRequest(unsigned int ,enum EUserUGCList ,enum EUGCMatchingUGCType ,enum EUserUGCListSortOrder ,unsigned int ,unsigned int ,unsigned int );
    public unsigned int CreateQueryAllUGCRequest(enum EUGCQuery ,enum EUGCMatchingUGCType ,unsigned int ,unsigned int ,char * );
    public unsigned int CreateQueryAllUGCRequest(enum EUGCQuery ,enum EUGCMatchingUGCType ,unsigned int ,unsigned int ,unsigned int );
    public unsigned int CreateQueryUGCDetailsRequest(unsigned int * ,unsigned int );
    public unsigned int SendQueryUGCRequest(unsigned int );
    public bool GetQueryUGCResult(unsigned int ,unsigned int ,struct SteamUGCDetails_t * );
    public bool GetQueryUGCPreviewURL(unsigned int ,unsigned int ,char * ,unsigned int );
    public bool GetQueryUGCMetadata(unsigned int ,unsigned int ,char * ,unsigned int );
    public bool GetQueryUGCChildren(unsigned int ,unsigned int ,unsigned int * ,unsigned int );
    public bool GetQueryUGCStatistic(unsigned int ,unsigned int ,enum EItemStatistic ,unsigned int * );
    public unsigned int GetQueryUGCNumAdditionalPreviews(unsigned int ,unsigned int );
    public bool GetQueryUGCAdditionalPreview(unsigned int ,unsigned int ,unsigned int ,char * ,unsigned int ,char * ,unsigned int ,enum EItemPreviewType * );
    public unsigned int GetQueryUGCNumKeyValueTags(unsigned int ,unsigned int );
    public bool GetQueryUGCKeyValueTag(unsigned int ,unsigned int ,unsigned int ,char * ,unsigned int ,char * ,unsigned int );
    public bool ReleaseQueryUGCRequest(unsigned int );
    public bool AddRequiredTag(unsigned int ,char * );
    public bool AddExcludedTag(unsigned int ,char * );
    public bool SetReturnOnlyIDs(unsigned int ,bool );
    public bool SetReturnKeyValueTags(unsigned int ,bool );
    public bool SetReturnLongDescription(unsigned int ,bool );
    public bool SetReturnMetadata(unsigned int ,bool );
    public bool SetReturnChildren(unsigned int ,bool );
    public bool SetReturnAdditionalPreviews(unsigned int ,bool );
    public bool SetReturnTotalOnly(unsigned int ,bool );
    public bool SetReturnPlaytimeStats(unsigned int ,unsigned int );
    public bool SetLanguage(unsigned int ,char * );
    public bool SetAllowCachedResponse(unsigned int ,unsigned int );
    public bool SetCloudFileNameFilter(unsigned int ,char * );
    public bool SetMatchAnyTag(unsigned int ,bool );
    public bool SetSearchText(unsigned int ,char * );
    public bool SetRankedByTrendDays(unsigned int ,unsigned int );
    public bool AddRequiredKeyValueTag(unsigned int ,char * ,char * );
    public unsigned int RequestUGCDetails(unsigned int ,unsigned int );
    public unsigned int CreateItem(unsigned int ,enum EWorkshopFileType );
    public unsigned int StartItemUpdate(unsigned int ,unsigned int );
    public bool SetItemTitle(unsigned int ,char * );
    public bool SetItemDescription(unsigned int ,char * );
    public bool SetItemUpdateLanguage(unsigned int ,char * );
    public bool SetItemMetadata(unsigned int ,char * );
    public bool SetItemVisibility(unsigned int ,enum ERemoteStoragePublishedFileVisibility );
    public bool SetItemTags(unsigned int ,struct SteamParamStringArray_t * );
    public bool SetItemContent(unsigned int ,char * );
    public bool SetItemPreview(unsigned int ,char * );
    public bool SetAllowLegacyUpload(unsigned int ,bool );
    public bool RemoveItemKeyValueTags(unsigned int ,char * );
    public bool AddItemKeyValueTag(unsigned int ,char * ,char * );
    public bool AddItemPreviewFile(unsigned int ,char * ,enum EItemPreviewType );
    public bool AddItemPreviewVideo(unsigned int ,char * );
    public bool UpdateItemPreviewFile(unsigned int ,unsigned int ,char * );
    public bool UpdateItemPreviewVideo(unsigned int ,unsigned int ,char * );
    public bool RemoveItemPreview(unsigned int ,unsigned int );
    public unsigned int SubmitItemUpdate(unsigned int ,char * );
    public enum EItemUpdateStatus GetItemUpdateProgress(unsigned int ,unsigned int * ,unsigned int * );
    public unsigned int SetUserItemVote(unsigned int ,bool );
    public unsigned int GetUserItemVote(unsigned int );
    public unsigned int AddItemToFavorites(unsigned int ,unsigned int );
    public unsigned int RemoveItemFromFavorites(unsigned int ,unsigned int );
    public unsigned int SubscribeItem(unsigned int );
    public unsigned int UnsubscribeItem(unsigned int );
    public unsigned int GetNumSubscribedItems();
    public unsigned int GetSubscribedItems(unsigned int * ,unsigned int );
    public unsigned int GetItemState(unsigned int );
    public bool GetItemInstallInfo(unsigned int ,unsigned int * ,char * ,unsigned int ,unsigned int * );
    public bool GetItemDownloadInfo(unsigned int ,unsigned int * ,unsigned int * );
    public bool DownloadItem(unsigned int ,bool );
    public bool BInitWorkshopForGameServer(unsigned int ,char * );
    public void SuspendDownloads(bool );
    public unsigned int StartPlaytimeTracking(unsigned int * ,unsigned int );
    public unsigned int StopPlaytimeTracking(unsigned int * ,unsigned int );
    public unsigned int StopPlaytimeTrackingForAllItems();
    public unsigned int AddDependency(unsigned int ,unsigned int );
    public unsigned int RemoveDependency(unsigned int ,unsigned int );
    public unsigned int AddAppDependency(unsigned int ,unsigned int );
    public unsigned int RemoveAppDependency(unsigned int ,unsigned int );
    public unsigned int GetAppDependencies(unsigned int );
    public unsigned int DeleteItem(unsigned int );
    public void ISteamUGC(class ISteamUGC * );
    public void ISteamUGC(class ISteamUGC & );
    public void ISteamUGC();
    public class ISteamUGC & operator=(class ISteamUGC * );
    public class ISteamUGC & operator=(class ISteamUGC & );
};

class ISteamUGC
{
    public unsigned int CreateQueryUserUGCRequest(unsigned int ,enum EUserUGCList ,enum EUGCMatchingUGCType ,enum EUserUGCListSortOrder ,unsigned int ,unsigned int ,unsigned int );
    public unsigned int CreateQueryAllUGCRequest(enum EUGCQuery ,enum EUGCMatchingUGCType ,unsigned int ,unsigned int ,char * );
    public unsigned int CreateQueryAllUGCRequest(enum EUGCQuery ,enum EUGCMatchingUGCType ,unsigned int ,unsigned int ,unsigned int );
    public unsigned int CreateQueryUGCDetailsRequest(unsigned int * ,unsigned int );
    public unsigned int SendQueryUGCRequest(unsigned int );
    public bool GetQueryUGCResult(unsigned int ,unsigned int ,struct SteamUGCDetails_t * );
    public bool GetQueryUGCPreviewURL(unsigned int ,unsigned int ,char * ,unsigned int );
    public bool GetQueryUGCMetadata(unsigned int ,unsigned int ,char * ,unsigned int );
    public bool GetQueryUGCChildren(unsigned int ,unsigned int ,unsigned int * ,unsigned int );
    public bool GetQueryUGCStatistic(unsigned int ,unsigned int ,enum EItemStatistic ,unsigned int * );
    public unsigned int GetQueryUGCNumAdditionalPreviews(unsigned int ,unsigned int );
    public bool GetQueryUGCAdditionalPreview(unsigned int ,unsigned int ,unsigned int ,char * ,unsigned int ,char * ,unsigned int ,enum EItemPreviewType * );
    public unsigned int GetQueryUGCNumKeyValueTags(unsigned int ,unsigned int );
    public bool GetQueryUGCKeyValueTag(unsigned int ,unsigned int ,unsigned int ,char * ,unsigned int ,char * ,unsigned int );
    public bool ReleaseQueryUGCRequest(unsigned int );
    public bool AddRequiredTag(unsigned int ,char * );
    public bool AddExcludedTag(unsigned int ,char * );
    public bool SetReturnOnlyIDs(unsigned int ,bool );
    public bool SetReturnKeyValueTags(unsigned int ,bool );
    public bool SetReturnLongDescription(unsigned int ,bool );
    public bool SetReturnMetadata(unsigned int ,bool );
    public bool SetReturnChildren(unsigned int ,bool );
    public bool SetReturnAdditionalPreviews(unsigned int ,bool );
    public bool SetReturnTotalOnly(unsigned int ,bool );
    public bool SetReturnPlaytimeStats(unsigned int ,unsigned int );
    public bool SetLanguage(unsigned int ,char * );
    public bool SetAllowCachedResponse(unsigned int ,unsigned int );
    public bool SetCloudFileNameFilter(unsigned int ,char * );
    public bool SetMatchAnyTag(unsigned int ,bool );
    public bool SetSearchText(unsigned int ,char * );
    public bool SetRankedByTrendDays(unsigned int ,unsigned int );
    public bool AddRequiredKeyValueTag(unsigned int ,char * ,char * );
    public unsigned int RequestUGCDetails(unsigned int ,unsigned int );
    public unsigned int CreateItem(unsigned int ,enum EWorkshopFileType );
    public unsigned int StartItemUpdate(unsigned int ,unsigned int );
    public bool SetItemTitle(unsigned int ,char * );
    public bool SetItemDescription(unsigned int ,char * );
    public bool SetItemUpdateLanguage(unsigned int ,char * );
    public bool SetItemMetadata(unsigned int ,char * );
    public bool SetItemVisibility(unsigned int ,enum ERemoteStoragePublishedFileVisibility );
    public bool SetItemTags(unsigned int ,struct SteamParamStringArray_t * );
    public bool SetItemContent(unsigned int ,char * );
    public bool SetItemPreview(unsigned int ,char * );
    public bool SetAllowLegacyUpload(unsigned int ,bool );
    public bool RemoveItemKeyValueTags(unsigned int ,char * );
    public bool AddItemKeyValueTag(unsigned int ,char * ,char * );
    public bool AddItemPreviewFile(unsigned int ,char * ,enum EItemPreviewType );
    public bool AddItemPreviewVideo(unsigned int ,char * );
    public bool UpdateItemPreviewFile(unsigned int ,unsigned int ,char * );
    public bool UpdateItemPreviewVideo(unsigned int ,unsigned int ,char * );
    public bool RemoveItemPreview(unsigned int ,unsigned int );
    public unsigned int SubmitItemUpdate(unsigned int ,char * );
    public enum EItemUpdateStatus GetItemUpdateProgress(unsigned int ,unsigned int * ,unsigned int * );
    public unsigned int SetUserItemVote(unsigned int ,bool );
    public unsigned int GetUserItemVote(unsigned int );
    public unsigned int AddItemToFavorites(unsigned int ,unsigned int );
    public unsigned int RemoveItemFromFavorites(unsigned int ,unsigned int );
    public unsigned int SubscribeItem(unsigned int );
    public unsigned int UnsubscribeItem(unsigned int );
    public unsigned int GetNumSubscribedItems();
    public unsigned int GetSubscribedItems(unsigned int * ,unsigned int );
    public unsigned int GetItemState(unsigned int );
    public bool GetItemInstallInfo(unsigned int ,unsigned int * ,char * ,unsigned int ,unsigned int * );
    public bool GetItemDownloadInfo(unsigned int ,unsigned int * ,unsigned int * );
    public bool DownloadItem(unsigned int ,bool );
    public bool BInitWorkshopForGameServer(unsigned int ,char * );
    public void SuspendDownloads(bool );
    public unsigned int StartPlaytimeTracking(unsigned int * ,unsigned int );
    public unsigned int StopPlaytimeTracking(unsigned int * ,unsigned int );
    public unsigned int StopPlaytimeTrackingForAllItems();
    public unsigned int AddDependency(unsigned int ,unsigned int );
    public unsigned int RemoveDependency(unsigned int ,unsigned int );
    public unsigned int AddAppDependency(unsigned int ,unsigned int );
    public unsigned int RemoveAppDependency(unsigned int ,unsigned int );
    public unsigned int GetAppDependencies(unsigned int );
    public unsigned int DeleteItem(unsigned int );
    public void ISteamUGC(class ISteamUGC * );
    public void ISteamUGC(class ISteamUGC & );
    public void ISteamUGC();
    public class ISteamUGC & operator=(class ISteamUGC * );
    public class ISteamUGC & operator=(class ISteamUGC & );
};

class ISteamAppList
{
    public unsigned int GetNumInstalledApps();
    public unsigned int GetInstalledApps(unsigned int * ,unsigned int );
    public int GetAppName(unsigned int ,char * ,int );
    public int GetAppInstallDir(unsigned int ,char * ,int );
    public int GetAppBuildId(unsigned int );
    public void ISteamAppList(class ISteamAppList * );
    public void ISteamAppList(class ISteamAppList & );
    public void ISteamAppList();
    public class ISteamAppList & operator=(class ISteamAppList * );
    public class ISteamAppList & operator=(class ISteamAppList & );
};

class ISteamAppList
{
    public unsigned int GetNumInstalledApps();
    public unsigned int GetInstalledApps(unsigned int * ,unsigned int );
    public int GetAppName(unsigned int ,char * ,int );
    public int GetAppInstallDir(unsigned int ,char * ,int );
    public int GetAppBuildId(unsigned int );
    public void ISteamAppList(class ISteamAppList * );
    public void ISteamAppList(class ISteamAppList & );
    public void ISteamAppList();
    public class ISteamAppList & operator=(class ISteamAppList * );
    public class ISteamAppList & operator=(class ISteamAppList & );
};

enum AudioPlayback_Status
{
    AudioPlayback_Undefined=0,
    AudioPlayback_Playing=1,
    AudioPlayback_Paused=2,
    AudioPlayback_Idle=3
};

class ISteamMusic
{
    public bool BIsEnabled();
    public bool BIsPlaying();
    public enum AudioPlayback_Status GetPlaybackStatus();
    public void Play();
    public void Pause();
    public void PlayPrevious();
    public void PlayNext();
    public void SetVolume(float );
    public float GetVolume();
    public void ISteamMusic(class ISteamMusic * );
    public void ISteamMusic(class ISteamMusic & );
    public void ISteamMusic();
    public class ISteamMusic & operator=(class ISteamMusic * );
    public class ISteamMusic & operator=(class ISteamMusic & );
};

class ISteamMusic
{
    public bool BIsEnabled();
    public bool BIsPlaying();
    public enum AudioPlayback_Status GetPlaybackStatus();
    public void Play();
    public void Pause();
    public void PlayPrevious();
    public void PlayNext();
    public void SetVolume(float );
    public float GetVolume();
    public void ISteamMusic(class ISteamMusic * );
    public void ISteamMusic(class ISteamMusic & );
    public void ISteamMusic();
    public class ISteamMusic & operator=(class ISteamMusic * );
    public class ISteamMusic & operator=(class ISteamMusic & );
};

class ISteamMusicRemote
{
    public bool RegisterSteamMusicRemote(char * );
    public bool DeregisterSteamMusicRemote();
    public bool BIsCurrentMusicRemote();
    public bool BActivationSuccess(bool );
    public bool SetDisplayName(char * );
    public bool SetPNGIcon_64x64(void * ,unsigned int );
    public bool EnablePlayPrevious(bool );
    public bool EnablePlayNext(bool );
    public bool EnableShuffled(bool );
    public bool EnableLooped(bool );
    public bool EnableQueue(bool );
    public bool EnablePlaylists(bool );
    public bool UpdatePlaybackStatus(enum AudioPlayback_Status );
    public bool UpdateShuffled(bool );
    public bool UpdateLooped(bool );
    public bool UpdateVolume(float );
    public bool CurrentEntryWillChange();
    public bool CurrentEntryIsAvailable(bool );
    public bool UpdateCurrentEntryText(char * );
    public bool UpdateCurrentEntryElapsedSeconds(int );
    public bool UpdateCurrentEntryCoverArt(void * ,unsigned int );
    public bool CurrentEntryDidChange();
    public bool QueueWillChange();
    public bool ResetQueueEntries();
    public bool SetQueueEntry(int ,int ,char * );
    public bool SetCurrentQueueEntry(int );
    public bool QueueDidChange();
    public bool PlaylistWillChange();
    public bool ResetPlaylistEntries();
    public bool SetPlaylistEntry(int ,int ,char * );
    public bool SetCurrentPlaylistEntry(int );
    public bool PlaylistDidChange();
    public void ISteamMusicRemote(class ISteamMusicRemote * );
    public void ISteamMusicRemote(class ISteamMusicRemote & );
    public void ISteamMusicRemote();
    public class ISteamMusicRemote & operator=(class ISteamMusicRemote * );
    public class ISteamMusicRemote & operator=(class ISteamMusicRemote & );
};

class ISteamMusicRemote
{
    public bool RegisterSteamMusicRemote(char * );
    public bool DeregisterSteamMusicRemote();
    public bool BIsCurrentMusicRemote();
    public bool BActivationSuccess(bool );
    public bool SetDisplayName(char * );
    public bool SetPNGIcon_64x64(void * ,unsigned int );
    public bool EnablePlayPrevious(bool );
    public bool EnablePlayNext(bool );
    public bool EnableShuffled(bool );
    public bool EnableLooped(bool );
    public bool EnableQueue(bool );
    public bool EnablePlaylists(bool );
    public bool UpdatePlaybackStatus(enum AudioPlayback_Status );
    public bool UpdateShuffled(bool );
    public bool UpdateLooped(bool );
    public bool UpdateVolume(float );
    public bool CurrentEntryWillChange();
    public bool CurrentEntryIsAvailable(bool );
    public bool UpdateCurrentEntryText(char * );
    public bool UpdateCurrentEntryElapsedSeconds(int );
    public bool UpdateCurrentEntryCoverArt(void * ,unsigned int );
    public bool CurrentEntryDidChange();
    public bool QueueWillChange();
    public bool ResetQueueEntries();
    public bool SetQueueEntry(int ,int ,char * );
    public bool SetCurrentQueueEntry(int );
    public bool QueueDidChange();
    public bool PlaylistWillChange();
    public bool ResetPlaylistEntries();
    public bool SetPlaylistEntry(int ,int ,char * );
    public bool SetCurrentPlaylistEntry(int );
    public bool PlaylistDidChange();
    public void ISteamMusicRemote(class ISteamMusicRemote * );
    public void ISteamMusicRemote(class ISteamMusicRemote & );
    public void ISteamMusicRemote();
    public class ISteamMusicRemote & operator=(class ISteamMusicRemote * );
    public class ISteamMusicRemote & operator=(class ISteamMusicRemote & );
};

enum ISteamHTMLSurface::EHTMLMouseButton
{
    eHTMLMouseButton_Left=0,
    eHTMLMouseButton_Right=1,
    eHTMLMouseButton_Middle=2
};

enum ISteamHTMLSurface::EMouseCursor
{
    dc_user=0,
    dc_none=1,
    dc_arrow=2,
    dc_ibeam=3,
    dc_hourglass=4,
    dc_waitarrow=5,
    dc_crosshair=6,
    dc_up=7,
    dc_sizenw=8,
    dc_sizese=9,
    dc_sizene=10,
    dc_sizesw=11,
    dc_sizew=12,
    dc_sizee=13,
    dc_sizen=14,
    dc_sizes=15,
    dc_sizewe=16,
    dc_sizens=17,
    dc_sizeall=18,
    dc_no=19,
    dc_hand=20,
    dc_blank=21,
    dc_middle_pan=22,
    dc_north_pan=23,
    dc_north_east_pan=24,
    dc_east_pan=25,
    dc_south_east_pan=26,
    dc_south_pan=27,
    dc_south_west_pan=28,
    dc_west_pan=29,
    dc_north_west_pan=30,
    dc_alias=31,
    dc_cell=32,
    dc_colresize=33,
    dc_copycur=34,
    dc_verticaltext=35,
    dc_rowresize=36,
    dc_zoomin=37,
    dc_zoomout=38,
    dc_help=39,
    dc_custom=40,
    dc_last=41
};

enum ISteamHTMLSurface::EHTMLKeyModifiers
{
    k_eHTMLKeyModifier_None=0,
    k_eHTMLKeyModifier_AltDown=1,
    k_eHTMLKeyModifier_CtrlDown=2,
    k_eHTMLKeyModifier_ShiftDown=4
};

class ISteamHTMLSurface
{
    public void ~ISteamHTMLSurface();
    public bool Init();
    public bool Shutdown();
    public unsigned int CreateBrowser(char * ,char * );
    public void RemoveBrowser(unsigned int );
    public void LoadURL(unsigned int ,char * ,char * );
    public void SetSize(unsigned int ,unsigned int ,unsigned int );
    public void StopLoad(unsigned int );
    public void Reload(unsigned int );
    public void GoBack(unsigned int );
    public void GoForward(unsigned int );
    public void AddHeader(unsigned int ,char * ,char * );
    public void ExecuteJavascript(unsigned int ,char * );
    enum EHTMLMouseButton
    {
        eHTMLMouseButton_Left=0,
        eHTMLMouseButton_Right=1,
        eHTMLMouseButton_Middle=2
    };
    public void MouseUp(unsigned int ,enum ISteamHTMLSurface::EHTMLMouseButton );
    public void MouseDown(unsigned int ,enum ISteamHTMLSurface::EHTMLMouseButton );
    public void MouseDoubleClick(unsigned int ,enum ISteamHTMLSurface::EHTMLMouseButton );
    public void MouseMove(unsigned int ,int ,int );
    public void MouseWheel(unsigned int ,int );
    enum EMouseCursor
    {
        dc_user=0,
        dc_none=1,
        dc_arrow=2,
        dc_ibeam=3,
        dc_hourglass=4,
        dc_waitarrow=5,
        dc_crosshair=6,
        dc_up=7,
        dc_sizenw=8,
        dc_sizese=9,
        dc_sizene=10,
        dc_sizesw=11,
        dc_sizew=12,
        dc_sizee=13,
        dc_sizen=14,
        dc_sizes=15,
        dc_sizewe=16,
        dc_sizens=17,
        dc_sizeall=18,
        dc_no=19,
        dc_hand=20,
        dc_blank=21,
        dc_middle_pan=22,
        dc_north_pan=23,
        dc_north_east_pan=24,
        dc_east_pan=25,
        dc_south_east_pan=26,
        dc_south_pan=27,
        dc_south_west_pan=28,
        dc_west_pan=29,
        dc_north_west_pan=30,
        dc_alias=31,
        dc_cell=32,
        dc_colresize=33,
        dc_copycur=34,
        dc_verticaltext=35,
        dc_rowresize=36,
        dc_zoomin=37,
        dc_zoomout=38,
        dc_help=39,
        dc_custom=40,
        dc_last=41
    };
    enum EHTMLKeyModifiers
    {
        k_eHTMLKeyModifier_None=0,
        k_eHTMLKeyModifier_AltDown=1,
        k_eHTMLKeyModifier_CtrlDown=2,
        k_eHTMLKeyModifier_ShiftDown=4
    };
    public void KeyDown(unsigned int ,unsigned int ,enum ISteamHTMLSurface::EHTMLKeyModifiers ,bool );
    public void KeyUp(unsigned int ,unsigned int ,enum ISteamHTMLSurface::EHTMLKeyModifiers );
    public void KeyChar(unsigned int ,unsigned int ,enum ISteamHTMLSurface::EHTMLKeyModifiers );
    public void SetHorizontalScroll(unsigned int ,unsigned int );
    public void SetVerticalScroll(unsigned int ,unsigned int );
    public void SetKeyFocus(unsigned int ,bool );
    public void ViewSource(unsigned int );
    public void CopyToClipboard(unsigned int );
    public void PasteFromClipboard(unsigned int );
    public void Find(unsigned int ,char * ,bool ,bool );
    public void StopFind(unsigned int );
    public void GetLinkAtPosition(unsigned int ,int ,int );
    public void SetCookie(char * ,char * ,char * ,char * ,unsigned int ,bool ,bool );
    public void SetPageScaleFactor(unsigned int ,float ,int ,int );
    public void SetBackgroundMode(unsigned int ,bool );
    public void SetDPIScalingFactor(unsigned int ,float );
    public void OpenDeveloperTools(unsigned int );
    public void AllowStartRequest(unsigned int ,bool );
    public void JSDialogResponse(unsigned int ,bool );
    public void FileLoadDialogResponse(unsigned int ,char ** );
    public void ISteamHTMLSurface(class ISteamHTMLSurface & );
    public void ISteamHTMLSurface();
    public class ISteamHTMLSurface & operator=(class ISteamHTMLSurface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class ISteamHTMLSurface
{
    public void ~ISteamHTMLSurface();
    public bool Init();
    public bool Shutdown();
    public unsigned int CreateBrowser(char * ,char * );
    public void RemoveBrowser(unsigned int );
    public void LoadURL(unsigned int ,char * ,char * );
    public void SetSize(unsigned int ,unsigned int ,unsigned int );
    public void StopLoad(unsigned int );
    public void Reload(unsigned int );
    public void GoBack(unsigned int );
    public void GoForward(unsigned int );
    public void AddHeader(unsigned int ,char * ,char * );
    public void ExecuteJavascript(unsigned int ,char * );
    enum EHTMLMouseButton
    {
        eHTMLMouseButton_Left=0,
        eHTMLMouseButton_Right=1,
        eHTMLMouseButton_Middle=2
    };
    public void MouseUp(unsigned int ,enum ISteamHTMLSurface::EHTMLMouseButton );
    public void MouseDown(unsigned int ,enum ISteamHTMLSurface::EHTMLMouseButton );
    public void MouseDoubleClick(unsigned int ,enum ISteamHTMLSurface::EHTMLMouseButton );
    public void MouseMove(unsigned int ,int ,int );
    public void MouseWheel(unsigned int ,int );
    enum EMouseCursor
    {
        dc_user=0,
        dc_none=1,
        dc_arrow=2,
        dc_ibeam=3,
        dc_hourglass=4,
        dc_waitarrow=5,
        dc_crosshair=6,
        dc_up=7,
        dc_sizenw=8,
        dc_sizese=9,
        dc_sizene=10,
        dc_sizesw=11,
        dc_sizew=12,
        dc_sizee=13,
        dc_sizen=14,
        dc_sizes=15,
        dc_sizewe=16,
        dc_sizens=17,
        dc_sizeall=18,
        dc_no=19,
        dc_hand=20,
        dc_blank=21,
        dc_middle_pan=22,
        dc_north_pan=23,
        dc_north_east_pan=24,
        dc_east_pan=25,
        dc_south_east_pan=26,
        dc_south_pan=27,
        dc_south_west_pan=28,
        dc_west_pan=29,
        dc_north_west_pan=30,
        dc_alias=31,
        dc_cell=32,
        dc_colresize=33,
        dc_copycur=34,
        dc_verticaltext=35,
        dc_rowresize=36,
        dc_zoomin=37,
        dc_zoomout=38,
        dc_help=39,
        dc_custom=40,
        dc_last=41
    };
    enum EHTMLKeyModifiers
    {
        k_eHTMLKeyModifier_None=0,
        k_eHTMLKeyModifier_AltDown=1,
        k_eHTMLKeyModifier_CtrlDown=2,
        k_eHTMLKeyModifier_ShiftDown=4
    };
    public void KeyDown(unsigned int ,unsigned int ,enum ISteamHTMLSurface::EHTMLKeyModifiers ,bool );
    public void KeyUp(unsigned int ,unsigned int ,enum ISteamHTMLSurface::EHTMLKeyModifiers );
    public void KeyChar(unsigned int ,unsigned int ,enum ISteamHTMLSurface::EHTMLKeyModifiers );
    public void SetHorizontalScroll(unsigned int ,unsigned int );
    public void SetVerticalScroll(unsigned int ,unsigned int );
    public void SetKeyFocus(unsigned int ,bool );
    public void ViewSource(unsigned int );
    public void CopyToClipboard(unsigned int );
    public void PasteFromClipboard(unsigned int );
    public void Find(unsigned int ,char * ,bool ,bool );
    public void StopFind(unsigned int );
    public void GetLinkAtPosition(unsigned int ,int ,int );
    public void SetCookie(char * ,char * ,char * ,char * ,unsigned int ,bool ,bool );
    public void SetPageScaleFactor(unsigned int ,float ,int ,int );
    public void SetBackgroundMode(unsigned int ,bool );
    public void SetDPIScalingFactor(unsigned int ,float );
    public void OpenDeveloperTools(unsigned int );
    public void AllowStartRequest(unsigned int ,bool );
    public void JSDialogResponse(unsigned int ,bool );
    public void FileLoadDialogResponse(unsigned int ,char ** );
    public void ISteamHTMLSurface(class ISteamHTMLSurface & );
    public void ISteamHTMLSurface();
    public class ISteamHTMLSurface & operator=(class ISteamHTMLSurface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class ISteamInventory
{
    public enum EResult GetResultStatus(int );
    public bool GetResultItems(int ,struct SteamItemDetails_t * ,unsigned int * );
    public bool GetResultItemProperty(int ,unsigned int ,char * ,char * ,unsigned int * );
    public unsigned int GetResultTimestamp(int );
    public bool CheckResultSteamID(int ,class CSteamID );
    public void DestroyResult(int );
    public bool GetAllItems(int * );
    public bool GetItemsByID(int * ,unsigned int * ,unsigned int );
    public bool SerializeResult(int ,void * ,unsigned int * );
    public bool DeserializeResult(int * ,void * ,unsigned int ,bool );
    public bool GenerateItems(int * ,int * ,unsigned int * ,unsigned int );
    public bool GrantPromoItems(int * );
    public bool AddPromoItem(int * ,int );
    public bool AddPromoItems(int * ,int * ,unsigned int );
    public bool ConsumeItem(int * ,unsigned int ,unsigned int );
    public bool ExchangeItems(int * ,int * ,unsigned int * ,unsigned int ,unsigned int * ,unsigned int * ,unsigned int );
    public bool TransferItemQuantity(int * ,unsigned int ,unsigned int ,unsigned int );
    public void SendItemDropHeartbeat();
    public bool TriggerItemDrop(int * ,int );
    public bool TradeItems(int * ,class CSteamID ,unsigned int * ,unsigned int * ,unsigned int ,unsigned int * ,unsigned int * ,unsigned int );
    public bool LoadItemDefinitions();
    public bool GetItemDefinitionIDs(int * ,unsigned int * );
    public bool GetItemDefinitionProperty(int ,char * ,char * ,unsigned int * );
    public unsigned int RequestEligiblePromoItemDefinitionsIDs(class CSteamID );
    public bool GetEligiblePromoItemDefinitionIDs(class CSteamID ,int * ,unsigned int * );
    public unsigned int StartPurchase(int * ,unsigned int * ,unsigned int );
    public unsigned int RequestPrices();
    public unsigned int GetNumItemsWithPrices();
    public bool GetItemsWithPrices(int * ,unsigned int * ,unsigned int * ,unsigned int );
    public bool GetItemPrice(int ,unsigned int * ,unsigned int * );
    public unsigned int StartUpdateProperties();
    public bool RemoveProperty(unsigned int ,unsigned int ,char * );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,float );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,int );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,bool );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,char * );
    public bool SubmitUpdateProperties(unsigned int ,int * );
    public void ISteamInventory(class ISteamInventory * );
    public void ISteamInventory(class ISteamInventory & );
    public void ISteamInventory();
    public class ISteamInventory & operator=(class ISteamInventory * );
    public class ISteamInventory & operator=(class ISteamInventory & );
};

class ISteamInventory
{
    public enum EResult GetResultStatus(int );
    public bool GetResultItems(int ,struct SteamItemDetails_t * ,unsigned int * );
    public bool GetResultItemProperty(int ,unsigned int ,char * ,char * ,unsigned int * );
    public unsigned int GetResultTimestamp(int );
    public bool CheckResultSteamID(int ,class CSteamID );
    public void DestroyResult(int );
    public bool GetAllItems(int * );
    public bool GetItemsByID(int * ,unsigned int * ,unsigned int );
    public bool SerializeResult(int ,void * ,unsigned int * );
    public bool DeserializeResult(int * ,void * ,unsigned int ,bool );
    public bool GenerateItems(int * ,int * ,unsigned int * ,unsigned int );
    public bool GrantPromoItems(int * );
    public bool AddPromoItem(int * ,int );
    public bool AddPromoItems(int * ,int * ,unsigned int );
    public bool ConsumeItem(int * ,unsigned int ,unsigned int );
    public bool ExchangeItems(int * ,int * ,unsigned int * ,unsigned int ,unsigned int * ,unsigned int * ,unsigned int );
    public bool TransferItemQuantity(int * ,unsigned int ,unsigned int ,unsigned int );
    public void SendItemDropHeartbeat();
    public bool TriggerItemDrop(int * ,int );
    public bool TradeItems(int * ,class CSteamID ,unsigned int * ,unsigned int * ,unsigned int ,unsigned int * ,unsigned int * ,unsigned int );
    public bool LoadItemDefinitions();
    public bool GetItemDefinitionIDs(int * ,unsigned int * );
    public bool GetItemDefinitionProperty(int ,char * ,char * ,unsigned int * );
    public unsigned int RequestEligiblePromoItemDefinitionsIDs(class CSteamID );
    public bool GetEligiblePromoItemDefinitionIDs(class CSteamID ,int * ,unsigned int * );
    public unsigned int StartPurchase(int * ,unsigned int * ,unsigned int );
    public unsigned int RequestPrices();
    public unsigned int GetNumItemsWithPrices();
    public bool GetItemsWithPrices(int * ,unsigned int * ,unsigned int * ,unsigned int );
    public bool GetItemPrice(int ,unsigned int * ,unsigned int * );
    public unsigned int StartUpdateProperties();
    public bool RemoveProperty(unsigned int ,unsigned int ,char * );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,float );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,int );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,bool );
    public bool SetProperty(unsigned int ,unsigned int ,char * ,char * );
    public bool SubmitUpdateProperties(unsigned int ,int * );
    public void ISteamInventory(class ISteamInventory * );
    public void ISteamInventory(class ISteamInventory & );
    public void ISteamInventory();
    public class ISteamInventory & operator=(class ISteamInventory * );
    public class ISteamInventory & operator=(class ISteamInventory & );
};

class ISteamVideo
{
    public void GetVideoURL(unsigned int );
    public bool IsBroadcasting(int * );
    public void GetOPFSettings(unsigned int );
    public bool GetOPFStringForApp(unsigned int ,char * ,int * );
    public void ISteamVideo(class ISteamVideo * );
    public void ISteamVideo(class ISteamVideo & );
    public void ISteamVideo();
    public class ISteamVideo & operator=(class ISteamVideo * );
    public class ISteamVideo & operator=(class ISteamVideo & );
};

class ISteamVideo
{
    public void GetVideoURL(unsigned int );
    public bool IsBroadcasting(int * );
    public void GetOPFSettings(unsigned int );
    public bool GetOPFStringForApp(unsigned int ,char * ,int * );
    public void ISteamVideo(class ISteamVideo * );
    public void ISteamVideo(class ISteamVideo & );
    public void ISteamVideo();
    public class ISteamVideo & operator=(class ISteamVideo * );
    public class ISteamVideo & operator=(class ISteamVideo & );
};

enum EParentalFeature
{
    k_EFeatureInvalid=0,
    k_EFeatureStore=1,
    k_EFeatureCommunity=2,
    k_EFeatureProfile=3,
    k_EFeatureFriends=4,
    k_EFeatureNews=5,
    k_EFeatureTrading=6,
    k_EFeatureSettings=7,
    k_EFeatureConsole=8,
    k_EFeatureBrowser=9,
    k_EFeatureParentalSetup=10,
    k_EFeatureLibrary=11,
    k_EFeatureTest=12,
    k_EFeatureMax=13
};

class ISteamParentalSettings
{
    public bool BIsParentalLockEnabled();
    public bool BIsParentalLockLocked();
    public bool BIsAppBlocked(unsigned int );
    public bool BIsAppInBlockList(unsigned int );
    public bool BIsFeatureBlocked(enum EParentalFeature );
    public bool BIsFeatureInBlockList(enum EParentalFeature );
    public void ISteamParentalSettings(class ISteamParentalSettings * );
    public void ISteamParentalSettings(class ISteamParentalSettings & );
    public void ISteamParentalSettings();
    public class ISteamParentalSettings & operator=(class ISteamParentalSettings * );
    public class ISteamParentalSettings & operator=(class ISteamParentalSettings & );
};

class ISteamParentalSettings
{
    public bool BIsParentalLockEnabled();
    public bool BIsParentalLockLocked();
    public bool BIsAppBlocked(unsigned int );
    public bool BIsAppInBlockList(unsigned int );
    public bool BIsFeatureBlocked(enum EParentalFeature );
    public bool BIsFeatureInBlockList(enum EParentalFeature );
    public void ISteamParentalSettings(class ISteamParentalSettings * );
    public void ISteamParentalSettings(class ISteamParentalSettings & );
    public void ISteamParentalSettings();
    public class ISteamParentalSettings & operator=(class ISteamParentalSettings * );
    public class ISteamParentalSettings & operator=(class ISteamParentalSettings & );
};

enum EInputActionOrigin
{
    k_EInputActionOrigin_None=0,
    k_EInputActionOrigin_SteamController_A=1,
    k_EInputActionOrigin_SteamController_B=2,
    k_EInputActionOrigin_SteamController_X=3,
    k_EInputActionOrigin_SteamController_Y=4,
    k_EInputActionOrigin_SteamController_LeftBumper=5,
    k_EInputActionOrigin_SteamController_RightBumper=6,
    k_EInputActionOrigin_SteamController_LeftGrip=7,
    k_EInputActionOrigin_SteamController_RightGrip=8,
    k_EInputActionOrigin_SteamController_Start=9,
    k_EInputActionOrigin_SteamController_Back=10,
    k_EInputActionOrigin_SteamController_LeftPad_Touch=11,
    k_EInputActionOrigin_SteamController_LeftPad_Swipe=12,
    k_EInputActionOrigin_SteamController_LeftPad_Click=13,
    k_EInputActionOrigin_SteamController_LeftPad_DPadNorth=14,
    k_EInputActionOrigin_SteamController_LeftPad_DPadSouth=15,
    k_EInputActionOrigin_SteamController_LeftPad_DPadWest=16,
    k_EInputActionOrigin_SteamController_LeftPad_DPadEast=17,
    k_EInputActionOrigin_SteamController_RightPad_Touch=18,
    k_EInputActionOrigin_SteamController_RightPad_Swipe=19,
    k_EInputActionOrigin_SteamController_RightPad_Click=20,
    k_EInputActionOrigin_SteamController_RightPad_DPadNorth=21,
    k_EInputActionOrigin_SteamController_RightPad_DPadSouth=22,
    k_EInputActionOrigin_SteamController_RightPad_DPadWest=23,
    k_EInputActionOrigin_SteamController_RightPad_DPadEast=24,
    k_EInputActionOrigin_SteamController_LeftTrigger_Pull=25,
    k_EInputActionOrigin_SteamController_LeftTrigger_Click=26,
    k_EInputActionOrigin_SteamController_RightTrigger_Pull=27,
    k_EInputActionOrigin_SteamController_RightTrigger_Click=28,
    k_EInputActionOrigin_SteamController_LeftStick_Move=29,
    k_EInputActionOrigin_SteamController_LeftStick_Click=30,
    k_EInputActionOrigin_SteamController_LeftStick_DPadNorth=31,
    k_EInputActionOrigin_SteamController_LeftStick_DPadSouth=32,
    k_EInputActionOrigin_SteamController_LeftStick_DPadWest=33,
    k_EInputActionOrigin_SteamController_LeftStick_DPadEast=34,
    k_EInputActionOrigin_SteamController_Gyro_Move=35,
    k_EInputActionOrigin_SteamController_Gyro_Pitch=36,
    k_EInputActionOrigin_SteamController_Gyro_Yaw=37,
    k_EInputActionOrigin_SteamController_Gyro_Roll=38,
    k_EInputActionOrigin_SteamController_Reserved0=39,
    k_EInputActionOrigin_SteamController_Reserved1=40,
    k_EInputActionOrigin_SteamController_Reserved2=41,
    k_EInputActionOrigin_SteamController_Reserved3=42,
    k_EInputActionOrigin_SteamController_Reserved4=43,
    k_EInputActionOrigin_SteamController_Reserved5=44,
    k_EInputActionOrigin_SteamController_Reserved6=45,
    k_EInputActionOrigin_SteamController_Reserved7=46,
    k_EInputActionOrigin_SteamController_Reserved8=47,
    k_EInputActionOrigin_SteamController_Reserved9=48,
    k_EInputActionOrigin_SteamController_Reserved10=49,
    k_EInputActionOrigin_PS4_X=50,
    k_EInputActionOrigin_PS4_Circle=51,
    k_EInputActionOrigin_PS4_Triangle=52,
    k_EInputActionOrigin_PS4_Square=53,
    k_EInputActionOrigin_PS4_LeftBumper=54,
    k_EInputActionOrigin_PS4_RightBumper=55,
    k_EInputActionOrigin_PS4_Options=56,
    k_EInputActionOrigin_PS4_Share=57,
    k_EInputActionOrigin_PS4_LeftPad_Touch=58,
    k_EInputActionOrigin_PS4_LeftPad_Swipe=59,
    k_EInputActionOrigin_PS4_LeftPad_Click=60,
    k_EInputActionOrigin_PS4_LeftPad_DPadNorth=61,
    k_EInputActionOrigin_PS4_LeftPad_DPadSouth=62,
    k_EInputActionOrigin_PS4_LeftPad_DPadWest=63,
    k_EInputActionOrigin_PS4_LeftPad_DPadEast=64,
    k_EInputActionOrigin_PS4_RightPad_Touch=65,
    k_EInputActionOrigin_PS4_RightPad_Swipe=66,
    k_EInputActionOrigin_PS4_RightPad_Click=67,
    k_EInputActionOrigin_PS4_RightPad_DPadNorth=68,
    k_EInputActionOrigin_PS4_RightPad_DPadSouth=69,
    k_EInputActionOrigin_PS4_RightPad_DPadWest=70,
    k_EInputActionOrigin_PS4_RightPad_DPadEast=71,
    k_EInputActionOrigin_PS4_CenterPad_Touch=72,
    k_EInputActionOrigin_PS4_CenterPad_Swipe=73,
    k_EInputActionOrigin_PS4_CenterPad_Click=74,
    k_EInputActionOrigin_PS4_CenterPad_DPadNorth=75,
    k_EInputActionOrigin_PS4_CenterPad_DPadSouth=76,
    k_EInputActionOrigin_PS4_CenterPad_DPadWest=77,
    k_EInputActionOrigin_PS4_CenterPad_DPadEast=78,
    k_EInputActionOrigin_PS4_LeftTrigger_Pull=79,
    k_EInputActionOrigin_PS4_LeftTrigger_Click=80,
    k_EInputActionOrigin_PS4_RightTrigger_Pull=81,
    k_EInputActionOrigin_PS4_RightTrigger_Click=82,
    k_EInputActionOrigin_PS4_LeftStick_Move=83,
    k_EInputActionOrigin_PS4_LeftStick_Click=84,
    k_EInputActionOrigin_PS4_LeftStick_DPadNorth=85,
    k_EInputActionOrigin_PS4_LeftStick_DPadSouth=86,
    k_EInputActionOrigin_PS4_LeftStick_DPadWest=87,
    k_EInputActionOrigin_PS4_LeftStick_DPadEast=88,
    k_EInputActionOrigin_PS4_RightStick_Move=89,
    k_EInputActionOrigin_PS4_RightStick_Click=90,
    k_EInputActionOrigin_PS4_RightStick_DPadNorth=91,
    k_EInputActionOrigin_PS4_RightStick_DPadSouth=92,
    k_EInputActionOrigin_PS4_RightStick_DPadWest=93,
    k_EInputActionOrigin_PS4_RightStick_DPadEast=94,
    k_EInputActionOrigin_PS4_DPad_North=95,
    k_EInputActionOrigin_PS4_DPad_South=96,
    k_EInputActionOrigin_PS4_DPad_West=97,
    k_EInputActionOrigin_PS4_DPad_East=98,
    k_EInputActionOrigin_PS4_Gyro_Move=99,
    k_EInputActionOrigin_PS4_Gyro_Pitch=100,
    k_EInputActionOrigin_PS4_Gyro_Yaw=101,
    k_EInputActionOrigin_PS4_Gyro_Roll=102,
    k_EInputActionOrigin_PS4_Reserved0=103,
    k_EInputActionOrigin_PS4_Reserved1=104,
    k_EInputActionOrigin_PS4_Reserved2=105,
    k_EInputActionOrigin_PS4_Reserved3=106,
    k_EInputActionOrigin_PS4_Reserved4=107,
    k_EInputActionOrigin_PS4_Reserved5=108,
    k_EInputActionOrigin_PS4_Reserved6=109,
    k_EInputActionOrigin_PS4_Reserved7=110,
    k_EInputActionOrigin_PS4_Reserved8=111,
    k_EInputActionOrigin_PS4_Reserved9=112,
    k_EInputActionOrigin_PS4_Reserved10=113,
    k_EInputActionOrigin_XBoxOne_A=114,
    k_EInputActionOrigin_XBoxOne_B=115,
    k_EInputActionOrigin_XBoxOne_X=116,
    k_EInputActionOrigin_XBoxOne_Y=117,
    k_EInputActionOrigin_XBoxOne_LeftBumper=118,
    k_EInputActionOrigin_XBoxOne_RightBumper=119,
    k_EInputActionOrigin_XBoxOne_Menu=120,
    k_EInputActionOrigin_XBoxOne_View=121,
    k_EInputActionOrigin_XBoxOne_LeftTrigger_Pull=122,
    k_EInputActionOrigin_XBoxOne_LeftTrigger_Click=123,
    k_EInputActionOrigin_XBoxOne_RightTrigger_Pull=124,
    k_EInputActionOrigin_XBoxOne_RightTrigger_Click=125,
    k_EInputActionOrigin_XBoxOne_LeftStick_Move=126,
    k_EInputActionOrigin_XBoxOne_LeftStick_Click=127,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadNorth=128,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadSouth=129,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadWest=130,
    k_EInputActionOrigin_XBoxOne_LeftStick_DPadEast=131,
    k_EInputActionOrigin_XBoxOne_RightStick_Move=132,
    k_EInputActionOrigin_XBoxOne_RightStick_Click=133,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadNorth=134,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadSouth=135,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadWest=136,
    k_EInputActionOrigin_XBoxOne_RightStick_DPadEast=137,
    k_EInputActionOrigin_XBoxOne_DPad_North=138,
    k_EInputActionOrigin_XBoxOne_DPad_South=139,
    k_EInputActionOrigin_XBoxOne_DPad_West=140,
    k_EInputActionOrigin_XBoxOne_DPad_East=141,
    k_EInputActionOrigin_XBoxOne_Reserved0=142,
    k_EInputActionOrigin_XBoxOne_Reserved1=143,
    k_EInputActionOrigin_XBoxOne_Reserved2=144,
    k_EInputActionOrigin_XBoxOne_Reserved3=145,
    k_EInputActionOrigin_XBoxOne_Reserved4=146,
    k_EInputActionOrigin_XBoxOne_Reserved5=147,
    k_EInputActionOrigin_XBoxOne_Reserved6=148,
    k_EInputActionOrigin_XBoxOne_Reserved7=149,
    k_EInputActionOrigin_XBoxOne_Reserved8=150,
    k_EInputActionOrigin_XBoxOne_Reserved9=151,
    k_EInputActionOrigin_XBoxOne_Reserved10=152,
    k_EInputActionOrigin_XBox360_A=153,
    k_EInputActionOrigin_XBox360_B=154,
    k_EInputActionOrigin_XBox360_X=155,
    k_EInputActionOrigin_XBox360_Y=156,
    k_EInputActionOrigin_XBox360_LeftBumper=157,
    k_EInputActionOrigin_XBox360_RightBumper=158,
    k_EInputActionOrigin_XBox360_Start=159,
    k_EInputActionOrigin_XBox360_Back=160,
    k_EInputActionOrigin_XBox360_LeftTrigger_Pull=161,
    k_EInputActionOrigin_XBox360_LeftTrigger_Click=162,
    k_EInputActionOrigin_XBox360_RightTrigger_Pull=163,
    k_EInputActionOrigin_XBox360_RightTrigger_Click=164,
    k_EInputActionOrigin_XBox360_LeftStick_Move=165,
    k_EInputActionOrigin_XBox360_LeftStick_Click=166,
    k_EInputActionOrigin_XBox360_LeftStick_DPadNorth=167,
    k_EInputActionOrigin_XBox360_LeftStick_DPadSouth=168,
    k_EInputActionOrigin_XBox360_LeftStick_DPadWest=169,
    k_EInputActionOrigin_XBox360_LeftStick_DPadEast=170,
    k_EInputActionOrigin_XBox360_RightStick_Move=171,
    k_EInputActionOrigin_XBox360_RightStick_Click=172,
    k_EInputActionOrigin_XBox360_RightStick_DPadNorth=173,
    k_EInputActionOrigin_XBox360_RightStick_DPadSouth=174,
    k_EInputActionOrigin_XBox360_RightStick_DPadWest=175,
    k_EInputActionOrigin_XBox360_RightStick_DPadEast=176,
    k_EInputActionOrigin_XBox360_DPad_North=177,
    k_EInputActionOrigin_XBox360_DPad_South=178,
    k_EInputActionOrigin_XBox360_DPad_West=179,
    k_EInputActionOrigin_XBox360_DPad_East=180,
    k_EInputActionOrigin_XBox360_Reserved0=181,
    k_EInputActionOrigin_XBox360_Reserved1=182,
    k_EInputActionOrigin_XBox360_Reserved2=183,
    k_EInputActionOrigin_XBox360_Reserved3=184,
    k_EInputActionOrigin_XBox360_Reserved4=185,
    k_EInputActionOrigin_XBox360_Reserved5=186,
    k_EInputActionOrigin_XBox360_Reserved6=187,
    k_EInputActionOrigin_XBox360_Reserved7=188,
    k_EInputActionOrigin_XBox360_Reserved8=189,
    k_EInputActionOrigin_XBox360_Reserved9=190,
    k_EInputActionOrigin_XBox360_Reserved10=191,
    k_EInputActionOrigin_Switch_A=192,
    k_EInputActionOrigin_Switch_B=193,
    k_EInputActionOrigin_Switch_X=194,
    k_EInputActionOrigin_Switch_Y=195,
    k_EInputActionOrigin_Switch_LeftBumper=196,
    k_EInputActionOrigin_Switch_RightBumper=197,
    k_EInputActionOrigin_Switch_Plus=198,
    k_EInputActionOrigin_Switch_Minus=199,
    k_EInputActionOrigin_Switch_Capture=200,
    k_EInputActionOrigin_Switch_LeftTrigger_Pull=201,
    k_EInputActionOrigin_Switch_LeftTrigger_Click=202,
    k_EInputActionOrigin_Switch_RightTrigger_Pull=203,
    k_EInputActionOrigin_Switch_RightTrigger_Click=204,
    k_EInputActionOrigin_Switch_LeftStick_Move=205,
    k_EInputActionOrigin_Switch_LeftStick_Click=206,
    k_EInputActionOrigin_Switch_LeftStick_DPadNorth=207,
    k_EInputActionOrigin_Switch_LeftStick_DPadSouth=208,
    k_EInputActionOrigin_Switch_LeftStick_DPadWest=209,
    k_EInputActionOrigin_Switch_LeftStick_DPadEast=210,
    k_EInputActionOrigin_Switch_RightStick_Move=211,
    k_EInputActionOrigin_Switch_RightStick_Click=212,
    k_EInputActionOrigin_Switch_RightStick_DPadNorth=213,
    k_EInputActionOrigin_Switch_RightStick_DPadSouth=214,
    k_EInputActionOrigin_Switch_RightStick_DPadWest=215,
    k_EInputActionOrigin_Switch_RightStick_DPadEast=216,
    k_EInputActionOrigin_Switch_DPad_North=217,
    k_EInputActionOrigin_Switch_DPad_South=218,
    k_EInputActionOrigin_Switch_DPad_West=219,
    k_EInputActionOrigin_Switch_DPad_East=220,
    k_EInputActionOrigin_Switch_ProGyro_Move=221,
    k_EInputActionOrigin_Switch_ProGyro_Pitch=222,
    k_EInputActionOrigin_Switch_ProGyro_Yaw=223,
    k_EInputActionOrigin_Switch_ProGyro_Roll=224,
    k_EInputActionOrigin_Switch_Reserved0=225,
    k_EInputActionOrigin_Switch_Reserved1=226,
    k_EInputActionOrigin_Switch_Reserved2=227,
    k_EInputActionOrigin_Switch_Reserved3=228,
    k_EInputActionOrigin_Switch_Reserved4=229,
    k_EInputActionOrigin_Switch_Reserved5=230,
    k_EInputActionOrigin_Switch_Reserved6=231,
    k_EInputActionOrigin_Switch_Reserved7=232,
    k_EInputActionOrigin_Switch_Reserved8=233,
    k_EInputActionOrigin_Switch_Reserved9=234,
    k_EInputActionOrigin_Switch_Reserved10=235,
    k_EInputActionOrigin_Switch_RightGyro_Move=236,
    k_EInputActionOrigin_Switch_RightGyro_Pitch=237,
    k_EInputActionOrigin_Switch_RightGyro_Yaw=238,
    k_EInputActionOrigin_Switch_RightGyro_Roll=239,
    k_EInputActionOrigin_Switch_LeftGyro_Move=240,
    k_EInputActionOrigin_Switch_LeftGyro_Pitch=241,
    k_EInputActionOrigin_Switch_LeftGyro_Yaw=242,
    k_EInputActionOrigin_Switch_LeftGyro_Roll=243,
    k_EInputActionOrigin_Switch_LeftGrip_Lower=244,
    k_EInputActionOrigin_Switch_LeftGrip_Upper=245,
    k_EInputActionOrigin_Switch_RightGrip_Lower=246,
    k_EInputActionOrigin_Switch_RightGrip_Upper=247,
    k_EInputActionOrigin_Switch_Reserved11=248,
    k_EInputActionOrigin_Switch_Reserved12=249,
    k_EInputActionOrigin_Switch_Reserved13=250,
    k_EInputActionOrigin_Switch_Reserved14=251,
    k_EInputActionOrigin_Switch_Reserved15=252,
    k_EInputActionOrigin_Switch_Reserved16=253,
    k_EInputActionOrigin_Switch_Reserved17=254,
    k_EInputActionOrigin_Switch_Reserved18=255,
    k_EInputActionOrigin_Switch_Reserved19=256,
    k_EInputActionOrigin_Switch_Reserved20=257,
    k_EInputActionOrigin_Count=258,
    k_EInputActionOrigin_MaximumPossibleValue=32767
};

class ISteamInput
{
    public bool Init();
    public bool Shutdown();
    public void RunFrame();
    public int GetConnectedControllers(unsigned int * );
    public unsigned int GetActionSetHandle(char * );
    public void ActivateActionSet(unsigned int ,unsigned int );
    public unsigned int GetCurrentActionSet(unsigned int );
    public void ActivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateAllActionSetLayers(unsigned int );
    public int GetActiveActionSetLayers(unsigned int ,unsigned int * );
    public unsigned int GetDigitalActionHandle(char * );
    public struct InputDigitalActionData_t GetDigitalActionData(unsigned int ,unsigned int );
    public int GetDigitalActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EInputActionOrigin * );
    public unsigned int GetAnalogActionHandle(char * );
    public struct InputAnalogActionData_t GetAnalogActionData(unsigned int ,unsigned int );
    public int GetAnalogActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EInputActionOrigin * );
    public char * GetGlyphForActionOrigin(enum EInputActionOrigin );
    public char * GetStringForActionOrigin(enum EInputActionOrigin );
    public void StopAnalogActionMomentum(unsigned int ,unsigned int );
    public struct InputMotionData_t GetMotionData(unsigned int );
    public void TriggerVibration(unsigned int ,unsigned int ,unsigned int );
    public void SetLEDColor(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void TriggerHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int );
    public void TriggerRepeatedHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public bool ShowBindingPanel(unsigned int );
    public enum ESteamInputType GetInputTypeForHandle(unsigned int );
    public unsigned int GetControllerForGamepadIndex(int );
    public int GetGamepadIndexForController(unsigned int );
    public char * GetStringForXboxOrigin(enum EXboxOrigin );
    public char * GetGlyphForXboxOrigin(enum EXboxOrigin );
    public enum EInputActionOrigin GetActionOriginFromXboxOrigin(unsigned int ,enum EXboxOrigin );
    public enum EInputActionOrigin TranslateActionOrigin(enum ESteamInputType ,enum EInputActionOrigin );
    public void ISteamInput(class ISteamInput * );
    public void ISteamInput(class ISteamInput & );
    public void ISteamInput();
    public class ISteamInput & operator=(class ISteamInput * );
    public class ISteamInput & operator=(class ISteamInput & );
};

class ISteamInput
{
    public bool Init();
    public bool Shutdown();
    public void RunFrame();
    public int GetConnectedControllers(unsigned int * );
    public unsigned int GetActionSetHandle(char * );
    public void ActivateActionSet(unsigned int ,unsigned int );
    public unsigned int GetCurrentActionSet(unsigned int );
    public void ActivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateActionSetLayer(unsigned int ,unsigned int );
    public void DeactivateAllActionSetLayers(unsigned int );
    public int GetActiveActionSetLayers(unsigned int ,unsigned int * );
    public unsigned int GetDigitalActionHandle(char * );
    public struct InputDigitalActionData_t GetDigitalActionData(unsigned int ,unsigned int );
    public int GetDigitalActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EInputActionOrigin * );
    public unsigned int GetAnalogActionHandle(char * );
    public struct InputAnalogActionData_t GetAnalogActionData(unsigned int ,unsigned int );
    public int GetAnalogActionOrigins(unsigned int ,unsigned int ,unsigned int ,enum EInputActionOrigin * );
    public char * GetGlyphForActionOrigin(enum EInputActionOrigin );
    public char * GetStringForActionOrigin(enum EInputActionOrigin );
    public void StopAnalogActionMomentum(unsigned int ,unsigned int );
    public struct InputMotionData_t GetMotionData(unsigned int );
    public void TriggerVibration(unsigned int ,unsigned int ,unsigned int );
    public void SetLEDColor(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void TriggerHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int );
    public void TriggerRepeatedHapticPulse(unsigned int ,enum ESteamControllerPad ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public bool ShowBindingPanel(unsigned int );
    public enum ESteamInputType GetInputTypeForHandle(unsigned int );
    public unsigned int GetControllerForGamepadIndex(int );
    public int GetGamepadIndexForController(unsigned int );
    public char * GetStringForXboxOrigin(enum EXboxOrigin );
    public char * GetGlyphForXboxOrigin(enum EXboxOrigin );
    public enum EInputActionOrigin GetActionOriginFromXboxOrigin(unsigned int ,enum EXboxOrigin );
    public enum EInputActionOrigin TranslateActionOrigin(enum ESteamInputType ,enum EInputActionOrigin );
    public void ISteamInput(class ISteamInput * );
    public void ISteamInput(class ISteamInput & );
    public void ISteamInput();
    public class ISteamInput & operator=(class ISteamInput * );
    public class ISteamInput & operator=(class ISteamInput & );
};

class CSteamGameServerAPIContext
{
    public void CSteamGameServerAPIContext();
    public void Clear();
    public bool Init();
    public class ISteamClient * SteamClient();
    public class ISteamGameServer * SteamGameServer();
    public class ISteamUtils * SteamGameServerUtils();
    public class ISteamNetworking * SteamGameServerNetworking();
    public class ISteamGameServerStats * SteamGameServerStats();
    public class ISteamHTTP * SteamHTTP();
    public class ISteamInventory * SteamInventory();
    public class ISteamUGC * SteamUGC();
    public class ISteamApps * SteamApps();
    private class ISteamClient * m_pSteamClient;
    private class ISteamGameServer * m_pSteamGameServer;
    private class ISteamUtils * m_pSteamGameServerUtils;
    private class ISteamNetworking * m_pSteamGameServerNetworking;
    private class ISteamGameServerStats * m_pSteamGameServerStats;
    private class ISteamHTTP * m_pSteamHTTP;
    private class ISteamInventory * m_pSteamInventory;
    private class ISteamUGC * m_pSteamUGC;
    private class ISteamApps * m_pSteamApps;
};

class CSteamGameServerAPIContext
{
    public void CSteamGameServerAPIContext();
    public void Clear();
    public bool Init();
    public class ISteamClient * SteamClient();
    public class ISteamGameServer * SteamGameServer();
    public class ISteamUtils * SteamGameServerUtils();
    public class ISteamNetworking * SteamGameServerNetworking();
    public class ISteamGameServerStats * SteamGameServerStats();
    public class ISteamHTTP * SteamHTTP();
    public class ISteamInventory * SteamInventory();
    public class ISteamUGC * SteamUGC();
    public class ISteamApps * SteamApps();
    private class ISteamClient * m_pSteamClient;
    private class ISteamGameServer * m_pSteamGameServer;
    private class ISteamUtils * m_pSteamGameServerUtils;
    private class ISteamNetworking * m_pSteamGameServerNetworking;
    private class ISteamGameServerStats * m_pSteamGameServerStats;
    private class ISteamHTTP * m_pSteamHTTP;
    private class ISteamInventory * m_pSteamInventory;
    private class ISteamUGC * m_pSteamUGC;
    private class ISteamApps * m_pSteamApps;
};

enum ESteamPartyBeaconLocationData
{
    k_ESteamPartyBeaconLocationDataInvalid=0,
    k_ESteamPartyBeaconLocationDataName=1,
    k_ESteamPartyBeaconLocationDataIconURLSmall=2,
    k_ESteamPartyBeaconLocationDataIconURLMedium=3,
    k_ESteamPartyBeaconLocationDataIconURLLarge=4
};

class ISteamParties
{
    public unsigned int GetNumActiveBeacons();
    public unsigned int GetBeaconByIndex(unsigned int );
    public bool GetBeaconDetails(unsigned int ,class CSteamID * ,struct SteamPartyBeaconLocation_t * ,char * ,int );
    public unsigned int JoinParty(unsigned int );
    public bool GetNumAvailableBeaconLocations(unsigned int * );
    public bool GetAvailableBeaconLocations(struct SteamPartyBeaconLocation_t * ,unsigned int );
    public unsigned int CreateBeacon(unsigned int ,struct SteamPartyBeaconLocation_t * ,char * ,char * );
    public void OnReservationCompleted(unsigned int ,class CSteamID );
    public void CancelReservation(unsigned int ,class CSteamID );
    public unsigned int ChangeNumOpenSlots(unsigned int ,unsigned int );
    public bool DestroyBeacon(unsigned int );
    public bool GetBeaconLocationData(struct SteamPartyBeaconLocation_t ,enum ESteamPartyBeaconLocationData ,char * ,int );
    public void ISteamParties(class ISteamParties * );
    public void ISteamParties(class ISteamParties & );
    public void ISteamParties();
    public class ISteamParties & operator=(class ISteamParties * );
    public class ISteamParties & operator=(class ISteamParties & );
};

class ISteamParties
{
    public unsigned int GetNumActiveBeacons();
    public unsigned int GetBeaconByIndex(unsigned int );
    public bool GetBeaconDetails(unsigned int ,class CSteamID * ,struct SteamPartyBeaconLocation_t * ,char * ,int );
    public unsigned int JoinParty(unsigned int );
    public bool GetNumAvailableBeaconLocations(unsigned int * );
    public bool GetAvailableBeaconLocations(struct SteamPartyBeaconLocation_t * ,unsigned int );
    public unsigned int CreateBeacon(unsigned int ,struct SteamPartyBeaconLocation_t * ,char * ,char * );
    public void OnReservationCompleted(unsigned int ,class CSteamID );
    public void CancelReservation(unsigned int ,class CSteamID );
    public unsigned int ChangeNumOpenSlots(unsigned int ,unsigned int );
    public bool DestroyBeacon(unsigned int );
    public bool GetBeaconLocationData(struct SteamPartyBeaconLocation_t ,enum ESteamPartyBeaconLocationData ,char * ,int );
    public void ISteamParties(class ISteamParties * );
    public void ISteamParties(class ISteamParties & );
    public void ISteamParties();
    public class ISteamParties & operator=(class ISteamParties * );
    public class ISteamParties & operator=(class ISteamParties & );
};

struct FriendGameInfo_t
{
    class CGameID m_gameID;
    unsigned int m_unGameIP;
    unsigned int m_usGamePort;
    unsigned int m_usQueryPort;
    class CSteamID m_steamIDLobby;
    void FriendGameInfo_t();
};

struct MatchMakingKeyValuePair_t
{
    void MatchMakingKeyValuePair_t(char * ,char * );
    void MatchMakingKeyValuePair_t();
    char m_szKey[256];
    char m_szValue[256];
};

class servernetadr_t
{
    public void servernetadr_t();
    public void Init(unsigned int ,unsigned int ,unsigned int );
    public unsigned int GetQueryPort();
    public void SetQueryPort(unsigned int );
    public unsigned int GetConnectionPort();
    public void SetConnectionPort(unsigned int );
    public unsigned int GetIP();
    public void SetIP(unsigned int );
    public char * GetConnectionAddressString();
    public char * GetQueryAddressString();
    public bool operator<(class servernetadr_t & );
    public void operator=(class servernetadr_t & );
    private char * ToString(unsigned int ,unsigned int );
    private unsigned int m_usConnectionPort;
    private unsigned int m_usQueryPort;
    private unsigned int m_unIP;
};

class servernetadr_t
{
    public void servernetadr_t();
    public void Init(unsigned int ,unsigned int ,unsigned int );
    public unsigned int GetQueryPort();
    public void SetQueryPort(unsigned int );
    public unsigned int GetConnectionPort();
    public void SetConnectionPort(unsigned int );
    public unsigned int GetIP();
    public void SetIP(unsigned int );
    public char * GetConnectionAddressString();
    public char * GetQueryAddressString();
    public bool operator<(class servernetadr_t & );
    public void operator=(class servernetadr_t & );
    private char * ToString(unsigned int ,unsigned int );
    private unsigned int m_usConnectionPort;
    private unsigned int m_usQueryPort;
    private unsigned int m_unIP;
};

class gameserveritem_t
{
    public void gameserveritem_t();
    public char * GetName();
    public void SetName(char * );
    public class servernetadr_t m_NetAdr;
    public int m_nPing;
    public bool m_bHadSuccessfulResponse;
    public bool m_bDoNotRefresh;
    public char m_szGameDir[32];
    public char m_szMap[32];
    public char m_szGameDescription[64];
    public unsigned int m_nAppID;
    public int m_nPlayers;
    public int m_nMaxPlayers;
    public int m_nBotPlayers;
    public bool m_bPassword;
    public bool m_bSecure;
    public unsigned int m_ulTimeLastPlayed;
    public int m_nServerVersion;
    private char m_szServerName[64];
    public char m_szGameTags[128];
    public class CSteamID m_steamID;
    public class gameserveritem_t & operator=(class gameserveritem_t * );
    public class gameserveritem_t & operator=(class gameserveritem_t & );
};

class gameserveritem_t
{
    public void gameserveritem_t();
    public char * GetName();
    public void SetName(char * );
    public class servernetadr_t m_NetAdr;
    public int m_nPing;
    public bool m_bHadSuccessfulResponse;
    public bool m_bDoNotRefresh;
    public char m_szGameDir[32];
    public char m_szMap[32];
    public char m_szGameDescription[64];
    public unsigned int m_nAppID;
    public int m_nPlayers;
    public int m_nMaxPlayers;
    public int m_nBotPlayers;
    public bool m_bPassword;
    public bool m_bSecure;
    public unsigned int m_ulTimeLastPlayed;
    public int m_nServerVersion;
    private char m_szServerName[64];
    public char m_szGameTags[128];
    public class CSteamID m_steamID;
    public class gameserveritem_t & operator=(class gameserveritem_t * );
    public class gameserveritem_t & operator=(class gameserveritem_t & );
};

enum EMatchMakingServerResponse
{
    eServerResponded=0,
    eServerFailedToRespond=1,
    eNoServersListedOnMasterServer=2
};

class ISteamMatchmakingServerListResponse
{
    public void ServerResponded(void * ,int );
    public void ServerFailedToRespond(void * ,int );
    public void RefreshComplete(void * ,enum EMatchMakingServerResponse );
    public void ISteamMatchmakingServerListResponse(class ISteamMatchmakingServerListResponse * );
    public void ISteamMatchmakingServerListResponse(class ISteamMatchmakingServerListResponse & );
    public void ISteamMatchmakingServerListResponse();
    public class ISteamMatchmakingServerListResponse & operator=(class ISteamMatchmakingServerListResponse * );
    public class ISteamMatchmakingServerListResponse & operator=(class ISteamMatchmakingServerListResponse & );
};

class ISteamMatchmakingServerListResponse
{
    public void ServerResponded(void * ,int );
    public void ServerFailedToRespond(void * ,int );
    public void RefreshComplete(void * ,enum EMatchMakingServerResponse );
    public void ISteamMatchmakingServerListResponse(class ISteamMatchmakingServerListResponse * );
    public void ISteamMatchmakingServerListResponse(class ISteamMatchmakingServerListResponse & );
    public void ISteamMatchmakingServerListResponse();
    public class ISteamMatchmakingServerListResponse & operator=(class ISteamMatchmakingServerListResponse * );
    public class ISteamMatchmakingServerListResponse & operator=(class ISteamMatchmakingServerListResponse & );
};

class ISteamMatchmakingPingResponse
{
    public void ServerResponded(class gameserveritem_t & );
    public void ServerFailedToRespond();
    public void ISteamMatchmakingPingResponse(class ISteamMatchmakingPingResponse * );
    public void ISteamMatchmakingPingResponse(class ISteamMatchmakingPingResponse & );
    public void ISteamMatchmakingPingResponse();
    public class ISteamMatchmakingPingResponse & operator=(class ISteamMatchmakingPingResponse * );
    public class ISteamMatchmakingPingResponse & operator=(class ISteamMatchmakingPingResponse & );
};

class ISteamMatchmakingPingResponse
{
    public void ServerResponded(class gameserveritem_t & );
    public void ServerFailedToRespond();
    public void ISteamMatchmakingPingResponse(class ISteamMatchmakingPingResponse * );
    public void ISteamMatchmakingPingResponse(class ISteamMatchmakingPingResponse & );
    public void ISteamMatchmakingPingResponse();
    public class ISteamMatchmakingPingResponse & operator=(class ISteamMatchmakingPingResponse * );
    public class ISteamMatchmakingPingResponse & operator=(class ISteamMatchmakingPingResponse & );
};

class ISteamMatchmakingPlayersResponse
{
    public void AddPlayerToList(char * ,int ,float );
    public void PlayersFailedToRespond();
    public void PlayersRefreshComplete();
    public void ISteamMatchmakingPlayersResponse(class ISteamMatchmakingPlayersResponse * );
    public void ISteamMatchmakingPlayersResponse(class ISteamMatchmakingPlayersResponse & );
    public void ISteamMatchmakingPlayersResponse();
    public class ISteamMatchmakingPlayersResponse & operator=(class ISteamMatchmakingPlayersResponse * );
    public class ISteamMatchmakingPlayersResponse & operator=(class ISteamMatchmakingPlayersResponse & );
};

class ISteamMatchmakingPlayersResponse
{
    public void AddPlayerToList(char * ,int ,float );
    public void PlayersFailedToRespond();
    public void PlayersRefreshComplete();
    public void ISteamMatchmakingPlayersResponse(class ISteamMatchmakingPlayersResponse * );
    public void ISteamMatchmakingPlayersResponse(class ISteamMatchmakingPlayersResponse & );
    public void ISteamMatchmakingPlayersResponse();
    public class ISteamMatchmakingPlayersResponse & operator=(class ISteamMatchmakingPlayersResponse * );
    public class ISteamMatchmakingPlayersResponse & operator=(class ISteamMatchmakingPlayersResponse & );
};

class ISteamMatchmakingRulesResponse
{
    public void RulesResponded(char * ,char * );
    public void RulesFailedToRespond();
    public void RulesRefreshComplete();
    public void ISteamMatchmakingRulesResponse(class ISteamMatchmakingRulesResponse * );
    public void ISteamMatchmakingRulesResponse(class ISteamMatchmakingRulesResponse & );
    public void ISteamMatchmakingRulesResponse();
    public class ISteamMatchmakingRulesResponse & operator=(class ISteamMatchmakingRulesResponse * );
    public class ISteamMatchmakingRulesResponse & operator=(class ISteamMatchmakingRulesResponse & );
};

class ISteamMatchmakingRulesResponse
{
    public void RulesResponded(char * ,char * );
    public void RulesFailedToRespond();
    public void RulesRefreshComplete();
    public void ISteamMatchmakingRulesResponse(class ISteamMatchmakingRulesResponse * );
    public void ISteamMatchmakingRulesResponse(class ISteamMatchmakingRulesResponse & );
    public void ISteamMatchmakingRulesResponse();
    public class ISteamMatchmakingRulesResponse & operator=(class ISteamMatchmakingRulesResponse * );
    public class ISteamMatchmakingRulesResponse & operator=(class ISteamMatchmakingRulesResponse & );
};

enum ESteamPartyBeaconLocationType
{
    k_ESteamPartyBeaconLocationType_Invalid=0,
    k_ESteamPartyBeaconLocationType_ChatGroup=1,
    k_ESteamPartyBeaconLocationType_Max=2
};

struct SteamPartyBeaconLocation_t
{
    enum ESteamPartyBeaconLocationType m_eType;
    unsigned int m_ulLocationID;
};

struct SteamParamStringArray_t
{
    char ** m_ppStrings;
    int m_nNumStrings;
};

struct LeaderboardEntry_t
{
    class CSteamID m_steamIDUser;
    int m_nGlobalRank;
    int m_nScore;
    int m_cDetails;
    unsigned int m_hUGC;
    void LeaderboardEntry_t();
};

struct P2PSessionState_t
{
    unsigned int m_bConnectionActive;
    unsigned int m_bConnecting;
    unsigned int m_eP2PSessionError;
    unsigned int m_bUsingRelay;
    int m_nBytesQueuedForSend;
    int m_nPacketsQueuedForSend;
    unsigned int m_nRemoteIP;
    unsigned int m_nRemotePort;
};

struct InputDigitalActionData_t
{
    bool bState;
    bool bActive;
};

enum EInputSourceMode
{
    k_EInputSourceMode_None=0,
    k_EInputSourceMode_Dpad=1,
    k_EInputSourceMode_Buttons=2,
    k_EInputSourceMode_FourButtons=3,
    k_EInputSourceMode_AbsoluteMouse=4,
    k_EInputSourceMode_RelativeMouse=5,
    k_EInputSourceMode_JoystickMove=6,
    k_EInputSourceMode_JoystickMouse=7,
    k_EInputSourceMode_JoystickCamera=8,
    k_EInputSourceMode_ScrollWheel=9,
    k_EInputSourceMode_Trigger=10,
    k_EInputSourceMode_TouchMenu=11,
    k_EInputSourceMode_MouseJoystick=12,
    k_EInputSourceMode_MouseRegion=13,
    k_EInputSourceMode_RadialMenu=14,
    k_EInputSourceMode_SingleButton=15,
    k_EInputSourceMode_Switches=16
};

struct InputAnalogActionData_t
{
    enum EInputSourceMode eMode;
    float x;
    float y;
    bool bActive;
};

struct InputMotionData_t
{
    float rotQuatX;
    float rotQuatY;
    float rotQuatZ;
    float rotQuatW;
    float posAccelX;
    float posAccelY;
    float posAccelZ;
    float rotVelX;
    float rotVelY;
    float rotVelZ;
};

struct SteamUGCDetails_t
{
    unsigned int m_nPublishedFileId;
    enum EResult m_eResult;
    enum EWorkshopFileType m_eFileType;
    unsigned int m_nCreatorAppID;
    unsigned int m_nConsumerAppID;
    char m_rgchTitle[129];
    char m_rgchDescription[8000];
    unsigned int m_ulSteamIDOwner;
    unsigned int m_rtimeCreated;
    unsigned int m_rtimeUpdated;
    unsigned int m_rtimeAddedToUserList;
    enum ERemoteStoragePublishedFileVisibility m_eVisibility;
    bool m_bBanned;
    bool m_bAcceptedForUse;
    bool m_bTagsTruncated;
    char m_rgchTags[1025];
    unsigned int m_hFile;
    unsigned int m_hPreviewFile;
    char m_pchFileName[260];
    int m_nFileSize;
    int m_nPreviewFileSize;
    char m_rgchURL[256];
    unsigned int m_unVotesUp;
    unsigned int m_unVotesDown;
    float m_flScore;
    unsigned int m_unNumChildren;
};

struct SteamItemDetails_t
{
    unsigned int m_itemId;
    int m_iDefinition;
    unsigned int m_unQuantity;
    unsigned int m_unFlags;
};

struct GameOverlayActivated_t
{
    enum <unnamed-enum-k_iCallback>
    {
        k_iCallback=331
    };
    unsigned int m_bActive;
};

class SSteamManager
{
    public void SSteamManager(class SSteamManager & );
    public void SSteamManager();
    public void ~SSteamManager();
    public void Update();
    public char * GetPlayerName();
    public bool GetAchievement(enum SAchievementID ,bool * );
    public void SetAchievement(enum SAchievementID );
    public bool GetStat(enum SStatID ,int * );
    public void SetStat(enum SStatID ,int ,bool );
    public void StoreStats();
    public void ResetStatsAndAchievements();
    public bool Initialized;
    public void Initialize();
    public void Shutdown();
    private char * GetSteamAchievementId(enum SAchievementID );
    private char * GetSteamStatId(enum SStatID );
    struct CCallbackInternal_OnGameOverlayActivated : private CCallbackImpl<1>
    {
        void CCallbackInternal_OnGameOverlayActivated(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
        void CCallbackInternal_OnGameOverlayActivated();
        struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & operator=(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
        void Run(void * );
        void ~CCallbackInternal_OnGameOverlayActivated();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnGameOverlayActivated m_steamcallback_OnGameOverlayActivated;
    private void OnGameOverlayActivated(struct GameOverlayActivated_t * );
    struct CCallbackInternal_OnUserStatsReceived : private CCallbackImpl<24>
    {
        void CCallbackInternal_OnUserStatsReceived(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
        void CCallbackInternal_OnUserStatsReceived();
        struct SSteamManager::CCallbackInternal_OnUserStatsReceived & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
        void Run(void * );
        void ~CCallbackInternal_OnUserStatsReceived();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnUserStatsReceived m_steamcallback_OnUserStatsReceived;
    private void OnUserStatsReceived(struct UserStatsReceived_t * );
    struct CCallbackInternal_OnUserStatsStored : private CCallbackImpl<16>
    {
        void CCallbackInternal_OnUserStatsStored(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
        void CCallbackInternal_OnUserStatsStored();
        struct SSteamManager::CCallbackInternal_OnUserStatsStored & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
        void Run(void * );
        void ~CCallbackInternal_OnUserStatsStored();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnUserStatsStored m_steamcallback_OnUserStatsStored;
    private void OnUserStatsStored(struct UserStatsStored_t * );
    struct CCallbackInternal_OnAchievementStored : private CCallbackImpl<152>
    {
        void CCallbackInternal_OnAchievementStored(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
        void CCallbackInternal_OnAchievementStored();
        struct SSteamManager::CCallbackInternal_OnAchievementStored & operator=(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
        void Run(void * );
        void ~CCallbackInternal_OnAchievementStored();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnAchievementStored m_steamcallback_OnAchievementStored;
    private void OnAchievementStored(struct UserAchievementStored_t * );
    public class SSteamManager & operator=(class SSteamManager & );
    public void * __vecDelDtor(unsigned int );
};

class SSteamManager
{
    public void SSteamManager(class SSteamManager & );
    public void SSteamManager();
    public void ~SSteamManager();
    public void Update();
    public char * GetPlayerName();
    public bool GetAchievement(enum SAchievementID ,bool * );
    public void SetAchievement(enum SAchievementID );
    public bool GetStat(enum SStatID ,int * );
    public void SetStat(enum SStatID ,int ,bool );
    public void StoreStats();
    public void ResetStatsAndAchievements();
    public bool Initialized;
    public void Initialize();
    public void Shutdown();
    private char * GetSteamAchievementId(enum SAchievementID );
    private char * GetSteamStatId(enum SStatID );
    struct CCallbackInternal_OnGameOverlayActivated : private CCallbackImpl<1>
    {
        void CCallbackInternal_OnGameOverlayActivated(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
        void CCallbackInternal_OnGameOverlayActivated();
        struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & operator=(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
        void Run(void * );
        void ~CCallbackInternal_OnGameOverlayActivated();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnGameOverlayActivated m_steamcallback_OnGameOverlayActivated;
    private void OnGameOverlayActivated(struct GameOverlayActivated_t * );
    struct CCallbackInternal_OnUserStatsReceived : private CCallbackImpl<24>
    {
        void CCallbackInternal_OnUserStatsReceived(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
        void CCallbackInternal_OnUserStatsReceived();
        struct SSteamManager::CCallbackInternal_OnUserStatsReceived & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
        void Run(void * );
        void ~CCallbackInternal_OnUserStatsReceived();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnUserStatsReceived m_steamcallback_OnUserStatsReceived;
    private void OnUserStatsReceived(struct UserStatsReceived_t * );
    struct CCallbackInternal_OnUserStatsStored : private CCallbackImpl<16>
    {
        void CCallbackInternal_OnUserStatsStored(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
        void CCallbackInternal_OnUserStatsStored();
        struct SSteamManager::CCallbackInternal_OnUserStatsStored & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
        void Run(void * );
        void ~CCallbackInternal_OnUserStatsStored();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnUserStatsStored m_steamcallback_OnUserStatsStored;
    private void OnUserStatsStored(struct UserStatsStored_t * );
    struct CCallbackInternal_OnAchievementStored : private CCallbackImpl<152>
    {
        void CCallbackInternal_OnAchievementStored(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
        void CCallbackInternal_OnAchievementStored();
        struct SSteamManager::CCallbackInternal_OnAchievementStored & operator=(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
        void Run(void * );
        void ~CCallbackInternal_OnAchievementStored();
        void __local_vftable_ctor_closure();
        void * __vecDelDtor(unsigned int );
    };
    private struct SSteamManager::CCallbackInternal_OnAchievementStored m_steamcallback_OnAchievementStored;
    private void OnAchievementStored(struct UserAchievementStored_t * );
    public class SSteamManager & operator=(class SSteamManager & );
    public void * __vecDelDtor(unsigned int );
};

struct SSteamManager::CCallbackInternal_OnGameOverlayActivated : private CCallbackImpl<1>
{
    void CCallbackInternal_OnGameOverlayActivated(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
    void CCallbackInternal_OnGameOverlayActivated();
    struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & operator=(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
    void Run(void * );
    void ~CCallbackInternal_OnGameOverlayActivated();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct SSteamManager::CCallbackInternal_OnGameOverlayActivated : private CCallbackImpl<1>
{
    void CCallbackInternal_OnGameOverlayActivated(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
    void CCallbackInternal_OnGameOverlayActivated();
    struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & operator=(struct SSteamManager::CCallbackInternal_OnGameOverlayActivated & );
    void Run(void * );
    void ~CCallbackInternal_OnGameOverlayActivated();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

class CCallbackImpl<1> : protected CCallbackBase
{
    public void ~CCallbackImpl<1>();
    public void SetGameserverFlag();
    protected void Run(void * ,bool ,unsigned int );
    protected void Run(void * );
    protected int GetCallbackSizeBytes();
    public void CCallbackImpl<1>();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct SSteamManager::CCallbackInternal_OnUserStatsReceived : private CCallbackImpl<24>
{
    void CCallbackInternal_OnUserStatsReceived(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
    void CCallbackInternal_OnUserStatsReceived();
    struct SSteamManager::CCallbackInternal_OnUserStatsReceived & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
    void Run(void * );
    void ~CCallbackInternal_OnUserStatsReceived();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct SSteamManager::CCallbackInternal_OnUserStatsReceived : private CCallbackImpl<24>
{
    void CCallbackInternal_OnUserStatsReceived(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
    void CCallbackInternal_OnUserStatsReceived();
    struct SSteamManager::CCallbackInternal_OnUserStatsReceived & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsReceived & );
    void Run(void * );
    void ~CCallbackInternal_OnUserStatsReceived();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct UserStatsReceived_t
{
    enum <unnamed-enum-k_iCallback>
    {
        k_iCallback=1101
    };
    unsigned int m_nGameID;
    enum EResult m_eResult;
    class CSteamID m_steamIDUser;
    void UserStatsReceived_t();
};

struct SSteamManager::CCallbackInternal_OnUserStatsStored : private CCallbackImpl<16>
{
    void CCallbackInternal_OnUserStatsStored(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
    void CCallbackInternal_OnUserStatsStored();
    struct SSteamManager::CCallbackInternal_OnUserStatsStored & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
    void Run(void * );
    void ~CCallbackInternal_OnUserStatsStored();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct SSteamManager::CCallbackInternal_OnUserStatsStored : private CCallbackImpl<16>
{
    void CCallbackInternal_OnUserStatsStored(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
    void CCallbackInternal_OnUserStatsStored();
    struct SSteamManager::CCallbackInternal_OnUserStatsStored & operator=(struct SSteamManager::CCallbackInternal_OnUserStatsStored & );
    void Run(void * );
    void ~CCallbackInternal_OnUserStatsStored();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct UserStatsStored_t
{
    enum <unnamed-enum-k_iCallback>
    {
        k_iCallback=1102
    };
    unsigned int m_nGameID;
    enum EResult m_eResult;
};

struct SSteamManager::CCallbackInternal_OnAchievementStored : private CCallbackImpl<152>
{
    void CCallbackInternal_OnAchievementStored(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
    void CCallbackInternal_OnAchievementStored();
    struct SSteamManager::CCallbackInternal_OnAchievementStored & operator=(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
    void Run(void * );
    void ~CCallbackInternal_OnAchievementStored();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct SSteamManager::CCallbackInternal_OnAchievementStored : private CCallbackImpl<152>
{
    void CCallbackInternal_OnAchievementStored(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
    void CCallbackInternal_OnAchievementStored();
    struct SSteamManager::CCallbackInternal_OnAchievementStored & operator=(struct SSteamManager::CCallbackInternal_OnAchievementStored & );
    void Run(void * );
    void ~CCallbackInternal_OnAchievementStored();
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct UserAchievementStored_t
{
    enum <unnamed-enum-k_iCallback>
    {
        k_iCallback=1103
    };
    unsigned int m_nGameID;
    bool m_bGroupAchievement;
    char m_rgchAchievementName[128];
    unsigned int m_nCurProgress;
    unsigned int m_nMaxProgress;
};

class CCallbackImpl<24> : protected CCallbackBase
{
    public void ~CCallbackImpl<24>();
    public void SetGameserverFlag();
    protected void Run(void * ,bool ,unsigned int );
    protected void Run(void * );
    protected int GetCallbackSizeBytes();
    public void CCallbackImpl<24>();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class CCallbackImpl<16> : protected CCallbackBase
{
    public void ~CCallbackImpl<16>();
    public void SetGameserverFlag();
    protected void Run(void * ,bool ,unsigned int );
    protected void Run(void * );
    protected int GetCallbackSizeBytes();
    public void CCallbackImpl<16>();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class CCallbackImpl<152> : protected CCallbackBase
{
    public void ~CCallbackImpl<152>();
    public void SetGameserverFlag();
    protected void Run(void * ,bool ,unsigned int );
    protected void Run(void * );
    protected int GetCallbackSizeBytes();
    public void CCallbackImpl<152>();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct UPnPGateway::GatewayData
{
    char lanaddr[64];
    struct UPNPUrls urls;
    struct IGDdatas data;
    void GatewayData();
};

class WSAStartupSingleton
{
    public void WSAStartupSingleton();
    public void ~WSAStartupSingleton();
    public void AddRef();
    public void Deref();
    protected int refCount;
    public void * __vecDelDtor(unsigned int );
};

struct APP_MSG_RESEND_REQUEST : public MSG_GENERIC
{
    unsigned int playerSlot;
    int lastFrameCount;
};

struct STAGEMSG_SLOT : public MSG_GENERIC
{
    int slotNumber;
};

struct STAGEMSG_GAMESETTINGS : public MSG_GENERIC
{
    struct GAME_SETTINGS Settings;
};

struct STAGEMSG_CHAT : public MSG_GENERIC
{
    enum ChatMessageType chatMessageType;
    char strChatString[508];
};

struct STAGEMSG_MAPLOADINGDATA : public MSG_GENERIC
{
    int slot;
    int mapDownloadProgress;
};

struct STAGEMSG_STARTGAME : public MSG_GENERIC
{
    int initialLatency;
};

struct PEER_MSG_LAST_RECEIVED_FRAMES : public MSG_GENERIC
{
    int playerSlot;
    int lastReceivedFrame;
};

enum ClientToServerMessageType
{
    Login=0,
    UpdateUser=1,
    CreateMatch=2,
    UpdateMatch=3,
    RemoveMatch=4,
    SendChat=5
};

enum ServerToClientMessageType
{
    Accept=0,
    ProtocolVersionNotSupported=1,
    UpdateUsers=2,
    UpdateMatches=3,
    UpdateChat=4
};

struct DiscoveryMessage
{
    int gameVersion;
    char serverName[261];
};

struct <unnamed-type-sfb_table>
{
    int l[5];
    int s[3];
};

struct <unnamed-type-sfb_index>
{
    int l[23];
    int s[14];
};

struct <unnamed-type-huf_tabs>
{
    int maxval;
    int linbits;
    int ref;
    int tabstart;
    int tabend;
};

struct stbi_io_callbacks
{
    int  ( * read)(void * ,char * ,int );
    void  ( * skip)(void * ,int );
    int  ( * eof)(void * );
};

enum <unnamed-enum-STBI_ORDER_RGB>
{
    STBI_ORDER_RGB=0,
    STBI_ORDER_BGR=1
};

enum <unnamed-enum-STBI__SCAN_load>
{
    STBI__SCAN_load=0,
    STBI__SCAN_type=1,
    STBI__SCAN_header=2
};

enum <unnamed-enum-STBI__F_none>
{
    STBI__F_none=0,
    STBI__F_sub=1,
    STBI__F_up=2,
    STBI__F_avg=3,
    STBI__F_paeth=4,
    STBI__F_avg_first=5,
    STBI__F_paeth_first=6
};

enum <unnamed-enum-DXT_FULL_BLOCK>
{
    DXT_FULL_BLOCK=0,
    DXT_PREV_BLOCK=1,
    DXT_SINGLE_PREV_COLOR=2,
    DXT_PREV_COLOR=3,
    DXT_LAST_BLOCK=4,
    DXT_SINGLE_LAST_COLOR=5,
    DXT_LAST_COLOR=6,
    DXT_SINGLE_COLOR=7
};

struct _D3DXMACRO
{
    char * Name;
    char * Definition;
};

class SChain<SHillRing>
{
    private struct SHillRing * first;
    private struct SHillRing * last;
    private struct SHillRing * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SHillRing>();
    public void ~SChain<SHillRing>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SHillRing * StepToFirst();
    public struct SHillRing * StepToLast();
    public struct SHillRing * GetNext();
    public struct SHillRing * GetNext2();
    public struct SHillRing * GetPrev();
    public struct SHillRing * GetCurrent();
    public struct SHillRing * StepToNext();
    public struct SHillRing * StepToPrev();
    public struct SHillRing * Append(struct SHillRing * ,bool );
    public struct SHillRing * AppendNew(bool );
    public struct SHillRing * GetFirst();
    public struct SHillRing * GetSecond();
    public struct SHillRing * GetThird();
    public struct SHillRing * GetLastButOne();
    public struct SHillRing * GetLast();
    public struct SHillRing * InsertOver(struct SHillRing * ,bool );
    public struct SHillRing * InsertOverNew(bool );
    public struct SHillRing * InsertUnder(struct SHillRing * ,bool );
    public struct SHillRing * InsertUnderNew(bool );
    public void Delete(struct SHillRing * );
    public void Delete();
    public void DeleteAll();
    public struct SHillRing * GetPointer(int );
    public struct SHillRing * StepToIndex(int );
    public struct SHillRing & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SHillRing * );
    public void StepToPointer(struct SHillRing * );
    public void SendToBack(struct SHillRing * );
    public void BringToFront(struct SHillRing * );
    public void Swap(struct SHillRing * ,struct SHillRing * );
    public void * __vecDelDtor(unsigned int );
};

struct SWorldViewProjCB
{
    float WorldMatrix[4][4];
    float ViewMatrix[4][4];
    float ProjMatrix[4][4];
    const int Vector4fCount;
    void Set(struct D3DXMATRIX & ,struct D3DXMATRIX & ,struct D3DXMATRIX & );
    void SWorldViewProjCB();
};

struct SShadowTransformCB
{
    float ViewProjMatrix[4][4];
    const int Vector4fCount;
    void Set(struct D3DXMATRIX & ,struct D3DXMATRIX & );
    void Set(struct D3DXMATRIX & );
    void SShadowTransformCB();
};

struct SLightCB
{
    float Ambient[4];
    float BottomAmbient[4];
    float SunlightDir[4];
    float SunlightColor[4];
    float FogParams[4];
    const int Vector4fCount;
    void Set(struct _D3DCOLORVALUE & ,struct _D3DCOLORVALUE & ,struct D3DXVECTOR3 & ,struct _D3DCOLORVALUE & ,const float ,const float );
    void SLightCB();
};

enum GepardFlags
{
    Shaders=0,
    PhotoMode=1,
    NumFlags=2
};

enum SStandardShaderVariant
{
    Diffuse=0,
    DiffuseAndSelfIllumination=1,
    DiffuseAndReflection=2,
    DiffuseAndColorize=3,
    DiffuseAndTreeBending=4,
    DiffuseAndTreeWobble=5,
    DiffuseAndTreeBendingAndTreeWobble=6,
    COUNT=7
};

enum SDepthWriteShaderVariant
{
    Opaque=0,
    AlphaTest=1,
    TreeBending=2,
    TreeWobble=4,
    COUNT=8
};

enum STerrainShaderVariant
{
    Textured=0,
    Sketch=1,
    COUNT=2
};

struct _D3DPRESENT_PARAMETERS_
{
    unsigned int BackBufferWidth;
    unsigned int BackBufferHeight;
    enum _D3DFORMAT BackBufferFormat;
    unsigned int BackBufferCount;
    enum _D3DMULTISAMPLE_TYPE MultiSampleType;
    unsigned long MultiSampleQuality;
    enum _D3DSWAPEFFECT SwapEffect;
    struct HWND__ * hDeviceWindow;
    int Windowed;
    int EnableAutoDepthStencil;
    enum _D3DFORMAT AutoDepthStencilFormat;
    unsigned long Flags;
    unsigned int FullScreen_RefreshRateInHz;
    unsigned int PresentationInterval;
};

class SGepard : public SIGepard
{
    public bool BoardVisible;
    public void SetBoardVisibility(bool );
    public void SetResolution(int ,int );
    public void GetResolution(int & ,int & );
    public void SetSSAA(bool );
    public void SGepard(class SGepard & );
    public void SGepard();
    public void ~SGepard();
    public int Initialize(struct HWND__ * ,bool ,bool ,int ,int ,int ,bool );
    public void InitEditor();
    public void AddRef();
    public void Release();
    public int MemChk(void * );
    public void CreateScene();
    public void DestroyScene();
    public void SetViewProperties(float ,float ,float ,float ,float );
    public void SetPerspectiveProjection(float ,float ,float );
    public void SetOrthogonalProjection(float ,float ,float );
    public float GetFOV();
    public void GetViewBoundaries(struct D3DXVECTOR2 * );
    public void SetAmbientLight(float ,float ,float );
    public void SetBottomAmbientLight(float ,float ,float );
    public void SetSunLight(float ,float ,float ,float ,float );
    public void SetEnvironmentLight();
    public void SetFog(float ,float ,float ,float ,float );
    public void EnableFog();
    public void SelectionFog(unsigned long );
    public void SetMaterial(struct SMaterial & );
    public void CreateSpline(struct SHillRing * ,struct SSplineRing ** ,float ,int );
    public void AddNewSplineNode(struct SHillRing * ,float ,float ,float );
    public void LerpFolyo(struct SVertDiff * ,int ,struct SVert * ,int ,int ,float );
    public void SetTessFolyoAlpha(struct SVertDiff * ,int );
    public void DrawWater(struct SHillRing * ,int ,float ,class SStream * );
    public void JezusAtmentAVizenMiMiertNe();
    public void DeleteAllNodeInfos();
    public void CollectNode(struct SHillRing * ,struct SSplineRing * ,struct SNode * ,int ,float );
    public void SelectNode(struct SSplineRing * ,struct SNode * );
    public void SelectAllNode(struct SSplineRing * );
    public void DeselectAllNode(struct SSplineRing * );
    public void DeleteSelectedNodes(struct SHillRing * ,struct SSplineRing * );
    public void CloseSpline(struct SHillRing * );
    public void DoAltitude1(struct SHillRing * );
    public void DoAltitude2(struct SHillRing * );
    public void SetRiverSize(struct SHillRing * ,float );
    public float GetRiverSize(struct SHillRing * );
    public void GetNodePosition(struct SSplineRing * ,int ,float * ,float * ,float * );
    public void MoveSplineNode(struct SHillRing * ,struct SSplineRing * ,struct SNode * ,float ,float ,float );
    public void CreateHill(struct SHillRing ** );
    public void SetTopSplineAltitude(struct SHillRing * ,float );
    public void SetTopSplineAltitude2(struct SHillRing * ,float );
    public float GetTopSplineAltitude(struct SHillRing * );
    public float GetTopSplineAltitude2(struct SHillRing * );
    public void DestroySpline(struct SHillRing * ,struct SSplineRing * );
    public void DestroyHill(struct SHillRing * );
    public void RecalculateCentralNodes(struct SHillRing * );
    public void SetSplineAltitude2(float ,struct SSplineRing * );
    public float GetSplineAltitude2(struct SSplineRing * );
    public void DrawLine(float ,float ,float ,float ,float ,float );
    public void DrawNode(bool ,float ,float ,float ,struct _D3DCOLORVALUE );
    public void SelectSplineRing(struct SSplineRing * );
    public void SelectHillRing(struct SHillRing * );
    public int GetCheckBoxNr(struct SSplineRing * );
    public void SetSplineVisibility(struct SSplineRing * ,bool );
    public bool GetSplineVisibility(struct SSplineRing * );
    public void CleanupSplines();
    public void SaveSplines(class SStream * ,bool );
    public void SaveSplinesSel(class SStream * );
    public void LoadSplines(class SStream * );
    public void LoadSplinesSel(class SStream * );
    public void DestroySplines();
    public void GetSelections(struct SHillRing ** ,struct SSplineRing ** );
    public void RefreshSubNodes(struct SHillRing * );
    public void GetSelectedNode(float ,float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void GetSelectedNode2(float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void RedrawHill(struct SHillRing * );
    public void ReleaseMesh(struct SHillRing * );
    public void SetSplineDisplay(bool );
    public void RecalculateNodesAltitude();
    public void RecalculateControlPoints(struct SHillRing * );
    public void SetSplineSize(float ,struct SSplineRing * );
    public float GetSplineSize(struct SSplineRing * );
    public void DestroyFillBuffer();
    public struct SShaderInfo * CreateShader(float ,float ,int ,float ,int ,bool ,bool );
    public struct SShaderInfo * CreateShader(float ,float ,char * ,int ,bool ,bool );
    public struct SShader2Info * CreateShader2(float ,float ,int ,int ,enum SDrawType ,bool ,bool ,bool );
    public void MoveShader2(struct SShader2Info * ,float ,float ,bool );
    public void RelitShader2(struct SShader2Info * );
    public void DestroyShader2(struct SShader2Info * );
    public void RefreshShader(struct SShaderInfo * );
    public void UpdateShaders();
    public void SaveShaders(class SStream * );
    public void LoadShaders(class SStream * );
    public void CopyShaders(class SDArray<SShaderClipboard> & ,int ,int ,int ,int );
    public void PasteShaders(class SDArray<SShaderClipboard> & ,int ,int );
    public void DestroyShaders(bool );
    public struct SShaderInfo * GetIndexFromCoordinates(float ,float );
    public void SetSelectedShader(struct SShaderInfo * );
    public void DeleteSelectedShader();
    public bool IsShaderSelected();
    public void BringToFront();
    public void SendToBack();
    public void RotateShaderToLeft();
    public void RotateShaderToRight();
    public struct SShaderInfo * GetSelectedShader();
    public void RefreshHill(struct SHillRing * );
    public class SChain<SNodeInfo2> * CollectTileNodes(int ,int ,class SChain<SSplineRing> * );
    public void AddToShaderFolderList(char * );
    public void ClearShaderFolderList();
    public void AddNodesFromSplineNodes(class SChain<SNode> * ,class SChain<SNodeInfo2> * ,float ,float ,float ,float );
    public void ClearHoleList();
    public void AddToHoleList(int ,int );
    public void CreateTriangles(struct SHillRing * );
    public struct S3Vertex GetNext3Vertex(class SChain<SNodeInfo2> * ,bool );
    public int HegyOldal;
    public int HeightFrom;
    public class SChain<SShaderInfo> ShaderInfos;
    public class SChain<SShader2Info> Shader2Infos;
    public struct SShaderInfo * SelectedShader;
    public class SChain<SFolders> ShaderFolders;
    public class SProperties * DecalsIni;
    public class SChain<SHoleInfo> GlobalHoleList;
    public class SChain<SNodeInfo> NodeInfos;
    public struct SHillRing * gpSelHillRing;
    public struct SSplineRing * gpSelSplineRing;
    public class SChain<SHillRing> HillChain;
    public bool SplineDisplay;
    public unsigned long Editor_LastTime;
    public int XSize;
    public int ZSize;
    private unsigned long RefCount;
    private class SmartPtr<IDirect3DTexture9> ShadowMapTexture;
    private class SmartPtr<IDirect3DTexture9> ShadowMapDepthTexture;
    private int ShadowMapWidth;
    private float ShadowDistance;
    private bool CheckDepthStencilFormat(enum _D3DFORMAT );
    private void SetUpPresentation();
    private bool ResetDevice();
    private void SetMode(bool ,bool ,int ,int ,int );
    private void Resize(unsigned long ,unsigned long );
    private void InitRenderStates();
    private void RenderScene(bool );
    private void RenderScene2(bool );
    private void RenderDecals(bool );
    private void RenderShadowMap(bool );
    private void RenderShadowBoxToStencil();
    private void ClearShadowMap();
    private void RenderBoardOnly();
    private struct HBITMAP__ * RenderToWinBitmap(int ,int ,int );
    private unsigned int * RenderMinimap(int ,int );
    private void UpdateMinimap(int ,int ,int ,unsigned int * );
    private void MakeScreenshot(int ,int ,char * ,unsigned long );
    private void BackbufferScreenshot(char * );
    private void LogCardInfo();
    private int GetHillSideFaceCount(struct SHillRing * );
    private int GetHillSideVertexCount(struct SHillRing * );
    private void SortSplines(struct SHillRing * );
    private unsigned long Adapter;
    private struct _D3DADAPTER_IDENTIFIER9 AdapterID;
    private enum _D3DDEVTYPE DeviceType;
    private enum _D3DFORMAT AdapterFormat;
    private struct IDirect3D9 * lpD3D;
    private struct _D3DDISPLAYMODE d3ddm;
    private struct D3DXMATRIX CameraMatrix;
    private struct D3DXMATRIX ProjectionMatrix;
    private struct D3DXMATRIX ShadowMatrix;
    private struct D3DXMATRIX InverseShadowCameraMatrix;
    public struct IDirect3DDevice9 * lpD3DDev;
    public unsigned long DefAmbient;
    public float CameraHRot;
    public float CameraVRot;
    public float CameraXPos;
    public float CameraYPos;
    public float CameraZPos;
    public void * Glow;
    private char * ScreenshotFile;
    private struct HWND__ * hWnd;
    private bool FullScreen;
    private bool VSync;
    private enum _D3DMULTISAMPLE_TYPE MSAALevel;
    private struct _D3DPRESENT_PARAMETERS_ PresentationParameters;
    private int ModeWidth;
    private int ModeHeight;
    private float OrthoScale;
    private float FOV;
    private float NearPlane;
    private float FarPlane;
    private int ViewWidth;
    private int ViewHeight;
    private int ViewWidthScaled;
    private int ViewHeightScaled;
    public int getViewWidth();
    public int getViewHeight();
    public struct _D3DPRESENT_PARAMETERS_ & GetPresentationParameters();
    private class SBoard * Board;
    public int PolyCount;
    public struct _D3DCOLORVALUE AmbientColorVal;
    public struct _D3DCOLORVALUE BottomAmbientColorVal;
    public struct _D3DCOLORVALUE SunColorVal;
    public struct _D3DCOLORVALUE EnvironmentColorVal;
    public struct D3DXVECTOR3 SunDir;
    public struct _D3DCOLORVALUE FogColorVal;
    public struct D3DXMATRIX SunProjection;
    public float LastSunDirection;
    public float LastSunElevation;
    public unsigned long FogColor;
    public float FogStart;
    public float FogEnd;
    public float FogStart2;
    public float FogEnd2;
    public float FogMultiplier;
    public float FogMultiplier256;
    private class SGroup * node1;
    private class SGroup * node2;
    private int FPSTextFrame;
    private int DebugTextFrame;
    private int FPSFont;
    public void EnableFPS(bool ,int ,int );
    public bool GetFPSEnabled();
    public int GetDebugTextFrame();
    public int FrameCount;
    public unsigned long RenderCounter;
    public unsigned long WorldTime;
    public unsigned long LastWorldTime;
    public unsigned long ElapsedTime;
    public unsigned long AnimTime;
    public unsigned long AnimElapsedTime;
    public float Interpolation;
    public void AdvanceTime(unsigned long ,unsigned long );
    public void SetInterpolation(float );
    public unsigned long GetAnimElapsedTime();
    public void TransformScaledPointAdd(float ,float ,float ,float ,float & ,float & ,float & ,float & ,unsigned long & );
    public void TransformScaledPointBlend(float ,float ,float ,float ,float & ,float & ,float & ,float & ,float & ,unsigned long & );
    public void TransformScaledPointUi(float ,float ,float ,float ,float & ,float & ,float & );
    public void TransformGroundPoint(float ,float ,float & ,float & ,float & ,float & ,unsigned long & ,float ,float );
    public void TransformPoint(float ,float ,float ,float * ,float * );
    public void TransformPoint(float ,float ,float ,float * ,float * ,float * );
    public void TransformScreenToCamera(float & ,float & );
    public float GetClickDistanceSquare(struct D3DXVECTOR3 & ,float ,float );
    public bool CheckClickBox(struct D3DXVECTOR3 & ,float ,float ,float ,float );
    private struct SLightProp LightProps[4];
    private void RefreshLights();
    private unsigned int GetLightHandle();
    private struct SShadowTransformCB shadowCB;
    private struct SLightCB lightCB;
    public int CreateDirectionalLight(float ,float ,float ,float ,float ,float );
    public int CreatePointLight(float ,float ,float ,float ,float ,float ,float ,float );
    public void SetLightPosition(int ,float ,float ,float );
    public void DestroyLight(int );
    public void SetLightingType(enum SLightingType );
    public void SetAmbientColor(unsigned long );
    public void SetAmbientGray(int );
    public void SetShadowCB();
    public void SetLightCB();
    private class SHeap<SObjectCacheProp> ObjectCache;
    private class SHeap<SObjectProp> StaticObjects;
    private class SHeap<SObjectProp> DynamicObjects;
    private bool ObjectsHashed;
    private int * ObjectHash;
    private class SDArray<SObjectHashChain> ObjectHashChain;
    private void HashObjects();
    private void RenderObjects(bool ,bool );
    private void RenderObjectShadows(bool );
    private void RenderObjectShadowDecals();
    private void GenerateObjectShadow(class SGroup & ,bool );
    private void RegenerateObjectShadowDecals();
    private void ClearObjectShadows(bool ,bool );
    private int ShadowQuality;
    private int MaxShadowQuality;
    private struct IDirect3DSurface9 * ShadowRenderTarget;
    private struct IDirect3DSurface9 * ShadowRenderTargetZ;
    public int PrecacheObject(char * ,float ,enum SDrawType );
    public int CleanupObjectCache();
    public class SIObject * CreateObject(char * ,float ,bool );
    public class SIObject * CreateObject(int ,bool );
    public void ReplaceObject(class SIObject * ,char * ,float );
    public void ReplaceObject(class SIObject * ,int );
    public void RemoveDynamicObject(int );
    public void RemoveHashedObject(int );
    public int GetShadowQuality();
    public void SetShadowQuality(int );
    public int GetMaxShadowQuality();
    public float GetShadowDistance();
    public void SetShadowDistance(float );
    public void TriggerRehash();
    public void MakeObjectShadowMask(class SGroup & );
    public void ProjectPoint(float ,float ,float ,float ,float ,float & ,float & );
    public void MakeObjectShadowShader(class SGroup & );
    public void SkipObjectShadowMask(class SIObject * ,class SStream * );
    public void GenerateAllShadowShaders();
    private int SunLight;
    public class STerrain * Terrain;
    public class SIPlane * CreatePlane(int ,int );
    public void DestroyPlane();
    private void * ShaderChangeNotification;
    private bool Flags[2];
    private int DebugMode;
    private struct D3DXMATRIX IdentityMatrix;
    private void InitVertexShader(char * ,class SmartPtr<IDirect3DVertexShader9> & ,struct _D3DXMACRO * );
    private void InitPixelShader(char * ,class SmartPtr<IDirect3DPixelShader9> & ,struct _D3DXMACRO * );
    private void InitShaders();
    private void ClearShaders();
    private void SetWorldViewProjVertexShaderConstantBuffer(struct D3DXMATRIX & );
    public bool GetFlag(enum GepardFlags );
    public void SetFlag(enum GepardFlags ,bool );
    public int GetDebugMode();
    public void SetDebugMode(int );
    struct DebugLine
    {
        class SVector start;
        class SVector end;
        unsigned long color;
        int owner;
        void DebugLine();
    };
    private class Array<SGepard::DebugLine> debugLines;
    private void RenderDebugLines();
    public void AddDebugLine(class SVector ,class SVector ,unsigned long ,int );
    public void ClearDebugLines(unsigned long ,int );
    public class SmartPtr<IDirect3DVertexShader9> standardVertexShaders[7];
    public class SmartPtr<IDirect3DPixelShader9> standardPixelShaders[7];
    public class SmartPtr<IDirect3DVertexShader9> depthWriteVertexShaders[8];
    public class SmartPtr<IDirect3DPixelShader9> depthWritePixelShaders[8];
    public class SmartPtr<IDirect3DVertexShader9> terrainVertexShader[2];
    public class SmartPtr<IDirect3DPixelShader9> terrainPixelShader[2];
    public class SmartPtr<IDirect3DVertexShader9> terrainLightingVertexShader;
    public class SmartPtr<IDirect3DVertexShader9> ambientLitVertexShader;
    public class SmartPtr<IDirect3DVertexShader9> decalVertexShader;
    public class SmartPtr<IDirect3DVertexShader9> unlitDecalVertexShader;
    public class SmartPtr<IDirect3DPixelShader9> sepiaPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> terrainLightingPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> ambientLitPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> decalPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> unlitDecalPixelShader;
    private class SHeap<STextureProp> Textures;
    private int TextureFilter;
    private int TextureDetail;
    private enum _D3DFORMAT TFOpaque;
    private enum _D3DFORMAT TF1Bit;
    private enum _D3DFORMAT TFAlpha;
    private enum _D3DFORMAT TFHiOpaque;
    private enum _D3DFORMAT TFHiAlpha;
    private enum _D3DFORMAT TFShadow;
    private enum _D3DFORMAT TFShadowNull;
    private enum _D3DFORMAT TFShadowDepth;
    private bool TFSupportNonPow2;
    private enum SDrawType DrawType;
    private bool CheckTextureFormat(enum _D3DFORMAT ,bool );
    private void InitTextureFormats();
    private int CreateTextureFromDXT(char * ,char * ,bool );
    private void LoadDXTToLevelBitmaps(char * ,class SDArray<SBitmap *> & );
    private int CreateTextureFromLevelBitmaps(class SDArray<SBitmap *> & ,char * );
    private void ReloadTexture(int );
    public void RoundToTextureSize(int ,int ,int & ,int & );
    public void SetTextureCacheDirectory(char * );
    public int LoadTexture(char * ,bool ,bool );
    public int CreateEmptyTexture(int ,int ,int ,bool ,bool );
    public int CreateShadowTexture(int ,int );
    public int AddRefTexture(int );
    public void ReleaseTexture(int ,bool );
    public void CleanupTextureCache();
    public void SetDrawType(enum SDrawType );
    public int GetTextureAlpha(int );
    public void SetTexture(int ,int ,bool );
    public void SetShadowMapTexture(int );
    public void ResetShadowMapTexture(int );
    public void SetTextureFilter(int );
    public int GetTextureFilter();
    public void SetTextureDetail(int );
    public int GetTextureDetail();
    public int CreateTextureFromBitmap(char * ,class SBitmap & ,bool );
    public void UpdateTextureFromBitmap(int ,class SBitmap & );
    public void ChangeTextureAlphaType(int ,int );
    public bool IsTextureOpaque(int );
    private class SHeap<SDynamicShaderProp> DynamicShaders;
    private void RenderDynamicShaders();
    public int CreateDynamicShader(int ,float ,float ,float ,unsigned long );
    public void RemoveDynamicShader(int );
    public void SetDynamicShaderPosition(int ,float ,float );
    private class SHeap<SRectProp> Rects;
    private void RenderRects();
    private void RefreshRect(class SMesh * ,int ,int ,int ,int );
    public int CreateRect(unsigned long ,int ,int ,int ,int );
    public void RemoveRect(int );
    public void SetRectColor(int ,unsigned long );
    public void SetRectPosition(int ,int ,int ,int ,int );
    public void UpdateRects();
    private class SHeap<SSmokeTrail> SmokeTrails;
    private void RenderSmokeTrails();
    public int CreateSmokeTrail(int ,float ,float ,float ,int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackSmokeTrail(int ,float ,float ,float ,float );
    public void CloseSmokeTrail(int );
    public void RemoveSmokeTrail(int );
    private class SHeap<SGroundTrail> GroundTrails;
    private void RenderGroundTrails();
    public int CreateGroundTrail(int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackGroundTrail(int ,float ,float ,float );
    public void CloseGroundTrail(int );
    public void RemoveGroundTrail(int );
    private class SHeap<SGLake> Lakes;
    private void RenderLakes();
    public int CreateLake(int ,float ,float ,float ,int ,int );
    public void RemoveLake(int );
    public void ChangeLakeHeight(int ,float );
    public void DrawLakesToWaterMap();
    private class SHeap<SDynamicVB> DynamicVBs;
    private void ClearDynamicVBs();
    private void RestoreDynamicVBs();
    public int CreateDynamicVB(int ,unsigned long );
    public void RemoveDynamicVB(int );
    public unsigned int * LockDynamicVB(int ,unsigned long );
    public void UnlockDynamicVB(int );
    public void DrawDynamicVB(int ,unsigned long );
    public void SetTileset(int );
    public void ClearGlow();
    public void AddGlow(float ,float ,float ,int ,int ,int ,int ,float );
    public void TurnOnGlow();
    public void TurnOffGlow();
    public void EgysegAlattiTalajKoszolas(float ,float ,int );
    public int LoadEffect(char * ,char * );
    public void CreateEffectsHandler();
    public void DestroyEffectsHandler();
    public class SEffect * Effect;
    public void PlayEffect(int ,class SIObject * ,class SDArray<SAblak> * );
    public void PlayEffect(int ,class SIObject * ,char * ,int );
    public void * PlayEffect(int ,float ,float ,float ,float );
    public void PlayEffect(int ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void TrackEffect(void * ,float ,float ,float ,float );
    public void StopEffect(void * );
    public void RefreshIndices(void * );
    public bool FullBright;
    public int Tileset;
    public void SetFullBright(bool );
    public float GetCameraHRot();
    public class SVector GetCameraForward();
    public void WaterLine(float ,float ,float ,float ,float );
    public bool FirstDrawWater;
    public void SetUpObjectEffects();
    public int GetTileset();
    public int Temp;
    public float ResolutionScale;
    public class SmartPtr<IDirect3DSurface9> ResolutionScaleSurface;
    public class SmartPtr<IDirect3DSurface9> ResolutionScaleDepthSurface;
    public void SetResolutionScale(float );
    public void InitResolutionScale();
    public void ClearResolutionScale();
    public void * __vecDelDtor(unsigned int );
};

enum SLightingType
{
    LT_NORMAL=0,
    LT_AMBIENT=1,
    LT_PRELIT=2
};

class SGepard : public SIGepard
{
    public bool BoardVisible;
    public void SetBoardVisibility(bool );
    public void SetResolution(int ,int );
    public void GetResolution(int & ,int & );
    public void SetSSAA(bool );
    public void SGepard(class SGepard & );
    public void SGepard();
    public void ~SGepard();
    public int Initialize(struct HWND__ * ,bool ,bool ,int ,int ,int ,bool );
    public void InitEditor();
    public void AddRef();
    public void Release();
    public int MemChk(void * );
    public void CreateScene();
    public void DestroyScene();
    public void SetViewProperties(float ,float ,float ,float ,float );
    public void SetPerspectiveProjection(float ,float ,float );
    public void SetOrthogonalProjection(float ,float ,float );
    public float GetFOV();
    public void GetViewBoundaries(struct D3DXVECTOR2 * );
    public void SetAmbientLight(float ,float ,float );
    public void SetBottomAmbientLight(float ,float ,float );
    public void SetSunLight(float ,float ,float ,float ,float );
    public void SetEnvironmentLight();
    public void SetFog(float ,float ,float ,float ,float );
    public void EnableFog();
    public void SelectionFog(unsigned long );
    public void SetMaterial(struct SMaterial & );
    public void CreateSpline(struct SHillRing * ,struct SSplineRing ** ,float ,int );
    public void AddNewSplineNode(struct SHillRing * ,float ,float ,float );
    public void LerpFolyo(struct SVertDiff * ,int ,struct SVert * ,int ,int ,float );
    public void SetTessFolyoAlpha(struct SVertDiff * ,int );
    public void DrawWater(struct SHillRing * ,int ,float ,class SStream * );
    public void JezusAtmentAVizenMiMiertNe();
    public void DeleteAllNodeInfos();
    public void CollectNode(struct SHillRing * ,struct SSplineRing * ,struct SNode * ,int ,float );
    public void SelectNode(struct SSplineRing * ,struct SNode * );
    public void SelectAllNode(struct SSplineRing * );
    public void DeselectAllNode(struct SSplineRing * );
    public void DeleteSelectedNodes(struct SHillRing * ,struct SSplineRing * );
    public void CloseSpline(struct SHillRing * );
    public void DoAltitude1(struct SHillRing * );
    public void DoAltitude2(struct SHillRing * );
    public void SetRiverSize(struct SHillRing * ,float );
    public float GetRiverSize(struct SHillRing * );
    public void GetNodePosition(struct SSplineRing * ,int ,float * ,float * ,float * );
    public void MoveSplineNode(struct SHillRing * ,struct SSplineRing * ,struct SNode * ,float ,float ,float );
    public void CreateHill(struct SHillRing ** );
    public void SetTopSplineAltitude(struct SHillRing * ,float );
    public void SetTopSplineAltitude2(struct SHillRing * ,float );
    public float GetTopSplineAltitude(struct SHillRing * );
    public float GetTopSplineAltitude2(struct SHillRing * );
    public void DestroySpline(struct SHillRing * ,struct SSplineRing * );
    public void DestroyHill(struct SHillRing * );
    public void RecalculateCentralNodes(struct SHillRing * );
    public void SetSplineAltitude2(float ,struct SSplineRing * );
    public float GetSplineAltitude2(struct SSplineRing * );
    public void DrawLine(float ,float ,float ,float ,float ,float );
    public void DrawNode(bool ,float ,float ,float ,struct _D3DCOLORVALUE );
    public void SelectSplineRing(struct SSplineRing * );
    public void SelectHillRing(struct SHillRing * );
    public int GetCheckBoxNr(struct SSplineRing * );
    public void SetSplineVisibility(struct SSplineRing * ,bool );
    public bool GetSplineVisibility(struct SSplineRing * );
    public void CleanupSplines();
    public void SaveSplines(class SStream * ,bool );
    public void SaveSplinesSel(class SStream * );
    public void LoadSplines(class SStream * );
    public void LoadSplinesSel(class SStream * );
    public void DestroySplines();
    public void GetSelections(struct SHillRing ** ,struct SSplineRing ** );
    public void RefreshSubNodes(struct SHillRing * );
    public void GetSelectedNode(float ,float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void GetSelectedNode2(float ,float ,struct SHillRing ** ,struct SSplineRing ** ,struct SNode ** ,bool );
    public void RedrawHill(struct SHillRing * );
    public void ReleaseMesh(struct SHillRing * );
    public void SetSplineDisplay(bool );
    public void RecalculateNodesAltitude();
    public void RecalculateControlPoints(struct SHillRing * );
    public void SetSplineSize(float ,struct SSplineRing * );
    public float GetSplineSize(struct SSplineRing * );
    public void DestroyFillBuffer();
    public struct SShaderInfo * CreateShader(float ,float ,int ,float ,int ,bool ,bool );
    public struct SShaderInfo * CreateShader(float ,float ,char * ,int ,bool ,bool );
    public struct SShader2Info * CreateShader2(float ,float ,int ,int ,enum SDrawType ,bool ,bool ,bool );
    public void MoveShader2(struct SShader2Info * ,float ,float ,bool );
    public void RelitShader2(struct SShader2Info * );
    public void DestroyShader2(struct SShader2Info * );
    public void RefreshShader(struct SShaderInfo * );
    public void UpdateShaders();
    public void SaveShaders(class SStream * );
    public void LoadShaders(class SStream * );
    public void CopyShaders(class SDArray<SShaderClipboard> & ,int ,int ,int ,int );
    public void PasteShaders(class SDArray<SShaderClipboard> & ,int ,int );
    public void DestroyShaders(bool );
    public struct SShaderInfo * GetIndexFromCoordinates(float ,float );
    public void SetSelectedShader(struct SShaderInfo * );
    public void DeleteSelectedShader();
    public bool IsShaderSelected();
    public void BringToFront();
    public void SendToBack();
    public void RotateShaderToLeft();
    public void RotateShaderToRight();
    public struct SShaderInfo * GetSelectedShader();
    public void RefreshHill(struct SHillRing * );
    public class SChain<SNodeInfo2> * CollectTileNodes(int ,int ,class SChain<SSplineRing> * );
    public void AddToShaderFolderList(char * );
    public void ClearShaderFolderList();
    public void AddNodesFromSplineNodes(class SChain<SNode> * ,class SChain<SNodeInfo2> * ,float ,float ,float ,float );
    public void ClearHoleList();
    public void AddToHoleList(int ,int );
    public void CreateTriangles(struct SHillRing * );
    public struct S3Vertex GetNext3Vertex(class SChain<SNodeInfo2> * ,bool );
    public int HegyOldal;
    public int HeightFrom;
    public class SChain<SShaderInfo> ShaderInfos;
    public class SChain<SShader2Info> Shader2Infos;
    public struct SShaderInfo * SelectedShader;
    public class SChain<SFolders> ShaderFolders;
    public class SProperties * DecalsIni;
    public class SChain<SHoleInfo> GlobalHoleList;
    public class SChain<SNodeInfo> NodeInfos;
    public struct SHillRing * gpSelHillRing;
    public struct SSplineRing * gpSelSplineRing;
    public class SChain<SHillRing> HillChain;
    public bool SplineDisplay;
    public unsigned long Editor_LastTime;
    public int XSize;
    public int ZSize;
    private unsigned long RefCount;
    private class SmartPtr<IDirect3DTexture9> ShadowMapTexture;
    private class SmartPtr<IDirect3DTexture9> ShadowMapDepthTexture;
    private int ShadowMapWidth;
    private float ShadowDistance;
    private bool CheckDepthStencilFormat(enum _D3DFORMAT );
    private void SetUpPresentation();
    private bool ResetDevice();
    private void SetMode(bool ,bool ,int ,int ,int );
    private void Resize(unsigned long ,unsigned long );
    private void InitRenderStates();
    private void RenderScene(bool );
    private void RenderScene2(bool );
    private void RenderDecals(bool );
    private void RenderShadowMap(bool );
    private void RenderShadowBoxToStencil();
    private void ClearShadowMap();
    private void RenderBoardOnly();
    private struct HBITMAP__ * RenderToWinBitmap(int ,int ,int );
    private unsigned int * RenderMinimap(int ,int );
    private void UpdateMinimap(int ,int ,int ,unsigned int * );
    private void MakeScreenshot(int ,int ,char * ,unsigned long );
    private void BackbufferScreenshot(char * );
    private void LogCardInfo();
    private int GetHillSideFaceCount(struct SHillRing * );
    private int GetHillSideVertexCount(struct SHillRing * );
    private void SortSplines(struct SHillRing * );
    private unsigned long Adapter;
    private struct _D3DADAPTER_IDENTIFIER9 AdapterID;
    private enum _D3DDEVTYPE DeviceType;
    private enum _D3DFORMAT AdapterFormat;
    private struct IDirect3D9 * lpD3D;
    private struct _D3DDISPLAYMODE d3ddm;
    private struct D3DXMATRIX CameraMatrix;
    private struct D3DXMATRIX ProjectionMatrix;
    private struct D3DXMATRIX ShadowMatrix;
    private struct D3DXMATRIX InverseShadowCameraMatrix;
    public struct IDirect3DDevice9 * lpD3DDev;
    public unsigned long DefAmbient;
    public float CameraHRot;
    public float CameraVRot;
    public float CameraXPos;
    public float CameraYPos;
    public float CameraZPos;
    public void * Glow;
    private char * ScreenshotFile;
    private struct HWND__ * hWnd;
    private bool FullScreen;
    private bool VSync;
    private enum _D3DMULTISAMPLE_TYPE MSAALevel;
    private struct _D3DPRESENT_PARAMETERS_ PresentationParameters;
    private int ModeWidth;
    private int ModeHeight;
    private float OrthoScale;
    private float FOV;
    private float NearPlane;
    private float FarPlane;
    private int ViewWidth;
    private int ViewHeight;
    private int ViewWidthScaled;
    private int ViewHeightScaled;
    public int getViewWidth();
    public int getViewHeight();
    public struct _D3DPRESENT_PARAMETERS_ & GetPresentationParameters();
    private class SBoard * Board;
    public int PolyCount;
    public struct _D3DCOLORVALUE AmbientColorVal;
    public struct _D3DCOLORVALUE BottomAmbientColorVal;
    public struct _D3DCOLORVALUE SunColorVal;
    public struct _D3DCOLORVALUE EnvironmentColorVal;
    public struct D3DXVECTOR3 SunDir;
    public struct _D3DCOLORVALUE FogColorVal;
    public struct D3DXMATRIX SunProjection;
    public float LastSunDirection;
    public float LastSunElevation;
    public unsigned long FogColor;
    public float FogStart;
    public float FogEnd;
    public float FogStart2;
    public float FogEnd2;
    public float FogMultiplier;
    public float FogMultiplier256;
    private class SGroup * node1;
    private class SGroup * node2;
    private int FPSTextFrame;
    private int DebugTextFrame;
    private int FPSFont;
    public void EnableFPS(bool ,int ,int );
    public bool GetFPSEnabled();
    public int GetDebugTextFrame();
    public int FrameCount;
    public unsigned long RenderCounter;
    public unsigned long WorldTime;
    public unsigned long LastWorldTime;
    public unsigned long ElapsedTime;
    public unsigned long AnimTime;
    public unsigned long AnimElapsedTime;
    public float Interpolation;
    public void AdvanceTime(unsigned long ,unsigned long );
    public void SetInterpolation(float );
    public unsigned long GetAnimElapsedTime();
    public void TransformScaledPointAdd(float ,float ,float ,float ,float & ,float & ,float & ,float & ,unsigned long & );
    public void TransformScaledPointBlend(float ,float ,float ,float ,float & ,float & ,float & ,float & ,float & ,unsigned long & );
    public void TransformScaledPointUi(float ,float ,float ,float ,float & ,float & ,float & );
    public void TransformGroundPoint(float ,float ,float & ,float & ,float & ,float & ,unsigned long & ,float ,float );
    public void TransformPoint(float ,float ,float ,float * ,float * );
    public void TransformPoint(float ,float ,float ,float * ,float * ,float * );
    public void TransformScreenToCamera(float & ,float & );
    public float GetClickDistanceSquare(struct D3DXVECTOR3 & ,float ,float );
    public bool CheckClickBox(struct D3DXVECTOR3 & ,float ,float ,float ,float );
    private struct SLightProp LightProps[4];
    private void RefreshLights();
    private unsigned int GetLightHandle();
    private struct SShadowTransformCB shadowCB;
    private struct SLightCB lightCB;
    public int CreateDirectionalLight(float ,float ,float ,float ,float ,float );
    public int CreatePointLight(float ,float ,float ,float ,float ,float ,float ,float );
    public void SetLightPosition(int ,float ,float ,float );
    public void DestroyLight(int );
    public void SetLightingType(enum SLightingType );
    public void SetAmbientColor(unsigned long );
    public void SetAmbientGray(int );
    public void SetShadowCB();
    public void SetLightCB();
    private class SHeap<SObjectCacheProp> ObjectCache;
    private class SHeap<SObjectProp> StaticObjects;
    private class SHeap<SObjectProp> DynamicObjects;
    private bool ObjectsHashed;
    private int * ObjectHash;
    private class SDArray<SObjectHashChain> ObjectHashChain;
    private void HashObjects();
    private void RenderObjects(bool ,bool );
    private void RenderObjectShadows(bool );
    private void RenderObjectShadowDecals();
    private void GenerateObjectShadow(class SGroup & ,bool );
    private void RegenerateObjectShadowDecals();
    private void ClearObjectShadows(bool ,bool );
    private int ShadowQuality;
    private int MaxShadowQuality;
    private struct IDirect3DSurface9 * ShadowRenderTarget;
    private struct IDirect3DSurface9 * ShadowRenderTargetZ;
    public int PrecacheObject(char * ,float ,enum SDrawType );
    public int CleanupObjectCache();
    public class SIObject * CreateObject(char * ,float ,bool );
    public class SIObject * CreateObject(int ,bool );
    public void ReplaceObject(class SIObject * ,char * ,float );
    public void ReplaceObject(class SIObject * ,int );
    public void RemoveDynamicObject(int );
    public void RemoveHashedObject(int );
    public int GetShadowQuality();
    public void SetShadowQuality(int );
    public int GetMaxShadowQuality();
    public float GetShadowDistance();
    public void SetShadowDistance(float );
    public void TriggerRehash();
    public void MakeObjectShadowMask(class SGroup & );
    public void ProjectPoint(float ,float ,float ,float ,float ,float & ,float & );
    public void MakeObjectShadowShader(class SGroup & );
    public void SkipObjectShadowMask(class SIObject * ,class SStream * );
    public void GenerateAllShadowShaders();
    private int SunLight;
    public class STerrain * Terrain;
    public class SIPlane * CreatePlane(int ,int );
    public void DestroyPlane();
    private void * ShaderChangeNotification;
    private bool Flags[2];
    private int DebugMode;
    private struct D3DXMATRIX IdentityMatrix;
    private void InitVertexShader(char * ,class SmartPtr<IDirect3DVertexShader9> & ,struct _D3DXMACRO * );
    private void InitPixelShader(char * ,class SmartPtr<IDirect3DPixelShader9> & ,struct _D3DXMACRO * );
    private void InitShaders();
    private void ClearShaders();
    private void SetWorldViewProjVertexShaderConstantBuffer(struct D3DXMATRIX & );
    public bool GetFlag(enum GepardFlags );
    public void SetFlag(enum GepardFlags ,bool );
    public int GetDebugMode();
    public void SetDebugMode(int );
    struct DebugLine
    {
        class SVector start;
        class SVector end;
        unsigned long color;
        int owner;
        void DebugLine();
    };
    private class Array<SGepard::DebugLine> debugLines;
    private void RenderDebugLines();
    public void AddDebugLine(class SVector ,class SVector ,unsigned long ,int );
    public void ClearDebugLines(unsigned long ,int );
    public class SmartPtr<IDirect3DVertexShader9> standardVertexShaders[7];
    public class SmartPtr<IDirect3DPixelShader9> standardPixelShaders[7];
    public class SmartPtr<IDirect3DVertexShader9> depthWriteVertexShaders[8];
    public class SmartPtr<IDirect3DPixelShader9> depthWritePixelShaders[8];
    public class SmartPtr<IDirect3DVertexShader9> terrainVertexShader[2];
    public class SmartPtr<IDirect3DPixelShader9> terrainPixelShader[2];
    public class SmartPtr<IDirect3DVertexShader9> terrainLightingVertexShader;
    public class SmartPtr<IDirect3DVertexShader9> ambientLitVertexShader;
    public class SmartPtr<IDirect3DVertexShader9> decalVertexShader;
    public class SmartPtr<IDirect3DVertexShader9> unlitDecalVertexShader;
    public class SmartPtr<IDirect3DPixelShader9> sepiaPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> terrainLightingPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> ambientLitPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> decalPixelShader;
    public class SmartPtr<IDirect3DPixelShader9> unlitDecalPixelShader;
    private class SHeap<STextureProp> Textures;
    private int TextureFilter;
    private int TextureDetail;
    private enum _D3DFORMAT TFOpaque;
    private enum _D3DFORMAT TF1Bit;
    private enum _D3DFORMAT TFAlpha;
    private enum _D3DFORMAT TFHiOpaque;
    private enum _D3DFORMAT TFHiAlpha;
    private enum _D3DFORMAT TFShadow;
    private enum _D3DFORMAT TFShadowNull;
    private enum _D3DFORMAT TFShadowDepth;
    private bool TFSupportNonPow2;
    private enum SDrawType DrawType;
    private bool CheckTextureFormat(enum _D3DFORMAT ,bool );
    private void InitTextureFormats();
    private int CreateTextureFromDXT(char * ,char * ,bool );
    private void LoadDXTToLevelBitmaps(char * ,class SDArray<SBitmap *> & );
    private int CreateTextureFromLevelBitmaps(class SDArray<SBitmap *> & ,char * );
    private void ReloadTexture(int );
    public void RoundToTextureSize(int ,int ,int & ,int & );
    public void SetTextureCacheDirectory(char * );
    public int LoadTexture(char * ,bool ,bool );
    public int CreateEmptyTexture(int ,int ,int ,bool ,bool );
    public int CreateShadowTexture(int ,int );
    public int AddRefTexture(int );
    public void ReleaseTexture(int ,bool );
    public void CleanupTextureCache();
    public void SetDrawType(enum SDrawType );
    public int GetTextureAlpha(int );
    public void SetTexture(int ,int ,bool );
    public void SetShadowMapTexture(int );
    public void ResetShadowMapTexture(int );
    public void SetTextureFilter(int );
    public int GetTextureFilter();
    public void SetTextureDetail(int );
    public int GetTextureDetail();
    public int CreateTextureFromBitmap(char * ,class SBitmap & ,bool );
    public void UpdateTextureFromBitmap(int ,class SBitmap & );
    public void ChangeTextureAlphaType(int ,int );
    public bool IsTextureOpaque(int );
    private class SHeap<SDynamicShaderProp> DynamicShaders;
    private void RenderDynamicShaders();
    public int CreateDynamicShader(int ,float ,float ,float ,unsigned long );
    public void RemoveDynamicShader(int );
    public void SetDynamicShaderPosition(int ,float ,float );
    private class SHeap<SRectProp> Rects;
    private void RenderRects();
    private void RefreshRect(class SMesh * ,int ,int ,int ,int );
    public int CreateRect(unsigned long ,int ,int ,int ,int );
    public void RemoveRect(int );
    public void SetRectColor(int ,unsigned long );
    public void SetRectPosition(int ,int ,int ,int ,int );
    public void UpdateRects();
    private class SHeap<SSmokeTrail> SmokeTrails;
    private void RenderSmokeTrails();
    public int CreateSmokeTrail(int ,float ,float ,float ,int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackSmokeTrail(int ,float ,float ,float ,float );
    public void CloseSmokeTrail(int );
    public void RemoveSmokeTrail(int );
    private class SHeap<SGroundTrail> GroundTrails;
    private void RenderGroundTrails();
    public int CreateGroundTrail(int ,float ,float ,float ,float ,enum SDrawType );
    public void TrackGroundTrail(int ,float ,float ,float );
    public void CloseGroundTrail(int );
    public void RemoveGroundTrail(int );
    private class SHeap<SGLake> Lakes;
    private void RenderLakes();
    public int CreateLake(int ,float ,float ,float ,int ,int );
    public void RemoveLake(int );
    public void ChangeLakeHeight(int ,float );
    public void DrawLakesToWaterMap();
    private class SHeap<SDynamicVB> DynamicVBs;
    private void ClearDynamicVBs();
    private void RestoreDynamicVBs();
    public int CreateDynamicVB(int ,unsigned long );
    public void RemoveDynamicVB(int );
    public unsigned int * LockDynamicVB(int ,unsigned long );
    public void UnlockDynamicVB(int );
    public void DrawDynamicVB(int ,unsigned long );
    public void SetTileset(int );
    public void ClearGlow();
    public void AddGlow(float ,float ,float ,int ,int ,int ,int ,float );
    public void TurnOnGlow();
    public void TurnOffGlow();
    public void EgysegAlattiTalajKoszolas(float ,float ,int );
    public int LoadEffect(char * ,char * );
    public void CreateEffectsHandler();
    public void DestroyEffectsHandler();
    public class SEffect * Effect;
    public void PlayEffect(int ,class SIObject * ,class SDArray<SAblak> * );
    public void PlayEffect(int ,class SIObject * ,char * ,int );
    public void * PlayEffect(int ,float ,float ,float ,float );
    public void PlayEffect(int ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void TrackEffect(void * ,float ,float ,float ,float );
    public void StopEffect(void * );
    public void RefreshIndices(void * );
    public bool FullBright;
    public int Tileset;
    public void SetFullBright(bool );
    public float GetCameraHRot();
    public class SVector GetCameraForward();
    public void WaterLine(float ,float ,float ,float ,float );
    public bool FirstDrawWater;
    public void SetUpObjectEffects();
    public int GetTileset();
    public int Temp;
    public float ResolutionScale;
    public class SmartPtr<IDirect3DSurface9> ResolutionScaleSurface;
    public class SmartPtr<IDirect3DSurface9> ResolutionScaleDepthSurface;
    public void SetResolutionScale(float );
    public void InitResolutionScale();
    public void ClearResolutionScale();
    public void * __vecDelDtor(unsigned int );
};

struct SPoint
{
    float x;
    float y;
    float z;
};

class SSpline
{
    public void SSpline(class SGepard * ,bool ,int );
    public void ~SSpline();
    public void AddNode(float ,float ,float ,bool );
    public void SelectNode(struct SNode * );
    public void DeselectNode(int );
    public void DeleteSelectedNodes();
    public void DrawNodes(bool ,struct SHillRing * ,struct SSplineRing * );
    public void DrawLines();
    public void SelectAllNode();
    public void DeselectAllNode();
    public void Close();
    public void GetCenter(float * ,float * );
    public void Reduce(float );
    public void MoveNode(struct SNode * ,float ,float ,float );
    public void SetAltitude(float );
    public void SetAltitude2(float );
    public void ReplaceNodesFrom(class SSpline * ,class SSpline * );
    public void ReplaceNodesFrom(class SSpline * );
    public void CopySelectionFrom(class SSpline * );
    public void KillSubNodes();
    public void RefreshSubNodes();
    public int IsSegmentTouch(float ,float ,int * ,int * );
    public void RecalculateControlPoints();
    public bool IsFloatNear(float ,float );
    public bool IsSectionSame(float ,float ,float ,float );
    public bool IsAxleSame(float ,float ,float ,float );
    public void RefreshSubNodes2();
    public class SGepard * Gepard;
    public struct SPoint lpLine[2];
    public struct IDirect3DDevice9 * lpD3DDev;
    public class SChain<SNode> Nodes;
    public float lastx;
    public float lastz;
    public float lastxkul;
    public float lastzkul;
    public bool Closed;
    public float Altitude;
    public float Altitude2;
    public bool MiddleSpline;
    public int CheckBoxNr;
    public bool VisibilityState;
    public float Size;
    public unsigned long Seed;
    public float FirstLeftX;
    public float FirstLeftY;
    public float FirstLeftZ;
    public float FirstCenterX;
    public float FirstCenterY;
    public float FirstCenterZ;
    public float FirstRightX;
    public float FirstRightY;
    public float FirstRightZ;
    public float FirstLeftJoinedX;
    public float FirstLeftJoinedY;
    public float FirstLeftJoinedZ;
    public float FirstRightJoinedX;
    public float FirstRightJoinedY;
    public float FirstRightJoinedZ;
    public float LastLeftX;
    public float LastLeftY;
    public float LastLeftZ;
    public float LastCenterX;
    public float LastCenterY;
    public float LastCenterZ;
    public float LastRightX;
    public float LastRightY;
    public float LastRightZ;
    public float LastLeftJoinedX;
    public float LastLeftJoinedY;
    public float LastLeftJoinedZ;
    public float LastRightJoinedX;
    public float LastRightJoinedY;
    public float LastRightJoinedZ;
    public float URatio;
    public float VEndPos;
    public float VStartPos;
    public int UAlign;
    public float JoinedVPos;
    public float RiverLength;
    public class SChain<SRiverStripRing> * RiverStripChain;
    public void * __vecDelDtor(unsigned int );
};

struct SNode
{
    struct SNode * next;
    struct SNode * prev;
    bool ControlPoint;
    bool Selected;
    bool Highlighted;
    int HeightFrom;
    float x;
    float y;
    float z;
    float waterleftsize;
    float waterrightsize;
};

struct SMaterial : public _D3DMATERIAL9
{
    void SMaterial();
    void SetDiffuse(float ,float ,float ,float );
    void SetAmbient(float ,float ,float ,float );
    void SetSpecular(float ,float ,float ,float ,float );
    void SetEmissive(float ,float ,float ,float );
    void GetDiffuse(float & ,float & ,float & );
    void GetAmbient(float & ,float & ,float & );
    void GetSpecular(float & ,float & ,float & );
    void GetEmissive(float & ,float & ,float & );
};

class SChain<SNode>
{
    private struct SNode * first;
    private struct SNode * last;
    private struct SNode * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SNode>();
    public void ~SChain<SNode>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SNode * StepToFirst();
    public struct SNode * StepToLast();
    public struct SNode * GetNext();
    public struct SNode * GetNext2();
    public struct SNode * GetPrev();
    public struct SNode * GetCurrent();
    public struct SNode * StepToNext();
    public struct SNode * StepToPrev();
    public struct SNode * Append(struct SNode * ,bool );
    public struct SNode * AppendNew(bool );
    public struct SNode * GetFirst();
    public struct SNode * GetSecond();
    public struct SNode * GetThird();
    public struct SNode * GetLastButOne();
    public struct SNode * GetLast();
    public struct SNode * InsertOver(struct SNode * ,bool );
    public struct SNode * InsertOverNew(bool );
    public struct SNode * InsertUnder(struct SNode * ,bool );
    public struct SNode * InsertUnderNew(bool );
    public void Delete(struct SNode * );
    public void Delete();
    public void DeleteAll();
    public struct SNode * GetPointer(int );
    public struct SNode * StepToIndex(int );
    public struct SNode & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SNode * );
    public void StepToPointer(struct SNode * );
    public void SendToBack(struct SNode * );
    public void BringToFront(struct SNode * );
    public void Swap(struct SNode * ,struct SNode * );
    public void * __vecDelDtor(unsigned int );
};

struct S3Vertex
{
    struct D3DXVECTOR3 v1;
    struct D3DXVECTOR3 v2;
    struct D3DXVECTOR3 v3;
    void S3Vertex();
};

class SChain<SShaderInfo>
{
    private struct SShaderInfo * first;
    private struct SShaderInfo * last;
    private struct SShaderInfo * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SShaderInfo>();
    public void ~SChain<SShaderInfo>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SShaderInfo * StepToFirst();
    public struct SShaderInfo * StepToLast();
    public struct SShaderInfo * GetNext();
    public struct SShaderInfo * GetNext2();
    public struct SShaderInfo * GetPrev();
    public struct SShaderInfo * GetCurrent();
    public struct SShaderInfo * StepToNext();
    public struct SShaderInfo * StepToPrev();
    public struct SShaderInfo * Append(struct SShaderInfo * ,bool );
    public struct SShaderInfo * AppendNew(bool );
    public struct SShaderInfo * GetFirst();
    public struct SShaderInfo * GetSecond();
    public struct SShaderInfo * GetThird();
    public struct SShaderInfo * GetLastButOne();
    public struct SShaderInfo * GetLast();
    public struct SShaderInfo * InsertOver(struct SShaderInfo * ,bool );
    public struct SShaderInfo * InsertOverNew(bool );
    public struct SShaderInfo * InsertUnder(struct SShaderInfo * ,bool );
    public struct SShaderInfo * InsertUnderNew(bool );
    public void Delete(struct SShaderInfo * );
    public void Delete();
    public void DeleteAll();
    public struct SShaderInfo * GetPointer(int );
    public struct SShaderInfo * StepToIndex(int );
    public struct SShaderInfo & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SShaderInfo * );
    public void StepToPointer(struct SShaderInfo * );
    public void SendToBack(struct SShaderInfo * );
    public void BringToFront(struct SShaderInfo * );
    public void Swap(struct SShaderInfo * ,struct SShaderInfo * );
    public void * __vecDelDtor(unsigned int );
};

class SChain<SShader2Info>
{
    private struct SShader2Info * first;
    private struct SShader2Info * last;
    private struct SShader2Info * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SShader2Info>();
    public void ~SChain<SShader2Info>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SShader2Info * StepToFirst();
    public struct SShader2Info * StepToLast();
    public struct SShader2Info * GetNext();
    public struct SShader2Info * GetNext2();
    public struct SShader2Info * GetPrev();
    public struct SShader2Info * GetCurrent();
    public struct SShader2Info * StepToNext();
    public struct SShader2Info * StepToPrev();
    public struct SShader2Info * Append(struct SShader2Info * ,bool );
    public struct SShader2Info * AppendNew(bool );
    public struct SShader2Info * GetFirst();
    public struct SShader2Info * GetSecond();
    public struct SShader2Info * GetThird();
    public struct SShader2Info * GetLastButOne();
    public struct SShader2Info * GetLast();
    public struct SShader2Info * InsertOver(struct SShader2Info * ,bool );
    public struct SShader2Info * InsertOverNew(bool );
    public struct SShader2Info * InsertUnder(struct SShader2Info * ,bool );
    public struct SShader2Info * InsertUnderNew(bool );
    public void Delete(struct SShader2Info * );
    public void Delete();
    public void DeleteAll();
    public struct SShader2Info * GetPointer(int );
    public struct SShader2Info * StepToIndex(int );
    public struct SShader2Info & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SShader2Info * );
    public void StepToPointer(struct SShader2Info * );
    public void SendToBack(struct SShader2Info * );
    public void BringToFront(struct SShader2Info * );
    public void Swap(struct SShader2Info * ,struct SShader2Info * );
    public void * __vecDelDtor(unsigned int );
};

struct SFolders
{
    struct SFolders * next;
    struct SFolders * prev;
    char filename[120];
};

class SChain<SFolders>
{
    private struct SFolders * first;
    private struct SFolders * last;
    private struct SFolders * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SFolders>();
    public void ~SChain<SFolders>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SFolders * StepToFirst();
    public struct SFolders * StepToLast();
    public struct SFolders * GetNext();
    public struct SFolders * GetNext2();
    public struct SFolders * GetPrev();
    public struct SFolders * GetCurrent();
    public struct SFolders * StepToNext();
    public struct SFolders * StepToPrev();
    public struct SFolders * Append(struct SFolders * ,bool );
    public struct SFolders * AppendNew(bool );
    public struct SFolders * GetFirst();
    public struct SFolders * GetSecond();
    public struct SFolders * GetThird();
    public struct SFolders * GetLastButOne();
    public struct SFolders * GetLast();
    public struct SFolders * InsertOver(struct SFolders * ,bool );
    public struct SFolders * InsertOverNew(bool );
    public struct SFolders * InsertUnder(struct SFolders * ,bool );
    public struct SFolders * InsertUnderNew(bool );
    public void Delete(struct SFolders * );
    public void Delete();
    public void DeleteAll();
    public struct SFolders * GetPointer(int );
    public struct SFolders * StepToIndex(int );
    public struct SFolders & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SFolders * );
    public void StepToPointer(struct SFolders * );
    public void SendToBack(struct SFolders * );
    public void BringToFront(struct SFolders * );
    public void Swap(struct SFolders * ,struct SFolders * );
    public void * __vecDelDtor(unsigned int );
};

struct SHoleInfo
{
    struct SHoleInfo * next;
    struct SHoleInfo * prev;
    int x;
    int z;
    class SChain<SNodeInfo2> * nodechain;
};

class SChain<SHoleInfo>
{
    private struct SHoleInfo * first;
    private struct SHoleInfo * last;
    private struct SHoleInfo * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SHoleInfo>();
    public void ~SChain<SHoleInfo>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SHoleInfo * StepToFirst();
    public struct SHoleInfo * StepToLast();
    public struct SHoleInfo * GetNext();
    public struct SHoleInfo * GetNext2();
    public struct SHoleInfo * GetPrev();
    public struct SHoleInfo * GetCurrent();
    public struct SHoleInfo * StepToNext();
    public struct SHoleInfo * StepToPrev();
    public struct SHoleInfo * Append(struct SHoleInfo * ,bool );
    public struct SHoleInfo * AppendNew(bool );
    public struct SHoleInfo * GetFirst();
    public struct SHoleInfo * GetSecond();
    public struct SHoleInfo * GetThird();
    public struct SHoleInfo * GetLastButOne();
    public struct SHoleInfo * GetLast();
    public struct SHoleInfo * InsertOver(struct SHoleInfo * ,bool );
    public struct SHoleInfo * InsertOverNew(bool );
    public struct SHoleInfo * InsertUnder(struct SHoleInfo * ,bool );
    public struct SHoleInfo * InsertUnderNew(bool );
    public void Delete(struct SHoleInfo * );
    public void Delete();
    public void DeleteAll();
    public struct SHoleInfo * GetPointer(int );
    public struct SHoleInfo * StepToIndex(int );
    public struct SHoleInfo & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SHoleInfo * );
    public void StepToPointer(struct SHoleInfo * );
    public void SendToBack(struct SHoleInfo * );
    public void BringToFront(struct SHoleInfo * );
    public void Swap(struct SHoleInfo * ,struct SHoleInfo * );
    public void * __vecDelDtor(unsigned int );
};

struct SNodeInfo
{
    struct SNodeInfo * prev;
    struct SNodeInfo * next;
    struct SHillRing * hillring;
    struct SSplineRing * splinering;
    struct SNode * node;
    float magassag;
    int nodeindex;
};

class SChain<SNodeInfo>
{
    private struct SNodeInfo * first;
    private struct SNodeInfo * last;
    private struct SNodeInfo * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SNodeInfo>();
    public void ~SChain<SNodeInfo>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SNodeInfo * StepToFirst();
    public struct SNodeInfo * StepToLast();
    public struct SNodeInfo * GetNext();
    public struct SNodeInfo * GetNext2();
    public struct SNodeInfo * GetPrev();
    public struct SNodeInfo * GetCurrent();
    public struct SNodeInfo * StepToNext();
    public struct SNodeInfo * StepToPrev();
    public struct SNodeInfo * Append(struct SNodeInfo * ,bool );
    public struct SNodeInfo * AppendNew(bool );
    public struct SNodeInfo * GetFirst();
    public struct SNodeInfo * GetSecond();
    public struct SNodeInfo * GetThird();
    public struct SNodeInfo * GetLastButOne();
    public struct SNodeInfo * GetLast();
    public struct SNodeInfo * InsertOver(struct SNodeInfo * ,bool );
    public struct SNodeInfo * InsertOverNew(bool );
    public struct SNodeInfo * InsertUnder(struct SNodeInfo * ,bool );
    public struct SNodeInfo * InsertUnderNew(bool );
    public void Delete(struct SNodeInfo * );
    public void Delete();
    public void DeleteAll();
    public struct SNodeInfo * GetPointer(int );
    public struct SNodeInfo * StepToIndex(int );
    public struct SNodeInfo & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SNodeInfo * );
    public void StepToPointer(struct SNodeInfo * );
    public void SendToBack(struct SNodeInfo * );
    public void BringToFront(struct SNodeInfo * );
    public void Swap(struct SNodeInfo * ,struct SNodeInfo * );
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DTexture9>
{
    public void SmartPtr<IDirect3DTexture9>(class SmartPtr<IDirect3DTexture9> & );
    public void SmartPtr<IDirect3DTexture9>(struct IDirect3DTexture9 * );
    public void SmartPtr<IDirect3DTexture9>();
    public void ~SmartPtr<IDirect3DTexture9>();
    public void operator=(class SmartPtr<IDirect3DTexture9> & );
    public void operator=(struct IDirect3DTexture9 * );
    public struct IDirect3DTexture9 * operator struct IDirect3DTexture9 *();
    public struct IDirect3DTexture9 & operator*();
    public struct IDirect3DTexture9 * operator->();
    public struct IDirect3DTexture9 ** Receive();
    private struct IDirect3DTexture9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DTexture9>
{
    public void SmartPtr<IDirect3DTexture9>(class SmartPtr<IDirect3DTexture9> & );
    public void SmartPtr<IDirect3DTexture9>(struct IDirect3DTexture9 * );
    public void SmartPtr<IDirect3DTexture9>();
    public void ~SmartPtr<IDirect3DTexture9>();
    public void operator=(class SmartPtr<IDirect3DTexture9> & );
    public void operator=(struct IDirect3DTexture9 * );
    public struct IDirect3DTexture9 * operator struct IDirect3DTexture9 *();
    public struct IDirect3DTexture9 & operator*();
    public struct IDirect3DTexture9 * operator->();
    public struct IDirect3DTexture9 ** Receive();
    private struct IDirect3DTexture9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

struct SLightProp
{
    int type;
    struct _D3DLIGHT9 d3dlight;
};

struct SObjectCacheProp
{
    char * FileName;
    float Scale;
    unsigned int RefCount;
    class SGroup * Group;
};

class SHeap<SObjectCacheProp>
{
    struct __Tstruct
    {
        int use;
        struct SObjectCacheProp data;
    };
    private struct SHeap<SObjectCacheProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SObjectCacheProp>();
    public void ~SHeap<SObjectCacheProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SObjectCacheProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SObjectCacheProp>
{
    struct __Tstruct
    {
        int use;
        struct SObjectCacheProp data;
    };
    private struct SHeap<SObjectCacheProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SObjectCacheProp>();
    public void ~SHeap<SObjectCacheProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SObjectCacheProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SObjectProp
{
    int CacheIdx;
    class SGroup * Group;
    unsigned long LastRendered;
};

class SHeap<SObjectProp>
{
    struct __Tstruct
    {
        int use;
        struct SObjectProp data;
    };
    private struct SHeap<SObjectProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SObjectProp>();
    public void ~SHeap<SObjectProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SObjectProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SObjectProp>
{
    struct __Tstruct
    {
        int use;
        struct SObjectProp data;
    };
    private struct SHeap<SObjectProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SObjectProp>();
    public void ~SHeap<SObjectProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SObjectProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SObjectHashChain
{
    int ObjectIdx;
    int Next;
};

struct SObjectHashChain
{
    int ObjectIdx;
    int Next;
};

class SDArray<SObjectHashChain>
{
    private int size;
    private int maxsize;
    public struct SObjectHashChain * array;
    public void SDArray<SObjectHashChain>(class SDArray<SObjectHashChain> & );
    public void SDArray<SObjectHashChain>();
    public void ~SDArray<SObjectHashChain>();
    public int Add(struct SObjectHashChain & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SObjectHashChain & operator[](int );
    public void operator=(class SDArray<SObjectHashChain> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SObjectHashChain>
{
    private int size;
    private int maxsize;
    public struct SObjectHashChain * array;
    public void SDArray<SObjectHashChain>(class SDArray<SObjectHashChain> & );
    public void SDArray<SObjectHashChain>();
    public void ~SDArray<SObjectHashChain>();
    public int Add(struct SObjectHashChain & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SObjectHashChain & operator[](int );
    public void operator=(class SDArray<SObjectHashChain> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DVertexShader9>
{
    public void SmartPtr<IDirect3DVertexShader9>(class SmartPtr<IDirect3DVertexShader9> & );
    public void SmartPtr<IDirect3DVertexShader9>(struct IDirect3DVertexShader9 * );
    public void SmartPtr<IDirect3DVertexShader9>();
    public void ~SmartPtr<IDirect3DVertexShader9>();
    public void operator=(class SmartPtr<IDirect3DVertexShader9> & );
    public void operator=(struct IDirect3DVertexShader9 * );
    public struct IDirect3DVertexShader9 * operator struct IDirect3DVertexShader9 *();
    public struct IDirect3DVertexShader9 & operator*();
    public struct IDirect3DVertexShader9 * operator->();
    public struct IDirect3DVertexShader9 ** Receive();
    private struct IDirect3DVertexShader9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DVertexShader9>
{
    public void SmartPtr<IDirect3DVertexShader9>(class SmartPtr<IDirect3DVertexShader9> & );
    public void SmartPtr<IDirect3DVertexShader9>(struct IDirect3DVertexShader9 * );
    public void SmartPtr<IDirect3DVertexShader9>();
    public void ~SmartPtr<IDirect3DVertexShader9>();
    public void operator=(class SmartPtr<IDirect3DVertexShader9> & );
    public void operator=(struct IDirect3DVertexShader9 * );
    public struct IDirect3DVertexShader9 * operator struct IDirect3DVertexShader9 *();
    public struct IDirect3DVertexShader9 & operator*();
    public struct IDirect3DVertexShader9 * operator->();
    public struct IDirect3DVertexShader9 ** Receive();
    private struct IDirect3DVertexShader9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DPixelShader9>
{
    public void SmartPtr<IDirect3DPixelShader9>(class SmartPtr<IDirect3DPixelShader9> & );
    public void SmartPtr<IDirect3DPixelShader9>(struct IDirect3DPixelShader9 * );
    public void SmartPtr<IDirect3DPixelShader9>();
    public void ~SmartPtr<IDirect3DPixelShader9>();
    public void operator=(class SmartPtr<IDirect3DPixelShader9> & );
    public void operator=(struct IDirect3DPixelShader9 * );
    public struct IDirect3DPixelShader9 * operator struct IDirect3DPixelShader9 *();
    public struct IDirect3DPixelShader9 & operator*();
    public struct IDirect3DPixelShader9 * operator->();
    public struct IDirect3DPixelShader9 ** Receive();
    private struct IDirect3DPixelShader9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DPixelShader9>
{
    public void SmartPtr<IDirect3DPixelShader9>(class SmartPtr<IDirect3DPixelShader9> & );
    public void SmartPtr<IDirect3DPixelShader9>(struct IDirect3DPixelShader9 * );
    public void SmartPtr<IDirect3DPixelShader9>();
    public void ~SmartPtr<IDirect3DPixelShader9>();
    public void operator=(class SmartPtr<IDirect3DPixelShader9> & );
    public void operator=(struct IDirect3DPixelShader9 * );
    public struct IDirect3DPixelShader9 * operator struct IDirect3DPixelShader9 *();
    public struct IDirect3DPixelShader9 & operator*();
    public struct IDirect3DPixelShader9 * operator->();
    public struct IDirect3DPixelShader9 ** Receive();
    private struct IDirect3DPixelShader9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

struct SGepard::DebugLine
{
    class SVector start;
    class SVector end;
    unsigned long color;
    int owner;
    void DebugLine();
};

class Array<SGepard::DebugLine>
{
    public void Array<SGepard::DebugLine>(class Array<SGepard::DebugLine> * );
    public void Array<SGepard::DebugLine>(class Array<SGepard::DebugLine> & );
    public void Array<SGepard::DebugLine>();
    public void ~Array<SGepard::DebugLine>();
    public void operator=(class ArrayRef<SGepard::DebugLine> & );
    public void operator=(class Array<SGepard::DebugLine> * );
    public void operator=(class Array<SGepard::DebugLine> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SGepard::DebugLine & operator[](unsigned int );
    public struct SGepard::DebugLine & operator[](unsigned int );
    public struct SGepard::DebugLine & GetLast();
    public struct SGepard::DebugLine & GetLast();
    public void Add(struct SGepard::DebugLine * );
    public void Add(struct SGepard::DebugLine & );
    public void Insert(unsigned int ,struct SGepard::DebugLine * );
    public void Insert(unsigned int ,struct SGepard::DebugLine & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SGepard::DebugLine & );
    public void RemoveLast();
    public struct SGepard::DebugLine * begin();
    public struct SGepard::DebugLine * begin();
    public struct SGepard::DebugLine * end();
    public struct SGepard::DebugLine * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SGepard::DebugLine> operator class ArrayRef<struct SGepard::DebugLine>();
    private struct SGepard::DebugLine * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SGepard::DebugLine * Allocate(unsigned int );
    private void Deallocate(struct SGepard::DebugLine * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ArrayRef<SGepard::DebugLine>
{
};

struct SGepard::DebugLine
{
    class SVector start;
    class SVector end;
    unsigned long color;
    int owner;
    void DebugLine();
};

class Array<SGepard::DebugLine>
{
    public void Array<SGepard::DebugLine>(class Array<SGepard::DebugLine> * );
    public void Array<SGepard::DebugLine>(class Array<SGepard::DebugLine> & );
    public void Array<SGepard::DebugLine>();
    public void ~Array<SGepard::DebugLine>();
    public void operator=(class ArrayRef<SGepard::DebugLine> & );
    public void operator=(class Array<SGepard::DebugLine> * );
    public void operator=(class Array<SGepard::DebugLine> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct SGepard::DebugLine & operator[](unsigned int );
    public struct SGepard::DebugLine & operator[](unsigned int );
    public struct SGepard::DebugLine & GetLast();
    public struct SGepard::DebugLine & GetLast();
    public void Add(struct SGepard::DebugLine * );
    public void Add(struct SGepard::DebugLine & );
    public void Insert(unsigned int ,struct SGepard::DebugLine * );
    public void Insert(unsigned int ,struct SGepard::DebugLine & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct SGepard::DebugLine & );
    public void RemoveLast();
    public struct SGepard::DebugLine * begin();
    public struct SGepard::DebugLine * begin();
    public struct SGepard::DebugLine * end();
    public struct SGepard::DebugLine * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<SGepard::DebugLine> operator class ArrayRef<struct SGepard::DebugLine>();
    private struct SGepard::DebugLine * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct SGepard::DebugLine * Allocate(unsigned int );
    private void Deallocate(struct SGepard::DebugLine * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

struct STextureProp
{
    char * FileName;
    struct IDirect3DTexture9 * lpTexture;
    int RefCount;
    unsigned long Width;
    unsigned long Height;
    bool MipMaps;
    int Alpha;
};

class SHeap<STextureProp>
{
    struct __Tstruct
    {
        int use;
        struct STextureProp data;
    };
    private struct SHeap<STextureProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<STextureProp>();
    public void ~SHeap<STextureProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct STextureProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<STextureProp>
{
    struct __Tstruct
    {
        int use;
        struct STextureProp data;
    };
    private struct SHeap<STextureProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<STextureProp>();
    public void ~SHeap<STextureProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct STextureProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SBitmap
{
    public void SBitmap(class SBitmap & ,enum _D3DFORMAT );
    public void SBitmap(int ,int ,enum _D3DFORMAT ,bool );
    public void SBitmap(class SBitmap * );
    public void SBitmap();
    public void operator=(class SBitmap * );
    public void ~SBitmap();
    public bool LoadPNG(char * ,char * );
    public bool LoadTGA(char * ,char * );
    public bool SaveTGA(char * ,char * );
    public void NextMipLevel();
    public void Rotate(int );
    public void MakeOpaque();
    public void MakeInverseOpaque();
    public void BitBlt(int ,int ,int ,int ,class SBitmap & ,int ,int );
    public struct HBITMAP__ * CreateWinBitmap();
    public int GetLogicalSize();
    public int Width;
    public int Height;
    public enum _D3DFORMAT Format;
    public int Start;
    public int Pitch;
    public int Pixel;
    public int Size;
    public unsigned int * Data;
    protected void InitPixelFormat();
    protected void AllocateData(bool );
    public void * __vecDelDtor(unsigned int );
};

struct SDynamicShaderProp
{
    int TextureIndex;
    float X;
    float Z;
    float Size;
    unsigned long Color;
};

class SHeap<SDynamicShaderProp>
{
    struct __Tstruct
    {
        int use;
        struct SDynamicShaderProp data;
    };
    private struct SHeap<SDynamicShaderProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SDynamicShaderProp>();
    public void ~SHeap<SDynamicShaderProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SDynamicShaderProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SDynamicShaderProp>
{
    struct __Tstruct
    {
        int use;
        struct SDynamicShaderProp data;
    };
    private struct SHeap<SDynamicShaderProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SDynamicShaderProp>();
    public void ~SHeap<SDynamicShaderProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SDynamicShaderProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SRectProp
{
    class SMesh * Mesh;
    unsigned long Color;
    int X0;
    int Z0;
    int X1;
    int Z1;
};

class SHeap<SRectProp>
{
    struct __Tstruct
    {
        int use;
        struct SRectProp data;
    };
    private struct SHeap<SRectProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SRectProp>();
    public void ~SHeap<SRectProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SRectProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SRectProp>
{
    struct __Tstruct
    {
        int use;
        struct SRectProp data;
    };
    private struct SHeap<SRectProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SRectProp>();
    public void ~SHeap<SRectProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SRectProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SSmokeTrail
{
    class SDArray<SSmokeTrailPoint> * Points;
    int TextureIndex;
    bool AutoDestruct;
    int Color;
    float Strength;
    float FadeSpeed;
    float UScale;
    float VScale;
    enum SDrawType DrawType;
};

class SHeap<SSmokeTrail>
{
    struct __Tstruct
    {
        int use;
        struct SSmokeTrail data;
    };
    private struct SHeap<SSmokeTrail>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SSmokeTrail>();
    public void ~SHeap<SSmokeTrail>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SSmokeTrail & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SSmokeTrail>
{
    struct __Tstruct
    {
        int use;
        struct SSmokeTrail data;
    };
    private struct SHeap<SSmokeTrail>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SSmokeTrail>();
    public void ~SHeap<SSmokeTrail>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SSmokeTrail & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SGroundTrail
{
    class SHeap<SGroundTrailSegment> * Segments;
    int TextureIndex;
    bool AutoDestruct;
    float Strength;
    float FadeTime;
    float UScale;
    float VScale;
    float LastX;
    float LastZ;
    float LastDir;
    bool HaveFirst;
    enum SDrawType DrawType;
};

class SHeap<SGroundTrail>
{
    struct __Tstruct
    {
        int use;
        struct SGroundTrail data;
    };
    private struct SHeap<SGroundTrail>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SGroundTrail>();
    public void ~SHeap<SGroundTrail>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SGroundTrail & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SGroundTrail>
{
    struct __Tstruct
    {
        int use;
        struct SGroundTrail data;
    };
    private struct SHeap<SGroundTrail>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SGroundTrail>();
    public void ~SHeap<SGroundTrail>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SGroundTrail & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SLakeBlock
{
    int BlockIdx;
    class SMesh * Mesh;
    class SMesh * Mesh2;
    int RecalcHeightTransparency;
};

struct SLakeBlock
{
    int BlockIdx;
    class SMesh * Mesh;
    class SMesh * Mesh2;
    int RecalcHeightTransparency;
};

class SDArray<SLakeBlock>
{
    private int size;
    private int maxsize;
    public struct SLakeBlock * array;
    public void SDArray<SLakeBlock>(class SDArray<SLakeBlock> & );
    public void SDArray<SLakeBlock>();
    public void ~SDArray<SLakeBlock>();
    public int Add(struct SLakeBlock & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SLakeBlock & operator[](int );
    public void operator=(class SDArray<SLakeBlock> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SLakeBlock>
{
    private int size;
    private int maxsize;
    public struct SLakeBlock * array;
    public void SDArray<SLakeBlock>(class SDArray<SLakeBlock> & );
    public void SDArray<SLakeBlock>();
    public void ~SDArray<SLakeBlock>();
    public int Add(struct SLakeBlock & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SLakeBlock & operator[](int );
    public void operator=(class SDArray<SLakeBlock> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SGLake
{
    int TextureIndex;
    int TextureIndex2;
    float Y;
    unsigned long Color;
    class SDArray<SLakeBlock> Blocks;
    int Flow;
    int Sparkle;
    void SGLake(struct SGLake * );
    void SGLake(struct SGLake & );
    void SGLake();
    void ~SGLake();
    struct SGLake & operator=(struct SGLake * );
    struct SGLake & operator=(struct SGLake & );
    void * __vecDelDtor(unsigned int );
};

class SHeap<SGLake>
{
    struct __Tstruct
    {
        int use;
        struct SGLake data;
        void __Tstruct(struct SHeap<SGLake>::__Tstruct * );
        void __Tstruct(struct SHeap<SGLake>::__Tstruct & );
        void __Tstruct();
        void ~__Tstruct();
        struct SHeap<SGLake>::__Tstruct & operator=(struct SHeap<SGLake>::__Tstruct * );
        struct SHeap<SGLake>::__Tstruct & operator=(struct SHeap<SGLake>::__Tstruct & );
        void * __vecDelDtor(unsigned int );
    };
    private struct SHeap<SGLake>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SGLake>();
    public void ~SHeap<SGLake>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SGLake & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SGLake>
{
    struct __Tstruct
    {
        int use;
        struct SGLake data;
        void __Tstruct(struct SHeap<SGLake>::__Tstruct * );
        void __Tstruct(struct SHeap<SGLake>::__Tstruct & );
        void __Tstruct();
        void ~__Tstruct();
        struct SHeap<SGLake>::__Tstruct & operator=(struct SHeap<SGLake>::__Tstruct * );
        struct SHeap<SGLake>::__Tstruct & operator=(struct SHeap<SGLake>::__Tstruct & );
        void * __vecDelDtor(unsigned int );
    };
    private struct SHeap<SGLake>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SGLake>();
    public void ~SHeap<SGLake>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SGLake & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SDynamicVB
{
    struct IDirect3DVertexBuffer9 * lpVertexBuffer;
    unsigned long NumVertices;
    unsigned long VertexFormat;
    int VertexSize;
    bool Locked;
    int LockPosition;
};

class SHeap<SDynamicVB>
{
    struct __Tstruct
    {
        int use;
        struct SDynamicVB data;
    };
    private struct SHeap<SDynamicVB>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SDynamicVB>();
    public void ~SHeap<SDynamicVB>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SDynamicVB & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SDynamicVB>
{
    struct __Tstruct
    {
        int use;
        struct SDynamicVB data;
    };
    private struct SHeap<SDynamicVB>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SDynamicVB>();
    public void ~SHeap<SDynamicVB>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SDynamicVB & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DSurface9>
{
    public void SmartPtr<IDirect3DSurface9>(class SmartPtr<IDirect3DSurface9> & );
    public void SmartPtr<IDirect3DSurface9>(struct IDirect3DSurface9 * );
    public void SmartPtr<IDirect3DSurface9>();
    public void ~SmartPtr<IDirect3DSurface9>();
    public void operator=(class SmartPtr<IDirect3DSurface9> & );
    public void operator=(struct IDirect3DSurface9 * );
    public struct IDirect3DSurface9 * operator struct IDirect3DSurface9 *();
    public struct IDirect3DSurface9 & operator*();
    public struct IDirect3DSurface9 * operator->();
    public struct IDirect3DSurface9 ** Receive();
    private struct IDirect3DSurface9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

class SmartPtr<IDirect3DSurface9>
{
    public void SmartPtr<IDirect3DSurface9>(class SmartPtr<IDirect3DSurface9> & );
    public void SmartPtr<IDirect3DSurface9>(struct IDirect3DSurface9 * );
    public void SmartPtr<IDirect3DSurface9>();
    public void ~SmartPtr<IDirect3DSurface9>();
    public void operator=(class SmartPtr<IDirect3DSurface9> & );
    public void operator=(struct IDirect3DSurface9 * );
    public struct IDirect3DSurface9 * operator struct IDirect3DSurface9 *();
    public struct IDirect3DSurface9 & operator*();
    public struct IDirect3DSurface9 * operator->();
    public struct IDirect3DSurface9 ** Receive();
    private struct IDirect3DSurface9 * Ptr;
    public void * __vecDelDtor(unsigned int );
};

class SAnimation : public SBitmap
{
    public void SAnimation();
    public void ~SAnimation();
    public bool LoadANI(char * ,char * );
    public bool NextFrame(bool );
    public int GetFrames();
    private unsigned int * Buffer;
    private int BufferLen;
    private int BufferPtr;
    private int CurrentFrame;
    private int Frames;
    private bool Anim2Format;
    public void * __vecDelDtor(unsigned int );
};

class SAnimation : public SBitmap
{
    public void SAnimation();
    public void ~SAnimation();
    public bool LoadANI(char * ,char * );
    public bool NextFrame(bool );
    public int GetFrames();
    private unsigned int * Buffer;
    private int BufferLen;
    private int BufferPtr;
    private int CurrentFrame;
    private int Frames;
    private bool Anim2Format;
    public void * __vecDelDtor(unsigned int );
};

union __m64
{
    unsigned int m64_u64;
    float m64_f32[2];
    char m64_i8[8];
    int m64_i16[4];
    int m64_i32[2];
    int m64_i64;
    unsigned int m64_u8[8];
    unsigned int m64_u16[4];
    unsigned int m64_u32[2];
};

union __m128
{
    float m128_f32[4];
    unsigned int m128_u64[2];
    char m128_i8[16];
    int m128_i16[8];
    int m128_i32[4];
    int m128_i64[2];
    unsigned int m128_u8[16];
    unsigned int m128_u16[8];
    unsigned int m128_u32[4];
};

struct stbi__context
{
    unsigned int img_x;
    unsigned int img_y;
    int img_n;
    int img_out_n;
    struct stbi_io_callbacks io;
    void * io_user_data;
    int read_from_callbacks;
    int buflen;
    unsigned int buffer_start[128];
    unsigned int * img_buffer;
    unsigned int * img_buffer_end;
    unsigned int * img_buffer_original;
    unsigned int * img_buffer_original_end;
};

struct stbi__result_info
{
    int bits_per_channel;
    int num_channels;
    int channel_order;
};

struct stbi__zhuffman
{
    unsigned int fast[512];
    unsigned int firstcode[16];
    int maxcode[17];
    unsigned int firstsymbol[16];
    unsigned int size[288];
    unsigned int value[288];
};

struct stbi__zbuf
{
    unsigned int * zbuffer;
    unsigned int * zbuffer_end;
    int num_bits;
    unsigned int code_buffer;
    char * zout;
    char * zout_start;
    char * zout_end;
    int z_expandable;
    struct stbi__zhuffman z_length;
    struct stbi__zhuffman z_distance;
};

struct stbi__pngchunk
{
    unsigned int length;
    unsigned int type;
};

struct stbi__png
{
    struct stbi__context * s;
    unsigned int * idata;
    unsigned int * expanded;
    unsigned int * out;
    int depth;
};

class STextureBitmap : public SBitmap
{
    public void STextureBitmap(struct IDirect3DTexture9 * ,int );
    public void ~STextureBitmap();
    private struct IDirect3DTexture9 * lpTexture;
    private int Level;
    public void * __vecDelDtor(unsigned int );
};

class SSurfaceBitmap : public SBitmap
{
    public void SSurfaceBitmap(struct IDirect3DSurface9 * );
    public void ~SSurfaceBitmap();
    private struct IDirect3DSurface9 * lpSurface;
    public void * __vecDelDtor(unsigned int );
};

class SShadowMask
{
    public void SShadowMask(class SStream * );
    public void SShadowMask(int ,int ,class SBitmap & );
    public void ~SShadowMask();
    public void MakeBitmap(class SBitmap & );
    public void Save(class SStream * );
    public int Width;
    public int Height;
    public int Pitch;
    public int Size;
    public unsigned int * Data;
    public void * __vecDelDtor(unsigned int );
};

class SShadowMask
{
    public void SShadowMask(class SStream * );
    public void SShadowMask(int ,int ,class SBitmap & );
    public void ~SShadowMask();
    public void MakeBitmap(class SBitmap & );
    public void Save(class SStream * );
    public int Width;
    public int Height;
    public int Pitch;
    public int Size;
    public unsigned int * Data;
    public void * __vecDelDtor(unsigned int );
};

class SShadowMask2
{
    public void SShadowMask2(class SStream * );
    public void SShadowMask2(class SShadowMask & );
    public void SShadowMask2(int ,int ,class SBitmap & );
    public void ~SShadowMask2();
    public void MakeBitmap(class SBitmap & );
    public void Save(class SStream * );
    public int Width;
    public int Height;
    public int Pitch;
    public int Size;
    public unsigned int * Data;
    public void * __vecDelDtor(unsigned int );
};

union Blt_A8R8G8B8_From_DXT1::__l2::<unnamed-type-c>
{
    unsigned long val;
    unsigned int r;
    unsigned int g;
    unsigned int b;
    unsigned int a;
};

union Blt_A8R8G8B8_From_DXT5::__l2::<unnamed-type-c>
{
    unsigned long val;
    unsigned int r;
    unsigned int g;
    unsigned int b;
    unsigned int a;
};

struct stbi_io_callbacks
{
    int  ( * read)(void * ,char * ,int );
    void  ( * skip)(void * ,int );
    int  ( * eof)(void * );
};

enum _D3DSHADEMODE
{
    D3DSHADE_FLAT=1,
    D3DSHADE_GOURAUD=2,
    D3DSHADE_PHONG=3,
    D3DSHADE_FORCE_DWORD=2147483647
};

enum _D3DBLEND
{
    D3DBLEND_ZERO=1,
    D3DBLEND_ONE=2,
    D3DBLEND_SRCCOLOR=3,
    D3DBLEND_INVSRCCOLOR=4,
    D3DBLEND_SRCALPHA=5,
    D3DBLEND_INVSRCALPHA=6,
    D3DBLEND_DESTALPHA=7,
    D3DBLEND_INVDESTALPHA=8,
    D3DBLEND_DESTCOLOR=9,
    D3DBLEND_INVDESTCOLOR=10,
    D3DBLEND_SRCALPHASAT=11,
    D3DBLEND_BOTHSRCALPHA=12,
    D3DBLEND_BOTHINVSRCALPHA=13,
    D3DBLEND_BLENDFACTOR=14,
    D3DBLEND_INVBLENDFACTOR=15,
    D3DBLEND_SRCCOLOR2=16,
    D3DBLEND_INVSRCCOLOR2=17,
    D3DBLEND_FORCE_DWORD=2147483647
};

enum _D3DTEXTUREADDRESS
{
    D3DTADDRESS_WRAP=1,
    D3DTADDRESS_MIRROR=2,
    D3DTADDRESS_CLAMP=3,
    D3DTADDRESS_BORDER=4,
    D3DTADDRESS_MIRRORONCE=5,
    D3DTADDRESS_FORCE_DWORD=2147483647
};

enum _D3DMATERIALCOLORSOURCE
{
    D3DMCS_MATERIAL=0,
    D3DMCS_COLOR1=1,
    D3DMCS_COLOR2=2,
    D3DMCS_FORCE_DWORD=2147483647
};

enum <unnamed-enum-VT_FILLED>
{
    VT_FILLED=1,
    VT_WIREFRAME=2,
    VT_TEXTURIZED=4,
    VT_SKETCHTEXTURE=8,
    VT_GOURAUD=16,
    VT_SPARSEWIREFRAME=32
};

enum <unnamed-enum-VERTEX_NORMAL>
{
    VERTEX_NORMAL=16,
    VERTEX_PSIZE=32,
    VERTEX_DIFFUSE=64,
    VERTEX_SPECULAR=128,
    VERTEX_TEXCOUNT_MASK=15,
    VERTEX_TEX0=0,
    VERTEX_TEX1=1,
    VERTEX_TEX2=2,
    VERTEX_TEX3=3,
    BASE_VERTEX=17,
    PLANE_VERTEX=65,
    LIT_VERTEX=81
};

enum <unnamed-enum-DRAW_TRIANGLES>
{
    DRAW_TRIANGLES=0,
    DRAW_LINES=1,
    DRAW_MULTI_MATERIAL=2,
    DRAW_TILE=4,
    DRAW_MULTI_MATERIAL_SHADOW=8,
    DRAW_MULTI_MATERIAL_SHADOW_SHADER=16,
    DRAW_TREE_BENDING=32,
    DRAW_TREE_WOBBLE=64
};

class STerrain : public SIPlane
{
    public void STerrain(class STerrain & );
    public void STerrain(class SGepard * ,int ,int );
    public void ~STerrain();
    public float GetHeight(float ,float );
    public float GetHeight(int ,int );
    public float GetHeightTriangular(float ,float );
    public struct D3DXVECTOR3 GetNormal(int ,int );
    public struct D3DXVECTOR3 GetEdgeNormal(float ,float );
    public float GetOldHeight(float ,float );
    public float GetOldHeight(int ,int );
    public void RaiseHeight(int ,int ,float );
    public void UpdateBlockMap(int );
    public bool IsVisible(float ,float ,int );
    public void CalculateVisibleParcels(struct D3DXMATRIX & ,struct D3DXMATRIX & );
    public bool IsParcelVisible(float ,float );
    public bool IsParcelVisible(int );
    public void Draw();
    public void DrawLighting();
    public void DrawShadow();
    public void DrawShadow2();
    public void DrawLimits();
    public int GetFogMode();
    public void Acquire(float &** ,float &** ,unsigned int &** [9],struct STile &** ,unsigned int &** );
    public void InitTileVariations(char * );
    public void InitTileset2();
    public void ReleaseTileset();
    public void InitLimits();
    public void LoadSketchTexture(char * );
    public void SetViewType(int );
    public void ComputeShadows();
    public void UpdateVisMap(unsigned int * ,unsigned int * ,int );
    public void Update(int ,int ,int ,int );
    public void UpdateColorMap(int ,int ,int ,int );
    public void UpdateLimits();
    public void EnableGodMode(bool );
    public void SetCompactMode(bool );
    public bool GetCompactMode();
    public void SetBlockMapAddress(unsigned int * ,unsigned int * );
    public void SetBlockMapMode(bool );
    public bool GetBlockMapMode();
    private struct IDirect3DDevice9 * lpD3DDev;
    private class SGepard * Gepard;
    private int XSize;
    private int ZSize;
    private int Stride;
    private int NumTiles;
    private int NumVertices;
    private float * HeightMap;
    private float * OldHeightMap;
    private unsigned int * BlendMap[9];
    private unsigned long * ColorMap;
    private struct D3DXVECTOR3 * NormalMap;
    private unsigned int * ShadowMap;
    private unsigned int * WaterMap;
    private int XParcels;
    private int ZParcels;
    private int NumParcels;
    private struct SParcelInfo * Parcels;
    private struct STile * TileMap;
    private int TileTextures[10];
    private int Variations[10];
    private class SString TilePrefix;
    private int ViewType;
    private struct D3DXMATRIX IdentityMatrix;
    private struct D3DXMATRIX WireframeLiftupMatrix;
    private struct SMaterial WireframeMaterial;
    private struct SMaterial Wireframe2Material;
    private int SketchTexture;
    private bool CompactMode;
    private class SMesh * LimitMesh;
    private int LimitTexture;
    private unsigned int * VisMap;
    private unsigned int * VisMap2;
    private int FogMode;
    private bool GodMode;
    private bool BlockMapMode;
    private unsigned int * BlockMap;
    private unsigned int * CurrentBlockMap;
    public class STerrain & operator=(class STerrain & );
    public void * __vecDelDtor(unsigned int );
};

class STerrain : public SIPlane
{
    public void STerrain(class STerrain & );
    public void STerrain(class SGepard * ,int ,int );
    public void ~STerrain();
    public float GetHeight(float ,float );
    public float GetHeight(int ,int );
    public float GetHeightTriangular(float ,float );
    public struct D3DXVECTOR3 GetNormal(int ,int );
    public struct D3DXVECTOR3 GetEdgeNormal(float ,float );
    public float GetOldHeight(float ,float );
    public float GetOldHeight(int ,int );
    public void RaiseHeight(int ,int ,float );
    public void UpdateBlockMap(int );
    public bool IsVisible(float ,float ,int );
    public void CalculateVisibleParcels(struct D3DXMATRIX & ,struct D3DXMATRIX & );
    public bool IsParcelVisible(float ,float );
    public bool IsParcelVisible(int );
    public void Draw();
    public void DrawLighting();
    public void DrawShadow();
    public void DrawShadow2();
    public void DrawLimits();
    public int GetFogMode();
    public void Acquire(float &** ,float &** ,unsigned int &** [9],struct STile &** ,unsigned int &** );
    public void InitTileVariations(char * );
    public void InitTileset2();
    public void ReleaseTileset();
    public void InitLimits();
    public void LoadSketchTexture(char * );
    public void SetViewType(int );
    public void ComputeShadows();
    public void UpdateVisMap(unsigned int * ,unsigned int * ,int );
    public void Update(int ,int ,int ,int );
    public void UpdateColorMap(int ,int ,int ,int );
    public void UpdateLimits();
    public void EnableGodMode(bool );
    public void SetCompactMode(bool );
    public bool GetCompactMode();
    public void SetBlockMapAddress(unsigned int * ,unsigned int * );
    public void SetBlockMapMode(bool );
    public bool GetBlockMapMode();
    private struct IDirect3DDevice9 * lpD3DDev;
    private class SGepard * Gepard;
    private int XSize;
    private int ZSize;
    private int Stride;
    private int NumTiles;
    private int NumVertices;
    private float * HeightMap;
    private float * OldHeightMap;
    private unsigned int * BlendMap[9];
    private unsigned long * ColorMap;
    private struct D3DXVECTOR3 * NormalMap;
    private unsigned int * ShadowMap;
    private unsigned int * WaterMap;
    private int XParcels;
    private int ZParcels;
    private int NumParcels;
    private struct SParcelInfo * Parcels;
    private struct STile * TileMap;
    private int TileTextures[10];
    private int Variations[10];
    private class SString TilePrefix;
    private int ViewType;
    private struct D3DXMATRIX IdentityMatrix;
    private struct D3DXMATRIX WireframeLiftupMatrix;
    private struct SMaterial WireframeMaterial;
    private struct SMaterial Wireframe2Material;
    private int SketchTexture;
    private bool CompactMode;
    private class SMesh * LimitMesh;
    private int LimitTexture;
    private unsigned int * VisMap;
    private unsigned int * VisMap2;
    private int FogMode;
    private bool GodMode;
    private bool BlockMapMode;
    private unsigned int * BlockMap;
    private unsigned int * CurrentBlockMap;
    public class STerrain & operator=(class STerrain & );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SBitmap *>
{
    private int size;
    private int maxsize;
    public class SBitmap ** array;
    public void SDArray<SBitmap *>(class SDArray<SBitmap *> & );
    public void SDArray<SBitmap *>();
    public void ~SDArray<SBitmap *>();
    public int Add(class SBitmap &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SBitmap &** operator[](int );
    public void operator=(class SDArray<SBitmap *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SBitmap *>
{
    private int size;
    private int maxsize;
    public class SBitmap ** array;
    public void SDArray<SBitmap *>(class SDArray<SBitmap *> & );
    public void SDArray<SBitmap *>();
    public void ~SDArray<SBitmap *>();
    public int Add(class SBitmap &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SBitmap &** operator[](int );
    public void operator=(class SDArray<SBitmap *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SMesh
{
    public void SMesh(class SMesh & );
    public void SMesh(class SGepard * ,int );
    public void ~SMesh();
    public void AddRef();
    public void Release();
    public void Draw(int ,int ,float );
    public void Draw(int );
    public void CreateVertexBuffer(int );
    public void LockVertexBuffer();
    public void UnlockVertexBuffer();
    public unsigned int * CreateIndexBuffer(int ,int );
    public void LockIndexBuffer(int );
    public void UnlockIndexBuffer(int );
    public struct SMeshMaterial * CreateMaterialBuffer(int );
    public unsigned long GetNumVertices();
    protected unsigned long RefCount;
    protected struct IDirect3DDevice9 * lpD3DDev;
    protected class SGepard * Gepard;
    protected struct IDirect3DVertexBuffer9 * lpVertexBuffer;
    protected void * lpVertices;
    protected unsigned long NumVertices;
    protected unsigned long VertexFormat;
    protected int VertexSize;
    protected int OffsetXYZ;
    protected int OffsetNormal;
    protected int OffsetDiffuse;
    protected int OffsetSpecular;
    protected int OffsetTexture1;
    protected int OffsetTexture2;
    protected int OffsetTexture3;
    protected struct IDirect3DIndexBuffer9 * lpIndexBuffer[3];
    protected unsigned int * lpIndices[3];
    protected unsigned long NumIndices[3];
    protected struct SMeshMaterial * lpMaterials;
    protected unsigned long NumMaterials;
    public struct D3DXVECTOR3 & DVCoords(int );
    public struct D3DXVECTOR3 & DVNormal(int );
    public unsigned long & DVDiffuseColor(int );
    public unsigned long & DVSpecularColor(int );
    public struct D3DXVECTOR2 & DVTextureCoords(int );
    public struct D3DXVECTOR2 & DVTextureCoords2(int );
    public struct D3DXVECTOR2 & DVTextureCoords3(int );
    public unsigned int & DI(int );
    public unsigned int & DI1(int );
    public unsigned int & DI2(int );
    public class SMesh & operator=(class SMesh & );
    public void * __vecDelDtor(unsigned int );
};

class SMesh
{
    public void SMesh(class SMesh & );
    public void SMesh(class SGepard * ,int );
    public void ~SMesh();
    public void AddRef();
    public void Release();
    public void Draw(int ,int ,float );
    public void Draw(int );
    public void CreateVertexBuffer(int );
    public void LockVertexBuffer();
    public void UnlockVertexBuffer();
    public unsigned int * CreateIndexBuffer(int ,int );
    public void LockIndexBuffer(int );
    public void UnlockIndexBuffer(int );
    public struct SMeshMaterial * CreateMaterialBuffer(int );
    public unsigned long GetNumVertices();
    protected unsigned long RefCount;
    protected struct IDirect3DDevice9 * lpD3DDev;
    protected class SGepard * Gepard;
    protected struct IDirect3DVertexBuffer9 * lpVertexBuffer;
    protected void * lpVertices;
    protected unsigned long NumVertices;
    protected unsigned long VertexFormat;
    protected int VertexSize;
    protected int OffsetXYZ;
    protected int OffsetNormal;
    protected int OffsetDiffuse;
    protected int OffsetSpecular;
    protected int OffsetTexture1;
    protected int OffsetTexture2;
    protected int OffsetTexture3;
    protected struct IDirect3DIndexBuffer9 * lpIndexBuffer[3];
    protected unsigned int * lpIndices[3];
    protected unsigned long NumIndices[3];
    protected struct SMeshMaterial * lpMaterials;
    protected unsigned long NumMaterials;
    public struct D3DXVECTOR3 & DVCoords(int );
    public struct D3DXVECTOR3 & DVNormal(int );
    public unsigned long & DVDiffuseColor(int );
    public unsigned long & DVSpecularColor(int );
    public struct D3DXVECTOR2 & DVTextureCoords(int );
    public struct D3DXVECTOR2 & DVTextureCoords2(int );
    public struct D3DXVECTOR2 & DVTextureCoords3(int );
    public unsigned int & DI(int );
    public unsigned int & DI1(int );
    public unsigned int & DI2(int );
    public class SMesh & operator=(class SMesh & );
    public void * __vecDelDtor(unsigned int );
};

struct SMeshMaterial
{
    int TextureIndex;
    int TextureIndex2;
    int NumFaces;
    int StartVertex;
    int NumVertices;
    int Flags;
};

struct SParcelInfo
{
    class SParcel * Mesh;
    class SParcel2 * Mesh2;
    class SMesh * BlockMapMesh;
    bool Visible;
    float LowPoint;
};

class SParcel : public SMesh
{
    public void SParcel(class SParcel & );
    public void SParcel(class SGepard * ,int ,int );
    public void ~SParcel();
    public void Update(float * ,unsigned int * [9],unsigned long * ,struct D3DXVECTOR3 * ,int );
    public void DrawLayered(int ,int * );
    public void DrawWireframe(int );
    public void DrawSketch(int ,int ,int ,int );
    public void DrawSimple();
    private bool BlendVisible[9];
    public class SParcel & operator=(class SParcel & );
    public void * __vecDelDtor(unsigned int );
};

class SParcel : public SMesh
{
    public void SParcel(class SParcel & );
    public void SParcel(class SGepard * ,int ,int );
    public void ~SParcel();
    public void Update(float * ,unsigned int * [9],unsigned long * ,struct D3DXVECTOR3 * ,int );
    public void DrawLayered(int ,int * );
    public void DrawWireframe(int );
    public void DrawSketch(int ,int ,int ,int );
    public void DrawSimple();
    private bool BlendVisible[9];
    public class SParcel & operator=(class SParcel & );
    public void * __vecDelDtor(unsigned int );
};

class SParcel2 : public SMesh
{
    public void SParcel2(class SParcel2 & );
    public void SParcel2(class SGepard * ,int ,int ,float * ,unsigned int * [9],unsigned long * ,struct D3DXVECTOR3 * ,int ,int ,int * );
    public void ~SParcel2();
    public void Update(unsigned long * ,unsigned int * ,int ,int );
    public void UpdateFullBright();
    private unsigned int * ParcelVertices;
    public class SParcel2 & operator=(class SParcel2 & );
    public void * __vecDelDtor(unsigned int );
};

class SParcel2 : public SMesh
{
    public void SParcel2(class SParcel2 & );
    public void SParcel2(class SGepard * ,int ,int ,float * ,unsigned int * [9],unsigned long * ,struct D3DXVECTOR3 * ,int ,int ,int * );
    public void ~SParcel2();
    public void Update(unsigned long * ,unsigned int * ,int ,int );
    public void UpdateFullBright();
    private unsigned int * ParcelVertices;
    public class SParcel2 & operator=(class SParcel2 & );
    public void * __vecDelDtor(unsigned int );
};

class SGroup : public SIObject
{
    private unsigned long RefCount;
    private struct IDirect3DDevice9 * lpD3DDev;
    private class SGepard * Gepard;
    private class SDArray<SMeshProp> MeshArray;
    private class STransformation Transformation;
    private class STransformation LastTransformation;
    private bool Recalculate;
    private int LastRecalculated;
    private enum SDrawType DrawType;
    private bool ambientMode;
    private struct _D3DCOLORVALUE ambientColor;
    private int Type;
    private bool Visible;
    private int GepardIndex;
    private unsigned long Flags;
    private bool IsColorized;
    private struct SColorizeConstants ColorizeConstants;
    private float treeBendParams[4];
    private float treeBendAmplitude;
    private float treeBendFreqX;
    private float treeBendFreqZ;
    private float treeBendPhaseX;
    private float treeBendPhaseZ;
    private float treeWobbleParams[4];
    private float treeWobbleAmplitude;
    public void SGroup(class SGroup & );
    public void SGroup(class SGroup & ,bool ,int );
    public void SGroup(class SGepard * ,enum SDrawType );
    public void ~SGroup();
    public void AddRef();
    public void Release();
    public void GetInternalIndex(bool & ,int & );
    public void Replace(class SGroup & );
    public void SetMeshVisible(int ,bool );
    public void SetMeshCanCastShadows(int ,bool );
    public bool Load4DFile(char * ,char * ,float );
    public bool LoadNew4DFile(char * ,char * ,float );
    public void ForceUpdate();
    public void Precalculate();
    public void PrecalculateForShadow();
    public void Draw();
    public void DrawShadowHack();
    public void DrawShadowHack2();
    public void DrawShadow();
    public void DrawShadow2();
    public void ComputeVisBounding(float & ,float & ,float & ,float & );
    public void ComputeShadowBounding(float & ,float & ,float & ,float & );
    public void ComputeProjectedShadowBounding(float & ,float & ,float & ,float & );
    public void ComputeTransformedBounding(float & ,float & ,float & ,float & ,float & ,float & ,float ,float );
    public void GetPosition(float & ,float & ,float & );
    public void SetMatrix(struct D3DXMATRIX );
    public void SetPosition(float ,float ,float );
    public void SetRotation(float ,float ,float );
    public void SetScale(float );
    public void SetRotation2(float ,float ,float );
    public void SetRelativeRotation(float ,float ,float ,float );
    public void SetAmbient(struct _D3DCOLORVALUE );
    public void SetAmbient(float );
    public void SetColorizeProperties(int ,float ,float );
    public void SetTreeParams(float ,float );
    public int GetMeshIndex(char * );
    public int GetMeshIndex2(char * );
    public char * GetMeshName(int );
    public class SDArray<SString> GetMeshNames();
    public void SetMeshProperties(int ,float ,float ,float ,float ,float ,float );
    public void SetMeshPosition(int ,float ,float ,float );
    public void SetMeshRotation(int ,float ,float ,float );
    public void SetMeshRotation2(int ,float ,float );
    public void SetMeshUVTransformActive(int ,bool );
    public void SetMeshUVTransformValue(int ,float );
    public void GetMeshProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshProperties(int ,float & ,float & ,float & );
    public struct SMatrix4 GetMeshProperties(int );
    public void GetMeshProperties(int ,struct D3DXMATRIX & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,struct D3DXMATRIX & );
    public void Show(bool );
    public void SetFlags(unsigned long );
    public void SaveStatus();
    public void LogTransforms(struct _iobuf * );
    struct SEffects
    {
        struct SGroup::SEffects * prev;
        struct SGroup::SEffects * next;
        void * effect;
    };
    public class SChain<SGroup::SEffects> Effects;
    public void * SetEffect(void * );
    public void ClearEffect(void * );
    public bool IsVisible();
    public bool NeedNewShadow;
    public bool CanCastShadow();
    public class SShadowMask2 * ShadowMask2;
    public float ShadowMaskUMin;
    public float ShadowMaskUMax;
    public float ShadowMaskVMin;
    public float ShadowMaskVMax;
    public int ShadowTexture;
    public class SMesh * ShadowMesh;
    public int SMX0;
    public int SMZ0;
    public int SMX1;
    public int SMZ1;
    public void ClearShadow(bool );
    public void GetScreenPos(float & ,float & ,float & );
    public float GetClickDistanceSquare(float ,float );
    public bool CheckClickBox(float ,float ,float ,float );
    public void GetInterpolatedPosition(float & ,float & ,float & );
    public int VisClass;
    public int Selection;
    public void SetVisClass(int );
    public void SetSelection(int );
    public bool GetActivationState();
    public void SetActivationState(bool );
    public bool Activated;
    public class SGroup & operator=(class SGroup & );
    public void * __vecDelDtor(unsigned int );
};

class SGroup : public SIObject
{
    private unsigned long RefCount;
    private struct IDirect3DDevice9 * lpD3DDev;
    private class SGepard * Gepard;
    private class SDArray<SMeshProp> MeshArray;
    private class STransformation Transformation;
    private class STransformation LastTransformation;
    private bool Recalculate;
    private int LastRecalculated;
    private enum SDrawType DrawType;
    private bool ambientMode;
    private struct _D3DCOLORVALUE ambientColor;
    private int Type;
    private bool Visible;
    private int GepardIndex;
    private unsigned long Flags;
    private bool IsColorized;
    private struct SColorizeConstants ColorizeConstants;
    private float treeBendParams[4];
    private float treeBendAmplitude;
    private float treeBendFreqX;
    private float treeBendFreqZ;
    private float treeBendPhaseX;
    private float treeBendPhaseZ;
    private float treeWobbleParams[4];
    private float treeWobbleAmplitude;
    public void SGroup(class SGroup & );
    public void SGroup(class SGroup & ,bool ,int );
    public void SGroup(class SGepard * ,enum SDrawType );
    public void ~SGroup();
    public void AddRef();
    public void Release();
    public void GetInternalIndex(bool & ,int & );
    public void Replace(class SGroup & );
    public void SetMeshVisible(int ,bool );
    public void SetMeshCanCastShadows(int ,bool );
    public bool Load4DFile(char * ,char * ,float );
    public bool LoadNew4DFile(char * ,char * ,float );
    public void ForceUpdate();
    public void Precalculate();
    public void PrecalculateForShadow();
    public void Draw();
    public void DrawShadowHack();
    public void DrawShadowHack2();
    public void DrawShadow();
    public void DrawShadow2();
    public void ComputeVisBounding(float & ,float & ,float & ,float & );
    public void ComputeShadowBounding(float & ,float & ,float & ,float & );
    public void ComputeProjectedShadowBounding(float & ,float & ,float & ,float & );
    public void ComputeTransformedBounding(float & ,float & ,float & ,float & ,float & ,float & ,float ,float );
    public void GetPosition(float & ,float & ,float & );
    public void SetMatrix(struct D3DXMATRIX );
    public void SetPosition(float ,float ,float );
    public void SetRotation(float ,float ,float );
    public void SetScale(float );
    public void SetRotation2(float ,float ,float );
    public void SetRelativeRotation(float ,float ,float ,float );
    public void SetAmbient(struct _D3DCOLORVALUE );
    public void SetAmbient(float );
    public void SetColorizeProperties(int ,float ,float );
    public void SetTreeParams(float ,float );
    public int GetMeshIndex(char * );
    public int GetMeshIndex2(char * );
    public char * GetMeshName(int );
    public class SDArray<SString> GetMeshNames();
    public void SetMeshProperties(int ,float ,float ,float ,float ,float ,float );
    public void SetMeshPosition(int ,float ,float ,float );
    public void SetMeshRotation(int ,float ,float ,float );
    public void SetMeshRotation2(int ,float ,float );
    public void SetMeshUVTransformActive(int ,bool );
    public void SetMeshUVTransformValue(int ,float );
    public void GetMeshProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshProperties(int ,float & ,float & ,float & );
    public struct SMatrix4 GetMeshProperties(int );
    public void GetMeshProperties(int ,struct D3DXMATRIX & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,float & ,float & ,float & );
    public void GetMeshInterpolatedProperties(int ,struct D3DXMATRIX & );
    public void Show(bool );
    public void SetFlags(unsigned long );
    public void SaveStatus();
    public void LogTransforms(struct _iobuf * );
    struct SEffects
    {
        struct SGroup::SEffects * prev;
        struct SGroup::SEffects * next;
        void * effect;
    };
    public class SChain<SGroup::SEffects> Effects;
    public void * SetEffect(void * );
    public void ClearEffect(void * );
    public bool IsVisible();
    public bool NeedNewShadow;
    public bool CanCastShadow();
    public class SShadowMask2 * ShadowMask2;
    public float ShadowMaskUMin;
    public float ShadowMaskUMax;
    public float ShadowMaskVMin;
    public float ShadowMaskVMax;
    public int ShadowTexture;
    public class SMesh * ShadowMesh;
    public int SMX0;
    public int SMZ0;
    public int SMX1;
    public int SMZ1;
    public void ClearShadow(bool );
    public void GetScreenPos(float & ,float & ,float & );
    public float GetClickDistanceSquare(float ,float );
    public bool CheckClickBox(float ,float ,float ,float );
    public void GetInterpolatedPosition(float & ,float & ,float & );
    public int VisClass;
    public int Selection;
    public void SetVisClass(int );
    public void SetSelection(int );
    public bool GetActivationState();
    public void SetActivationState(bool );
    public bool Activated;
    public class SGroup & operator=(class SGroup & );
    public void * __vecDelDtor(unsigned int );
};

class SEffect
{
    public void SEffect(class SGepard * );
    public void ~SEffect();
    public void DestroyPlayingEffects();
    public void PlayEffect(int ,class SIObject * ,class SDArray<SAblak> * );
    public void PlayEffect(int ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    public void * PlayEffect(int ,float ,float ,float ,float );
    public void PlayEffect(int ,class SIObject * ,char * ,int );
    public int LoadEffect(char * ,char * ,float ,float );
    public void MoveEffects();
    public void CleanUpPointersInCurrentPlayingEffect();
    public void StopEffect(void * );
    public void RefreshIndices(void * );
    public void TrackEffect(void * ,float ,float ,float ,float );
    public void PorzasParameterek(void * ,float ,bool ,float ,float ,float ,float );
    public class SProperties * EffectsINI;
    public class SHeap<SEffectDesc> EffectsLoaded;
    public class SChain<SEffectDesc2> EffectsPlaying;
    public class SGepard * Gepard;
    public struct IDirect3DDevice9 * lpD3DDev;
    public int minh;
    public int maxh;
    public void Init_ShaderLight(struct SShaderLight * ,char * );
    public struct SShaderLight * Clone_ShaderLight(struct SShaderLight * ,float ,float ,float );
    public bool Move_ShaderLight(struct SShaderLight * );
    public struct SBoom * Clone_Boom(struct SBoom * ,float ,float ,float );
    public void Init_Boom(struct SBoom * ,char * );
    public bool Move_Boom(struct SBoom * );
    public void Init_Ghost(struct SGhost * ,char * );
    public struct SGhost * Clone_Ghost(struct SGhost * ,float ,float ,float );
    public bool Move_Ghost(struct SGhost * );
    public void Init_TT(struct STT * ,char * );
    public void Init_Lokeshullam(struct SLokeshullam * ,char * );
    public struct SLokeshullam * Clone_Lokeshullam(struct SLokeshullam * ,float ,float ,float );
    public bool Move_Lokeshullam(struct SLokeshullam * );
    public void Init_Lighting(struct SLighting * ,char * );
    public struct SLighting * Clone_Lighting(struct SLighting * ,float ,float ,float );
    public bool Move_Lighting(struct SLighting * );
    public void ClearGlow(void * );
    public void AddGlow(void * ,float ,float ,float ,int ,int ,int ,int ,float );
    public void Init_Reflektor(struct SReflektor * ,char * );
    public struct SReflektor * Clone_Reflektor(struct SReflektor * ,class SIObject * );
    public bool Move_Reflektor(struct SReflektor * );
    public void Reflektor_RefreshIndices(struct SReflektor * );
    public void * __vecDelDtor(unsigned int );
};

class SPtr<SMesh>
{
    private class SMesh * ptr;
    public void SPtr<SMesh>(class SPtr<SMesh> & );
    public void SPtr<SMesh>();
    public void ~SPtr<SMesh>();
    public class SPtr<SMesh> & operator=(class SMesh * );
    public class SPtr<SMesh> & operator=(class SPtr<SMesh> & );
    public class SMesh * operator->();
    public void * __vecDelDtor(unsigned int );
};

struct SMeshProp
{
    class SString MeshName;
    int Parent;
    struct D3DXMATRIX OriginMatrix;
    struct D3DXMATRIX WorldMatrix;
    class STransformation Transformation;
    class STransformation LastTransformation;
    bool HasUVTranslate;
    float UVTranslate;
    float LastUVTranslate;
    bool Visible;
    bool CanCastShadows;
    class SPtr<SMesh> Mesh;
    struct D3DXVECTOR3 Bound[8];
    void SMeshProp(struct SMeshProp * );
    void SMeshProp(struct SMeshProp & );
    void SMeshProp();
    void ~SMeshProp();
    struct SMeshProp & operator=(struct SMeshProp * );
    struct SMeshProp & operator=(struct SMeshProp & );
    void * __vecDelDtor(unsigned int );
};

struct SMeshProp
{
    class SString MeshName;
    int Parent;
    struct D3DXMATRIX OriginMatrix;
    struct D3DXMATRIX WorldMatrix;
    class STransformation Transformation;
    class STransformation LastTransformation;
    bool HasUVTranslate;
    float UVTranslate;
    float LastUVTranslate;
    bool Visible;
    bool CanCastShadows;
    class SPtr<SMesh> Mesh;
    struct D3DXVECTOR3 Bound[8];
    void SMeshProp(struct SMeshProp * );
    void SMeshProp(struct SMeshProp & );
    void SMeshProp();
    void ~SMeshProp();
    struct SMeshProp & operator=(struct SMeshProp * );
    struct SMeshProp & operator=(struct SMeshProp & );
    void * __vecDelDtor(unsigned int );
};

class SDArray<SMeshProp>
{
    private int size;
    private int maxsize;
    public struct SMeshProp * array;
    public void SDArray<SMeshProp>(class SDArray<SMeshProp> & );
    public void SDArray<SMeshProp>();
    public void ~SDArray<SMeshProp>();
    public int Add(struct SMeshProp & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SMeshProp & operator[](int );
    public void operator=(class SDArray<SMeshProp> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SMeshProp>
{
    private int size;
    private int maxsize;
    public struct SMeshProp * array;
    public void SDArray<SMeshProp>(class SDArray<SMeshProp> & );
    public void SDArray<SMeshProp>();
    public void ~SDArray<SMeshProp>();
    public int Add(struct SMeshProp & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SMeshProp & operator[](int );
    public void operator=(class SDArray<SMeshProp> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class STransformation
{
    public struct D3DXVECTOR3 Translation;
    public float Scale;
    public struct D3DXQUATERNION Rotation;
    public void STransformation(class STransformation & ,class STransformation & ,float );
    public void STransformation();
    public void Identity();
    public void SetRotation(float ,float ,float );
    public struct SMatrix4 GetMatrix();
    public void GetMatrix(struct D3DXMATRIX & );
    public void LogToFile(struct _iobuf * );
};

struct SColorizeConstants
{
    float R;
    float G;
    float B;
    float dummy0;
    float SM;
    float VM;
    float dummy1;
    float dummy2;
};

struct SGroup::SEffects
{
    struct SGroup::SEffects * prev;
    struct SGroup::SEffects * next;
    void * effect;
};

class SChain<SGroup::SEffects>
{
    private struct SGroup::SEffects * first;
    private struct SGroup::SEffects * last;
    private struct SGroup::SEffects * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SGroup::SEffects>();
    public void ~SChain<SGroup::SEffects>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SGroup::SEffects * StepToFirst();
    public struct SGroup::SEffects * StepToLast();
    public struct SGroup::SEffects * GetNext();
    public struct SGroup::SEffects * GetNext2();
    public struct SGroup::SEffects * GetPrev();
    public struct SGroup::SEffects * GetCurrent();
    public struct SGroup::SEffects * StepToNext();
    public struct SGroup::SEffects * StepToPrev();
    public struct SGroup::SEffects * Append(struct SGroup::SEffects * ,bool );
    public struct SGroup::SEffects * AppendNew(bool );
    public struct SGroup::SEffects * GetFirst();
    public struct SGroup::SEffects * GetSecond();
    public struct SGroup::SEffects * GetThird();
    public struct SGroup::SEffects * GetLastButOne();
    public struct SGroup::SEffects * GetLast();
    public struct SGroup::SEffects * InsertOver(struct SGroup::SEffects * ,bool );
    public struct SGroup::SEffects * InsertOverNew(bool );
    public struct SGroup::SEffects * InsertUnder(struct SGroup::SEffects * ,bool );
    public struct SGroup::SEffects * InsertUnderNew(bool );
    public void Delete(struct SGroup::SEffects * );
    public void Delete();
    public void DeleteAll();
    public struct SGroup::SEffects * GetPointer(int );
    public struct SGroup::SEffects * StepToIndex(int );
    public struct SGroup::SEffects & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SGroup::SEffects * );
    public void StepToPointer(struct SGroup::SEffects * );
    public void SendToBack(struct SGroup::SEffects * );
    public void BringToFront(struct SGroup::SEffects * );
    public void Swap(struct SGroup::SEffects * ,struct SGroup::SEffects * );
    public void * __vecDelDtor(unsigned int );
};

class SParticles4
{
    public void SParticles4(class SParticles4 & );
    public void SParticles4(class SParticles4 * ,class SIObject * ,char * ,int );
    public void SParticles4(class SParticles4 * ,float ,float ,float ,float );
    public void SParticles4(char * ,class SEffect * ,class SGepard * );
    public void ~SParticles4();
    public int PrecacheObject(char * ,enum SDrawType );
    public bool MoveParticles();
    public void SetPosition(float ,float ,float );
    public void StopEffect();
    public void CloneParticles(class SParticles4 * );
    public void RefreshIndices();
    public class SDArray<int> GroupPrototypes;
    public class SDArray<int> GroupPrototypeQs;
    public class SDArray<SParticles4Data> data;
    public float MainX;
    public float MainY;
    public float MainZ;
    public float X;
    public float Y;
    public float Z;
    public int ManageType;
    public int Darabszam;
    public float HSpeed;
    public float HSpeed_Rnd;
    public float KisG;
    public float VSpeed;
    public float VSpeed_Rnd;
    public int TalajKoszolas;
    public float Scale;
    public float FadeInSpeed;
    public float BorningSpeed;
    public float BorningCounter;
    public float FadeOutSpeed;
    public float FadeOutSpeed_Rnd;
    public float RandomR;
    public float MainR;
    public unsigned long ColorR;
    public unsigned long ColorG;
    public unsigned long ColorB;
    public float StartAlpha;
    public float StartTimeMoment;
    public float StopTimeMoment;
    public float StopTimeDuration;
    public float Variations;
    public float RecVariations;
    public class SIObject * Object;
    public int MeshIdx;
    public char MeshName[200];
    public bool Stopping;
    public float ScaleSpeed;
    public int THandle;
    public int SHandle;
    public bool BorningState;
    public float BorningStateCounter;
    public int BorningEnabledTime;
    public int BorningDisabledTime;
    public int BorningEnabledTimeRND;
    public int BorningDisabledTimeRND;
    public enum SDrawType DrawType;
    public bool Prototype;
    public char ClassName[120];
    public bool LensStarted;
    public int sz;
    public int Race;
    public float LensEffectLaunch;
    private class SEffect * Effect;
    private class SGepard * Gepard;
    private class SWorld * World;
    public class SParticles4 & operator=(class SParticles4 & );
    public void * __vecDelDtor(unsigned int );
};

struct SParticles4Data
{
    float x;
    float y;
    float z;
    float mainx;
    float mainz;
    float vectorx;
    float vectorz;
    float yspeed;
    float rotcounter;
    float kisg;
    int tindex;
    bool active;
    float alpha;
    float fadeoutspeed;
    int whichtexture;
    float scale;
    float randomr;
    bool fadein;
};

class SDArray<SParticles4Data>
{
    private int size;
    private int maxsize;
    public struct SParticles4Data * array;
    public void SDArray<SParticles4Data>(class SDArray<SParticles4Data> & );
    public void SDArray<SParticles4Data>();
    public void ~SDArray<SParticles4Data>();
    public int Add(struct SParticles4Data & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticles4Data & operator[](int );
    public void operator=(class SDArray<SParticles4Data> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SParticles4Data>
{
    private int size;
    private int maxsize;
    public struct SParticles4Data * array;
    public void SDArray<SParticles4Data>(class SDArray<SParticles4Data> & );
    public void SDArray<SParticles4Data>();
    public void ~SDArray<SParticles4Data>();
    public int Add(struct SParticles4Data & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticles4Data & operator[](int );
    public void operator=(class SDArray<SParticles4Data> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SParticles4Data
{
    float x;
    float y;
    float z;
    float mainx;
    float mainz;
    float vectorx;
    float vectorz;
    float yspeed;
    float rotcounter;
    float kisg;
    int tindex;
    bool active;
    float alpha;
    float fadeoutspeed;
    int whichtexture;
    float scale;
    float randomr;
    bool fadein;
};

struct SEffectDesc
{
    int type;
    void * userdata;
};

class SHeap<SEffectDesc>
{
    struct __Tstruct
    {
        int use;
        struct SEffectDesc data;
    };
    private struct SHeap<SEffectDesc>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SEffectDesc>();
    public void ~SHeap<SEffectDesc>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SEffectDesc & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SEffectDesc>
{
    struct __Tstruct
    {
        int use;
        struct SEffectDesc data;
    };
    private struct SHeap<SEffectDesc>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SEffectDesc>();
    public void ~SHeap<SEffectDesc>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SEffectDesc & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SEffectDesc2
{
    struct SEffectDesc2 * next;
    struct SEffectDesc2 * prev;
    int type;
    void * userdata;
    void * effectringofobject;
};

class SChain<SEffectDesc2>
{
    private struct SEffectDesc2 * first;
    private struct SEffectDesc2 * last;
    private struct SEffectDesc2 * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SEffectDesc2>();
    public void ~SChain<SEffectDesc2>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SEffectDesc2 * StepToFirst();
    public struct SEffectDesc2 * StepToLast();
    public struct SEffectDesc2 * GetNext();
    public struct SEffectDesc2 * GetNext2();
    public struct SEffectDesc2 * GetPrev();
    public struct SEffectDesc2 * GetCurrent();
    public struct SEffectDesc2 * StepToNext();
    public struct SEffectDesc2 * StepToPrev();
    public struct SEffectDesc2 * Append(struct SEffectDesc2 * ,bool );
    public struct SEffectDesc2 * AppendNew(bool );
    public struct SEffectDesc2 * GetFirst();
    public struct SEffectDesc2 * GetSecond();
    public struct SEffectDesc2 * GetThird();
    public struct SEffectDesc2 * GetLastButOne();
    public struct SEffectDesc2 * GetLast();
    public struct SEffectDesc2 * InsertOver(struct SEffectDesc2 * ,bool );
    public struct SEffectDesc2 * InsertOverNew(bool );
    public struct SEffectDesc2 * InsertUnder(struct SEffectDesc2 * ,bool );
    public struct SEffectDesc2 * InsertUnderNew(bool );
    public void Delete(struct SEffectDesc2 * );
    public void Delete();
    public void DeleteAll();
    public struct SEffectDesc2 * GetPointer(int );
    public struct SEffectDesc2 * StepToIndex(int );
    public struct SEffectDesc2 & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SEffectDesc2 * );
    public void StepToPointer(struct SEffectDesc2 * );
    public void SendToBack(struct SEffectDesc2 * );
    public void BringToFront(struct SEffectDesc2 * );
    public void Swap(struct SEffectDesc2 * ,struct SEffectDesc2 * );
    public void * __vecDelDtor(unsigned int );
};

struct SShaderLight
{
    struct SShader2Info * s2i;
    int thandle;
    int thandle0;
    int thandle1;
    int thandle2;
    int thandle3;
    int thandle4;
    enum SDrawType drawtype;
    float eltunes_kezdete;
    float eltunes_sebesseg;
    float felfutas_sebesseg;
    bool multitileset;
    int forcebright;
};

struct SBoom
{
    class SDArray<int> thandles;
    float framenr;
    float frameinc;
    float x;
    float y;
    float z;
    int drawtype;
    float scale;
    void SBoom(struct SBoom * );
    void SBoom(struct SBoom & );
    void SBoom();
    void ~SBoom();
    struct SBoom & operator=(struct SBoom * );
    struct SBoom & operator=(struct SBoom & );
    void * __vecDelDtor(unsigned int );
};

struct SGhost
{
    int thandle;
    float x;
    float y;
    float z;
    float alpha;
    float eltunes_kezdete;
    float eltunes_sebesseg;
    float felfutas_sebesseg;
    float nagyitas_sebesseg;
    float aktualis_meret;
    float felszallas_sebesseg;
    float magassag;
    float kiteres_mertek;
    float kiteres_sebesseg;
    float orix;
    float oriz;
};

struct STT
{
    class SDArray<int> thandles;
    void STT(struct STT * );
    void STT(struct STT & );
    void STT();
    void ~STT();
    struct STT & operator=(struct STT * );
    struct STT & operator=(struct STT & );
    void * __vecDelDtor(unsigned int );
};

struct SLokeshullam
{
    int Prototype;
    class SIObject * object;
    float scale;
    float scalespeed;
    float intensity;
    float disappearance;
};

struct SLighting
{
    char lightingdata[200];
    int lightingFPS;
    float lightingpos;
};

struct SReflektor
{
    int thandle;
    class SIObject * object;
    int managetype;
    int meshidx;
};

struct SParticles4::MoveParticles::__l42::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long diffuse;
    float u;
    float v;
};

enum _D3DTEXTUREOP
{
    D3DTOP_DISABLE=1,
    D3DTOP_SELECTARG1=2,
    D3DTOP_SELECTARG2=3,
    D3DTOP_MODULATE=4,
    D3DTOP_MODULATE2X=5,
    D3DTOP_MODULATE4X=6,
    D3DTOP_ADD=7,
    D3DTOP_ADDSIGNED=8,
    D3DTOP_ADDSIGNED2X=9,
    D3DTOP_SUBTRACT=10,
    D3DTOP_ADDSMOOTH=11,
    D3DTOP_BLENDDIFFUSEALPHA=12,
    D3DTOP_BLENDTEXTUREALPHA=13,
    D3DTOP_BLENDFACTORALPHA=14,
    D3DTOP_BLENDTEXTUREALPHAPM=15,
    D3DTOP_BLENDCURRENTALPHA=16,
    D3DTOP_PREMODULATE=17,
    D3DTOP_MODULATEALPHA_ADDCOLOR=18,
    D3DTOP_MODULATECOLOR_ADDALPHA=19,
    D3DTOP_MODULATEINVALPHA_ADDCOLOR=20,
    D3DTOP_MODULATEINVCOLOR_ADDALPHA=21,
    D3DTOP_BUMPENVMAP=22,
    D3DTOP_BUMPENVMAPLUMINANCE=23,
    D3DTOP_DOTPRODUCT3=24,
    D3DTOP_MULTIPLYADD=25,
    D3DTOP_LERP=26,
    D3DTOP_FORCE_DWORD=2147483647
};

class SParticles3
{
    public void SParticles3(class SParticles3 & );
    public void SParticles3(class SParticles3 * ,class SIObject * ,char * );
    public void SParticles3(class SParticles3 * ,float ,float ,float ,float );
    public void SParticles3(char * ,class SEffect * ,class SGepard * ,float ,float );
    public void ~SParticles3();
    public int PrecacheObject(char * ,enum SDrawType );
    public bool MoveParticles();
    public void SetPosition(float ,float ,float );
    public void StopEffect();
    public void CloneParticles(class SParticles3 * );
    public void RefreshIndices();
    public class SDArray<int> GroupPrototypes;
    public class SDArray<int> GroupPrototypeQs;
    public class SDArray<SParticles3Data> data;
    public int DynamicVB;
    public int MaxParticles;
    public float MainX;
    public float MainY;
    public float MainZ;
    public float X;
    public float Y;
    public float Z;
    public int ManageType;
    public int Darabszam;
    public float HSpeed;
    public float HSpeed_Rnd;
    public float KisG;
    public float VSpeed;
    public float VSpeed_Rnd;
    public int TalajKoszolas;
    public float Scale;
    public float BorningSpeed;
    public float BorningCounter;
    public float FadeOutSpeed;
    public float FadeOutSpeed_Rnd;
    public float RandomX;
    public float RandomZ;
    public unsigned long Color;
    public float StartAlpha;
    public float StartTimeMoment;
    public float StopTimeMoment;
    public float StopTimeDuration;
    public float Variations;
    public float RecVariations;
    public class SIObject * Object;
    public char MeshName[200];
    public int TorkolatMeshIdx;
    public bool Stopping;
    public float ScaleSpeed;
    public int THandle;
    public bool BorningState;
    public float BorningStateCounter;
    public int BorningEnabledTime;
    public int BorningDisabledTime;
    public int BorningEnabledTimeRND;
    public int BorningDisabledTimeRND;
    public float LokalisSzelirany;
    public float SzelIrany1;
    public float SzelIrany2;
    public float SzelIranyVecX1;
    public float SzelIranyVecZ1;
    public float SzelIranyVecX2;
    public float SzelIranyVecZ2;
    public float SzelEro1;
    public float SzelEro2;
    public float SzelMagassag1;
    public float SzelMagassag2;
    public float SzelMagRatioConv1;
    public float SzelMagRatioConv2;
    public float SzelTime1;
    public float SzelTime2;
    public float SzelSpinDir1;
    public float SzelSpinDir2;
    public float SzelLokesEro1;
    public float SzelLokesEro2;
    public float SzelLokesSebesseg1;
    public float SzelLokesSebesseg2;
    public float SzelLokesCounter1;
    public float SzelLokesCounter2;
    public bool SzelLokesMode1;
    public bool SzelLokesMode2;
    public bool NoWind;
    public void GetSzelVector(float & ,float ,float & );
    public enum SDrawType DrawType;
    public bool Prototype;
    public char ClassName[120];
    public int sz;
    private class SEffect * Effect;
    private class SGepard * Gepard;
    private class SWorld * World;
    public class SParticles3 & operator=(class SParticles3 & );
    public void * __vecDelDtor(unsigned int );
};

struct SParticles3Data
{
    float x;
    float y;
    float z;
    float vectorx;
    float vectorz;
    float yspeed;
    float kisg;
    int tindex;
    float alpha;
    float fadeoutspeed;
    int whichtexture;
    float scale;
};

class SDArray<SParticles3Data>
{
    private int size;
    private int maxsize;
    public struct SParticles3Data * array;
    public void SDArray<SParticles3Data>(class SDArray<SParticles3Data> & );
    public void SDArray<SParticles3Data>();
    public void ~SDArray<SParticles3Data>();
    public int Add(struct SParticles3Data & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticles3Data & operator[](int );
    public void operator=(class SDArray<SParticles3Data> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SParticles3Data>
{
    private int size;
    private int maxsize;
    public struct SParticles3Data * array;
    public void SDArray<SParticles3Data>(class SDArray<SParticles3Data> & );
    public void SDArray<SParticles3Data>();
    public void ~SDArray<SParticles3Data>();
    public int Add(struct SParticles3Data & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticles3Data & operator[](int );
    public void operator=(class SDArray<SParticles3Data> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SParticles3Data
{
    float x;
    float y;
    float z;
    float vectorx;
    float vectorz;
    float yspeed;
    float kisg;
    int tindex;
    float alpha;
    float fadeoutspeed;
    int whichtexture;
    float scale;
};

struct SParticles3::MoveParticles::__l59::SMyVertex
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long diffuse;
    unsigned long specular;
    float u;
    float v;
};

class SParticles2
{
    public void SParticles2(class SParticles2 & );
    public void SParticles2(class SParticles2 * ,float ,float ,float );
    public void SParticles2(char * ,class SEffect * ,class SGepard * );
    public void ~SParticles2();
    public int PrecacheObject(char * ,enum SDrawType );
    public bool MoveParticles();
    public void SetPosition(float ,float ,float );
    public class SDArray<int> GroupPrototypes;
    public class SDArray<int> GroupPrototypeQs;
    public class SDArray<SParticles2Data> data;
    public int DynamicVB;
    public int MaxParticles;
    public float MainX;
    public float MainY;
    public float MainZ;
    public float X;
    public float Y;
    public float Z;
    public int Darabszam;
    public float HSpeed;
    public float HSpeed_Rnd;
    public float KisG;
    public float VSpeed;
    public float VSpeed_Rnd;
    public int TalajKoszolas;
    public float Scale;
    public float ScaleRnd;
    public unsigned long Color;
    public float FadeOutSpeed;
    public float FadeOutSpeed_Rnd;
    public int THandle;
    public int THandle0;
    public int THandle1;
    public int THandle2;
    public int THandle3;
    public int THandle4;
    public bool MultiTileset;
    public enum SDrawType DrawType;
    public bool Prototype;
    public char ClassName[120];
    public int sz;
    private class SEffect * Effect;
    private class SGepard * Gepard;
    private class SWorld * World;
    public class SParticles2 & operator=(class SParticles2 & );
    public void * __vecDelDtor(unsigned int );
};

struct SParticles2Data
{
    float x;
    float y;
    float z;
    float vectorx;
    float vectorz;
    float yspeed;
    float kisg;
    int tindex;
    bool active;
    float alpha;
    float fadeoutspeed;
    float scale;
};

class SDArray<SParticles2Data>
{
    private int size;
    private int maxsize;
    public struct SParticles2Data * array;
    public void SDArray<SParticles2Data>(class SDArray<SParticles2Data> & );
    public void SDArray<SParticles2Data>();
    public void ~SDArray<SParticles2Data>();
    public int Add(struct SParticles2Data & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticles2Data & operator[](int );
    public void operator=(class SDArray<SParticles2Data> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SParticles2Data>
{
    private int size;
    private int maxsize;
    public struct SParticles2Data * array;
    public void SDArray<SParticles2Data>(class SDArray<SParticles2Data> & );
    public void SDArray<SParticles2Data>();
    public void ~SDArray<SParticles2Data>();
    public int Add(struct SParticles2Data & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticles2Data & operator[](int );
    public void operator=(class SDArray<SParticles2Data> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SParticles2Data
{
    float x;
    float y;
    float z;
    float vectorx;
    float vectorz;
    float yspeed;
    float kisg;
    int tindex;
    bool active;
    float alpha;
    float fadeoutspeed;
    float scale;
};

struct SParticles2::MoveParticles::__l13::SMyVertex
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long diffuse;
    unsigned long specular;
    float u;
    float v;
};

class SParticles
{
    public void SParticles(class SParticles & );
    public void SParticles(class SParticles * ,float ,float ,float );
    public void SParticles(class SParticles * ,class SIObject * ,char * ,int );
    public void SParticles(char * ,class SEffect * ,class SGepard * );
    public void ~SParticles();
    public void CloneParticles(class SParticles * );
    public int PrecacheObject(char * ,enum SDrawType ,int );
    public bool MoveParticles();
    public void SetPosition(float ,float ,float );
    public void RefreshIndices();
    public class SDArray<int> GroupPrototypes;
    public class SDArray<int> GroupPrototypeQs;
    public class SDArray<int> GroupPrototypes0;
    public class SDArray<int> GroupPrototypeQs0;
    public class SDArray<int> GroupPrototypes1;
    public class SDArray<int> GroupPrototypeQs1;
    public class SDArray<int> GroupPrototypes2;
    public class SDArray<int> GroupPrototypeQs2;
    public class SDArray<int> GroupPrototypes3;
    public class SDArray<int> GroupPrototypeQs3;
    public class SDArray<int> GroupPrototypes4;
    public class SDArray<int> GroupPrototypeQs4;
    public class SDArray<SParticlesData> data;
    public float MainX;
    public float MainY;
    public float MainZ;
    public float X;
    public float Y;
    public float Z;
    public int Darabszam;
    public int OsszesDarabszam;
    public float HSpeed;
    public float HSpeed_Rnd;
    public float KisG;
    public float ZRotSpeed;
    public float ZRotSpeed_Rnd;
    public float VSpeed;
    public float VSpeed_Rnd;
    public int Trail_Color;
    public float Trail_Strength;
    public float Trail_FadeSpeed;
    public float Trail_Scale;
    public int TalajKoszolas;
    public int BoomAfter;
    public bool MultiTileset;
    public float FadeOutSpeed;
    public float FadeOutSpeed_Rnd;
    public float TimeIntervall;
    public int ThisMeshRepeating;
    public class SParticles * Prototypes;
    public int LastedTime;
    public int TimePeriod;
    public float RandomX;
    public float RandomY;
    public float RandomZ;
    public int Race;
    public class SIObject * Object;
    public int MeshIdx;
    public int THandle;
    public enum SDrawType DrawType;
    public bool Prototype;
    public char ClassName[120];
    public char MeshName[200];
    public int sz;
    private class SEffect * Effect;
    private class SGepard * Gepard;
    private class SWorld * World;
    public class SParticles & operator=(class SParticles & );
    public void * __vecDelDtor(unsigned int );
};

struct SParticlesData
{
    float x;
    float y;
    float z;
    float xrot;
    float yrot;
    float zrot;
    float zrotspeed;
    float vectorx;
    float vectorz;
    float yspeed;
    float kisg;
    class SIObject * group;
    int smoketrailindex;
    bool active;
    float alpha;
    float fadeoutspeed;
};

class SDArray<SParticlesData>
{
    private int size;
    private int maxsize;
    public struct SParticlesData * array;
    public void SDArray<SParticlesData>(class SDArray<SParticlesData> & );
    public void SDArray<SParticlesData>();
    public void ~SDArray<SParticlesData>();
    public int Add(struct SParticlesData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticlesData & operator[](int );
    public void operator=(class SDArray<SParticlesData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SParticlesData>
{
    private int size;
    private int maxsize;
    public struct SParticlesData * array;
    public void SDArray<SParticlesData>(class SDArray<SParticlesData> & );
    public void SDArray<SParticlesData>();
    public void ~SDArray<SParticlesData>();
    public int Add(struct SParticlesData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SParticlesData & operator[](int );
    public void operator=(class SDArray<SParticlesData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SParticlesData
{
    float x;
    float y;
    float z;
    float xrot;
    float yrot;
    float zrot;
    float zrotspeed;
    float vectorx;
    float vectorz;
    float yspeed;
    float kisg;
    class SIObject * group;
    int smoketrailindex;
    bool active;
    float alpha;
    float fadeoutspeed;
};

enum _D3DCMPFUNC
{
    D3DCMP_NEVER=1,
    D3DCMP_LESS=2,
    D3DCMP_EQUAL=3,
    D3DCMP_LESSEQUAL=4,
    D3DCMP_GREATER=5,
    D3DCMP_NOTEQUAL=6,
    D3DCMP_GREATEREQUAL=7,
    D3DCMP_ALWAYS=8,
    D3DCMP_FORCE_DWORD=2147483647
};

enum _D3DTEXTURETRANSFORMFLAGS
{
    D3DTTFF_DISABLE=0,
    D3DTTFF_COUNT1=1,
    D3DTTFF_COUNT2=2,
    D3DTTFF_COUNT3=3,
    D3DTTFF_COUNT4=4,
    D3DTTFF_PROJECTED=256,
    D3DTTFF_FORCE_DWORD=2147483647
};

struct SPlaneVertex
{
    unsigned int x;
    unsigned int z;
    unsigned int alpha;
    unsigned int tx;
    unsigned int ty;
};

class SDArray<SPlaneVertex>
{
    private int size;
    private int maxsize;
    public struct SPlaneVertex * array;
    public void SDArray<SPlaneVertex>(class SDArray<SPlaneVertex> & );
    public void SDArray<SPlaneVertex>();
    public void ~SDArray<SPlaneVertex>();
    public int Add(struct SPlaneVertex & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SPlaneVertex & operator[](int );
    public void operator=(class SDArray<SPlaneVertex> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SPlaneVertex>
{
    private int size;
    private int maxsize;
    public struct SPlaneVertex * array;
    public void SDArray<SPlaneVertex>(class SDArray<SPlaneVertex> & );
    public void SDArray<SPlaneVertex>();
    public void ~SDArray<SPlaneVertex>();
    public int Add(struct SPlaneVertex & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SPlaneVertex & operator[](int );
    public void operator=(class SDArray<SPlaneVertex> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SPlaneVertex
{
    unsigned int x;
    unsigned int z;
    unsigned int alpha;
    unsigned int tx;
    unsigned int ty;
};

class SDArray<unsigned short>
{
    private int size;
    private int maxsize;
    public unsigned int * array;
    public void SDArray<unsigned short>(class SDArray<unsigned short> & );
    public void SDArray<unsigned short>();
    public void ~SDArray<unsigned short>();
    public int Add(unsigned int & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int & operator[](int );
    public void operator=(class SDArray<unsigned short> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<unsigned short>
{
    private int size;
    private int maxsize;
    public unsigned int * array;
    public void SDArray<unsigned short>(class SDArray<unsigned short> & );
    public void SDArray<unsigned short>();
    public void ~SDArray<unsigned short>();
    public int Add(unsigned int & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int & operator[](int );
    public void operator=(class SDArray<unsigned short> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SMeshMaterial
{
    int TextureIndex;
    int TextureIndex2;
    int NumFaces;
    int StartVertex;
    int NumVertices;
    int Flags;
};

class SDArray<SMeshMaterial>
{
    private int size;
    private int maxsize;
    public struct SMeshMaterial * array;
    public void SDArray<SMeshMaterial>(class SDArray<SMeshMaterial> & );
    public void SDArray<SMeshMaterial>();
    public void ~SDArray<SMeshMaterial>();
    public int Add(struct SMeshMaterial & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SMeshMaterial & operator[](int );
    public void operator=(class SDArray<SMeshMaterial> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SMeshMaterial>
{
    private int size;
    private int maxsize;
    public struct SMeshMaterial * array;
    public void SDArray<SMeshMaterial>(class SDArray<SMeshMaterial> & );
    public void SDArray<SMeshMaterial>();
    public void ~SDArray<SMeshMaterial>();
    public int Add(struct SMeshMaterial & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SMeshMaterial & operator[](int );
    public void operator=(class SDArray<SMeshMaterial> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

enum <unnamed-enum-MATERIAL_DOUBLESIDED>
{
    MATERIAL_DOUBLESIDED=1,
    MATERIAL_ENVIRONMENT=2,
    MATERIAL_SELFILL=4
};

enum <unnamed-enum-ALPHA_NONE>
{
    ALPHA_NONE=0,
    ALPHA_1BIT=1,
    ALPHA_BLEND=2,
    ALPHA_COLORMASK=3,
    ALPHA_PREMULTIPLY=4
};

enum <unnamed-enum-GROUP_PROTOTYPE>
{
    GROUP_PROTOTYPE=0,
    GROUP_DYNAMIC=1,
    GROUP_HASHED=2
};

enum _D3DZBUFFERTYPE
{
    D3DZB_FALSE=0,
    D3DZB_TRUE=1,
    D3DZB_USEW=2,
    D3DZB_FORCE_DWORD=2147483647
};

class SGlow
{
    public void SGlow(class SGlow & );
    public void SGlow(char * ,class SEffect * ,class SGepard * );
    public void ~SGlow();
    public bool DrawParticles();
    public void ClearGlow();
    public void AddGlow(float ,float ,float ,int ,int ,int ,int ,float );
    public class SDArray<SGlowData> data;
    public int ManageType;
    public int Darabszam;
    public float Scale;
    public float Variations;
    public float RecVariations;
    public int THandle;
    public enum SDrawType DrawType;
    public char ClassName[120];
    public bool FirstTime;
    public bool StopNow;
    public int sz;
    private class SEffect * Effect;
    private class SGepard * Gepard;
    private class SWorld * World;
    public class SGlow & operator=(class SGlow & );
    public void * __vecDelDtor(unsigned int );
};

struct SGlowData
{
    float x;
    float y;
    float z;
    bool active;
    int whichtexture;
    int scale;
    int r;
    int g;
    int b;
    bool needtofadeout;
    float fadeing;
};

class SDArray<SGlowData>
{
    private int size;
    private int maxsize;
    public struct SGlowData * array;
    public void SDArray<SGlowData>(class SDArray<SGlowData> & );
    public void SDArray<SGlowData>();
    public void ~SDArray<SGlowData>();
    public int Add(struct SGlowData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SGlowData & operator[](int );
    public void operator=(class SDArray<SGlowData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SGlowData>
{
    private int size;
    private int maxsize;
    public struct SGlowData * array;
    public void SDArray<SGlowData>(class SDArray<SGlowData> & );
    public void SDArray<SGlowData>();
    public void ~SDArray<SGlowData>();
    public int Add(struct SGlowData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SGlowData & operator[](int );
    public void operator=(class SDArray<SGlowData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SGlowData
{
    float x;
    float y;
    float z;
    bool active;
    int whichtexture;
    int scale;
    int r;
    int g;
    int b;
    bool needtofadeout;
    float fadeing;
};

struct SGlow::DrawParticles::__l9::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long diffuse;
    float u;
    float v;
};

class Array<DebugLineVertex>
{
    public void Array<DebugLineVertex>(class Array<DebugLineVertex> * );
    public void Array<DebugLineVertex>(class Array<DebugLineVertex> & );
    public void Array<DebugLineVertex>();
    public void ~Array<DebugLineVertex>();
    public void operator=(class ArrayRef<DebugLineVertex> & );
    public void operator=(class Array<DebugLineVertex> * );
    public void operator=(class Array<DebugLineVertex> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct DebugLineVertex & operator[](unsigned int );
    public struct DebugLineVertex & operator[](unsigned int );
    public struct DebugLineVertex & GetLast();
    public struct DebugLineVertex & GetLast();
    public void Add(struct DebugLineVertex * );
    public void Add(struct DebugLineVertex & );
    public void Insert(unsigned int ,struct DebugLineVertex * );
    public void Insert(unsigned int ,struct DebugLineVertex & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct DebugLineVertex & );
    public void RemoveLast();
    public struct DebugLineVertex * begin();
    public struct DebugLineVertex * begin();
    public struct DebugLineVertex * end();
    public struct DebugLineVertex * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<DebugLineVertex> operator class ArrayRef<struct DebugLineVertex>();
    private struct DebugLineVertex * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct DebugLineVertex * Allocate(unsigned int );
    private void Deallocate(struct DebugLineVertex * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ArrayRef<DebugLineVertex>
{
};

struct DebugLineVertex
{
    class SVector v;
    unsigned long color;
    void DebugLineVertex();
};

class Array<DebugLineVertex>
{
    public void Array<DebugLineVertex>(class Array<DebugLineVertex> * );
    public void Array<DebugLineVertex>(class Array<DebugLineVertex> & );
    public void Array<DebugLineVertex>();
    public void ~Array<DebugLineVertex>();
    public void operator=(class ArrayRef<DebugLineVertex> & );
    public void operator=(class Array<DebugLineVertex> * );
    public void operator=(class Array<DebugLineVertex> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct DebugLineVertex & operator[](unsigned int );
    public struct DebugLineVertex & operator[](unsigned int );
    public struct DebugLineVertex & GetLast();
    public struct DebugLineVertex & GetLast();
    public void Add(struct DebugLineVertex * );
    public void Add(struct DebugLineVertex & );
    public void Insert(unsigned int ,struct DebugLineVertex * );
    public void Insert(unsigned int ,struct DebugLineVertex & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct DebugLineVertex & );
    public void RemoveLast();
    public struct DebugLineVertex * begin();
    public struct DebugLineVertex * begin();
    public struct DebugLineVertex * end();
    public struct DebugLineVertex * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<DebugLineVertex> operator class ArrayRef<struct DebugLineVertex>();
    private struct DebugLineVertex * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct DebugLineVertex * Allocate(unsigned int );
    private void Deallocate(struct DebugLineVertex * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

enum <unnamed-enum-LT_NONE>
{
    LT_NONE=0,
    LT_DIRECTIONAL=1,
    LT_POINT=2
};

enum _D3DCULL
{
    D3DCULL_NONE=1,
    D3DCULL_CW=2,
    D3DCULL_CCW=3,
    D3DCULL_FORCE_DWORD=2147483647
};

enum _D3DSTENCILOP
{
    D3DSTENCILOP_KEEP=1,
    D3DSTENCILOP_ZERO=2,
    D3DSTENCILOP_REPLACE=3,
    D3DSTENCILOP_INCRSAT=4,
    D3DSTENCILOP_DECRSAT=5,
    D3DSTENCILOP_INVERT=6,
    D3DSTENCILOP_INCR=7,
    D3DSTENCILOP_DECR=8,
    D3DSTENCILOP_FORCE_DWORD=2147483647
};

enum _D3DFOGMODE
{
    D3DFOG_NONE=0,
    D3DFOG_EXP=1,
    D3DFOG_EXP2=2,
    D3DFOG_LINEAR=3,
    D3DFOG_FORCE_DWORD=2147483647
};

enum _D3DXREGISTER_SET
{
    D3DXRS_BOOL=0,
    D3DXRS_INT4=1,
    D3DXRS_FLOAT4=2,
    D3DXRS_SAMPLER=3,
    D3DXRS_FORCE_DWORD=2147483647
};

enum _D3DXPARAMETER_CLASS
{
    D3DXPC_SCALAR=0,
    D3DXPC_VECTOR=1,
    D3DXPC_MATRIX_ROWS=2,
    D3DXPC_MATRIX_COLUMNS=3,
    D3DXPC_OBJECT=4,
    D3DXPC_STRUCT=5,
    D3DXPC_FORCE_DWORD=2147483647
};

enum _D3DXPARAMETER_TYPE
{
    D3DXPT_VOID=0,
    D3DXPT_BOOL=1,
    D3DXPT_INT=2,
    D3DXPT_FLOAT=3,
    D3DXPT_STRING=4,
    D3DXPT_TEXTURE=5,
    D3DXPT_TEXTURE1D=6,
    D3DXPT_TEXTURE2D=7,
    D3DXPT_TEXTURE3D=8,
    D3DXPT_TEXTURECUBE=9,
    D3DXPT_SAMPLER=10,
    D3DXPT_SAMPLER1D=11,
    D3DXPT_SAMPLER2D=12,
    D3DXPT_SAMPLER3D=13,
    D3DXPT_SAMPLERCUBE=14,
    D3DXPT_PIXELSHADER=15,
    D3DXPT_VERTEXSHADER=16,
    D3DXPT_PIXELFRAGMENT=17,
    D3DXPT_VERTEXFRAGMENT=18,
    D3DXPT_UNSUPPORTED=19,
    D3DXPT_FORCE_DWORD=2147483647
};

struct _D3DXCONSTANTTABLE_DESC
{
    char * Creator;
    unsigned long Version;
    unsigned int Constants;
};

struct _D3DXCONSTANT_DESC
{
    char * Name;
    enum _D3DXREGISTER_SET RegisterSet;
    unsigned int RegisterIndex;
    unsigned int RegisterCount;
    enum _D3DXPARAMETER_CLASS Class;
    enum _D3DXPARAMETER_TYPE Type;
    unsigned int Rows;
    unsigned int Columns;
    unsigned int Elements;
    unsigned int StructMembers;
    unsigned int Bytes;
    void * DefaultValue;
};

enum _D3DXINCLUDE_TYPE
{
    D3DXINC_LOCAL=0,
    D3DXINC_SYSTEM=1,
    D3DXINC_FORCE_DWORD=2147483647
};

class SChain<SSplineRing>
{
    private struct SSplineRing * first;
    private struct SSplineRing * last;
    private struct SSplineRing * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SSplineRing>();
    public void ~SChain<SSplineRing>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SSplineRing * StepToFirst();
    public struct SSplineRing * StepToLast();
    public struct SSplineRing * GetNext();
    public struct SSplineRing * GetNext2();
    public struct SSplineRing * GetPrev();
    public struct SSplineRing * GetCurrent();
    public struct SSplineRing * StepToNext();
    public struct SSplineRing * StepToPrev();
    public struct SSplineRing * Append(struct SSplineRing * ,bool );
    public struct SSplineRing * AppendNew(bool );
    public struct SSplineRing * GetFirst();
    public struct SSplineRing * GetSecond();
    public struct SSplineRing * GetThird();
    public struct SSplineRing * GetLastButOne();
    public struct SSplineRing * GetLast();
    public struct SSplineRing * InsertOver(struct SSplineRing * ,bool );
    public struct SSplineRing * InsertOverNew(bool );
    public struct SSplineRing * InsertUnder(struct SSplineRing * ,bool );
    public struct SSplineRing * InsertUnderNew(bool );
    public void Delete(struct SSplineRing * );
    public void Delete();
    public void DeleteAll();
    public struct SSplineRing * GetPointer(int );
    public struct SSplineRing * StepToIndex(int );
    public struct SSplineRing & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SSplineRing * );
    public void StepToPointer(struct SSplineRing * );
    public void SendToBack(struct SSplineRing * );
    public void BringToFront(struct SSplineRing * );
    public void Swap(struct SSplineRing * ,struct SSplineRing * );
    public void * __vecDelDtor(unsigned int );
};

class SChain<SNodeInfo2>
{
    private struct SNodeInfo2 * first;
    private struct SNodeInfo2 * last;
    private struct SNodeInfo2 * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SNodeInfo2>();
    public void ~SChain<SNodeInfo2>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SNodeInfo2 * StepToFirst();
    public struct SNodeInfo2 * StepToLast();
    public struct SNodeInfo2 * GetNext();
    public struct SNodeInfo2 * GetNext2();
    public struct SNodeInfo2 * GetPrev();
    public struct SNodeInfo2 * GetCurrent();
    public struct SNodeInfo2 * StepToNext();
    public struct SNodeInfo2 * StepToPrev();
    public struct SNodeInfo2 * Append(struct SNodeInfo2 * ,bool );
    public struct SNodeInfo2 * AppendNew(bool );
    public struct SNodeInfo2 * GetFirst();
    public struct SNodeInfo2 * GetSecond();
    public struct SNodeInfo2 * GetThird();
    public struct SNodeInfo2 * GetLastButOne();
    public struct SNodeInfo2 * GetLast();
    public struct SNodeInfo2 * InsertOver(struct SNodeInfo2 * ,bool );
    public struct SNodeInfo2 * InsertOverNew(bool );
    public struct SNodeInfo2 * InsertUnder(struct SNodeInfo2 * ,bool );
    public struct SNodeInfo2 * InsertUnderNew(bool );
    public void Delete(struct SNodeInfo2 * );
    public void Delete();
    public void DeleteAll();
    public struct SNodeInfo2 * GetPointer(int );
    public struct SNodeInfo2 * StepToIndex(int );
    public struct SNodeInfo2 & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SNodeInfo2 * );
    public void StepToPointer(struct SNodeInfo2 * );
    public void SendToBack(struct SNodeInfo2 * );
    public void BringToFront(struct SNodeInfo2 * );
    public void Swap(struct SNodeInfo2 * ,struct SNodeInfo2 * );
    public void * __vecDelDtor(unsigned int );
};

struct SShaderClipboard
{
    class SString FileName;
    int X;
    int Z;
    int Rotation;
    void SShaderClipboard(struct SShaderClipboard * );
    void SShaderClipboard(struct SShaderClipboard & );
    void SShaderClipboard();
    void ~SShaderClipboard();
    struct SShaderClipboard & operator=(struct SShaderClipboard * );
    struct SShaderClipboard & operator=(struct SShaderClipboard & );
    void * __vecDelDtor(unsigned int );
};

class SDArray<SShaderClipboard>
{
    private int size;
    private int maxsize;
    public struct SShaderClipboard * array;
    public void SDArray<SShaderClipboard>(class SDArray<SShaderClipboard> & );
    public void SDArray<SShaderClipboard>();
    public void ~SDArray<SShaderClipboard>();
    public int Add(struct SShaderClipboard & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SShaderClipboard & operator[](int );
    public void operator=(class SDArray<SShaderClipboard> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SShaderClipboard>
{
    private int size;
    private int maxsize;
    public struct SShaderClipboard * array;
    public void SDArray<SShaderClipboard>(class SDArray<SShaderClipboard> & );
    public void SDArray<SShaderClipboard>();
    public void ~SDArray<SShaderClipboard>();
    public int Add(struct SShaderClipboard & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SShaderClipboard & operator[](int );
    public void operator=(class SDArray<SShaderClipboard> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SVertDiff
{
    float x;
    float y;
    float z;
    unsigned long diff;
    float u;
    float v;
};

struct SVert
{
    float x;
    float y;
    float z;
    float u;
    float v;
};

class SBoard : public SIBoard
{
    private struct IDirect3DDevice9 * lpD3DDev;
    private class SGepard * Gepard;
    private class SHeap<SFrame> Frames;
    private bool roundPixels;
    public void SBoard(class SBoard & );
    public void SBoard(class SGepard * );
    public void ~SBoard();
    public int CreateFrame(enum SFrameType ,int ,int ,int ,int ,bool );
    public void DestroyFrame(int );
    public void MoveFrame(int ,int ,int );
    public void MoveFrameFloat(int ,float ,float );
    public void ResizeFrame(int ,int ,int );
    public void ShowFrame(int ,bool );
    public void GravitateFrame(int ,int );
    public void GetFrameSize(int ,int & ,int & );
    public void SetSpriteGlyph(int ,int ,int );
    public void SetSpriteSepiaFilter(int ,bool ,unsigned long );
    public void SetTextColor(int ,unsigned long );
    public void SetText(int ,int ,int ,char * );
    public float GetTextEffectiveScaleFactor(int );
    public void RerenderText(int );
    public void SetTextF(int ,int ,int ,char * ,<btNoType> );
    public void SetTextV(int ,int ,int ,char * ,char * );
    public void SetBoxColor(int ,unsigned long );
    public void StartAnim(int ,char * ,int ,int ,int );
    public void StopAnim(int );
    public bool IsAnimPlaying(int );
    public void SetMinimapFont(int ,int );
    public void SetMinimapRotation(int ,float );
    public float GetMinimapRotation(int );
    public void SetScaleFactor(int ,float );
    public void SetPixelRounding(bool );
    private class SHeap<SFontProp> Fonts;
    public int LoadProportionalFont(char * ,int ,int ,unsigned int * ,int ,int ,int ,int );
    public int LoadTrueTypeFont(int ,enum TypeFace ,enum FontEffect ,int ,bool ,bool );
    public int LoadFixedFont(char * ,int ,int ,int ,int ,unsigned int * ,enum HDMode );
    public int LoadCustomFont(char * ,int ,struct SCustomGlyph * ,enum HDMode );
    public int LoadSingleFont(char * ,enum HDMode );
    public int AddRefFont(int );
    public void ReleaseFont(int );
    public int GetFontTexture(int );
    public void GetTextExtent(int ,char * ,int ,int & ,int & ,float );
    public struct HFONT__ * GetHFont(struct SFontProp & ,bool & ,float );
    private struct tagPOINT * CursorHotspots;
    private struct HICON__ ** CursorIcons;
    private int CursorFont;
    private int CursorGlyph;
    private int CursorX;
    private int CursorY;
    private int NumCursors;
    private int CursorSize;
    private bool CursorVisible;
    private bool HardwareCursor;
    private bool ForceSoftwareCursor;
    private void RenderCursor();
    private void InitHotspots();
    public void LoadCursorSet(float );
    public void UnloadCursorSet();
    public void SetCursor(int ,int ,int );
    public void ApplyHardwareCursor();
    struct FrameData
    {
        float xabs;
        float yabs;
        float scaleFactor;
    };
    private class SDArray<SBoard::FrameData> frameStack;
    public void Render();
    public class SBoard & operator=(class SBoard & );
    public void * __vecDelDtor(unsigned int );
};

struct SFrame
{
    float X;
    float Y;
    int Width;
    int Height;
    int Parent;
    int Child;
    int Sibling;
    int Flags;
    enum SFrameType Type;
    struct SFrame::_anonymous_3196::<unnamed-type-Sprite> Sprite;
    struct SFrame::_anonymous_3195::<unnamed-type-Text> Text;
    struct SFrame::_anonymous_3194::<unnamed-type-Box> Box;
    struct SFrame::_anonymous_3193::<unnamed-type-Anim> Anim;
    struct SFrame::_anonymous_3192::<unnamed-type-Minimap> Minimap;
    struct SFrame::_anonymous_3191::<unnamed-type-Scaler> Scaler;
};

struct SFrame::_anonymous_3191::<unnamed-type-Scaler>
{
    float ScaleFactor;
};

struct SFrame::_anonymous_3192::<unnamed-type-Minimap>
{
    int Font;
    struct SGlyph Glyph;
    float Rotation;
};

struct SFrame::_anonymous_3193::<unnamed-type-Anim>
{
    class SAnimation * Anim;
    int TextureIndex;
    unsigned long LastFrame;
    unsigned long EndTime;
    unsigned long FrameTime;
    int Flags;
    float MaxU;
    float MaxV;
};

struct SFrame::_anonymous_3194::<unnamed-type-Box>
{
    unsigned long Color;
};

struct SFrame::_anonymous_3195::<unnamed-type-Text>
{
    int Font;
    unsigned long Color;
    int Align;
    char * Text;
    char * ReducedText;
    int Width;
    int TrueTypeX;
    int TrueTypeY;
    int TrueTypeWidth;
    int TrueTypeHeight;
    int TrueTypeTextureIndex;
};

struct SFrame::_anonymous_3196::<unnamed-type-Sprite>
{
    int Font;
    struct SGlyph Glyph;
    unsigned long SepiaColor;
};

class SHeap<SFrame>
{
    struct __Tstruct
    {
        int use;
        struct SFrame data;
    };
    private struct SHeap<SFrame>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SFrame>();
    public void ~SHeap<SFrame>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SFrame & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SFrame>
{
    struct __Tstruct
    {
        int use;
        struct SFrame data;
    };
    private struct SHeap<SFrame>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SFrame>();
    public void ~SHeap<SFrame>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SFrame & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SFontProp>
{
    struct __Tstruct
    {
        int use;
        struct SFontProp data;
    };
    private struct SHeap<SFontProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SFontProp>();
    public void ~SHeap<SFontProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SFontProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SFontProp>
{
    struct __Tstruct
    {
        int use;
        struct SFontProp data;
    };
    private struct SHeap<SFontProp>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SFontProp>();
    public void ~SHeap<SFontProp>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SFontProp & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SRectFloat
{
    float Left;
    float Top;
    float Right;
    float Bottom;
};

struct SGlyph
{
    int Width;
    struct SRectFloat Src;
    struct SRectFloat Dest;
};

struct SFontProp
{
    int TextureIndex;
    int RefCount;
    int FirstGlyph;
    int LastGlyph;
    int TopMargin;
    int BottomMargin;
    int LeftMargin;
    int RightMargin;
    bool Italic;
    bool Bold;
    enum TypeFace typeFace;
    enum FontEffect fontEffect;
    int fontSize;
    struct SGlyph Glyphs[256];
};

struct SBoard::FrameData
{
    float xabs;
    float yabs;
    float scaleFactor;
};

struct SBoard::FrameData
{
    float xabs;
    float yabs;
    float scaleFactor;
};

class SDArray<SBoard::FrameData>
{
    private int size;
    private int maxsize;
    public struct SBoard::FrameData * array;
    public void SDArray<SBoard::FrameData>(class SDArray<SBoard::FrameData> & );
    public void SDArray<SBoard::FrameData>();
    public void ~SDArray<SBoard::FrameData>();
    public int Add(struct SBoard::FrameData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SBoard::FrameData & operator[](int );
    public void operator=(class SDArray<SBoard::FrameData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SBoard::FrameData>
{
    private int size;
    private int maxsize;
    public struct SBoard::FrameData * array;
    public void SDArray<SBoard::FrameData>(class SDArray<SBoard::FrameData> & );
    public void SDArray<SBoard::FrameData>();
    public void ~SDArray<SBoard::FrameData>();
    public int Add(struct SBoard::FrameData & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SBoard::FrameData & operator[](int );
    public void operator=(class SDArray<SBoard::FrameData> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SHeap<SObjectCacheProp>::__Tstruct
{
    int use;
    struct SObjectCacheProp data;
};

struct SHeap<SObjectProp>::__Tstruct
{
    int use;
    struct SObjectProp data;
};

struct SHeap<STextureProp>::__Tstruct
{
    int use;
    struct STextureProp data;
};

struct SHeap<SDynamicShaderProp>::__Tstruct
{
    int use;
    struct SDynamicShaderProp data;
};

struct SHeap<SRectProp>::__Tstruct
{
    int use;
    struct SRectProp data;
};

struct SHeap<SSmokeTrail>::__Tstruct
{
    int use;
    struct SSmokeTrail data;
};

struct SHeap<SGroundTrail>::__Tstruct
{
    int use;
    struct SGroundTrail data;
};

struct SHeap<SGLake>::__Tstruct
{
    int use;
    struct SGLake data;
    void __Tstruct(struct SHeap<SGLake>::__Tstruct * );
    void __Tstruct(struct SHeap<SGLake>::__Tstruct & );
    void __Tstruct();
    void ~__Tstruct();
    struct SHeap<SGLake>::__Tstruct & operator=(struct SHeap<SGLake>::__Tstruct * );
    struct SHeap<SGLake>::__Tstruct & operator=(struct SHeap<SGLake>::__Tstruct & );
    void * __vecDelDtor(unsigned int );
};

struct SHeap<SDynamicVB>::__Tstruct
{
    int use;
    struct SDynamicVB data;
};

class SChain<SRiverStripRing>
{
    private struct SRiverStripRing * first;
    private struct SRiverStripRing * last;
    private struct SRiverStripRing * current;
    private bool Closed;
    private int NumItems;
    public void SChain<SRiverStripRing>();
    public void ~SChain<SRiverStripRing>();
    public void CloseChain();
    public void OpenChain();
    public void Reset();
    public struct SRiverStripRing * StepToFirst();
    public struct SRiverStripRing * StepToLast();
    public struct SRiverStripRing * GetNext();
    public struct SRiverStripRing * GetNext2();
    public struct SRiverStripRing * GetPrev();
    public struct SRiverStripRing * GetCurrent();
    public struct SRiverStripRing * StepToNext();
    public struct SRiverStripRing * StepToPrev();
    public struct SRiverStripRing * Append(struct SRiverStripRing * ,bool );
    public struct SRiverStripRing * AppendNew(bool );
    public struct SRiverStripRing * GetFirst();
    public struct SRiverStripRing * GetSecond();
    public struct SRiverStripRing * GetThird();
    public struct SRiverStripRing * GetLastButOne();
    public struct SRiverStripRing * GetLast();
    public struct SRiverStripRing * InsertOver(struct SRiverStripRing * ,bool );
    public struct SRiverStripRing * InsertOverNew(bool );
    public struct SRiverStripRing * InsertUnder(struct SRiverStripRing * ,bool );
    public struct SRiverStripRing * InsertUnderNew(bool );
    public void Delete(struct SRiverStripRing * );
    public void Delete();
    public void DeleteAll();
    public struct SRiverStripRing * GetPointer(int );
    public struct SRiverStripRing * StepToIndex(int );
    public struct SRiverStripRing & operator[](int );
    public int GetNumberOfItems();
    public int FindIndex(struct SRiverStripRing * );
    public void StepToPointer(struct SRiverStripRing * );
    public void SendToBack(struct SRiverStripRing * );
    public void BringToFront(struct SRiverStripRing * );
    public void Swap(struct SRiverStripRing * ,struct SRiverStripRing * );
    public void * __vecDelDtor(unsigned int );
};

struct SRiverStripRing
{
    struct SRiverStripRing * next;
    struct SRiverStripRing * prev;
    unsigned long numvertices;
    float textureV1pos;
    float textureV2pos;
    int numverify;
    struct SXZ verify[14];
    struct SVertDiff * strip;
};

struct SXZ
{
    float x;
    float z;
};

struct SVertDiff2
{
    float x;
    float y;
    float z;
    unsigned long diff;
    float u;
    float v;
    float u2;
    float v2;
};

struct ID3DXBuffer : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void * GetBufferPointer();
    unsigned long GetBufferSize();
    void ID3DXBuffer(struct ID3DXBuffer * );
    void ID3DXBuffer(struct ID3DXBuffer & );
    void ID3DXBuffer();
    struct ID3DXBuffer & operator=(struct ID3DXBuffer * );
    struct ID3DXBuffer & operator=(struct ID3DXBuffer & );
};

struct ID3DXBuffer : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void * GetBufferPointer();
    unsigned long GetBufferSize();
    void ID3DXBuffer(struct ID3DXBuffer * );
    void ID3DXBuffer(struct ID3DXBuffer & );
    void ID3DXBuffer();
    struct ID3DXBuffer & operator=(struct ID3DXBuffer * );
    struct ID3DXBuffer & operator=(struct ID3DXBuffer & );
};

struct ID3DXInclude
{
    HRESULT Open(enum _D3DXINCLUDE_TYPE ,char * ,void * ,void ** ,unsigned int * );
    HRESULT Close(void * );
    void ID3DXInclude(struct ID3DXInclude * );
    void ID3DXInclude(struct ID3DXInclude & );
    void ID3DXInclude();
    struct ID3DXInclude & operator=(struct ID3DXInclude * );
    struct ID3DXInclude & operator=(struct ID3DXInclude & );
};

struct ID3DXInclude
{
    HRESULT Open(enum _D3DXINCLUDE_TYPE ,char * ,void * ,void ** ,unsigned int * );
    HRESULT Close(void * );
    void ID3DXInclude(struct ID3DXInclude * );
    void ID3DXInclude(struct ID3DXInclude & );
    void ID3DXInclude();
    struct ID3DXInclude & operator=(struct ID3DXInclude * );
    struct ID3DXInclude & operator=(struct ID3DXInclude & );
};

struct ID3DXConstantTable : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void * GetBufferPointer();
    unsigned long GetBufferSize();
    HRESULT GetDesc(struct _D3DXCONSTANTTABLE_DESC * );
    HRESULT GetConstantDesc(char * ,struct _D3DXCONSTANT_DESC * ,unsigned int * );
    unsigned int GetSamplerIndex(char * );
    char * GetConstant(char * ,unsigned int );
    char * GetConstantByName(char * ,char * );
    char * GetConstantElement(char * ,unsigned int );
    HRESULT SetDefaults(struct IDirect3DDevice9 * );
    HRESULT SetValue(struct IDirect3DDevice9 * ,char * ,void * ,unsigned int );
    HRESULT SetBool(struct IDirect3DDevice9 * ,char * ,int );
    HRESULT SetBoolArray(struct IDirect3DDevice9 * ,char * ,int * ,unsigned int );
    HRESULT SetInt(struct IDirect3DDevice9 * ,char * ,int );
    HRESULT SetIntArray(struct IDirect3DDevice9 * ,char * ,int * ,unsigned int );
    HRESULT SetFloat(struct IDirect3DDevice9 * ,char * ,float );
    HRESULT SetFloatArray(struct IDirect3DDevice9 * ,char * ,float * ,unsigned int );
    HRESULT SetVector(struct IDirect3DDevice9 * ,char * ,struct D3DXVECTOR4 * );
    HRESULT SetVectorArray(struct IDirect3DDevice9 * ,char * ,struct D3DXVECTOR4 * ,unsigned int );
    HRESULT SetMatrix(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * );
    HRESULT SetMatrixArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * ,unsigned int );
    HRESULT SetMatrixPointerArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX ** ,unsigned int );
    HRESULT SetMatrixTranspose(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * );
    HRESULT SetMatrixTransposeArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * ,unsigned int );
    HRESULT SetMatrixTransposePointerArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX ** ,unsigned int );
    void ID3DXConstantTable(struct ID3DXConstantTable * );
    void ID3DXConstantTable(struct ID3DXConstantTable & );
    void ID3DXConstantTable();
    struct ID3DXConstantTable & operator=(struct ID3DXConstantTable * );
    struct ID3DXConstantTable & operator=(struct ID3DXConstantTable & );
};

struct ID3DXConstantTable : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void * GetBufferPointer();
    unsigned long GetBufferSize();
    HRESULT GetDesc(struct _D3DXCONSTANTTABLE_DESC * );
    HRESULT GetConstantDesc(char * ,struct _D3DXCONSTANT_DESC * ,unsigned int * );
    unsigned int GetSamplerIndex(char * );
    char * GetConstant(char * ,unsigned int );
    char * GetConstantByName(char * ,char * );
    char * GetConstantElement(char * ,unsigned int );
    HRESULT SetDefaults(struct IDirect3DDevice9 * );
    HRESULT SetValue(struct IDirect3DDevice9 * ,char * ,void * ,unsigned int );
    HRESULT SetBool(struct IDirect3DDevice9 * ,char * ,int );
    HRESULT SetBoolArray(struct IDirect3DDevice9 * ,char * ,int * ,unsigned int );
    HRESULT SetInt(struct IDirect3DDevice9 * ,char * ,int );
    HRESULT SetIntArray(struct IDirect3DDevice9 * ,char * ,int * ,unsigned int );
    HRESULT SetFloat(struct IDirect3DDevice9 * ,char * ,float );
    HRESULT SetFloatArray(struct IDirect3DDevice9 * ,char * ,float * ,unsigned int );
    HRESULT SetVector(struct IDirect3DDevice9 * ,char * ,struct D3DXVECTOR4 * );
    HRESULT SetVectorArray(struct IDirect3DDevice9 * ,char * ,struct D3DXVECTOR4 * ,unsigned int );
    HRESULT SetMatrix(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * );
    HRESULT SetMatrixArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * ,unsigned int );
    HRESULT SetMatrixPointerArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX ** ,unsigned int );
    HRESULT SetMatrixTranspose(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * );
    HRESULT SetMatrixTransposeArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX * ,unsigned int );
    HRESULT SetMatrixTransposePointerArray(struct IDirect3DDevice9 * ,char * ,struct D3DXMATRIX ** ,unsigned int );
    void ID3DXConstantTable(struct ID3DXConstantTable * );
    void ID3DXConstantTable(struct ID3DXConstantTable & );
    void ID3DXConstantTable();
    struct ID3DXConstantTable & operator=(struct ID3DXConstantTable * );
    struct ID3DXConstantTable & operator=(struct ID3DXConstantTable & );
};

class Array<_D3DXMACRO>
{
    public void Array<_D3DXMACRO>(class Array<_D3DXMACRO> * );
    public void Array<_D3DXMACRO>(class Array<_D3DXMACRO> & );
    public void Array<_D3DXMACRO>();
    public void ~Array<_D3DXMACRO>();
    public void operator=(class ArrayRef<_D3DXMACRO> & );
    public void operator=(class Array<_D3DXMACRO> * );
    public void operator=(class Array<_D3DXMACRO> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct _D3DXMACRO & operator[](unsigned int );
    public struct _D3DXMACRO & operator[](unsigned int );
    public struct _D3DXMACRO & GetLast();
    public struct _D3DXMACRO & GetLast();
    public void Add(struct _D3DXMACRO * );
    public void Add(struct _D3DXMACRO & );
    public void Insert(unsigned int ,struct _D3DXMACRO * );
    public void Insert(unsigned int ,struct _D3DXMACRO & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct _D3DXMACRO & );
    public void RemoveLast();
    public struct _D3DXMACRO * begin();
    public struct _D3DXMACRO * begin();
    public struct _D3DXMACRO * end();
    public struct _D3DXMACRO * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<_D3DXMACRO> operator class ArrayRef<struct _D3DXMACRO>();
    private struct _D3DXMACRO * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct _D3DXMACRO * Allocate(unsigned int );
    private void Deallocate(struct _D3DXMACRO * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

class ArrayRef<_D3DXMACRO>
{
};

struct _D3DXMACRO
{
    char * Name;
    char * Definition;
};

class Array<_D3DXMACRO>
{
    public void Array<_D3DXMACRO>(class Array<_D3DXMACRO> * );
    public void Array<_D3DXMACRO>(class Array<_D3DXMACRO> & );
    public void Array<_D3DXMACRO>();
    public void ~Array<_D3DXMACRO>();
    public void operator=(class ArrayRef<_D3DXMACRO> & );
    public void operator=(class Array<_D3DXMACRO> * );
    public void operator=(class Array<_D3DXMACRO> & );
    public unsigned int GetCount();
    public void SetCount(unsigned int );
    public unsigned int GetCapacity();
    public void SetCapacity(unsigned int );
    public struct _D3DXMACRO & operator[](unsigned int );
    public struct _D3DXMACRO & operator[](unsigned int );
    public struct _D3DXMACRO & GetLast();
    public struct _D3DXMACRO & GetLast();
    public void Add(struct _D3DXMACRO * );
    public void Add(struct _D3DXMACRO & );
    public void Insert(unsigned int ,struct _D3DXMACRO * );
    public void Insert(unsigned int ,struct _D3DXMACRO & );
    public void Clear();
    public void RemoveAt(unsigned int );
    public void Remove(struct _D3DXMACRO & );
    public void RemoveLast();
    public struct _D3DXMACRO * begin();
    public struct _D3DXMACRO * begin();
    public struct _D3DXMACRO * end();
    public struct _D3DXMACRO * end();
    public void Serialize(class ReadIOBuffer & );
    public void Serialize(class WriteIOBuffer & );
    public class ArrayRef<_D3DXMACRO> operator class ArrayRef<struct _D3DXMACRO>();
    private struct _D3DXMACRO * array;
    private unsigned int count;
    private unsigned int capacity;
    private struct _D3DXMACRO * Allocate(unsigned int );
    private void Deallocate(struct _D3DXMACRO * );
    private void Grow();
    public void * __vecDelDtor(unsigned int );
};

struct DebugLineVertex
{
    class SVector v;
    unsigned long color;
    void DebugLineVertex();
};

struct SSmokeTrailPoint
{
    struct D3DXVECTOR3 Vector;
    float Scale;
    float TextureV;
    float Alpha;
    unsigned long StartTime;
    void SSmokeTrailPoint();
};

class SDArray<SSmokeTrailPoint>
{
    private int size;
    private int maxsize;
    public struct SSmokeTrailPoint * array;
    public void SDArray<SSmokeTrailPoint>(class SDArray<SSmokeTrailPoint> & );
    public void SDArray<SSmokeTrailPoint>();
    public void ~SDArray<SSmokeTrailPoint>();
    public int Add(struct SSmokeTrailPoint & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSmokeTrailPoint & operator[](int );
    public void operator=(class SDArray<SSmokeTrailPoint> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SSmokeTrailPoint>
{
    private int size;
    private int maxsize;
    public struct SSmokeTrailPoint * array;
    public void SDArray<SSmokeTrailPoint>(class SDArray<SSmokeTrailPoint> & );
    public void SDArray<SSmokeTrailPoint>();
    public void ~SDArray<SSmokeTrailPoint>();
    public int Add(struct SSmokeTrailPoint & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSmokeTrailPoint & operator[](int );
    public void operator=(class SDArray<SSmokeTrailPoint> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SSmokeTrailPoint
{
    struct D3DXVECTOR3 Vector;
    float Scale;
    float TextureV;
    float Alpha;
    unsigned long StartTime;
    void SSmokeTrailPoint();
};

class SHeap<SGroundTrailSegment>
{
    struct __Tstruct
    {
        int use;
        struct SGroundTrailSegment data;
        void __Tstruct();
    };
    private struct SHeap<SGroundTrailSegment>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SGroundTrailSegment>();
    public void ~SHeap<SGroundTrailSegment>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SGroundTrailSegment & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SHeap<SGroundTrailSegment>
{
    struct __Tstruct
    {
        int use;
        struct SGroundTrailSegment data;
        void __Tstruct();
    };
    private struct SHeap<SGroundTrailSegment>::__Tstruct * array;
    private int size;
    private int maxsize;
    private int nextempty;
    private int occupied;
    public void SHeap<SGroundTrailSegment>();
    public void ~SHeap<SGroundTrailSegment>();
    public int Add();
    public void Remove(int );
    public int GetOccupied();
    public int GetUpperBound();
    public int GetNext(int );
    public bool Present(int );
    public void Clear();
    public struct SGroundTrailSegment & operator[](int );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SHeap<SGroundTrailSegment>::__Tstruct
{
    int use;
    struct SGroundTrailSegment data;
    void __Tstruct();
};

struct SGroundTrailSegment
{
    struct D3DXVECTOR3 Vertices[4];
    unsigned long StartTime;
    bool Noticed;
    void SGroundTrailSegment();
};

struct TXCoord
{
    float u;
    float v;
    int use;
    int num;
};

struct SNodeInfo2
{
    struct SNodeInfo2 * prev;
    struct SNodeInfo2 * next;
    float x;
    float y;
    float z;
    int nodetype;
};

struct SBaseVertex
{
    float x;
    float y;
    float z;
    float nx;
    float ny;
    float nz;
    float tx;
    float ty;
    float tz;
};

class SDArray<SBaseVertex>
{
    private int size;
    private int maxsize;
    public struct SBaseVertex * array;
    public void SDArray<SBaseVertex>(class SDArray<SBaseVertex> & );
    public void SDArray<SBaseVertex>();
    public void ~SDArray<SBaseVertex>();
    public int Add(struct SBaseVertex & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SBaseVertex & operator[](int );
    public void operator=(class SDArray<SBaseVertex> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SBaseVertex>
{
    private int size;
    private int maxsize;
    public struct SBaseVertex * array;
    public void SDArray<SBaseVertex>(class SDArray<SBaseVertex> & );
    public void SDArray<SBaseVertex>();
    public void ~SDArray<SBaseVertex>();
    public int Add(struct SBaseVertex & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SBaseVertex & operator[](int );
    public void operator=(class SDArray<SBaseVertex> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void * __vecDelDtor(unsigned int );
};

struct SBaseVertex
{
    float x;
    float y;
    float z;
    float nx;
    float ny;
    float nz;
    float tx;
    float ty;
    float tz;
};

struct SShaderClipboard
{
    class SString FileName;
    int X;
    int Z;
    int Rotation;
    void SShaderClipboard(struct SShaderClipboard * );
    void SShaderClipboard(struct SShaderClipboard & );
    void SShaderClipboard();
    void ~SShaderClipboard();
    struct SShaderClipboard & operator=(struct SShaderClipboard * );
    struct SShaderClipboard & operator=(struct SShaderClipboard & );
    void * __vecDelDtor(unsigned int );
};

struct SGepard::CreateLake::__l2::<unnamed-type-path_buffer>
{
    int x;
    int z;
};

struct SGepard::LogCardInfo::__l2::<unnamed-type-AdapterFormats>
{
    enum _D3DFORMAT format;
    char * name;
};

struct SGepard::LogCardInfo::__l2::<unnamed-type-ResourceTypes>
{
    enum _D3DRESOURCETYPE type;
    unsigned long usage;
    char * name;
};

struct SGepard::RenderDynamicShaders::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long color;
    unsigned long specular;
    float u;
    float v;
};

struct SGepard::RenderGroundTrails::__l2::<unnamed-type-vert>
{
    struct _D3DVECTOR vec;
    int color;
    float u;
    float v;
};

struct SGepard::RenderSmokeTrails::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    int color;
    float u;
    float v;
};

struct SHeap<SEffectDesc>::__Tstruct
{
    int use;
    struct SEffectDesc data;
};

class SRain
{
    public void SRain(class SGepard * ,class SEffect * ,char * );
    public void ~SRain();
    public bool MoveRain();
    public class SGepard * Gepard;
    public class SEffect * Effect;
    public int THandle;
    public struct SEsoCsepp EsoCseppek[100][14];
    public void * __vecDelDtor(unsigned int );
};

struct SEsoCsepp
{
    float x;
    float y;
    float z;
    float speed;
};

class SLevelUpLens
{
    public void SLevelUpLens(class SLevelUpLens * ,class SIObject * ,char * ,int );
    public void SLevelUpLens(class SGepard * ,class SEffect * ,char * );
    public void ~SLevelUpLens();
    public bool MoveLevelUpLens();
    public void DrawLensLayer(float ,int ,float ,float & ,float ,float );
    public void StopEffect();
    public void RefreshIndices();
    public class SEffect * Effect;
    public class SGepard * Gepard;
    public float MainX;
    public float MainY;
    public float MainZ;
    public int THandle1;
    public int THandle2;
    public int THandle3;
    public float Scale1;
    public float Scale2;
    public float Scale3;
    public float Rotate1;
    public float Rotate2;
    public float Rotate3;
    public float Alpha1;
    public float Alpha2;
    public bool Prototype;
    public bool Stopping;
    public class SIObject * Object;
    public int MeshIdx;
    public char MeshName[200];
    public int Race;
    public void * __vecDelDtor(unsigned int );
};

class SWindowEffect
{
    public void SWindowEffect(class SWindowEffect * ,class SIObject * ,class SDArray<SAblak> * );
    public void SWindowEffect(class SGepard * ,class SEffect * ,char * );
    public bool MoveWindows();
    public class SEffect * Effect;
    public class SGepard * Gepard;
    public class SIObject * Object;
    public class SDArray<SAblak> * Ablakok;
    public float NextRandom;
    public int AblakCounter;
    public int AblakHang;
    public int NagyajtoHang;
};

class SEryngo
{
    public void SEryngo(class SEryngo * ,class SIObject * );
    public void SEryngo(class SGepard * ,class SEffect * ,char * );
    public bool MoveEryngo();
    public class SEffect * Effect;
    public class SGepard * Gepard;
    public class SIObject * Object;
    public float LokalisSzelirany;
    public float SzelIrany1;
    public float SzelIrany1_b;
    public float SzelIranyVecX1;
    public float SzelIranyVecZ1;
    public float SzelEro1;
    public float SzelMagassag1;
    public float SzelTime1;
    public float SzelSpinDir1;
    public float SzelLokesEro1;
    public float SzelLokesSebesseg1;
    public float SzelLokesCounter1;
    public bool SzelLokesMode1;
    public void * Porzas;
};

class SSnowfall
{
    public void SSnowfall(class SGepard * ,class SEffect * ,char * );
    public void ~SSnowfall();
    public bool MoveSnow();
    public class SGepard * Gepard;
    public class SEffect * Effect;
    public float Variations;
    public float RecVariations;
    public int THandle;
    public struct SHopehely Hopelyhek[100][160];
    public void * __vecDelDtor(unsigned int );
};

struct SHopehely
{
    float x;
    float y;
    float z;
    float speed;
    int alak;
    float sinvaluex;
    float sinvaluez;
    float sinspeedx;
    float sinspeedz;
    float sindevx;
    float sindevz;
};

struct SLevelUpLens::DrawLensLayer::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long diffuse;
    float u;
    float v;
};

struct SRain::MoveRain::__l11::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float u;
    float v;
};

struct SSnowfall::MoveSnow::__l10::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long diffuse;
    unsigned long specular;
    float u;
    float v;
};

struct SEffect::Move_Boom::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long color;
    float u;
    float v;
};

struct SEffect::Move_Ghost::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float u;
    float v;
};

struct SEffect::Move_Reflektor::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    unsigned long diffuse;
    float u;
    float v;
};

struct SHeap<SFrame>::__Tstruct
{
    int use;
    struct SFrame data;
};

struct SHeap<SFontProp>::__Tstruct
{
    int use;
    struct SFontProp data;
};

class FontBitmap
{
    public int X;
    public int Y;
    public int Width;
    public int Height;
    public unsigned int * Data;
    public void FontBitmap(class FontBitmap * );
    public void FontBitmap(int ,int );
    public void operator=(class FontBitmap * );
    public void ~FontBitmap();
    public class FontBitmap & Aquire(void * );
    public class FontBitmap Reduce2();
    public float kernel[256];
    public unsigned int kernel8[256];
    public class FontBitmap Blur(float ,float );
    public class FontBitmap BlurX(int );
    public class FontBitmap BlurY(int );
    public class FontBitmap BoxBlur(int );
    public class FontBitmap BoxBlurX(int ,int );
    public class FontBitmap BoxBlurY(int ,int );
    public class SBitmap ToWhiteAlpha();
    public class SBitmap ToGrayscale();
    public class SBitmap CombineLightAndShadow(class FontBitmap & ,class FontBitmap & ,int );
    public class SBitmap CombineEmboss(class FontBitmap & ,class FontBitmap & ,float );
    public void Add(class FontBitmap & ,int );
    public class SBitmap NormalWithShadow(int ,int & ,int & ,float );
    public class SBitmap GlowWithShadow(int ,int & ,int & ,float );
    public class SBitmap PushedGlowWithShadow(int ,int & ,int & ,float );
    public class SBitmap Emboss(int ,int & ,int & ,float );
    public void * __vecDelDtor(unsigned int );
};

class FontBitmap
{
    public int X;
    public int Y;
    public int Width;
    public int Height;
    public unsigned int * Data;
    public void FontBitmap(class FontBitmap * );
    public void FontBitmap(int ,int );
    public void operator=(class FontBitmap * );
    public void ~FontBitmap();
    public class FontBitmap & Aquire(void * );
    public class FontBitmap Reduce2();
    public float kernel[256];
    public unsigned int kernel8[256];
    public class FontBitmap Blur(float ,float );
    public class FontBitmap BlurX(int );
    public class FontBitmap BlurY(int );
    public class FontBitmap BoxBlur(int );
    public class FontBitmap BoxBlurX(int ,int );
    public class FontBitmap BoxBlurY(int ,int );
    public class SBitmap ToWhiteAlpha();
    public class SBitmap ToGrayscale();
    public class SBitmap CombineLightAndShadow(class FontBitmap & ,class FontBitmap & ,int );
    public class SBitmap CombineEmboss(class FontBitmap & ,class FontBitmap & ,float );
    public void Add(class FontBitmap & ,int );
    public class SBitmap NormalWithShadow(int ,int & ,int & ,float );
    public class SBitmap GlowWithShadow(int ,int & ,int & ,float );
    public class SBitmap PushedGlowWithShadow(int ,int & ,int & ,float );
    public class SBitmap Emboss(int ,int & ,int & ,float );
    public void * __vecDelDtor(unsigned int );
};

struct SBoard::Render::__l2::<unnamed-type-vert>
{
    float x;
    float y;
    float z;
    float rhw;
    unsigned long color;
    float u;
    float v;
};

struct tagBITMAPINFO
{
    struct tagBITMAPINFOHEADER bmiHeader;
    struct tagRGBQUAD bmiColors[1];
};

enum IKEEXT_CIPHER_TYPE_
{
    IKEEXT_CIPHER_DES=0,
    IKEEXT_CIPHER_3DES=1,
    IKEEXT_CIPHER_AES_128=2,
    IKEEXT_CIPHER_AES_192=3,
    IKEEXT_CIPHER_AES_256=4,
    IKEEXT_CIPHER_TYPE_MAX=5
};

enum IKEEXT_INTEGRITY_TYPE_
{
    IKEEXT_INTEGRITY_MD5=0,
    IKEEXT_INTEGRITY_SHA1=1,
    IKEEXT_INTEGRITY_SHA_256=2,
    IKEEXT_INTEGRITY_SHA_384=3,
    IKEEXT_INTEGRITY_TYPE_MAX=4
};

enum FWPS_BUILTIN_LAYERS_
{
    FWPS_LAYER_INBOUND_IPPACKET_V4=0,
    FWPS_LAYER_INBOUND_IPPACKET_V4_DISCARD=1,
    FWPS_LAYER_INBOUND_IPPACKET_V6=2,
    FWPS_LAYER_INBOUND_IPPACKET_V6_DISCARD=3,
    FWPS_LAYER_OUTBOUND_IPPACKET_V4=4,
    FWPS_LAYER_OUTBOUND_IPPACKET_V4_DISCARD=5,
    FWPS_LAYER_OUTBOUND_IPPACKET_V6=6,
    FWPS_LAYER_OUTBOUND_IPPACKET_V6_DISCARD=7,
    FWPS_LAYER_IPFORWARD_V4=8,
    FWPS_LAYER_IPFORWARD_V4_DISCARD=9,
    FWPS_LAYER_IPFORWARD_V6=10,
    FWPS_LAYER_IPFORWARD_V6_DISCARD=11,
    FWPS_LAYER_INBOUND_TRANSPORT_V4=12,
    FWPS_LAYER_INBOUND_TRANSPORT_V4_DISCARD=13,
    FWPS_LAYER_INBOUND_TRANSPORT_V6=14,
    FWPS_LAYER_INBOUND_TRANSPORT_V6_DISCARD=15,
    FWPS_LAYER_OUTBOUND_TRANSPORT_V4=16,
    FWPS_LAYER_OUTBOUND_TRANSPORT_V4_DISCARD=17,
    FWPS_LAYER_OUTBOUND_TRANSPORT_V6=18,
    FWPS_LAYER_OUTBOUND_TRANSPORT_V6_DISCARD=19,
    FWPS_LAYER_STREAM_V4=20,
    FWPS_LAYER_STREAM_V4_DISCARD=21,
    FWPS_LAYER_STREAM_V6=22,
    FWPS_LAYER_STREAM_V6_DISCARD=23,
    FWPS_LAYER_DATAGRAM_DATA_V4=24,
    FWPS_LAYER_DATAGRAM_DATA_V4_DISCARD=25,
    FWPS_LAYER_DATAGRAM_DATA_V6=26,
    FWPS_LAYER_DATAGRAM_DATA_V6_DISCARD=27,
    FWPS_LAYER_INBOUND_ICMP_ERROR_V4=28,
    FWPS_LAYER_INBOUND_ICMP_ERROR_V4_DISCARD=29,
    FWPS_LAYER_INBOUND_ICMP_ERROR_V6=30,
    FWPS_LAYER_INBOUND_ICMP_ERROR_V6_DISCARD=31,
    FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4=32,
    FWPS_LAYER_OUTBOUND_ICMP_ERROR_V4_DISCARD=33,
    FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6=34,
    FWPS_LAYER_OUTBOUND_ICMP_ERROR_V6_DISCARD=35,
    FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4=36,
    FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V4_DISCARD=37,
    FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6=38,
    FWPS_LAYER_ALE_RESOURCE_ASSIGNMENT_V6_DISCARD=39,
    FWPS_LAYER_ALE_AUTH_LISTEN_V4=40,
    FWPS_LAYER_ALE_AUTH_LISTEN_V4_DISCARD=41,
    FWPS_LAYER_ALE_AUTH_LISTEN_V6=42,
    FWPS_LAYER_ALE_AUTH_LISTEN_V6_DISCARD=43,
    FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4=44,
    FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V4_DISCARD=45,
    FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6=46,
    FWPS_LAYER_ALE_AUTH_RECV_ACCEPT_V6_DISCARD=47,
    FWPS_LAYER_ALE_AUTH_CONNECT_V4=48,
    FWPS_LAYER_ALE_AUTH_CONNECT_V4_DISCARD=49,
    FWPS_LAYER_ALE_AUTH_CONNECT_V6=50,
    FWPS_LAYER_ALE_AUTH_CONNECT_V6_DISCARD=51,
    FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4=52,
    FWPS_LAYER_ALE_FLOW_ESTABLISHED_V4_DISCARD=53,
    FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6=54,
    FWPS_LAYER_ALE_FLOW_ESTABLISHED_V6_DISCARD=55,
    FWPS_LAYER_INBOUND_MAC_FRAME_802_3=56,
    FWPS_LAYER_OUTBOUND_MAC_FRAME_802_3=57,
    FWPS_LAYER_ALE_AUTH_ROUTE_V4=58,
    FWPS_LAYER_ALE_AUTH_ROUTE_V6=59,
    FWPS_LAYER_NAME_RESOLUTION_CACHE_V4=60,
    FWPS_LAYER_NAME_RESOLUTION_CACHE_V6=61,
    FWPS_LAYER_ALE_RESOURCE_RELEASE_V4=62,
    FWPS_LAYER_ALE_RESOURCE_RELEASE_V6=63,
    FWPS_LAYER_ALE_ENDPOINT_CLOSURE_V4=64,
    FWPS_LAYER_ALE_ENDPOINT_CLOSURE_V6=65,
    FWPS_LAYER_ALE_CONNECT_REDIRECT_V4=66,
    FWPS_LAYER_ALE_CONNECT_REDIRECT_V6=67,
    FWPS_LAYER_ALE_BIND_REDIRECT_V4=68,
    FWPS_LAYER_ALE_BIND_REDIRECT_V6=69,
    FWPS_LAYER_STREAM_PACKET_V4=70,
    FWPS_LAYER_STREAM_PACKET_V6=71,
    FWPS_LAYER_IPSEC_KM_DEMUX_V4=72,
    FWPS_LAYER_IPSEC_KM_DEMUX_V6=73,
    FWPS_LAYER_IPSEC_V4=74,
    FWPS_LAYER_IPSEC_V6=75,
    FWPS_LAYER_IKEEXT_V4=76,
    FWPS_LAYER_IKEEXT_V6=77,
    FWPS_LAYER_RPC_UM=78,
    FWPS_LAYER_RPC_EPMAP=79,
    FWPS_LAYER_RPC_EP_ADD=80,
    FWPS_LAYER_RPC_PROXY_CONN=81,
    FWPS_LAYER_RPC_PROXY_IF=82,
    FWPS_LAYER_KM_AUTHORIZATION=83,
    FWPS_BUILTIN_LAYER_MAX=84
};

enum _INTERFACE_TYPE
{
    InterfaceTypeUndefined=-1,
    Internal=0,
    Isa=1,
    Eisa=2,
    MicroChannel=3,
    TurboChannel=4,
    PCIBus=5,
    VMEBus=6,
    NuBus=7,
    PCMCIABus=8,
    CBus=9,
    MPIBus=10,
    MPSABus=11,
    ProcessorInternal=12,
    InternalPowerBus=13,
    PNPISABus=14,
    PNPBus=15,
    Vmcs=16,
    MaximumInterfaceType=17
};

enum FWPM_NET_EVENT_TYPE_
{
    FWPM_NET_EVENT_TYPE_IKEEXT_MM_FAILURE=0,
    FWPM_NET_EVENT_TYPE_IKEEXT_QM_FAILURE=1,
    FWPM_NET_EVENT_TYPE_IKEEXT_EM_FAILURE=2,
    FWPM_NET_EVENT_TYPE_CLASSIFY_DROP=3,
    FWPM_NET_EVENT_TYPE_IPSEC_KERNEL_DROP=4,
    FWPM_NET_EVENT_TYPE_ADDITIONAL_ADDRESSES=5,
    FWPM_NET_EVENT_TYPE_IPSEC_DOSP_DROP=6,
    FWPM_NET_EVENT_TYPE_MAX=7
};

enum DL_ADDRESS_TYPE
{
    DlUnicast=0,
    DlMulticast=1,
    DlBroadcast=2
};

enum _NDIS_NET_BUFFER_LIST_INFO
{
    TcpIpChecksumNetBufferListInfo=0,
    TcpOffloadBytesTransferred=0,
    IPsecOffloadV1NetBufferListInfo=1,
    IPsecOffloadV2NetBufferListInfo=1,
    TcpLargeSendNetBufferListInfo=2,
    TcpReceiveNoPush=2,
    ClassificationHandleNetBufferListInfo=3,
    Ieee8021QNetBufferListInfo=4,
    NetBufferListCancelId=5,
    MediaSpecificInformation=6,
    NetBufferListFrameType=7,
    NetBufferListProtocolId=7,
    NetBufferListHashValue=8,
    NetBufferListHashInfo=9,
    WfpNetBufferListInfo=10,
    IPsecOffloadV2TunnelNetBufferListInfo=11,
    IPsecOffloadV2HeaderNetBufferListInfo=12,
    NetBufferListCorrelationId=13,
    NetBufferListFilteringInfo=14,
    MediaSpecificInformationEx=15,
    NblOriginalInterfaceIfIndex=16,
    NblReAuthWfpFlowContext=16,
    MaxNetBufferListInfo=17
};

enum FWPM_SYSTEM_PORT_TYPE_
{
    FWPM_SYSTEM_PORT_RPC_EPMAP=0,
    FWPM_SYSTEM_PORT_TEREDO=1,
    FWPM_SYSTEM_PORT_IPTLS_IN=2,
    FWPM_SYSTEM_PORT_IPTLS_OUT=3,
    FWPM_SYSTEM_PORT_TYPE_MAX=4
};

enum FWPS_DISCARD_MODULE0_
{
    FWPS_DISCARD_MODULE_NETWORK=0,
    FWPS_DISCARD_MODULE_TRANSPORT=1,
    FWPS_DISCARD_MODULE_GENERAL=2,
    FWPS_DISCARD_MODULE_MAX=3
};

enum TOKENRING_BROADCAST_INDICATOR
{
    TokenRingSpecificallyRoutedFrame=0,
    TokenRingAllRoutesExplorer=4,
    TokenRingSpanningTreeExplorer=6
};

enum FWPS_GENERAL_DISCARD_REASON_
{
    FWPS_DISCARD_FIREWALL_POLICY=0,
    FWPS_DISCARD_IPSEC=1,
    FWPS_GENERAL_DISCARD_REASON_MAX=2
};

enum FWPS_CALLOUT_NOTIFY_TYPE_
{
    FWPS_CALLOUT_NOTIFY_ADD_FILTER=0,
    FWPS_CALLOUT_NOTIFY_DELETE_FILTER=1,
    FWPS_CALLOUT_NOTIFY_ADD_FILTER_POST_COMMIT=2,
    FWPS_CALLOUT_NOTIFY_TYPE_MAX=3
};

enum IKEEXT_MM_SA_STATE_
{
    IKEEXT_MM_SA_STATE_NONE=0,
    IKEEXT_MM_SA_STATE_SA_SENT=1,
    IKEEXT_MM_SA_STATE_SSPI_SENT=2,
    IKEEXT_MM_SA_STATE_FINAL=3,
    IKEEXT_MM_SA_STATE_FINAL_SENT=4,
    IKEEXT_MM_SA_STATE_COMPLETE=5,
    IKEEXT_MM_SA_STATE_MAX=6
};

enum IKEEXT_EM_SA_STATE_
{
    IKEEXT_EM_SA_STATE_NONE=0,
    IKEEXT_EM_SA_STATE_SENT_ATTS=1,
    IKEEXT_EM_SA_STATE_SSPI_SENT=2,
    IKEEXT_EM_SA_STATE_AUTH_COMPLETE=3,
    IKEEXT_EM_SA_STATE_FINAL=4,
    IKEEXT_EM_SA_STATE_COMPLETE=5,
    IKEEXT_EM_SA_STATE_MAX=6
};

enum IKEEXT_SA_ROLE_
{
    IKEEXT_SA_ROLE_INITIATOR=0,
    IKEEXT_SA_ROLE_RESPONDER=1,
    IKEEXT_SA_ROLE_MAX=2
};

enum IPSEC_AUTH_TYPE_
{
    IPSEC_AUTH_MD5=0,
    IPSEC_AUTH_SHA_1=1,
    IPSEC_AUTH_SHA_256=2,
    IPSEC_AUTH_AES_128=3,
    IPSEC_AUTH_AES_192=4,
    IPSEC_AUTH_AES_256=5,
    IPSEC_AUTH_MAX=6
};

enum FWPM_NET_FAILURE_CAUSE_
{
    FWPM_NET_FAILURE_UNKNOWN=0,
    FWPM_NET_FAILURE_WRONG_COMPARTMENT=1,
    FWPM_NET_FAILURE_AUTHIP=2,
    FWPM_NET_FAILURE_CAUSE_MAX=3
};

enum IPSEC_CIPHER_TYPE_
{
    IPSEC_CIPHER_TYPE_DES=1,
    IPSEC_CIPHER_TYPE_3DES=2,
    IPSEC_CIPHER_TYPE_AES_128=3,
    IPSEC_CIPHER_TYPE_AES_192=4,
    IPSEC_CIPHER_TYPE_AES_256=5,
    IPSEC_CIPHER_TYPE_MAX=6
};

enum _NDIS_802_11_WEP_STATUS
{
    Ndis802_11WEPEnabled=0,
    Ndis802_11Encryption1Enabled=0,
    Ndis802_11WEPDisabled=1,
    Ndis802_11EncryptionDisabled=1,
    Ndis802_11WEPKeyAbsent=2,
    Ndis802_11Encryption1KeyAbsent=2,
    Ndis802_11WEPNotSupported=3,
    Ndis802_11EncryptionNotSupported=3,
    Ndis802_11Encryption2Enabled=4,
    Ndis802_11Encryption2KeyAbsent=5,
    Ndis802_11Encryption3Enabled=6,
    Ndis802_11Encryption3KeyAbsent=7
};

enum IPSEC_PFS_GROUP_
{
    IPSEC_PFS_NONE=0,
    IPSEC_PFS_1=1,
    IPSEC_PFS_2=2,
    IPSEC_PFS_2048=3,
    IPSEC_PFS_ECP_256=4,
    IPSEC_PFS_ECP_384=5,
    IPSEC_PFS_MM=6,
    IPSEC_PFS_MAX=7
};

enum SCOPE_LEVEL
{
    ScopeLevelInterface=1,
    ScopeLevelLink=2,
    ScopeLevelSubnet=3,
    ScopeLevelAdmin=4,
    ScopeLevelSite=5,
    ScopeLevelOrganization=8,
    ScopeLevelGlobal=14,
    ScopeLevelCount=16
};

enum FWPM_EVENT_PROVIDER_TYPE_
{
    FWPM_EVENT_PROVIDER_IKEEXT=0,
    FWPM_EVENT_PROVIDER_FILTER_ENGINE=1,
    FWPM_EVENT_PROVIDER_IPSEC_KERNEL=2,
    FWPM_EVENT_PROVIDER_IPSEC_DOSP=3,
    FWPM_EVENT_PROVIDER_TYPE_MAX=4
};

enum _EVENT_TYPE
{
    NotificationEvent=0,
    SynchronizationEvent=1
};

enum _REG_NOTIFY_CLASS
{
    RegNtDeleteKey=0,
    RegNtPreDeleteKey=0,
    RegNtSetValueKey=1,
    RegNtPreSetValueKey=1,
    RegNtDeleteValueKey=2,
    RegNtPreDeleteValueKey=2,
    RegNtSetInformationKey=3,
    RegNtPreSetInformationKey=3,
    RegNtRenameKey=4,
    RegNtPreRenameKey=4,
    RegNtEnumerateKey=5,
    RegNtPreEnumerateKey=5,
    RegNtEnumerateValueKey=6,
    RegNtPreEnumerateValueKey=6,
    RegNtQueryKey=7,
    RegNtPreQueryKey=7,
    RegNtQueryValueKey=8,
    RegNtPreQueryValueKey=8,
    RegNtQueryMultipleValueKey=9,
    RegNtPreQueryMultipleValueKey=9,
    RegNtPreCreateKey=10,
    RegNtPostCreateKey=11,
    RegNtPreOpenKey=12,
    RegNtPostOpenKey=13,
    RegNtKeyHandleClose=14,
    RegNtPreKeyHandleClose=14,
    RegNtPostDeleteKey=15,
    RegNtPostSetValueKey=16,
    RegNtPostDeleteValueKey=17,
    RegNtPostSetInformationKey=18,
    RegNtPostRenameKey=19,
    RegNtPostEnumerateKey=20,
    RegNtPostEnumerateValueKey=21,
    RegNtPostQueryKey=22,
    RegNtPostQueryValueKey=23,
    RegNtPostQueryMultipleValueKey=24,
    RegNtPostKeyHandleClose=25,
    RegNtPreCreateKeyEx=26,
    RegNtPostCreateKeyEx=27,
    RegNtPreOpenKeyEx=28,
    RegNtPostOpenKeyEx=29,
    RegNtPreFlushKey=30,
    RegNtPostFlushKey=31,
    RegNtPreLoadKey=32,
    RegNtPostLoadKey=33,
    RegNtPreUnLoadKey=34,
    RegNtPostUnLoadKey=35,
    RegNtPreQueryKeySecurity=36,
    RegNtPostQueryKeySecurity=37,
    RegNtPreSetKeySecurity=38,
    RegNtPostSetKeySecurity=39,
    RegNtCallbackObjectContextCleanup=40,
    RegNtPreRestoreKey=41,
    RegNtPostRestoreKey=42,
    RegNtPreSaveKey=43,
    RegNtPostSaveKey=44,
    RegNtPreReplaceKey=45,
    RegNtPostReplaceKey=46,
    MaxRegNtNotifyClass=47
};

enum IPSEC_TOKEN_TYPE_
{
    IPSEC_TOKEN_TYPE_MACHINE=0,
    IPSEC_TOKEN_TYPE_IMPERSONATION=1,
    IPSEC_TOKEN_TYPE_MAX=2
};

enum IPSEC_TOKEN_PRINCIPAL_
{
    IPSEC_TOKEN_PRINCIPAL_LOCAL=0,
    IPSEC_TOKEN_PRINCIPAL_PEER=1,
    IPSEC_TOKEN_PRINCIPAL_MAX=2
};

enum IPSEC_TOKEN_MODE_
{
    IPSEC_TOKEN_MODE_MAIN=0,
    IPSEC_TOKEN_MODE_EXTENDED=1,
    IPSEC_TOKEN_MODE_MAX=2
};

enum _MODE
{
    KernelMode=0,
    UserMode=1,
    MaximumMode=2
};

enum _NPI_MODULEID_TYPE
{
    MIT_GUID=1,
    MIT_IF_LUID=2
};

enum IPSEC_TRAFFIC_TYPE_
{
    IPSEC_TRAFFIC_TYPE_TRANSPORT=0,
    IPSEC_TRAFFIC_TYPE_TUNNEL=1,
    IPSEC_TRAFFIC_TYPE_MAX=2
};

enum tagTYSPEC
{
    TYSPEC_CLSID=0,
    TYSPEC_FILEEXT=1,
    TYSPEC_MIMETYPE=2,
    TYSPEC_FILENAME=3,
    TYSPEC_PROGID=4,
    TYSPEC_PACKAGENAME=5,
    TYSPEC_OBJECTID=6
};

enum _MEMORY_CACHING_TYPE
{
    MmNonCached=0,
    MmCached=1,
    MmWriteCombined=2,
    MmHardwareCoherentCached=3,
    MmNonCachedUnordered=4,
    MmUSWCCached=5,
    MmMaximumCacheType=6
};

enum FWP_IP_VERSION_
{
    FWP_IP_VERSION_V4=0,
    FWP_IP_VERSION_V6=1,
    FWP_IP_VERSION_NONE=2,
    FWP_IP_VERSION_MAX=3
};

enum FWPM_CHANGE_TYPE_
{
    FWPM_CHANGE_ADD=1,
    FWPM_CHANGE_DELETE=2,
    FWPM_CHANGE_TYPE_MAX=3
};

enum FWP_NE_FAMILY_
{
    FWP_AF_INET=0,
    FWP_AF_INET6=1,
    FWP_AF_ETHER=2,
    FWP_AF_NONE=3
};

enum FWP_DATA_TYPE_
{
    FWP_EMPTY=0,
    FWP_UINT8=1,
    FWP_UINT16=2,
    FWP_UINT32=3,
    FWP_UINT64=4,
    FWP_INT8=5,
    FWP_INT16=6,
    FWP_INT32=7,
    FWP_INT64=8,
    FWP_FLOAT=9,
    FWP_DOUBLE=10,
    FWP_BYTE_ARRAY16_TYPE=11,
    FWP_BYTE_BLOB_TYPE=12,
    FWP_SID=13,
    FWP_SECURITY_DESCRIPTOR_TYPE=14,
    FWP_TOKEN_INFORMATION_TYPE=15,
    FWP_TOKEN_ACCESS_INFORMATION_TYPE=16,
    FWP_UNICODE_STRING_TYPE=17,
    FWP_BYTE_ARRAY6_TYPE=18,
    FWP_SINGLE_DATA_TYPE_MAX=255,
    FWP_V4_ADDR_MASK=256,
    FWP_V6_ADDR_MASK=257,
    FWP_RANGE_TYPE=258,
    FWP_DATA_TYPE_MAX=259
};

enum FWPM_PROVIDER_CONTEXT_TYPE_
{
    FWPM_IPSEC_KEYING_CONTEXT=0,
    FWPM_IPSEC_IKE_QM_TRANSPORT_CONTEXT=1,
    FWPM_IPSEC_IKE_QM_TUNNEL_CONTEXT=2,
    FWPM_IPSEC_AUTHIP_QM_TRANSPORT_CONTEXT=3,
    FWPM_IPSEC_AUTHIP_QM_TUNNEL_CONTEXT=4,
    FWPM_IPSEC_IKE_MM_CONTEXT=5,
    FWPM_IPSEC_AUTHIP_MM_CONTEXT=6,
    FWPM_CLASSIFY_OPTIONS_CONTEXT=7,
    FWPM_GENERAL_CONTEXT=8,
    FWPM_IPSEC_IKEV2_QM_TUNNEL_CONTEXT=9,
    FWPM_IPSEC_IKEV2_MM_CONTEXT=10,
    FWPM_IPSEC_DOSP_CONTEXT=11,
    FWPM_PROVIDER_CONTEXT_TYPE_MAX=12
};

enum _MM_PAGE_PRIORITY
{
    LowPagePriority=0,
    NormalPagePriority=16,
    HighPagePriority=32
};

enum FWP_MATCH_TYPE_
{
    FWP_MATCH_EQUAL=0,
    FWP_MATCH_GREATER=1,
    FWP_MATCH_LESS=2,
    FWP_MATCH_GREATER_OR_EQUAL=3,
    FWP_MATCH_LESS_OR_EQUAL=4,
    FWP_MATCH_RANGE=5,
    FWP_MATCH_FLAGS_ALL_SET=6,
    FWP_MATCH_FLAGS_ANY_SET=7,
    FWP_MATCH_FLAGS_NONE_SET=8,
    FWP_MATCH_EQUAL_CASE_INSENSITIVE=9,
    FWP_MATCH_NOT_EQUAL=10,
    FWP_MATCH_TYPE_MAX=11
};

struct IPSEC_AUTH_TRANSFORM_ID0_
{
    enum IPSEC_AUTH_TYPE_ authType;
    unsigned int authConfig;
};

struct IPSEC_CIPHER_TRANSFORM_ID0_
{
    enum IPSEC_CIPHER_TYPE_ cipherType;
    unsigned int cipherConfig;
};

enum _POOL_TYPE
{
    NonPagedPool=0,
    PagedPool=1,
    NonPagedPoolMustSucceed=2,
    DontUseThisType=3,
    NonPagedPoolCacheAligned=4,
    PagedPoolCacheAligned=5,
    NonPagedPoolCacheAlignedMustS=6,
    MaxPoolType=7,
    NonPagedPoolSession=32,
    PagedPoolSession=33,
    NonPagedPoolMustSucceedSession=34,
    DontUseThisTypeSession=35,
    NonPagedPoolCacheAlignedSession=36,
    PagedPoolCacheAlignedSession=37,
    NonPagedPoolCacheAlignedMustSSession=38
};

enum FWP_CLASSIFY_OPTION_TYPE_
{
    FWP_CLASSIFY_OPTION_MULTICAST_STATE=0,
    FWP_CLASSIFY_OPTION_LOOSE_SOURCE_MAPPING=1,
    FWP_CLASSIFY_OPTION_UNICAST_LIFETIME=2,
    FWP_CLASSIFY_OPTION_MCAST_BCAST_LIFETIME=3,
    FWP_CLASSIFY_OPTION_SECURE_SOCKET_SECURITY_FLAGS=4,
    FWP_CLASSIFY_OPTION_SECURE_SOCKET_AUTHIP_MM_POLICY_KEY=5,
    FWP_CLASSIFY_OPTION_SECURE_SOCKET_AUTHIP_QM_POLICY_KEY=6,
    FWP_CLASSIFY_OPTION_MAX=7
};

enum NL_ADDRESS_TYPE
{
    NlatUnspecified=0,
    NlatUnicast=1,
    NlatAnycast=2,
    NlatMulticast=3,
    NlatBroadcast=4,
    NlatInvalid=5
};

enum IKEEXT_KEY_MODULE_TYPE_
{
    IKEEXT_KEY_MODULE_IKE=0,
    IKEEXT_KEY_MODULE_AUTHIP=1,
    IKEEXT_KEY_MODULE_IKEV2=2,
    IKEEXT_KEY_MODULE_MAX=3
};

enum FWPM_FIELD_TYPE_
{
    FWPM_FIELD_RAW_DATA=0,
    FWPM_FIELD_IP_ADDRESS=1,
    FWPM_FIELD_FLAGS=2,
    FWPM_FIELD_TYPE_MAX=3
};

enum IKEEXT_AUTHENTICATION_METHOD_TYPE_
{
    IKEEXT_PRESHARED_KEY=0,
    IKEEXT_CERTIFICATE=1,
    IKEEXT_KERBEROS=2,
    IKEEXT_ANONYMOUS=3,
    IKEEXT_SSL=4,
    IKEEXT_NTLM_V2=5,
    IKEEXT_IPV6_CGA=6,
    IKEEXT_CERTIFICATE_ECDSA_P256=7,
    IKEEXT_CERTIFICATE_ECDSA_P384=8,
    IKEEXT_SSL_ECDSA_P256=9,
    IKEEXT_SSL_ECDSA_P384=10,
    IKEEXT_EAP=11,
    IKEEXT_AUTHENTICATION_METHOD_TYPE_MAX=12
};

enum IKEEXT_AUTHENTICATION_IMPERSONATION_TYPE_
{
    IKEEXT_IMPERSONATION_NONE=0,
    IKEEXT_IMPERSONATION_SOCKET_PRINCIPAL=1,
    IKEEXT_IMPERSONATION_MAX=2
};

enum IKEEXT_CERT_CONFIG_TYPE_
{
    IKEEXT_CERT_CONFIG_EXPLICIT_TRUST_LIST=0,
    IKEEXT_CERT_CONFIG_ENTERPRISE_STORE=1,
    IKEEXT_CERT_CONFIG_TRUSTED_ROOT_STORE=2,
    IKEEXT_CERT_CONFIG_UNSPECIFIED=3,
    IKEEXT_CERT_CONFIG_TYPE_MAX=4
};

struct _LUID_AND_ATTRIBUTES
{
    struct _LUID Luid;
    unsigned long Attributes;
};

enum _SECURITY_IMPERSONATION_LEVEL
{
    SecurityAnonymous=0,
    SecurityIdentification=1,
    SecurityImpersonation=2,
    SecurityDelegation=3
};

struct _INITIAL_PRIVILEGE_SET
{
    unsigned long PrivilegeCount;
    unsigned long Control;
    struct _LUID_AND_ATTRIBUTES Privilege[3];
};

struct _PRIVILEGE_SET
{
    unsigned long PrivilegeCount;
    unsigned long Control;
    struct _LUID_AND_ATTRIBUTES Privilege[1];
};

enum _IRQ_PRIORITY
{
    IrqPriorityUndefined=0,
    IrqPriorityLow=1,
    IrqPriorityNormal=2,
    IrqPriorityHigh=3
};

struct _OWNER_ENTRY
{
    unsigned long OwnerThread;
    unsigned long IoPriorityBoosted:1;
    unsigned long OwnerCount:31;
    unsigned long TableSize;
};

struct _EPROCESS
{
};

enum _IRQ_DEVICE_POLICY
{
    IrqPolicyMachineDefault=0,
    IrqPolicyAllCloseProcessors=1,
    IrqPolicyOneCloseProcessor=2,
    IrqPolicyAllProcessorsInMachine=3,
    IrqPolicySpecifiedProcessors=4,
    IrqPolicySpreadMessagesAcrossAllProcessors=5
};

struct _SECURITY_SUBJECT_CONTEXT
{
    void * ClientToken;
    enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    void * PrimaryToken;
    void * ProcessAuditId;
};

struct _ALE_PEER_TOKENS
{
};

struct _unnamed_3332
{
    unsigned long Length;
    unsigned long Alignment;
    union _LARGE_INTEGER MinimumAddress;
    union _LARGE_INTEGER MaximumAddress;
};

struct _unnamed_3333
{
    unsigned long MinimumVector;
    unsigned long MaximumVector;
    enum _IRQ_DEVICE_POLICY AffinityPolicy;
    enum _IRQ_PRIORITY PriorityPolicy;
    unsigned long TargetedProcessors;
};

struct _unnamed_3334
{
    unsigned long MinimumChannel;
    unsigned long MaximumChannel;
};

struct _unnamed_3335
{
    unsigned long Data[3];
};

struct _unnamed_3336
{
    unsigned long Length;
    unsigned long MinBusNumber;
    unsigned long MaxBusNumber;
    unsigned long Reserved;
};

struct _unnamed_3337
{
    unsigned long Priority;
    unsigned long Reserved1;
    unsigned long Reserved2;
};

struct _unnamed_3338
{
    unsigned long Length40;
    unsigned long Alignment40;
    union _LARGE_INTEGER MinimumAddress;
    union _LARGE_INTEGER MaximumAddress;
};

struct _unnamed_3339
{
    unsigned long Length48;
    unsigned long Alignment48;
    union _LARGE_INTEGER MinimumAddress;
    union _LARGE_INTEGER MaximumAddress;
};

struct _unnamed_3340
{
    unsigned long Length64;
    unsigned long Alignment64;
    union _LARGE_INTEGER MinimumAddress;
    union _LARGE_INTEGER MaximumAddress;
};

union _unnamed_3341
{
    struct _unnamed_3332 Port;
    struct _unnamed_3332 Memory;
    struct _unnamed_3333 Interrupt;
    struct _unnamed_3334 Dma;
    struct _unnamed_3332 Generic;
    struct _unnamed_3335 DevicePrivate;
    struct _unnamed_3336 BusNumber;
    struct _unnamed_3337 ConfigData;
    struct _unnamed_3338 Memory40;
    struct _unnamed_3339 Memory48;
    struct _unnamed_3340 Memory64;
};

struct _IO_RESOURCE_DESCRIPTOR
{
    unsigned int Option;
    unsigned int Type;
    unsigned int ShareDisposition;
    unsigned int Spare1;
    unsigned int Flags;
    unsigned int Spare2;
    union _unnamed_3341 u;
};

struct _FILE_STANDARD_INFORMATION
{
    union _LARGE_INTEGER AllocationSize;
    union _LARGE_INTEGER EndOfFile;
    unsigned long NumberOfLinks;
    unsigned int DeletePending;
    unsigned int Directory;
};

struct _unnamed_3344
{
    union _LARGE_INTEGER Start;
    unsigned long Length;
};

struct _unnamed_3345
{
    unsigned long Level;
    unsigned long Vector;
    unsigned long Affinity;
};

struct _unnamed_3346
{
    unsigned int Reserved;
    unsigned int MessageCount;
    unsigned long Vector;
    unsigned long Affinity;
};

struct _unnamed_3347
{
    struct _unnamed_3346 Raw;
    struct _unnamed_3345 Translated;
};

struct _unnamed_3348
{
    unsigned long Channel;
    unsigned long Port;
    unsigned long Reserved1;
};

struct _unnamed_3349
{
    unsigned long Start;
    unsigned long Length;
    unsigned long Reserved;
};

struct _unnamed_3350
{
    unsigned long DataSize;
    unsigned long Reserved1;
    unsigned long Reserved2;
};

struct _unnamed_3351
{
    union _LARGE_INTEGER Start;
    unsigned long Length40;
};

struct _unnamed_3352
{
    union _LARGE_INTEGER Start;
    unsigned long Length48;
};

struct _unnamed_3353
{
    union _LARGE_INTEGER Start;
    unsigned long Length64;
};

union _unnamed_3354
{
    struct _unnamed_3344 Generic;
    struct _unnamed_3344 Port;
    struct _unnamed_3345 Interrupt;
    struct _unnamed_3347 MessageInterrupt;
    struct _unnamed_3344 Memory;
    struct _unnamed_3348 Dma;
    struct _unnamed_3335 DevicePrivate;
    struct _unnamed_3349 BusNumber;
    struct _unnamed_3350 DeviceSpecificData;
    struct _unnamed_3351 Memory40;
    struct _unnamed_3352 Memory48;
    struct _unnamed_3353 Memory64;
};

struct _CM_PARTIAL_RESOURCE_DESCRIPTOR
{
    unsigned int Type;
    unsigned int ShareDisposition;
    unsigned int Flags;
    union _unnamed_3354 u;
};

struct FWPS_IPSEC_SPECIFIC_TUPLES0_
{
    unsigned int localPort;
    unsigned int remotePort;
    unsigned int ipProtocol;
};

struct _SECURITY_QUALITY_OF_SERVICE
{
    unsigned long Length;
    enum _SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
    unsigned int ContextTrackingMode;
    unsigned int EffectiveOnly;
};

struct _SOURCEROUTE_HEADER
{
    unsigned int Length:5;
    unsigned int BroadcastIndicator:3;
    unsigned int Bil;
    unsigned int Direction:1;
    unsigned int LargestFrame:4;
    unsigned int Reserved:3;
    unsigned int Dlf;
    unsigned int Rd[0];
};

struct _DISPATCHER_HEADER
{
    unsigned int Type;
    unsigned int ControlFlags;
    unsigned int Absolute:1;
    unsigned int Coalescable:1;
    unsigned int KeepShifting:1;
    unsigned int EncodedTolerableDelay:5;
    unsigned int Abandoned;
    unsigned int Signalling;
    unsigned int ThreadControlFlags;
    unsigned int CpuThrottled:1;
    unsigned int CycleProfiling:1;
    unsigned int CounterProfiling:1;
    unsigned int Reserved:5;
    unsigned int Hand;
    unsigned int Size;
    unsigned int TimerControlFlags;
    unsigned int Index:6;
    unsigned int Inserted:1;
    unsigned int Expired:1;
    unsigned int DebugActive;
    unsigned int DpcActive;
    long Lock;
    long SignalState;
    struct _LIST_ENTRY WaitListHead;
};

enum _DOT11_PHY_TYPE
{
    dot11_phy_type_unknown=0,
    dot11_phy_type_any=0,
    dot11_phy_type_fhss=1,
    dot11_phy_type_dsss=2,
    dot11_phy_type_irbaseband=3,
    dot11_phy_type_ofdm=4,
    dot11_phy_type_hrdsss=5,
    dot11_phy_type_erp=6,
    dot11_phy_type_ht=7,
    dot11_phy_type_IHV_start=-2147483648,
    dot11_phy_type_IHV_end=-1
};

struct _KTHREAD
{
};

enum FWP_FILTER_ENUM_TYPE_
{
    FWP_FILTER_ENUM_FULLY_CONTAINED=0,
    FWP_FILTER_ENUM_OVERLAPPING=1,
    FWP_FILTER_ENUM_TYPE_MAX=2
};

struct _UNICODE_STRING
{
    unsigned int Length;
    unsigned int MaximumLength;
    unsigned int * Buffer;
};

struct _SYSTEM_POWER_STATE_CONTEXT
{
    unsigned long Reserved1:8;
    unsigned long TargetSystemState:4;
    unsigned long EffectiveSystemState:4;
    unsigned long CurrentSystemState:4;
    unsigned long IgnoreHibernationPath:1;
    unsigned long PseudoTransition:1;
    unsigned long Reserved2:10;
    unsigned long ContextAsUlong;
};

struct _PAGED_LOOKASIDE_LIST
{
    struct _GENERAL_LOOKASIDE L;
    struct _FAST_MUTEX Lock__ObsoleteButDoNotDelete;
};

struct _TXN_PARAMETER_BLOCK
{
    unsigned int Length;
    unsigned int TxFsContext;
    void * TransactionObject;
};

struct _ADDRESS_FAMILY_INFORMATION
{
    unsigned int EthernetType;
    unsigned int HeaderSize;
    unsigned int AddressBytes;
    unsigned int NextHeaderOffset;
    unsigned int HopLimitOffset;
    unsigned int SourceAddressOffset;
    unsigned int DestinationAddressOffset;
    unsigned int WfpInboundIpPacketLayerId;
    unsigned int WfpOutboundIpPacketLayerId;
    unsigned int WfpOutboundTransportLayerId;
    unsigned int WfpRouteAuthorizationLayerId;
};

struct _RTL_DYNAMIC_HASH_TABLE_ENTRY
{
    struct _LIST_ENTRY Linkage;
    unsigned long Signature;
};

enum _WHEA_ERROR_SEVERITY
{
    WheaErrSevRecoverable=0,
    WheaErrSevFatal=1,
    WheaErrSevCorrected=2,
    WheaErrSevInformational=3
};

struct FWPP_NBL_TAGGED_CONTEXT_
{
};

enum FWPM_ENGINE_OPTION_
{
    FWPM_ENGINE_COLLECT_NET_EVENTS=0,
    FWPM_ENGINE_NET_EVENT_MATCH_ANY_KEYWORDS=1,
    FWPM_ENGINE_NAME_CACHE=2,
    FWPM_ENGINE_OPTION_MAX=3
};

enum _IO_ALLOCATION_ACTION
{
    KeepObject=1,
    DeallocateObject=2,
    DeallocateObjectKeepRegisters=3
};

union _WHEA_PERSISTENCE_INFO
{
    unsigned int Signature:16;
    unsigned int Length:24;
    unsigned int Identifier:16;
    unsigned int Attributes:2;
    unsigned int DoNotLog:1;
    unsigned int Reserved:5;
    unsigned int AsULONGLONG;
};

struct WFP_NBL_INFO_CONTAINER_
{
    struct FWPP_NBL_INJECTION_CONTEXT_ * injectionCtxt;
    struct FWPP_NBL_TAGGED_CONTEXT_ * taggedContexts;
    void * ipsecCtxt;
};

enum FWP_DIRECTION_
{
    FWP_DIRECTION_OUTBOUND=0,
    FWP_DIRECTION_INBOUND=1,
    FWP_DIRECTION_MAX=2
};

struct _KEVENT
{
    struct _DISPATCHER_HEADER Header;
};

struct _SCATTER_GATHER_ELEMENT
{
    union _LARGE_INTEGER Address;
    unsigned long Length;
    unsigned long Reserved;
};

union _DL_OUI
{
    unsigned int Byte[3];
    unsigned int Group:1;
    unsigned int Local:1;
};

enum _FILE_INFORMATION_CLASS
{
    FileDirectoryInformation=1,
    FileFullDirectoryInformation=2,
    FileBothDirectoryInformation=3,
    FileBasicInformation=4,
    FileStandardInformation=5,
    FileInternalInformation=6,
    FileEaInformation=7,
    FileAccessInformation=8,
    FileNameInformation=9,
    FileRenameInformation=10,
    FileLinkInformation=11,
    FileNamesInformation=12,
    FileDispositionInformation=13,
    FilePositionInformation=14,
    FileFullEaInformation=15,
    FileModeInformation=16,
    FileAlignmentInformation=17,
    FileAllInformation=18,
    FileAllocationInformation=19,
    FileEndOfFileInformation=20,
    FileAlternateNameInformation=21,
    FileStreamInformation=22,
    FilePipeInformation=23,
    FilePipeLocalInformation=24,
    FilePipeRemoteInformation=25,
    FileMailslotQueryInformation=26,
    FileMailslotSetInformation=27,
    FileCompressionInformation=28,
    FileObjectIdInformation=29,
    FileCompletionInformation=30,
    FileMoveClusterInformation=31,
    FileQuotaInformation=32,
    FileReparsePointInformation=33,
    FileNetworkOpenInformation=34,
    FileAttributeTagInformation=35,
    FileTrackingInformation=36,
    FileIdBothDirectoryInformation=37,
    FileIdFullDirectoryInformation=38,
    FileValidDataLengthInformation=39,
    FileShortNameInformation=40,
    FileIoCompletionNotificationInformation=41,
    FileIoStatusBlockRangeInformation=42,
    FileIoPriorityHintInformation=43,
    FileSfioReserveInformation=44,
    FileSfioVolumeInformation=45,
    FileHardLinkInformation=46,
    FileProcessIdsUsingFileInformation=47,
    FileNormalizedNameInformation=48,
    FileNetworkPhysicalNameInformation=49,
    FileIdGlobalTxDirectoryInformation=50,
    FileIsRemoteDeviceInformation=51,
    FileAttributeCacheInformation=52,
    FileNumaNodeInformation=53,
    FileStandardLinkInformation=54,
    FileMaximumInformation=55
};

struct _KDPC
{
    unsigned int Type;
    unsigned int Importance;
    unsigned int Number;
    struct _LIST_ENTRY DpcListEntry;
    void  ( * DeferredRoutine)(struct _KDPC * ,void * ,void * ,void * );
    void * DeferredContext;
    void * SystemArgument1;
    void * SystemArgument2;
    void * DpcData;
};

struct _KDEVICE_QUEUE
{
    int Type;
    int Size;
    struct _LIST_ENTRY DeviceListHead;
    unsigned long Lock;
    unsigned int Busy;
};

enum IKEEXT_QM_SA_STATE_
{
    IKEEXT_QM_SA_STATE_NONE=0,
    IKEEXT_QM_SA_STATE_INITIAL=1,
    IKEEXT_QM_SA_STATE_FINAL=2,
    IKEEXT_QM_SA_STATE_COMPLETE=3,
    IKEEXT_QM_SA_STATE_MAX=4
};

struct _EVENT_DESCRIPTOR
{
    unsigned int Id;
    unsigned int Version;
    unsigned int Channel;
    unsigned int Level;
    unsigned int Opcode;
    unsigned int Task;
    unsigned int Keyword;
};

struct sockaddr
{
    unsigned int sa_family;
    char sa_data[14];
};

struct _COMPRESSED_DATA_INFO
{
};

struct _IPV4_HEADER
{
    unsigned int VersionAndHeaderLength;
    unsigned int HeaderLength:4;
    unsigned int Version:4;
    unsigned int TypeOfServiceAndEcnField;
    unsigned int EcnField:2;
    unsigned int TypeOfService:6;
    unsigned int TotalLength;
    unsigned int Identification;
    unsigned int FlagsAndOffset;
    unsigned int DontUse1:5;
    unsigned int MoreFragments:1;
    unsigned int DontFragment:1;
    unsigned int Reserved:1;
    unsigned int DontUse2:8;
    unsigned int TimeToLive;
    unsigned int Protocol;
    unsigned int HeaderChecksum;
    struct in_addr SourceAddress;
    struct in_addr DestinationAddress;
};

enum _DEVICE_USAGE_NOTIFICATION_TYPE
{
    DeviceUsageTypeUndefined=0,
    DeviceUsageTypePaging=1,
    DeviceUsageTypeHibernation=2,
    DeviceUsageTypeDumpFile=3
};

struct LIST_ENTRY32
{
    unsigned long Flink;
    unsigned long Blink;
};

struct _KAPC
{
    unsigned int Type;
    unsigned int SpareByte0;
    unsigned int Size;
    unsigned int SpareByte1;
    unsigned long SpareLong0;
    struct _KTHREAD * Thread;
    struct _LIST_ENTRY ApcListEntry;
    void  ( * KernelRoutine)(struct _KAPC * ,void  ( ** )(void * ,void * ,void * ),void ** ,void ** ,void ** );
    void  ( * RundownRoutine)(struct _KAPC * );
    void  ( * NormalRoutine)(void * ,void * ,void * );
    void * NormalContext;
    void * SystemArgument1;
    void * SystemArgument2;
    char ApcStateIndex;
    char ApcMode;
    unsigned int Inserted;
};

struct _KSEMAPHORE
{
    struct _DISPATCHER_HEADER Header;
    long Limit;
};

struct _ERESOURCE
{
    struct _LIST_ENTRY SystemResourcesList;
    struct _OWNER_ENTRY * OwnerTable;
    int ActiveCount;
    unsigned int Flag;
    struct _KSEMAPHORE * SharedWaiters;
    struct _KEVENT * ExclusiveWaiters;
    struct _OWNER_ENTRY OwnerEntry;
    unsigned long ActiveEntries;
    unsigned long ContentionCount;
    unsigned long NumberOfSharedWaiters;
    unsigned long NumberOfExclusiveWaiters;
    void * Address;
    unsigned long CreatorBackTraceIndex;
    unsigned long SpinLock;
};

enum _DEVICE_POWER_STATE
{
    PowerDeviceUnspecified=0,
    PowerDeviceD0=1,
    PowerDeviceD1=2,
    PowerDeviceD2=3,
    PowerDeviceD3=4,
    PowerDeviceMaximum=5
};

struct _PPL_LOOKASIDE_LIST
{
    struct _LOOKASIDE_LIST_EX List;
    struct _LOOKASIDE_LIST_EX * BackendList;
};

struct _STRING
{
    unsigned int Length;
    unsigned int MaximumLength;
    char * Buffer;
};

struct sockaddr_in
{
    unsigned int sin_family;
    unsigned int sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
};

struct _RTL_SCALABLE_MRSW_LOCK_COUNTER
{
    long Count;
};

struct _ALE_PEER_INFORMATION
{
};

struct _SINGLE_LIST_ENTRY
{
    struct _SINGLE_LIST_ENTRY * Next;
};

union _unnamed_3399
{
    struct _INITIAL_PRIVILEGE_SET InitialPrivilegeSet;
    struct _PRIVILEGE_SET PrivilegeSet;
};

struct _ACCESS_STATE
{
    struct _LUID OperationID;
    unsigned int SecurityEvaluated;
    unsigned int GenerateAudit;
    unsigned int GenerateOnClose;
    unsigned int PrivilegesAllocated;
    unsigned long Flags;
    unsigned long RemainingDesiredAccess;
    unsigned long PreviouslyGrantedAccess;
    unsigned long OriginalDesiredAccess;
    struct _SECURITY_SUBJECT_CONTEXT SubjectSecurityContext;
    void * SecurityDescriptor;
    void * AuxData;
    union _unnamed_3399 Privileges;
    unsigned int AuditPrivileges;
    struct _UNICODE_STRING ObjectName;
    struct _UNICODE_STRING ObjectTypeName;
};

struct _CM_RESOURCE_LIST
{
    unsigned long Count;
    struct _CM_FULL_RESOURCE_DESCRIPTOR List[1];
};

enum _WHEA_ERROR_PACKET_DATA_FORMAT
{
    WheaDataFormatIPFSalRecord=0,
    WheaDataFormatXPFMCA=1,
    WheaDataFormatMemory=2,
    WheaDataFormatPCIExpress=3,
    WheaDataFormatNMIPort=4,
    WheaDataFormatPCIXBus=5,
    WheaDataFormatPCIXDevice=6,
    WheaDataFormatGeneric=7,
    WheaDataFormatMax=8
};

struct sockaddr
{
    unsigned int sa_family;
    char sa_data[14];
};

struct _WPP_SOCKADDR
{
    struct sockaddr * SockAddr;
    unsigned int Length;
};

struct _MDL
{
    struct _MDL * Next;
    int Size;
    int MdlFlags;
    struct _EPROCESS * Process;
    void * MappedSystemVa;
    void * StartVa;
    unsigned long ByteCount;
    unsigned long ByteOffset;
};

struct _NET_BUFFER_LIST
{
    struct _NET_BUFFER_LIST * Next;
    struct _NET_BUFFER * FirstNetBuffer;
    union _SLIST_HEADER Link;
    struct _NET_BUFFER_LIST_CONTEXT * Context;
    struct _NET_BUFFER_LIST * ParentNetBufferList;
    void * NdisPoolHandle;
    void * NdisReserved[2];
    void * ProtocolReserved[4];
    void * MiniportReserved[2];
    void * Scratch;
    void * SourceHandle;
    unsigned long NblFlags;
    long ChildRefCount;
    unsigned long Flags;
    int Status;
    void * NetBufferListInfo[17];
};

struct _RTL_MRSW_LOCK
{
    unsigned long ExclusiveLock;
    long ReaderCount;
};

struct _ECP_LIST
{
};

struct _IO_DRIVER_CREATE_CONTEXT
{
    int Size;
    struct _ECP_LIST * ExtraCreateParameter;
    void * DeviceObjectHint;
    struct _TXN_PARAMETER_BLOCK * TxnParameters;
};

struct _unnamed_3410
{
    unsigned long LowPart;
    long HighPart;
};

union _LARGE_INTEGER
{
    unsigned long LowPart;
    long HighPart;
    struct _unnamed_3410 u;
    int QuadPart;
};

union _WHEA_ERROR_RECORD_HEADER_FLAGS
{
    unsigned long Recovered:1;
    unsigned long PreviousError:1;
    unsigned long Simulated:1;
    unsigned long Reserved:29;
    unsigned long AsULONG;
};

struct _FILE_NETWORK_OPEN_INFORMATION
{
    union _LARGE_INTEGER CreationTime;
    union _LARGE_INTEGER LastAccessTime;
    union _LARGE_INTEGER LastWriteTime;
    union _LARGE_INTEGER ChangeTime;
    union _LARGE_INTEGER AllocationSize;
    union _LARGE_INTEGER EndOfFile;
    unsigned long FileAttributes;
};

struct _GENERAL_LOOKASIDE_POOL
{
    union _SLIST_HEADER ListHead;
    struct _SINGLE_LIST_ENTRY SingleListHead;
    unsigned int Depth;
    unsigned int MaximumDepth;
    unsigned long TotalAllocates;
    unsigned long AllocateMisses;
    unsigned long AllocateHits;
    unsigned long TotalFrees;
    unsigned long FreeMisses;
    unsigned long FreeHits;
    enum _POOL_TYPE Type;
    unsigned long Tag;
    unsigned long Size;
    void *  ( * AllocateEx)(enum _POOL_TYPE ,unsigned long ,unsigned long ,struct _LOOKASIDE_LIST_EX * );
    void *  ( * Allocate)(enum _POOL_TYPE ,unsigned long ,unsigned long );
    void  ( * FreeEx)(void * ,struct _LOOKASIDE_LIST_EX * );
    void  ( * Free)(void * );
    struct _LIST_ENTRY ListEntry;
    unsigned long LastTotalAllocates;
    unsigned long LastAllocateMisses;
    unsigned long LastAllocateHits;
    unsigned long Future[2];
};

enum IPPROTO
{
    IPPROTO_HOPOPTS=0,
    IPPROTO_ICMP=1,
    IPPROTO_IGMP=2,
    IPPROTO_GGP=3,
    IPPROTO_IPV4=4,
    IPPROTO_ST=5,
    IPPROTO_TCP=6,
    IPPROTO_CBT=7,
    IPPROTO_EGP=8,
    IPPROTO_IGP=9,
    IPPROTO_PUP=12,
    IPPROTO_UDP=17,
    IPPROTO_IDP=22,
    IPPROTO_RDP=27,
    IPPROTO_IPV6=41,
    IPPROTO_ROUTING=43,
    IPPROTO_FRAGMENT=44,
    IPPROTO_ESP=50,
    IPPROTO_AH=51,
    IPPROTO_ICMPV6=58,
    IPPROTO_NONE=59,
    IPPROTO_DSTOPTS=60,
    IPPROTO_ND=77,
    IPPROTO_ICLFXBM=78,
    IPPROTO_PIM=103,
    IPPROTO_PGM=113,
    IPPROTO_L2TP=115,
    IPPROTO_SCTP=132,
    IPPROTO_RAW=255,
    IPPROTO_MAX=256,
    IPPROTO_RESERVED_RAW=257,
    IPPROTO_RESERVED_IPSEC=258,
    IPPROTO_RESERVED_IPSECOFFLOAD=259,
    IPPROTO_RESERVED_MAX=260
};

enum DEVICE_TEXT_TYPE
{
    DeviceTextDescription=0,
    DeviceTextLocationInformation=1
};

enum _NDIS_PROCESSOR_VENDOR
{
    NdisProcessorVendorUnknown=0,
    NdisProcessorVendorGenuinIntel=1,
    NdisProcessorVendorGenuineIntel=1,
    NdisProcessorVendorAuthenticAMD=2
};

union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS
{
    unsigned long Primary:1;
    unsigned long ContainmentWarning:1;
    unsigned long Reset:1;
    unsigned long ThresholdExceeded:1;
    unsigned long ResourceNotAvailable:1;
    unsigned long LatentError:1;
    unsigned long Reserved:26;
    unsigned long AsULONG;
};

struct _KLOCK_QUEUE_HANDLE
{
    struct _KSPIN_LOCK_QUEUE LockQueue;
    unsigned int OldIrql;
};

struct _IO_RESOURCE_LIST
{
    unsigned int Version;
    unsigned int Revision;
    unsigned long Count;
    struct _IO_RESOURCE_DESCRIPTOR Descriptors[1];
};

struct sockaddr_in6
{
    unsigned int sin6_family;
    unsigned int sin6_port;
    unsigned long sin6_flowinfo;
    struct in6_addr sin6_addr;
    unsigned long sin6_scope_id;
    struct SCOPE_ID sin6_scope_struct;
};

struct _FAST_IO_DISPATCH
{
    unsigned long SizeOfFastIoDispatch;
    unsigned int  ( * FastIoCheckIfPossible)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned int ,unsigned long ,unsigned int ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoRead)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned int ,unsigned long ,void * ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoWrite)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned int ,unsigned long ,void * ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoQueryBasicInfo)(struct _FILE_OBJECT * ,unsigned int ,struct _FILE_BASIC_INFORMATION * ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoQueryStandardInfo)(struct _FILE_OBJECT * ,unsigned int ,struct _FILE_STANDARD_INFORMATION * ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoLock)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,union _LARGE_INTEGER * ,struct _EPROCESS * ,unsigned long ,unsigned int ,unsigned int ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoUnlockSingle)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,union _LARGE_INTEGER * ,struct _EPROCESS * ,unsigned long ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoUnlockAll)(struct _FILE_OBJECT * ,struct _EPROCESS * ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoUnlockAllByKey)(struct _FILE_OBJECT * ,void * ,unsigned long ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoDeviceControl)(struct _FILE_OBJECT * ,unsigned int ,void * ,unsigned long ,void * ,unsigned long ,unsigned long ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    void  ( * AcquireFileForNtCreateSection)(struct _FILE_OBJECT * );
    void  ( * ReleaseFileForNtCreateSection)(struct _FILE_OBJECT * );
    void  ( * FastIoDetachDevice)(struct _DEVICE_OBJECT * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoQueryNetworkOpenInfo)(struct _FILE_OBJECT * ,unsigned int ,struct _FILE_NETWORK_OPEN_INFORMATION * ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    long  ( * AcquireForModWrite)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,struct _ERESOURCE ** ,struct _DEVICE_OBJECT * );
    unsigned int  ( * MdlRead)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned long ,struct _MDL ** ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * MdlReadComplete)(struct _FILE_OBJECT * ,struct _MDL * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * PrepareMdlWrite)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned long ,struct _MDL ** ,struct _IO_STATUS_BLOCK * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * MdlWriteComplete)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,struct _MDL * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoReadCompressed)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned long ,void * ,struct _MDL ** ,struct _IO_STATUS_BLOCK * ,struct _COMPRESSED_DATA_INFO * ,unsigned long ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoWriteCompressed)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,unsigned long ,unsigned long ,void * ,struct _MDL ** ,struct _IO_STATUS_BLOCK * ,struct _COMPRESSED_DATA_INFO * ,unsigned long ,struct _DEVICE_OBJECT * );
    unsigned int  ( * MdlReadCompleteCompressed)(struct _FILE_OBJECT * ,struct _MDL * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * MdlWriteCompleteCompressed)(struct _FILE_OBJECT * ,union _LARGE_INTEGER * ,struct _MDL * ,struct _DEVICE_OBJECT * );
    unsigned int  ( * FastIoQueryOpen)(struct _IRP * ,struct _FILE_NETWORK_OPEN_INFORMATION * ,struct _DEVICE_OBJECT * );
    long  ( * ReleaseForModWrite)(struct _FILE_OBJECT * ,struct _ERESOURCE * ,struct _DEVICE_OBJECT * );
    long  ( * AcquireForCcFlush)(struct _FILE_OBJECT * ,struct _DEVICE_OBJECT * );
    long  ( * ReleaseForCcFlush)(struct _FILE_OBJECT * ,struct _DEVICE_OBJECT * );
};

union _DL_EI48
{
    unsigned int Byte[3];
};

struct _LOOKASIDE_LIST_EX
{
    struct _GENERAL_LOOKASIDE_POOL L;
};

struct _PROCESSOR_NUMBER
{
    unsigned int Group;
    unsigned int Number;
    unsigned int Reserved;
};

struct _WHEA_ERROR_RECORD_HEADER
{
    unsigned long Signature;
    union _WHEA_REVISION Revision;
    unsigned long SignatureEnd;
    unsigned int SectionCount;
    enum _WHEA_ERROR_SEVERITY Severity;
    union _WHEA_ERROR_RECORD_HEADER_VALIDBITS ValidBits;
    unsigned long Length;
    union _WHEA_TIMESTAMP Timestamp;
    struct _GUID PlatformId;
    struct _GUID PartitionId;
    struct _GUID CreatorId;
    struct _GUID NotifyType;
    unsigned int RecordId;
    union _WHEA_ERROR_RECORD_HEADER_FLAGS Flags;
    union _WHEA_PERSISTENCE_INFO PersistenceInfo;
    unsigned int Reserved[12];
};

enum FWPS_NET_BUFFER_LIST_TYPE_
{
    FWPS_NBL_TYPE_ALLOCATED_BY_WFP=0,
    FWPS_NBL_TYPE_CLONED_BY_WFP=1,
    FWPS_NBL_TYPE_REFERENCED_BY_WFP=2,
    FWPS_NBL_TYPE_MAX=3
};

struct _NL_LOCAL_ADDRESS
{
};

struct _ENDPOINT_CONTEXT
{
};

struct FWPP_NBL_INJECTION_CONTEXT_
{
    enum FWPS_NET_BUFFER_LIST_TYPE_ nblType;
    struct _NET_BUFFER_LIST * parentFragmentNblChain;
    enum IPPROTO ipVersion;
    unsigned int ipv6FirstFragHeader[128];
    unsigned int * ipv6FirstFragHeaderAlloc;
    unsigned long ipv6FirstFragHeaderSize;
    unsigned int ipv4FirstFragHeader[20];
    int stackContextInitialized;
    int deepClone;
    struct ALE_IPSEC_CONTEXT_ ipSecContext;
    struct _NL_LOCAL_ADDRESS * epochLocalAddress;
    unsigned int epochLocalPort;
    struct _ENDPOINT_CONTEXT * epochEndpointContext;
    struct FWPP_PACKET_INJECTOR_INFO_ * injectorInfo;
    unsigned int * ipsecContextType;
    unsigned int ipsecContextTypeStorage;
    long referenceCount;
    struct IPSEC_VIRTUAL_IF_TUNNEL_INFO0_ virtualIfTunnelInfo;
};

enum FWPM_SERVICE_STATE_
{
    FWPM_SERVICE_STOPPED=0,
    FWPM_SERVICE_START_PENDING=1,
    FWPM_SERVICE_STOP_PENDING=2,
    FWPM_SERVICE_RUNNING=3,
    FWPM_SERVICE_STATE_MAX=4
};

struct _RTL_DYNAMIC_HASH_TABLE_CONTEXT
{
    struct _LIST_ENTRY * ChainHead;
    struct _LIST_ENTRY * PrevLinkage;
    unsigned long Signature;
};

struct ALE_IPSEC_CONTEXT_
{
    void * extensibleContext;
    unsigned int ipsecInboundFilterId;
    unsigned int lastAcquireTimeStamp;
    unsigned int preferredInboundSASpi;
    unsigned int preferredInboundTunnelSASpi;
    unsigned long flags;
    struct FWPS_IPSEC_SPECIFIC_TUPLES0_ specificTuples;
    unsigned int mmSaId;
    unsigned int qmSaId;
    struct _GUID saLookupContext;
    struct _ALE_PEER_TOKENS * peerTokenInformation;
    struct _ALE_PEER_INFORMATION * peerInformation;
    unsigned long queryMask;
    unsigned int ipsecStatus;
};

struct _WHEA_ERROR_RECORD
{
    struct _WHEA_ERROR_RECORD_HEADER Header;
    struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR SectionDescriptor[1];
};

struct _LIST_ENTRY
{
    struct _LIST_ENTRY * Flink;
    struct _LIST_ENTRY * Blink;
};

struct _DEVOBJ_EXTENSION
{
    int Type;
    unsigned int Size;
    struct _DEVICE_OBJECT * DeviceObject;
};

struct _GENERAL_LOOKASIDE
{
    union _SLIST_HEADER ListHead;
    struct _SINGLE_LIST_ENTRY SingleListHead;
    unsigned int Depth;
    unsigned int MaximumDepth;
    unsigned long TotalAllocates;
    unsigned long AllocateMisses;
    unsigned long AllocateHits;
    unsigned long TotalFrees;
    unsigned long FreeMisses;
    unsigned long FreeHits;
    enum _POOL_TYPE Type;
    unsigned long Tag;
    unsigned long Size;
    void *  ( * AllocateEx)(enum _POOL_TYPE ,unsigned long ,unsigned long ,struct _LOOKASIDE_LIST_EX * );
    void *  ( * Allocate)(enum _POOL_TYPE ,unsigned long ,unsigned long );
    void  ( * FreeEx)(void * ,struct _LOOKASIDE_LIST_EX * );
    void  ( * Free)(void * );
    struct _LIST_ENTRY ListEntry;
    unsigned long LastTotalAllocates;
    unsigned long LastAllocateMisses;
    unsigned long LastAllocateHits;
    unsigned long Future[2];
};

struct _SCATTER_GATHER_LIST
{
    unsigned long NumberOfElements;
    unsigned long Reserved;
    struct _SCATTER_GATHER_ELEMENT Elements[0];
};

struct _ETHREAD
{
};

struct _SECTION_OBJECT_POINTERS
{
    void * DataSectionObject;
    void * SharedCacheMap;
    void * ImageSectionObject;
};

enum _SYSTEM_POWER_STATE
{
    PowerSystemUnspecified=0,
    PowerSystemWorking=1,
    PowerSystemSleeping1=2,
    PowerSystemSleeping2=3,
    PowerSystemSleeping3=4,
    PowerSystemHibernate=5,
    PowerSystemShutdown=6,
    PowerSystemMaximum=7
};

union _POWER_STATE
{
    enum _SYSTEM_POWER_STATE SystemState;
    enum _DEVICE_POWER_STATE DeviceState;
};

struct _unnamed_3443
{
    unsigned int s_b1;
    unsigned int s_b2;
    unsigned int s_b3;
    unsigned int s_b4;
};

struct _unnamed_3444
{
    unsigned int s_w1;
    unsigned int s_w2;
};

union _unnamed_3445
{
    struct _unnamed_3443 S_un_b;
    struct _unnamed_3444 S_un_w;
    unsigned long S_addr;
};

struct in_addr
{
    union _unnamed_3445 S_un;
};

enum IKEEXT_DH_GROUP_
{
    IKEEXT_DH_GROUP_NONE=0,
    IKEEXT_DH_GROUP_1=1,
    IKEEXT_DH_GROUP_2=2,
    IKEEXT_DH_GROUP_2048=3,
    IKEEXT_DH_ECP_256=4,
    IKEEXT_DH_ECP_384=5,
    IKEEXT_DH_GROUP_MAX=6
};

union _WHEA_ERROR_RECORD_HEADER_VALIDBITS
{
    unsigned long PlatformId:1;
    unsigned long Timestamp:1;
    unsigned long PartitionId:1;
    unsigned long Reserved:29;
    unsigned long AsULONG;
};

union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS
{
    unsigned int FRUId:1;
    unsigned int FRUText:1;
    unsigned int Reserved:6;
    unsigned int AsUCHAR;
};

struct _IO_TIMER
{
};

struct _RTL_DYNAMIC_HASH_TABLE
{
    unsigned long Flags;
    unsigned long Shift;
    unsigned long TableSize;
    unsigned long Pivot;
    unsigned long DivisorMask;
    unsigned long NumEntries;
    unsigned long NonEmptyBuckets;
    unsigned long NumEnumerators;
    void * Directory;
};

struct FWPP_PACKET_INJECTOR_INFO_
{
    void * injectionHandle;
    void * injectionContext;
};

enum IPSEC_TRANSFORM_TYPE_
{
    IPSEC_TRANSFORM_AH=1,
    IPSEC_TRANSFORM_ESP_AUTH=2,
    IPSEC_TRANSFORM_ESP_CIPHER=3,
    IPSEC_TRANSFORM_ESP_AUTH_AND_CIPHER=4,
    IPSEC_TRANSFORM_ESP_AUTH_FW=5,
    IPSEC_TRANSFORM_TYPE_MAX=6
};

struct _IO_COMPLETION_CONTEXT
{
    void * Port;
    void * Key;
};

struct IPSEC_VIRTUAL_IF_TUNNEL_INFO0_
{
    unsigned int virtualIfTunnelId;
    unsigned int trafficSelectorId;
};

struct _unnamed_3456
{
    unsigned long LowPart;
    unsigned long HighPart;
};

union _ULARGE_INTEGER
{
    unsigned long LowPart;
    unsigned long HighPart;
    struct _unnamed_3456 u;
    unsigned int QuadPart;
};

struct _EVENT_DATA_DESCRIPTOR
{
    unsigned int Ptr;
    unsigned long Size;
    unsigned long Reserved;
};

struct _IO_SECURITY_CONTEXT
{
    struct _SECURITY_QUALITY_OF_SERVICE * SecurityQos;
    struct _ACCESS_STATE * AccessState;
    unsigned long DesiredAccess;
    unsigned long FullCreateOptions;
};

struct _NPI_MODULEID
{
    unsigned int Length;
    enum _NPI_MODULEID_TYPE Type;
    struct _GUID Guid;
    struct _LUID IfLuid;
};

struct _FILE_BASIC_INFORMATION
{
    union _LARGE_INTEGER CreationTime;
    union _LARGE_INTEGER LastAccessTime;
    union _LARGE_INTEGER LastWriteTime;
    union _LARGE_INTEGER ChangeTime;
    unsigned long FileAttributes;
};

struct _IPV6_FRAGMENT_HEADER
{
    unsigned int NextHeader;
    unsigned int Reserved;
    unsigned int DontUse1:8;
    unsigned int MoreFragments:1;
    unsigned int ReservedBits:2;
    unsigned int DontUse2:5;
    unsigned int OffsetAndFlags;
    unsigned int Id;
};

struct _VPB
{
    int Type;
    int Size;
    unsigned int Flags;
    unsigned int VolumeLabelLength;
    struct _DEVICE_OBJECT * DeviceObject;
    struct _DEVICE_OBJECT * RealDevice;
    unsigned long SerialNumber;
    unsigned long ReferenceCount;
    wchar_t VolumeLabel[32];
};

union _SLIST_HEADER
{
    unsigned int Alignment;
    struct _SINGLE_LIST_ENTRY Next;
    unsigned int Depth;
    unsigned int Sequence;
};

union _unnamed_3465
{
    struct _IRP * MasterIrp;
    long IrpCount;
    void * SystemBuffer;
};

struct _unnamed_3466
{
    void  ( * UserApcRoutine)(void * ,struct _IO_STATUS_BLOCK * ,unsigned long );
    void * IssuingProcess;
    void * UserApcContext;
};

union _unnamed_3467
{
    struct _unnamed_3466 AsynchronousParameters;
    union _LARGE_INTEGER AllocationSize;
};

struct _unnamed_3468
{
    struct _KDEVICE_QUEUE_ENTRY DeviceQueueEntry;
    void * DriverContext[4];
    struct _ETHREAD * Thread;
    char * AuxiliaryBuffer;
    struct _LIST_ENTRY ListEntry;
    struct _IO_STACK_LOCATION * CurrentStackLocation;
    unsigned long PacketType;
    struct _FILE_OBJECT * OriginalFileObject;
};

union _unnamed_3469
{
    struct _unnamed_3468 Overlay;
    struct _KAPC Apc;
    void * CompletionKey;
};

struct _IRP
{
    int Type;
    unsigned int Size;
    struct _MDL * MdlAddress;
    unsigned long Flags;
    union _unnamed_3465 AssociatedIrp;
    struct _LIST_ENTRY ThreadListEntry;
    struct _IO_STATUS_BLOCK IoStatus;
    char RequestorMode;
    unsigned int PendingReturned;
    char StackCount;
    char CurrentLocation;
    unsigned int Cancel;
    unsigned int CancelIrql;
    char ApcEnvironment;
    unsigned int AllocationFlags;
    struct _IO_STATUS_BLOCK * UserIosb;
    struct _KEVENT * UserEvent;
    union _unnamed_3467 Overlay;
    void  ( * CancelRoutine)(struct _DEVICE_OBJECT * ,struct _IRP * );
    void * UserBuffer;
    union _unnamed_3469 Tail;
};

enum BUS_QUERY_ID_TYPE
{
    BusQueryDeviceID=0,
    BusQueryHardwareIDs=1,
    BusQueryCompatibleIDs=2,
    BusQueryInstanceID=3,
    BusQueryDeviceSerialNumber=4,
    BusQueryContainerID=5
};

struct _NET_BUFFER_SHARED_MEMORY
{
    struct _NET_BUFFER_SHARED_MEMORY * NextSharedMemorySegment;
    unsigned long SharedMemoryFlags;
    void * SharedMemoryHandle;
    unsigned long SharedMemoryOffset;
    unsigned long SharedMemoryLength;
};

union _unnamed_3473
{
    unsigned int Byte[16];
    unsigned int Word[8];
};

struct in6_addr
{
    union _unnamed_3473 u;
};

enum IPSEC_FAILURE_POINT_
{
    IPSEC_FAILURE_NONE=0,
    IPSEC_FAILURE_ME=1,
    IPSEC_FAILURE_PEER=2,
    IPSEC_FAILURE_POINT_MAX=3
};

struct _WAIT_CONTEXT_BLOCK
{
    struct _KDEVICE_QUEUE_ENTRY WaitQueueEntry;
    enum _IO_ALLOCATION_ACTION  ( * DeviceRoutine)(struct _DEVICE_OBJECT * ,struct _IRP * ,void * ,void * );
    void * DeviceContext;
    unsigned long NumberOfMapRegisters;
    void * DeviceObject;
    void * CurrentIrp;
    struct _KDPC * BufferChainingDpc;
};

struct SCOPE_ID
{
    unsigned long Zone:28;
    unsigned long Level:4;
    unsigned long Value;
};

enum _WHEA_ERROR_TYPE
{
    WheaErrTypeProcessor=0,
    WheaErrTypeMemory=1,
    WheaErrTypePCIExpress=2,
    WheaErrTypeNMI=3,
    WheaErrTypePCIXBus=4,
    WheaErrTypePCIXDevice=5,
    WheaErrTypeGeneric=6
};

enum _WHEA_ERROR_SOURCE_TYPE
{
    WheaErrSrcTypeMCE=0,
    WheaErrSrcTypeCMC=1,
    WheaErrSrcTypeCPE=2,
    WheaErrSrcTypeNMI=3,
    WheaErrSrcTypePCIe=4,
    WheaErrSrcTypeGeneric=5,
    WheaErrSrcTypeINIT=6,
    WheaErrSrcTypeBOOT=7,
    WheaErrSrcTypeSCIGeneric=8,
    WheaErrSrcTypeIPFMCA=9,
    WheaErrSrcTypeIPFCMC=10,
    WheaErrSrcTypeIPFCPE=11,
    WheaErrSrcTypeMax=12
};

struct _WHEA_ERROR_PACKET_V2
{
    unsigned long Signature;
    unsigned long Version;
    unsigned long Length;
    union _WHEA_ERROR_PACKET_FLAGS Flags;
    enum _WHEA_ERROR_TYPE ErrorType;
    enum _WHEA_ERROR_SEVERITY ErrorSeverity;
    unsigned long ErrorSourceId;
    enum _WHEA_ERROR_SOURCE_TYPE ErrorSourceType;
    struct _GUID NotifyType;
    unsigned int Context;
    enum _WHEA_ERROR_PACKET_DATA_FORMAT DataFormat;
    unsigned long Reserved1;
    unsigned long DataOffset;
    unsigned long DataLength;
    unsigned long PshedDataOffset;
    unsigned long PshedDataLength;
};

union _WHEA_TIMESTAMP
{
    unsigned int Seconds:8;
    unsigned int Minutes:8;
    unsigned int Hours:8;
    unsigned int Precise:1;
    unsigned int Reserved:7;
    unsigned int Day:8;
    unsigned int Month:8;
    unsigned int Year:8;
    unsigned int Century:8;
    union _LARGE_INTEGER AsLARGE_INTEGER;
};

struct _NET_BUFFER_LIST_CONTEXT
{
    struct _NET_BUFFER_LIST_CONTEXT * Next;
    unsigned int Size;
    unsigned int Offset;
    unsigned int ContextData[0];
};

union _WHEA_REVISION
{
    unsigned int MinorRevision;
    unsigned int MajorRevision;
    unsigned int AsUSHORT;
};

enum _KSPIN_LOCK_QUEUE_NUMBER
{
    LockQueueUnusedSpare0=0,
    LockQueueExpansionLock=1,
    LockQueuePfnLock=2,
    LockQueueSystemSpaceLock=3,
    LockQueueVacbLock=4,
    LockQueueMasterLock=5,
    LockQueueNonPagedPoolLock=6,
    LockQueueIoCancelLock=7,
    LockQueueWorkQueueLock=8,
    LockQueueIoVpbLock=9,
    LockQueueIoDatabaseLock=10,
    LockQueueIoCompletionLock=11,
    LockQueueNtfsStructLock=12,
    LockQueueAfdWorkQueueLock=13,
    LockQueueBcbLock=14,
    LockQueueMmNonPagedPoolLock=15,
    LockQueueUnusedSpare16=16,
    LockQueueTimerTableLock=17,
    LockQueueMaximumLock=49
};

union _DL_EUI48
{
    unsigned int Byte[6];
    union _DL_OUI Oui;
    union _DL_EI48 Ei48;
};

struct _FILE_OBJECT
{
    int Type;
    int Size;
    struct _DEVICE_OBJECT * DeviceObject;
    struct _VPB * Vpb;
    void * FsContext;
    void * FsContext2;
    struct _SECTION_OBJECT_POINTERS * SectionObjectPointer;
    void * PrivateCacheMap;
    long FinalStatus;
    struct _FILE_OBJECT * RelatedFileObject;
    unsigned int LockOperation;
    unsigned int DeletePending;
    unsigned int ReadAccess;
    unsigned int WriteAccess;
    unsigned int DeleteAccess;
    unsigned int SharedRead;
    unsigned int SharedWrite;
    unsigned int SharedDelete;
    unsigned long Flags;
    struct _UNICODE_STRING FileName;
    union _LARGE_INTEGER CurrentByteOffset;
    unsigned long Waiters;
    unsigned long Busy;
    void * LastLock;
    struct _KEVENT Lock;
    struct _KEVENT Event;
    struct _IO_COMPLETION_CONTEXT * CompletionContext;
    unsigned long IrpListLock;
    struct _LIST_ENTRY IrpList;
    void * FileObjectExtension;
};

enum _DEVICE_RELATION_TYPE
{
    BusRelations=0,
    EjectionRelations=1,
    PowerRelations=2,
    RemovalRelations=3,
    TargetDeviceRelation=4,
    SingleBusRelations=5,
    TransportRelations=6
};

struct _NPAGED_LOOKASIDE_LIST
{
    struct _GENERAL_LOOKASIDE L;
    unsigned long Lock__ObsoleteButDoNotDelete;
};

union _unnamed_3489
{
    struct _LIST_ENTRY ListEntry;
    struct _WAIT_CONTEXT_BLOCK Wcb;
};

struct _DEVICE_OBJECT
{
    int Type;
    unsigned int Size;
    long ReferenceCount;
    struct _DRIVER_OBJECT * DriverObject;
    struct _DEVICE_OBJECT * NextDevice;
    struct _DEVICE_OBJECT * AttachedDevice;
    struct _IRP * CurrentIrp;
    struct _IO_TIMER * Timer;
    unsigned long Flags;
    unsigned long Characteristics;
    struct _VPB * Vpb;
    void * DeviceExtension;
    unsigned long DeviceType;
    char StackSize;
    union _unnamed_3489 Queue;
    unsigned long AlignmentRequirement;
    struct _KDEVICE_QUEUE DeviceQueue;
    struct _KDPC Dpc;
    unsigned long ActiveThreadCount;
    void * SecurityDescriptor;
    struct _KEVENT DeviceLock;
    unsigned int SectorSize;
    unsigned int Spare1;
    struct _DEVOBJ_EXTENSION * DeviceObjectExtension;
    void * Reserved;
};

struct _LUID
{
    unsigned long LowPart;
    long HighPart;
};

enum _MEMORY_CACHING_TYPE_ORIG
{
    MmFrameBufferCached=2
};

struct _CM_FULL_RESOURCE_DESCRIPTOR
{
    enum _INTERFACE_TYPE InterfaceType;
    unsigned long BusNumber;
    struct _CM_PARTIAL_RESOURCE_LIST PartialResourceList;
};

struct _INTERFACE
{
    unsigned int Size;
    unsigned int Version;
    void * Context;
    void  ( * InterfaceReference)(void * );
    void  ( * InterfaceDereference)(void * );
};

struct _unnamed_3495
{
    struct _IO_SECURITY_CONTEXT * SecurityContext;
    unsigned long Options;
    unsigned int FileAttributes;
    unsigned int ShareAccess;
    unsigned long EaLength;
};

struct _unnamed_3496
{
    unsigned long Length;
    unsigned long Key;
    union _LARGE_INTEGER ByteOffset;
};

struct _unnamed_3497
{
    unsigned long Length;
    struct _UNICODE_STRING * FileName;
    enum _FILE_INFORMATION_CLASS FileInformationClass;
    unsigned long FileIndex;
};

struct _unnamed_3498
{
    unsigned long Length;
    unsigned long CompletionFilter;
};

struct _unnamed_3499
{
    unsigned long Length;
    enum _FILE_INFORMATION_CLASS FileInformationClass;
};

struct _unnamed_3500
{
    unsigned long Length;
    enum _FILE_INFORMATION_CLASS FileInformationClass;
    struct _FILE_OBJECT * FileObject;
    unsigned int ReplaceIfExists;
    unsigned int AdvanceOnly;
    unsigned long ClusterCount;
    void * DeleteHandle;
};

struct _unnamed_3501
{
    unsigned long Length;
    void * EaList;
    unsigned long EaListLength;
    unsigned long EaIndex;
};

struct _unnamed_3502
{
    unsigned long Length;
};

enum _FSINFOCLASS
{
    FileFsVolumeInformation=1,
    FileFsLabelInformation=2,
    FileFsSizeInformation=3,
    FileFsDeviceInformation=4,
    FileFsAttributeInformation=5,
    FileFsControlInformation=6,
    FileFsFullSizeInformation=7,
    FileFsObjectIdInformation=8,
    FileFsDriverPathInformation=9,
    FileFsVolumeFlagsInformation=10,
    FileFsMaximumInformation=11
};

struct _unnamed_3504
{
    unsigned long Length;
    enum _FSINFOCLASS FsInformationClass;
};

struct _unnamed_3505
{
    unsigned long OutputBufferLength;
    unsigned long InputBufferLength;
    unsigned long FsControlCode;
    void * Type3InputBuffer;
};

struct _unnamed_3506
{
    union _LARGE_INTEGER * Length;
    unsigned long Key;
    union _LARGE_INTEGER ByteOffset;
};

struct _unnamed_3507
{
    unsigned long OutputBufferLength;
    unsigned long InputBufferLength;
    unsigned long IoControlCode;
    void * Type3InputBuffer;
};

struct _unnamed_3508
{
    unsigned long SecurityInformation;
    unsigned long Length;
};

struct _unnamed_3509
{
    unsigned long SecurityInformation;
    void * SecurityDescriptor;
};

struct _unnamed_3510
{
    struct _VPB * Vpb;
    struct _DEVICE_OBJECT * DeviceObject;
};

struct _SCSI_REQUEST_BLOCK
{
};

struct _unnamed_3512
{
    struct _SCSI_REQUEST_BLOCK * Srb;
};

struct _FILE_GET_QUOTA_INFORMATION
{
};

struct _unnamed_3514
{
    unsigned long Length;
    void * StartSid;
    struct _FILE_GET_QUOTA_INFORMATION * SidList;
    unsigned long SidListLength;
};

struct _unnamed_3515
{
    enum _DEVICE_RELATION_TYPE Type;
};

struct _GUID
{
    unsigned long Data1;
    unsigned int Data2;
    unsigned int Data3;
    unsigned int Data4[8];
};

struct _unnamed_3517
{
    struct _GUID * InterfaceType;
    unsigned int Size;
    unsigned int Version;
    struct _INTERFACE * Interface;
    void * InterfaceSpecificData;
};

struct _unnamed_3518
{
    struct _DEVICE_CAPABILITIES * Capabilities;
};

struct _unnamed_3519
{
    struct _IO_RESOURCE_REQUIREMENTS_LIST * IoResourceRequirementList;
};

struct _unnamed_3520
{
    unsigned long WhichSpace;
    void * Buffer;
    unsigned long Offset;
    unsigned long Length;
};

struct _unnamed_3521
{
    unsigned int Lock;
};

struct _unnamed_3522
{
    enum BUS_QUERY_ID_TYPE IdType;
};

struct _unnamed_3523
{
    enum DEVICE_TEXT_TYPE DeviceTextType;
    unsigned long LocaleId;
};

struct _unnamed_3524
{
    unsigned int InPath;
    unsigned int Reserved[3];
    enum _DEVICE_USAGE_NOTIFICATION_TYPE Type;
};

struct _unnamed_3525
{
    enum _SYSTEM_POWER_STATE PowerState;
};

struct _unnamed_3526
{
    struct _POWER_SEQUENCE * PowerSequence;
};

enum _POWER_STATE_TYPE
{
    SystemPowerState=0,
    DevicePowerState=1
};

enum POWER_ACTION
{
    PowerActionNone=0,
    PowerActionReserved=1,
    PowerActionSleep=2,
    PowerActionHibernate=3,
    PowerActionShutdown=4,
    PowerActionShutdownReset=5,
    PowerActionShutdownOff=6,
    PowerActionWarmEject=7
};

struct _unnamed_3529
{
    unsigned long SystemContext;
    struct _SYSTEM_POWER_STATE_CONTEXT SystemPowerStateContext;
    enum _POWER_STATE_TYPE Type;
    union _POWER_STATE State;
    enum POWER_ACTION ShutdownType;
};

struct _unnamed_3530
{
    struct _CM_RESOURCE_LIST * AllocatedResources;
    struct _CM_RESOURCE_LIST * AllocatedResourcesTranslated;
};

struct _unnamed_3531
{
    unsigned long ProviderId;
    void * DataPath;
    unsigned long BufferSize;
    void * Buffer;
};

struct _unnamed_3532
{
    void * Argument1;
    void * Argument2;
    void * Argument3;
    void * Argument4;
};

union _unnamed_3533
{
    struct _unnamed_3495 Create;
    struct _unnamed_3496 Read;
    struct _unnamed_3496 Write;
    struct _unnamed_3497 QueryDirectory;
    struct _unnamed_3498 NotifyDirectory;
    struct _unnamed_3499 QueryFile;
    struct _unnamed_3500 SetFile;
    struct _unnamed_3501 QueryEa;
    struct _unnamed_3502 SetEa;
    struct _unnamed_3504 QueryVolume;
    struct _unnamed_3504 SetVolume;
    struct _unnamed_3505 FileSystemControl;
    struct _unnamed_3506 LockControl;
    struct _unnamed_3507 DeviceIoControl;
    struct _unnamed_3508 QuerySecurity;
    struct _unnamed_3509 SetSecurity;
    struct _unnamed_3510 MountVolume;
    struct _unnamed_3510 VerifyVolume;
    struct _unnamed_3512 Scsi;
    struct _unnamed_3514 QueryQuota;
    struct _unnamed_3502 SetQuota;
    struct _unnamed_3515 QueryDeviceRelations;
    struct _unnamed_3517 QueryInterface;
    struct _unnamed_3518 DeviceCapabilities;
    struct _unnamed_3519 FilterResourceRequirements;
    struct _unnamed_3520 ReadWriteConfig;
    struct _unnamed_3521 SetLock;
    struct _unnamed_3522 QueryId;
    struct _unnamed_3523 QueryDeviceText;
    struct _unnamed_3524 UsageNotification;
    struct _unnamed_3525 WaitWake;
    struct _unnamed_3526 PowerSequence;
    struct _unnamed_3529 Power;
    struct _unnamed_3530 StartDevice;
    struct _unnamed_3531 WMI;
    struct _unnamed_3532 Others;
};

struct _IO_STACK_LOCATION
{
    unsigned int MajorFunction;
    unsigned int MinorFunction;
    unsigned int Flags;
    unsigned int Control;
    union _unnamed_3533 Parameters;
    struct _DEVICE_OBJECT * DeviceObject;
    struct _FILE_OBJECT * FileObject;
    long  ( * CompletionRoutine)(struct _DEVICE_OBJECT * ,struct _IRP * ,void * );
    void * Context;
};

struct _EVENT_DESCRIPTOR
{
    unsigned int Id;
    unsigned int Version;
    unsigned int Channel;
    unsigned int Level;
    unsigned int Opcode;
    unsigned int Task;
    unsigned int Keyword;
};

enum COMPARTMENT_ID
{
    UNSPECIFIED_COMPARTMENT_ID=0,
    DEFAULT_COMPARTMENT_ID=1
};

struct _PPL_LOOKASIDE_LIST_ARRAY
{
    unsigned long ValidEntryCount;
    unsigned long Flags;
    unsigned long Tag;
    unsigned long LookasideTag;
    unsigned long Size;
    enum _POOL_TYPE PoolType;
    unsigned int Depth;
    struct _PPL_LOOKASIDE_LIST ** LookasideLists;
};

struct _CM_PARTIAL_RESOURCE_LIST
{
    unsigned int Version;
    unsigned int Revision;
    unsigned long Count;
    struct _CM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptors[1];
};

struct _KDEVICE_QUEUE_ENTRY
{
    struct _LIST_ENTRY DeviceListEntry;
    unsigned long SortKey;
    unsigned int Inserted;
};

struct _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR
{
    unsigned long SectionOffset;
    unsigned long SectionLength;
    union _WHEA_REVISION Revision;
    union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_VALIDBITS ValidBits;
    unsigned int Reserved;
    union _WHEA_ERROR_RECORD_SECTION_DESCRIPTOR_FLAGS Flags;
    struct _GUID SectionType;
    struct _GUID FRUId;
    enum _WHEA_ERROR_SEVERITY SectionSeverity;
    char FRUText[20];
};

struct _FAST_MUTEX
{
    long Count;
    struct _KTHREAD * Owner;
    unsigned long Contention;
    struct _KEVENT Gate;
    unsigned long OldIrql;
};

union _WHEA_ERROR_PACKET_FLAGS
{
    unsigned long PreviousError:1;
    unsigned long Reserved1:1;
    unsigned long HypervisorError:1;
    unsigned long Simulated:1;
    unsigned long PlatformPfaControl:1;
    unsigned long PlatformDirectedOffline:1;
    unsigned long Reserved2:26;
    unsigned long AsULONG;
};

struct _DEVICE_CAPABILITIES
{
    unsigned int Size;
    unsigned int Version;
    unsigned long DeviceD1:1;
    unsigned long DeviceD2:1;
    unsigned long LockSupported:1;
    unsigned long EjectSupported:1;
    unsigned long Removable:1;
    unsigned long DockDevice:1;
    unsigned long UniqueID:1;
    unsigned long SilentInstall:1;
    unsigned long RawDeviceOK:1;
    unsigned long SurpriseRemovalOK:1;
    unsigned long WakeFromD0:1;
    unsigned long WakeFromD1:1;
    unsigned long WakeFromD2:1;
    unsigned long WakeFromD3:1;
    unsigned long HardwareDisabled:1;
    unsigned long NonDynamic:1;
    unsigned long WarmEjectSupported:1;
    unsigned long NoDisplayInUI:1;
    unsigned long Reserved:14;
    unsigned long Address;
    unsigned long UINumber;
    enum _DEVICE_POWER_STATE DeviceState[7];
    enum _SYSTEM_POWER_STATE SystemWake;
    enum _DEVICE_POWER_STATE DeviceWake;
    unsigned long D1Latency;
    unsigned long D2Latency;
    unsigned long D3Latency;
};

struct _IO_STATUS_BLOCK
{
    long Status;
    void * Pointer;
    unsigned long Information;
};

struct _RTL_SCALABLE_MRSW_LOCK
{
    unsigned long ExclusiveLock;
    unsigned long ReaderArrayMask;
    struct _RTL_SCALABLE_MRSW_LOCK_COUNTER ReaderCount[4];
};

struct _POWER_SEQUENCE
{
    unsigned long SequenceD1;
    unsigned long SequenceD2;
    unsigned long SequenceD3;
};

struct _GUID
{
    unsigned long Data1;
    unsigned int Data2;
    unsigned int Data3;
    unsigned int Data4[8];
};

struct _KSPIN_LOCK_QUEUE
{
    struct _KSPIN_LOCK_QUEUE * Next;
    unsigned long * Lock;
};

struct _DRIVER_EXTENSION
{
    struct _DRIVER_OBJECT * DriverObject;
    long  ( * AddDevice)(struct _DRIVER_OBJECT * ,struct _DEVICE_OBJECT * );
    unsigned long Count;
    struct _UNICODE_STRING ServiceKeyName;
};

union _REFERENCE_OBJECT
{
    unsigned long Deleting:1;
    unsigned long ReferenceCount:30;
    unsigned long Overflow:1;
    long Value;
};

struct _DRIVER_OBJECT
{
    int Type;
    int Size;
    struct _DEVICE_OBJECT * DeviceObject;
    unsigned long Flags;
    void * DriverStart;
    unsigned long DriverSize;
    void * DriverSection;
    struct _DRIVER_EXTENSION * DriverExtension;
    struct _UNICODE_STRING DriverName;
    struct _UNICODE_STRING * HardwareDatabase;
    struct _FAST_IO_DISPATCH * FastIoDispatch;
    long  ( * DriverInit)(struct _DRIVER_OBJECT * ,struct _UNICODE_STRING * );
    void  ( * DriverStartIo)(struct _DEVICE_OBJECT * ,struct _IRP * );
    void  ( * DriverUnload)(struct _DRIVER_OBJECT * );
    long  ( * MajorFunction)[28];
};

struct _NET_BUFFER
{
    struct _NET_BUFFER * Next;
    struct _MDL * CurrentMdl;
    unsigned long CurrentMdlOffset;
    unsigned long DataLength;
    unsigned long stDataLength;
    struct _MDL * MdlChain;
    unsigned long DataOffset;
    union _SLIST_HEADER Link;
    unsigned int ChecksumBias;
    unsigned int Reserved;
    void * NdisPoolHandle;
    void * NdisReserved[2];
    void * ProtocolReserved[6];
    void * MiniportReserved[4];
    union _LARGE_INTEGER DataPhysicalAddress;
    struct _NET_BUFFER_SHARED_MEMORY * SharedMemoryInfo;
    struct _SCATTER_GATHER_LIST * ScatterGatherList;
};

struct LIST_ENTRY64
{
    unsigned int Flink;
    unsigned int Blink;
};

struct _RTL_DYNAMIC_HASH_TABLE_ENUMERATOR
{
    struct _RTL_DYNAMIC_HASH_TABLE_ENTRY HashEntry;
    struct _LIST_ENTRY * ChainHead;
    unsigned long BucketIndex;
};

struct _NETIO_NET_BUFFER_CONTEXT
{
    unsigned long OriginalDataOffset;
    unsigned long OriginalDataLength;
    unsigned long TruncatedLength;
    unsigned long Flags;
    unsigned long EcnField:2;
    unsigned long EspTrailerSpaceAllocated:1;
    void * Scratch[2];
};

struct _NPI_MODULEID
{
    unsigned int Length;
    enum _NPI_MODULEID_TYPE Type;
    struct _GUID Guid;
    struct _LUID IfLuid;
};

struct _IO_RESOURCE_REQUIREMENTS_LIST
{
    unsigned long ListSize;
    enum _INTERFACE_TYPE InterfaceType;
    unsigned long BusNumber;
    unsigned long SlotNumber;
    unsigned long Reserved[3];
    unsigned long AlternativeLists;
    struct _IO_RESOURCE_LIST List[1];
};

enum tagBINDSTATUS
{
    BINDSTATUS_FINDINGRESOURCE=1,
    BINDSTATUS_CONNECTING=2,
    BINDSTATUS_REDIRECTING=3,
    BINDSTATUS_BEGINDOWNLOADDATA=4,
    BINDSTATUS_DOWNLOADINGDATA=5,
    BINDSTATUS_ENDDOWNLOADDATA=6,
    BINDSTATUS_BEGINDOWNLOADCOMPONENTS=7,
    BINDSTATUS_INSTALLINGCOMPONENTS=8,
    BINDSTATUS_ENDDOWNLOADCOMPONENTS=9,
    BINDSTATUS_USINGCACHEDCOPY=10,
    BINDSTATUS_SENDINGREQUEST=11,
    BINDSTATUS_CLASSIDAVAILABLE=12,
    BINDSTATUS_MIMETYPEAVAILABLE=13,
    BINDSTATUS_CACHEFILENAMEAVAILABLE=14,
    BINDSTATUS_BEGINSYNCOPERATION=15,
    BINDSTATUS_ENDSYNCOPERATION=16,
    BINDSTATUS_BEGINUPLOADDATA=17,
    BINDSTATUS_UPLOADINGDATA=18,
    BINDSTATUS_ENDUPLOADDATA=19,
    BINDSTATUS_PROTOCOLCLASSID=20,
    BINDSTATUS_ENCODING=21,
    BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE=22,
    BINDSTATUS_CLASSINSTALLLOCATION=23,
    BINDSTATUS_DECODING=24,
    BINDSTATUS_LOADINGMIMEHANDLER=25,
    BINDSTATUS_CONTENTDISPOSITIONATTACH=26,
    BINDSTATUS_FILTERREPORTMIMETYPE=27,
    BINDSTATUS_CLSIDCANINSTANTIATE=28,
    BINDSTATUS_IUNKNOWNAVAILABLE=29,
    BINDSTATUS_DIRECTBIND=30,
    BINDSTATUS_RAWMIMETYPE=31,
    BINDSTATUS_PROXYDETECTING=32,
    BINDSTATUS_ACCEPTRANGES=33,
    BINDSTATUS_COOKIE_SENT=34,
    BINDSTATUS_COMPACT_POLICY_RECEIVED=35,
    BINDSTATUS_COOKIE_SUPPRESSED=36,
    BINDSTATUS_COOKIE_STATE_UNKNOWN=37,
    BINDSTATUS_COOKIE_STATE_ACCEPT=38,
    BINDSTATUS_COOKIE_STATE_REJECT=39,
    BINDSTATUS_COOKIE_STATE_PROMPT=40,
    BINDSTATUS_COOKIE_STATE_LEASH=41,
    BINDSTATUS_COOKIE_STATE_DOWNGRADE=42,
    BINDSTATUS_POLICY_HREF=43,
    BINDSTATUS_P3P_HEADER=44,
    BINDSTATUS_SESSION_COOKIE_RECEIVED=45,
    BINDSTATUS_PERSISTENT_COOKIE_RECEIVED=46,
    BINDSTATUS_SESSION_COOKIES_ALLOWED=47,
    BINDSTATUS_CACHECONTROL=48,
    BINDSTATUS_CONTENTDISPOSITIONFILENAME=49,
    BINDSTATUS_MIMETEXTPLAINMISMATCH=50,
    BINDSTATUS_PUBLISHERAVAILABLE=51,
    BINDSTATUS_DISPLAYNAMEAVAILABLE=52,
    BINDSTATUS_SSLUX_NAVBLOCKED=53,
    BINDSTATUS_SERVER_MIMETYPEAVAILABLE=54,
    BINDSTATUS_SNIFFED_CLASSIDAVAILABLE=55,
    BINDSTATUS_64BIT_PROGRESS=56
};

enum tagSYSKIND
{
    SYS_WIN16=0,
    SYS_WIN32=1,
    SYS_MAC=2,
    SYS_WIN64=3
};

enum tagURLZONE
{
    URLZONE_INVALID=-1,
    URLZONE_PREDEFINED_MIN=0,
    URLZONE_LOCAL_MACHINE=0,
    URLZONE_INTRANET=1,
    URLZONE_TRUSTED=2,
    URLZONE_INTERNET=3,
    URLZONE_UNTRUSTED=4,
    URLZONE_PREDEFINED_MAX=999,
    URLZONE_USER_MIN=1000,
    URLZONE_USER_MAX=10000
};

enum _URLZONEREG
{
    URLZONEREG_DEFAULT=0,
    URLZONEREG_HKLM=1,
    URLZONEREG_HKCU=2
};

enum tagTYPEKIND
{
    TKIND_ENUM=0,
    TKIND_RECORD=1,
    TKIND_MODULE=2,
    TKIND_INTERFACE=3,
    TKIND_DISPATCH=4,
    TKIND_COCLASS=5,
    TKIND_ALIAS=6,
    TKIND_UNION=7,
    TKIND_MAX=8
};

enum tagCHANGEKIND
{
    CHANGEKIND_ADDMEMBER=0,
    CHANGEKIND_DELETEMEMBER=1,
    CHANGEKIND_SETNAMES=2,
    CHANGEKIND_SETDOCUMENTATION=3,
    CHANGEKIND_GENERAL=4,
    CHANGEKIND_INVALIDATE=5,
    CHANGEKIND_CHANGEFAILED=6,
    CHANGEKIND_MAX=7
};

enum tagCALLCONV
{
    CC_FASTCALL=0,
    CC_CDECL=1,
    CC_MSCPASCAL=2,
    CC_PASCAL=2,
    CC_MACPASCAL=3,
    CC_STDCALL=4,
    CC_FPFASTCALL=5,
    CC_SYSCALL=6,
    CC_MPWCDECL=7,
    CC_MPWPASCAL=8,
    CC_MAX=9
};

enum __MIDL_ICodeInstall_0001
{
    CIP_DISK_FULL=0,
    CIP_ACCESS_DENIED=1,
    CIP_NEWER_VERSION_EXISTS=2,
    CIP_OLDER_VERSION_EXISTS=3,
    CIP_NAME_CONFLICT=4,
    CIP_TRUST_VERIFICATION_COMPONENT_MISSING=5,
    CIP_EXE_SELF_REGISTERATION_TIMEOUT=6,
    CIP_UNSAFE_TO_ABORT=7,
    CIP_NEED_REBOOT=8,
    CIP_NEED_REBOOT_UI_PERMISSION=9
};

enum vc_attributes::YesNoMaybe
{
    No=268369921,
    Maybe=268369936,
    Yes=268370176
};

enum vc_attributes::AccessType
{
    NoAccess=0,
    Read=1,
    Write=2,
    ReadWrite=3
};

enum tagVARKIND
{
    VAR_PERINSTANCE=0,
    VAR_STATIC=1,
    VAR_CONST=2,
    VAR_DISPATCH=3
};

enum tagShutdownType
{
    IdleShutdown=0,
    ForcedShutdown=1
};

enum tagBINDSTRING
{
    BINDSTRING_HEADERS=1,
    BINDSTRING_ACCEPT_MIMES=2,
    BINDSTRING_EXTRA_URL=3,
    BINDSTRING_LANGUAGE=4,
    BINDSTRING_USERNAME=5,
    BINDSTRING_PASSWORD=6,
    BINDSTRING_UA_PIXELS=7,
    BINDSTRING_UA_COLOR=8,
    BINDSTRING_OS=9,
    BINDSTRING_USER_AGENT=10,
    BINDSTRING_ACCEPT_ENCODINGS=11,
    BINDSTRING_POST_COOKIE=12,
    BINDSTRING_POST_DATA_MIME=13,
    BINDSTRING_URL=14,
    BINDSTRING_IID=15,
    BINDSTRING_FLAG_BIND_TO_OBJECT=16,
    BINDSTRING_PTR_BIND_CONTEXT=17,
    BINDSTRING_XDR_ORIGIN=18
};

enum VARENUM
{
    VT_EMPTY=0,
    VT_NULL=1,
    VT_I2=2,
    VT_I4=3,
    VT_R4=4,
    VT_R8=5,
    VT_CY=6,
    VT_DATE=7,
    VT_BSTR=8,
    VT_DISPATCH=9,
    VT_ERROR=10,
    VT_BOOL=11,
    VT_VARIANT=12,
    VT_UNKNOWN=13,
    VT_DECIMAL=14,
    VT_I1=16,
    VT_UI1=17,
    VT_UI2=18,
    VT_UI4=19,
    VT_I8=20,
    VT_UI8=21,
    VT_INT=22,
    VT_UINT=23,
    VT_VOID=24,
    VT_HRESULT=25,
    VT_PTR=26,
    VT_SAFEARRAY=27,
    VT_CARRAY=28,
    VT_USERDEFINED=29,
    VT_LPSTR=30,
    VT_LPWSTR=31,
    VT_RECORD=36,
    VT_INT_PTR=37,
    VT_UINT_PTR=38,
    VT_FILETIME=64,
    VT_BLOB=65,
    VT_STREAM=66,
    VT_STORAGE=67,
    VT_STREAMED_OBJECT=68,
    VT_STORED_OBJECT=69,
    VT_BLOB_OBJECT=70,
    VT_CF=71,
    VT_CLSID=72,
    VT_VERSIONED_STREAM=73,
    VT_BSTR_BLOB=4095,
    VT_VECTOR=4096,
    VT_ARRAY=8192,
    VT_BYREF=16384,
    VT_RESERVED=32768,
    VT_ILLEGAL=65535,
    VT_ILLEGALMASKED=4095,
    VT_TYPEMASK=4095
};

enum tagDESCKIND
{
    DESCKIND_NONE=0,
    DESCKIND_FUNCDESC=1,
    DESCKIND_VARDESC=2,
    DESCKIND_TYPECOMP=3,
    DESCKIND_IMPLICITAPPOBJ=4,
    DESCKIND_MAX=5
};

enum _tagPARSEACTION
{
    PARSE_CANONICALIZE=1,
    PARSE_FRIENDLY=2,
    PARSE_SECURITY_URL=3,
    PARSE_ROOTDOCUMENT=4,
    PARSE_DOCUMENT=5,
    PARSE_ANCHOR=6,
    PARSE_ENCODE_IS_UNESCAPE=7,
    PARSE_DECODE_IS_ESCAPE=8,
    PARSE_PATH_FROM_URL=9,
    PARSE_URL_FROM_PATH=10,
    PARSE_MIME=11,
    PARSE_SERVER=12,
    PARSE_SCHEMA=13,
    PARSE_SITE=14,
    PARSE_DOMAIN=15,
    PARSE_LOCATION=16,
    PARSE_SECURITY_DOMAIN=17,
    PARSE_ESCAPE=18,
    PARSE_UNESCAPE=19
};

enum tagDOMNodeType
{
    NODE_INVALID=0,
    NODE_ELEMENT=1,
    NODE_ATTRIBUTE=2,
    NODE_TEXT=3,
    NODE_CDATA_SECTION=4,
    NODE_ENTITY_REFERENCE=5,
    NODE_ENTITY=6,
    NODE_PROCESSING_INSTRUCTION=7,
    NODE_COMMENT=8,
    NODE_DOCUMENT=9,
    NODE_DOCUMENT_TYPE=10,
    NODE_DOCUMENT_FRAGMENT=11,
    NODE_NOTATION=12
};

enum _tagPSUACTION
{
    PSU_DEFAULT=1,
    PSU_SECURITY_URL_ONLY=2
};

enum ReplacesCorHdrNumericDefines
{
    COMIMAGE_FLAGS_ILONLY=1,
    COMIMAGE_FLAGS_32BITREQUIRED=2,
    COMIMAGE_FLAGS_IL_LIBRARY=4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED=8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT=16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA=65536,
    COR_VERSION_MAJOR_V2=2,
    COR_VERSION_MAJOR=2,
    COR_VERSION_MINOR=0,
    COR_DELETED_NAME_LENGTH=8,
    COR_VTABLEGAP_NAME_LENGTH=8,
    NATIVE_TYPE_MAX_CB=1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=255,
    IMAGE_COR_MIH_METHODRVA=1,
    IMAGE_COR_MIH_EHRVA=2,
    IMAGE_COR_MIH_BASICBLOCK=8,
    COR_VTABLE_32BIT=1,
    COR_VTABLE_64BIT=2,
    COR_VTABLE_FROM_UNMANAGED=4,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN=8,
    COR_VTABLE_CALL_MOST_DERIVED=16,
    IMAGE_COR_EATJ_THUNK_SIZE=32,
    MAX_CLASS_NAME=1024,
    MAX_PACKAGE_NAME=1024
};

enum tagXMLEMEM_TYPE
{
    XMLELEMTYPE_ELEMENT=0,
    XMLELEMTYPE_TEXT=1,
    XMLELEMTYPE_COMMENT=2,
    XMLELEMTYPE_DOCUMENT=3,
    XMLELEMTYPE_DTD=4,
    XMLELEMTYPE_PI=5,
    XMLELEMTYPE_OTHER=6
};

enum _tagQUERYOPTION
{
    QUERY_EXPIRATION_DATE=1,
    QUERY_TIME_OF_LAST_CHANGE=2,
    QUERY_CONTENT_ENCODING=3,
    QUERY_CONTENT_TYPE=4,
    QUERY_REFRESH=5,
    QUERY_RECOMBINE=6,
    QUERY_CAN_NAVIGATE=7,
    QUERY_USES_NETWORK=8,
    QUERY_IS_CACHED=9,
    QUERY_IS_INSTALLEDENTRY=10,
    QUERY_IS_CACHED_OR_MAPPED=11,
    QUERY_USES_CACHE=12,
    QUERY_IS_SECURE=13,
    QUERY_IS_SAFE=14,
    QUERY_USES_HISTORYFOLDER=15
};

struct tagPARAMDESC
{
    struct tagPARAMDESCEX * pparamdescex;
    unsigned int wParamFlags;
};

struct tagPARAMDESCEX
{
    unsigned long cBytes;
    struct tagVARIANT varDefaultValue;
};

union tagBINDPTR
{
    struct tagFUNCDESC * lpfuncdesc;
    struct tagVARDESC * lpvardesc;
    struct ITypeComp * lptcomp;
};

enum tagFUNCKIND
{
    FUNC_VIRTUAL=0,
    FUNC_PUREVIRTUAL=1,
    FUNC_NONVIRTUAL=2,
    FUNC_STATIC=3,
    FUNC_DISPATCH=4
};

struct tagTLIBATTR
{
    struct _GUID guid;
    unsigned long lcid;
    enum tagSYSKIND syskind;
    unsigned int wMajorVerNum;
    unsigned int wMinorVerNum;
    unsigned int wLibFlags;
};

struct tagELEMDESC
{
    struct tagTYPEDESC tdesc;
    struct tagIDLDESC idldesc;
    struct tagPARAMDESC paramdesc;
};

struct tagVARIANT
{
    unsigned int vt;
    unsigned int wReserved1;
    unsigned int wReserved2;
    unsigned int wReserved3;
    int llVal;
    long lVal;
    unsigned int bVal;
    int iVal;
    float fltVal;
    float dblVal;
    int boolVal;
    long scode;
    union tagCY cyVal;
    float date;
    wchar_t * bstrVal;
    struct IUnknown * punkVal;
    struct IDispatch * pdispVal;
    struct tagSAFEARRAY * parray;
    unsigned int * pbVal;
    int * piVal;
    long * plVal;
    int * pllVal;
    float * pfltVal;
    float * pdblVal;
    int * pboolVal;
    long * pscode;
    union tagCY * pcyVal;
    float * pdate;
    wchar_t ** pbstrVal;
    struct IUnknown ** ppunkVal;
    struct IDispatch ** ppdispVal;
    struct tagSAFEARRAY ** pparray;
    struct tagVARIANT * pvarVal;
    void * byref;
    char cVal;
    unsigned int uiVal;
    unsigned long ulVal;
    unsigned int ullVal;
    int intVal;
    unsigned int uintVal;
    struct tagDEC * pdecVal;
    char * pcVal;
    unsigned int * puiVal;
    unsigned long * pulVal;
    unsigned int * pullVal;
    int * pintVal;
    unsigned int * puintVal;
    void * pvRecord;
    struct IRecordInfo * pRecInfo;
    struct tagDEC decVal;
};

struct tagSAFEARRAYBOUND
{
    unsigned long cElements;
    long lLbound;
};

struct tagTYPEDESC
{
    struct tagTYPEDESC * lptdesc;
    struct tagARRAYDESC * lpadesc;
    unsigned long hreftype;
    unsigned int vt;
};

struct tagEXCEPINFO
{
    unsigned int wCode;
    unsigned int wReserved;
    wchar_t * bstrSource;
    wchar_t * bstrDescription;
    wchar_t * bstrHelpFile;
    unsigned long dwHelpContext;
    void * pvReserved;
    HRESULT  ( * pfnDeferredFillIn)(struct tagEXCEPINFO * );
    long scode;
};

struct tagSTATSTG
{
    wchar_t * pwcsName;
    unsigned long type;
    union _ULARGE_INTEGER cbSize;
    struct _FILETIME mtime;
    struct _FILETIME ctime;
    struct _FILETIME atime;
    unsigned long grfMode;
    unsigned long grfLocksSupported;
    struct _GUID clsid;
    unsigned long grfStateBits;
    unsigned long reserved;
};

enum tagINVOKEKIND
{
    INVOKE_FUNC=1,
    INVOKE_PROPERTYGET=2,
    INVOKE_PROPERTYPUT=4,
    INVOKE_PROPERTYPUTREF=8
};

struct tagFUNCDESC
{
    long memid;
    long * lprgscode;
    struct tagELEMDESC * lprgelemdescParam;
    enum tagFUNCKIND funckind;
    enum tagINVOKEKIND invkind;
    enum tagCALLCONV callconv;
    int cParams;
    int cParamsOpt;
    int oVft;
    int cScodes;
    struct tagELEMDESC elemdescFunc;
    unsigned int wFuncFlags;
};

struct tagIDLDESC
{
    unsigned long dwReserved;
    unsigned int wIDLFlags;
};

struct _TP_POOL
{
};

struct _TP_CLEANUP_GROUP
{
};

struct _ACTIVATION_CONTEXT
{
};

struct _TP_CALLBACK_INSTANCE
{
};

struct _TP_CALLBACK_ENVIRON_V1
{
    unsigned long Version;
    struct _TP_POOL * Pool;
    struct _TP_CLEANUP_GROUP * CleanupGroup;
    void  ( * CleanupGroupCancelCallback)(void * ,void * );
    void * RaceDll;
    struct _ACTIVATION_CONTEXT * ActivationContext;
    void  ( * FinalizationCallback)(struct _TP_CALLBACK_INSTANCE * ,void * );
    union <unnamed-type-u>
    {
        unsigned long Flags;
        struct <unnamed-type-s>
        {
            unsigned long LongFunction:1;
            unsigned long Persistent:1;
            unsigned long Private:30;
        };
        struct _TP_CALLBACK_ENVIRON_V1::<unnamed-type-u>::<unnamed-type-s> s;
    };
    union _TP_CALLBACK_ENVIRON_V1::<unnamed-type-u> u;
};

union _TP_CALLBACK_ENVIRON_V1::<unnamed-type-u>
{
    unsigned long Flags;
    struct <unnamed-type-s>
    {
        unsigned long LongFunction:1;
        unsigned long Persistent:1;
        unsigned long Private:30;
    };
    struct _TP_CALLBACK_ENVIRON_V1::<unnamed-type-u>::<unnamed-type-s> s;
};

struct _TP_CALLBACK_ENVIRON_V1::<unnamed-type-u>::<unnamed-type-s>
{
    unsigned long LongFunction:1;
    unsigned long Persistent:1;
    unsigned long Private:30;
};

enum tagApplicationType
{
    ServerApplication=0,
    LibraryApplication=1
};

struct tagCABSTR
{
    unsigned long cElems;
    wchar_t ** pElems;
};

enum PIDMSI_STATUS_VALUE
{
    PIDMSI_STATUS_NORMAL=0,
    PIDMSI_STATUS_NEW=1,
    PIDMSI_STATUS_PRELIM=2,
    PIDMSI_STATUS_DRAFT=3,
    PIDMSI_STATUS_INPROGRESS=4,
    PIDMSI_STATUS_EDIT=5,
    PIDMSI_STATUS_REVIEW=6,
    PIDMSI_STATUS_PROOF=7,
    PIDMSI_STATUS_FINAL=8,
    PIDMSI_STATUS_OTHER=32767
};

struct tagCACLSID
{
    unsigned long cElems;
    struct _GUID * pElems;
};

struct tagCADBL
{
    unsigned long cElems;
    float * pElems;
};

struct tagCAUB
{
    unsigned long cElems;
    unsigned int * pElems;
};

struct tagCACY
{
    unsigned long cElems;
    union tagCY * pElems;
};

struct _FILETIME
{
    unsigned long dwLowDateTime;
    unsigned long dwHighDateTime;
};

struct tagVARDESC
{
    long memid;
    wchar_t * lpstrSchema;
    unsigned long oInst;
    struct tagVARIANT * lpvarValue;
    struct tagELEMDESC elemdescVar;
    unsigned int wVarFlags;
    enum tagVARKIND varkind;
};

struct IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void IUnknown(struct IUnknown * );
    void IUnknown(struct IUnknown & );
    void IUnknown();
    struct IUnknown & operator=(struct IUnknown * );
    struct IUnknown & operator=(struct IUnknown & );
};

struct IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    void IUnknown(struct IUnknown & );
    void IUnknown();
    struct IUnknown & operator=(struct IUnknown & );
};

struct tagARRAYDESC
{
    struct tagTYPEDESC tdescElem;
    unsigned int cDims;
    struct tagSAFEARRAYBOUND rgbounds[1];
};

union tagCY
{
    unsigned long Lo;
    long Hi;
    int int64;
};

struct tagDEC
{
    unsigned int wReserved;
    unsigned int scale;
    unsigned int sign;
    unsigned int signscale;
    unsigned long Hi32;
    unsigned long Lo32;
    unsigned long Mid32;
    unsigned int Lo64;
};

struct tagCAUL
{
    unsigned long cElems;
    unsigned long * pElems;
};

struct tagBSTRBLOB
{
    unsigned long cbSize;
    unsigned int * pData;
};

struct tagCAH
{
    unsigned long cElems;
    union _LARGE_INTEGER * pElems;
};

struct ITypeComp : public IUnknown
{
    HRESULT Bind(wchar_t * ,unsigned long ,unsigned int ,struct ITypeInfo ** ,enum tagDESCKIND * ,union tagBINDPTR * );
    HRESULT BindType(wchar_t * ,unsigned long ,struct ITypeInfo ** ,struct ITypeComp ** );
    void ITypeComp(struct ITypeComp * );
    void ITypeComp(struct ITypeComp & );
    void ITypeComp();
    struct ITypeComp & operator=(struct ITypeComp * );
    struct ITypeComp & operator=(struct ITypeComp & );
};

struct ITypeComp : public IUnknown
{
    HRESULT Bind(wchar_t * ,unsigned long ,unsigned int ,struct ITypeInfo ** ,enum tagDESCKIND * ,union tagBINDPTR * );
    HRESULT BindType(wchar_t * ,unsigned long ,struct ITypeInfo ** ,struct ITypeComp ** );
    void ITypeComp(struct ITypeComp & );
    void ITypeComp();
    struct ITypeComp & operator=(struct ITypeComp & );
};

struct tagCAUI
{
    unsigned long cElems;
    unsigned int * pElems;
};

struct tagCAFILETIME
{
    unsigned long cElems;
    struct _FILETIME * pElems;
};

struct tagDISPPARAMS
{
    struct tagVARIANT * rgvarg;
    long * rgdispidNamedArgs;
    unsigned int cArgs;
    unsigned int cNamedArgs;
};

struct tagSAFEARRAY
{
    unsigned int cDims;
    unsigned int fFeatures;
    unsigned long cbElements;
    unsigned long cLocks;
    void * pvData;
    struct tagSAFEARRAYBOUND rgsabound[1];
};

struct tagPROPVARIANT
{
    unsigned int vt;
    unsigned int wReserved1;
    unsigned int wReserved2;
    unsigned int wReserved3;
    char cVal;
    unsigned int bVal;
    int iVal;
    unsigned int uiVal;
    long lVal;
    unsigned long ulVal;
    int intVal;
    unsigned int uintVal;
    union _LARGE_INTEGER hVal;
    union _ULARGE_INTEGER uhVal;
    float fltVal;
    float dblVal;
    int boolVal;
    long scode;
    union tagCY cyVal;
    float date;
    struct _FILETIME filetime;
    struct _GUID * puuid;
    struct tagCLIPDATA * pclipdata;
    wchar_t * bstrVal;
    struct tagBSTRBLOB bstrblobVal;
    struct tagBLOB blob;
    char * pszVal;
    wchar_t * pwszVal;
    struct IUnknown * punkVal;
    struct IDispatch * pdispVal;
    struct IStream * pStream;
    struct IStorage * pStorage;
    struct tagVersionedStream * pVersionedStream;
    struct tagSAFEARRAY * parray;
    struct tagCAC cac;
    struct tagCAUB caub;
    struct tagCAI cai;
    struct tagCAUI caui;
    struct tagCAL cal;
    struct tagCAUL caul;
    struct tagCAH cah;
    struct tagCAUH cauh;
    struct tagCAFLT caflt;
    struct tagCADBL cadbl;
    struct tagCABOOL cabool;
    struct tagCASCODE cascode;
    struct tagCACY cacy;
    struct tagCADATE cadate;
    struct tagCAFILETIME cafiletime;
    struct tagCACLSID cauuid;
    struct tagCACLIPDATA caclipdata;
    struct tagCABSTR cabstr;
    struct tagCABSTRBLOB cabstrblob;
    struct tagCALPSTR calpstr;
    struct tagCALPWSTR calpwstr;
    struct tagCAPROPVARIANT capropvar;
    char * pcVal;
    unsigned int * pbVal;
    int * piVal;
    unsigned int * puiVal;
    long * plVal;
    unsigned long * pulVal;
    int * pintVal;
    unsigned int * puintVal;
    float * pfltVal;
    float * pdblVal;
    int * pboolVal;
    struct tagDEC * pdecVal;
    long * pscode;
    union tagCY * pcyVal;
    float * pdate;
    wchar_t ** pbstrVal;
    struct IUnknown ** ppunkVal;
    struct IDispatch ** ppdispVal;
    struct tagSAFEARRAY ** pparray;
    struct tagPROPVARIANT * pvarVal;
    struct tagDEC decVal;
};

struct tagCAPROPVARIANT
{
    unsigned long cElems;
    struct tagPROPVARIANT * pElems;
};

struct _lldiv_t
{
    int quot;
    int rem;
};

struct tagCLIPDATA
{
    unsigned long cbSize;
    long ulClipFmt;
    unsigned int * pClipData;
};

struct tagCADATE
{
    unsigned long cElems;
    float * pElems;
};

struct tagCAC
{
    unsigned long cElems;
    char * pElems;
};

struct tagTYPEATTR
{
    struct _GUID guid;
    unsigned long lcid;
    unsigned long dwReserved;
    long memidConstructor;
    long memidDestructor;
    wchar_t * lpstrSchema;
    unsigned long cbSizeInstance;
    enum tagTYPEKIND typekind;
    unsigned int cFuncs;
    unsigned int cVars;
    unsigned int cImplTypes;
    unsigned int cbSizeVft;
    unsigned int cbAlignment;
    unsigned int wTypeFlags;
    unsigned int wMajorVerNum;
    unsigned int wMinorVerNum;
    struct tagTYPEDESC tdescAlias;
    struct tagIDLDESC idldescType;
};

struct tagBLOB
{
    unsigned long cbSize;
    unsigned int * pBlobData;
};

union _LARGE_INTEGER
{
    unsigned long LowPart;
    long HighPart;
    struct <unnamed-type-u>
    {
        unsigned long LowPart;
        long HighPart;
    };
    struct _LARGE_INTEGER::<unnamed-type-u> u;
    int QuadPart;
};

struct _LARGE_INTEGER::<unnamed-type-u>
{
    unsigned long LowPart;
    long HighPart;
};

union _ULARGE_INTEGER
{
    unsigned long LowPart;
    unsigned long HighPart;
    struct <unnamed-type-u>
    {
        unsigned long LowPart;
        unsigned long HighPart;
    };
    struct _ULARGE_INTEGER::<unnamed-type-u> u;
    unsigned int QuadPart;
};

struct _ULARGE_INTEGER::<unnamed-type-u>
{
    unsigned long LowPart;
    unsigned long HighPart;
};

struct ISequentialStream : public IUnknown
{
    HRESULT Read(void * ,unsigned long ,unsigned long * );
    HRESULT Write(void * ,unsigned long ,unsigned long * );
    void ISequentialStream(struct ISequentialStream * );
    void ISequentialStream(struct ISequentialStream & );
    void ISequentialStream();
    struct ISequentialStream & operator=(struct ISequentialStream * );
    struct ISequentialStream & operator=(struct ISequentialStream & );
};

struct ISequentialStream : public IUnknown
{
    HRESULT Read(void * ,unsigned long ,unsigned long * );
    HRESULT Write(void * ,unsigned long ,unsigned long * );
    void ISequentialStream(struct ISequentialStream & );
    void ISequentialStream();
    struct ISequentialStream & operator=(struct ISequentialStream & );
};

struct tagCAI
{
    unsigned long cElems;
    int * pElems;
};

struct IEnumSTATSTG : public IUnknown
{
    HRESULT Next(unsigned long ,struct tagSTATSTG * ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumSTATSTG ** );
    void IEnumSTATSTG(struct IEnumSTATSTG * );
    void IEnumSTATSTG(struct IEnumSTATSTG & );
    void IEnumSTATSTG();
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG * );
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG & );
};

struct IEnumSTATSTG : public IUnknown
{
    HRESULT Next(unsigned long ,struct tagSTATSTG * ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumSTATSTG ** );
    void IEnumSTATSTG(struct IEnumSTATSTG & );
    void IEnumSTATSTG();
    struct IEnumSTATSTG & operator=(struct IEnumSTATSTG & );
};

struct ITypeLib : public IUnknown
{
    unsigned int GetTypeInfoCount();
    HRESULT GetTypeInfo(unsigned int ,struct ITypeInfo ** );
    HRESULT GetTypeInfoType(unsigned int ,enum tagTYPEKIND * );
    HRESULT GetTypeInfoOfGuid(struct _GUID & ,struct ITypeInfo ** );
    HRESULT GetLibAttr(struct tagTLIBATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetDocumentation(int ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT IsName(wchar_t * ,unsigned long ,int * );
    HRESULT FindName(wchar_t * ,unsigned long ,struct ITypeInfo ** ,long * ,unsigned int * );
    void ReleaseTLibAttr(struct tagTLIBATTR * );
    void ITypeLib(struct ITypeLib * );
    void ITypeLib(struct ITypeLib & );
    void ITypeLib();
    struct ITypeLib & operator=(struct ITypeLib * );
    struct ITypeLib & operator=(struct ITypeLib & );
};

struct ITypeLib : public IUnknown
{
    unsigned int GetTypeInfoCount();
    HRESULT GetTypeInfo(unsigned int ,struct ITypeInfo ** );
    HRESULT GetTypeInfoType(unsigned int ,enum tagTYPEKIND * );
    HRESULT GetTypeInfoOfGuid(struct _GUID & ,struct ITypeInfo ** );
    HRESULT GetLibAttr(struct tagTLIBATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetDocumentation(int ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT IsName(wchar_t * ,unsigned long ,int * );
    HRESULT FindName(wchar_t * ,unsigned long ,struct ITypeInfo ** ,long * ,unsigned int * );
    void ReleaseTLibAttr(struct tagTLIBATTR * );
    void ITypeLib(struct ITypeLib & );
    void ITypeLib();
    struct ITypeLib & operator=(struct ITypeLib & );
};

struct tagCAL
{
    unsigned long cElems;
    long * pElems;
};

struct tagCAUH
{
    unsigned long cElems;
    union _ULARGE_INTEGER * pElems;
};

struct IRecordInfo : public IUnknown
{
    HRESULT RecordInit(void * );
    HRESULT RecordClear(void * );
    HRESULT RecordCopy(void * ,void * );
    HRESULT GetGuid(struct _GUID * );
    HRESULT GetName(wchar_t ** );
    HRESULT GetSize(unsigned long * );
    HRESULT GetTypeInfo(struct ITypeInfo ** );
    HRESULT GetField(void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNoCopy(void * ,wchar_t * ,struct tagVARIANT * ,void ** );
    HRESULT PutField(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT PutFieldNoCopy(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNames(unsigned long * ,wchar_t ** );
    int IsMatchingType(struct IRecordInfo * );
    void * RecordCreate();
    HRESULT RecordCreateCopy(void * ,void ** );
    HRESULT RecordDestroy(void * );
    void IRecordInfo(struct IRecordInfo * );
    void IRecordInfo(struct IRecordInfo & );
    void IRecordInfo();
    struct IRecordInfo & operator=(struct IRecordInfo * );
    struct IRecordInfo & operator=(struct IRecordInfo & );
};

struct IRecordInfo : public IUnknown
{
    HRESULT RecordInit(void * );
    HRESULT RecordClear(void * );
    HRESULT RecordCopy(void * ,void * );
    HRESULT GetGuid(struct _GUID * );
    HRESULT GetName(wchar_t ** );
    HRESULT GetSize(unsigned long * );
    HRESULT GetTypeInfo(struct ITypeInfo ** );
    HRESULT GetField(void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNoCopy(void * ,wchar_t * ,struct tagVARIANT * ,void ** );
    HRESULT PutField(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT PutFieldNoCopy(unsigned long ,void * ,wchar_t * ,struct tagVARIANT * );
    HRESULT GetFieldNames(unsigned long * ,wchar_t ** );
    int IsMatchingType(struct IRecordInfo * );
    void * RecordCreate();
    HRESULT RecordCreateCopy(void * ,void ** );
    HRESULT RecordDestroy(void * );
    void IRecordInfo(struct IRecordInfo & );
    void IRecordInfo();
    struct IRecordInfo & operator=(struct IRecordInfo & );
};

struct _ldiv_t
{
    long quot;
    long rem;
};

struct tagCASCODE
{
    unsigned long cElems;
    long * pElems;
};

enum tagGLOBALOPT_EH_VALUES
{
    COMGLB_EXCEPTION_HANDLE=0,
    COMGLB_EXCEPTION_DONOT_HANDLE_FATAL=1,
    COMGLB_EXCEPTION_DONOT_HANDLE=1,
    COMGLB_EXCEPTION_DONOT_HANDLE_ANY=2
};

struct tagCALPWSTR
{
    unsigned long cElems;
    wchar_t ** pElems;
};

struct tagCAFLT
{
    unsigned long cElems;
    float * pElems;
};

struct tagCALPSTR
{
    unsigned long cElems;
    char ** pElems;
};

struct tagCABOOL
{
    unsigned long cElems;
    int * pElems;
};

struct _FILETIME
{
    unsigned long dwLowDateTime;
    unsigned long dwHighDateTime;
};

struct IStorage : public IUnknown
{
    HRESULT CreateStream(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT OpenStream(wchar_t * ,void * ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT CreateStorage(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStorage ** );
    HRESULT OpenStorage(wchar_t * ,struct IStorage * ,unsigned long ,wchar_t ** ,unsigned long ,struct IStorage ** );
    HRESULT CopyTo(unsigned long ,struct _GUID * ,wchar_t ** ,struct IStorage * );
    HRESULT MoveElementTo(wchar_t * ,struct IStorage * ,wchar_t * ,unsigned long );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT EnumElements(unsigned long ,void * ,unsigned long ,struct IEnumSTATSTG ** );
    HRESULT DestroyElement(wchar_t * );
    HRESULT RenameElement(wchar_t * ,wchar_t * );
    HRESULT SetElementTimes(wchar_t * ,struct _FILETIME * ,struct _FILETIME * ,struct _FILETIME * );
    HRESULT SetClass(struct _GUID & );
    HRESULT SetStateBits(unsigned long ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    void IStorage(struct IStorage * );
    void IStorage(struct IStorage & );
    void IStorage();
    struct IStorage & operator=(struct IStorage * );
    struct IStorage & operator=(struct IStorage & );
};

struct IStorage : public IUnknown
{
    HRESULT CreateStream(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT OpenStream(wchar_t * ,void * ,unsigned long ,unsigned long ,struct IStream ** );
    HRESULT CreateStorage(wchar_t * ,unsigned long ,unsigned long ,unsigned long ,struct IStorage ** );
    HRESULT OpenStorage(wchar_t * ,struct IStorage * ,unsigned long ,wchar_t ** ,unsigned long ,struct IStorage ** );
    HRESULT CopyTo(unsigned long ,struct _GUID * ,wchar_t ** ,struct IStorage * );
    HRESULT MoveElementTo(wchar_t * ,struct IStorage * ,wchar_t * ,unsigned long );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT EnumElements(unsigned long ,void * ,unsigned long ,struct IEnumSTATSTG ** );
    HRESULT DestroyElement(wchar_t * );
    HRESULT RenameElement(wchar_t * ,wchar_t * );
    HRESULT SetElementTimes(wchar_t * ,struct _FILETIME * ,struct _FILETIME * ,struct _FILETIME * );
    HRESULT SetClass(struct _GUID & );
    HRESULT SetStateBits(unsigned long ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    void IStorage(struct IStorage & );
    void IStorage();
    struct IStorage & operator=(struct IStorage & );
};

struct ITypeInfo : public IUnknown
{
    HRESULT GetTypeAttr(struct tagTYPEATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetFuncDesc(unsigned int ,struct tagFUNCDESC ** );
    HRESULT GetVarDesc(unsigned int ,struct tagVARDESC ** );
    HRESULT GetNames(long ,wchar_t ** ,unsigned int ,unsigned int * );
    HRESULT GetRefTypeOfImplType(unsigned int ,unsigned long * );
    HRESULT GetImplTypeFlags(unsigned int ,int * );
    HRESULT GetIDsOfNames(wchar_t ** ,unsigned int ,long * );
    HRESULT Invoke(void * ,long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    HRESULT GetDocumentation(long ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT GetDllEntry(long ,enum tagINVOKEKIND ,wchar_t ** ,wchar_t ** ,unsigned int * );
    HRESULT GetRefTypeInfo(unsigned long ,struct ITypeInfo ** );
    HRESULT AddressOfMember(long ,enum tagINVOKEKIND ,void ** );
    HRESULT CreateInstance(struct IUnknown * ,struct _GUID & ,void ** );
    HRESULT GetMops(long ,wchar_t ** );
    HRESULT GetContainingTypeLib(struct ITypeLib ** ,unsigned int * );
    void ReleaseTypeAttr(struct tagTYPEATTR * );
    void ReleaseFuncDesc(struct tagFUNCDESC * );
    void ReleaseVarDesc(struct tagVARDESC * );
    void ITypeInfo(struct ITypeInfo * );
    void ITypeInfo(struct ITypeInfo & );
    void ITypeInfo();
    struct ITypeInfo & operator=(struct ITypeInfo * );
    struct ITypeInfo & operator=(struct ITypeInfo & );
};

struct ITypeInfo : public IUnknown
{
    HRESULT GetTypeAttr(struct tagTYPEATTR ** );
    HRESULT GetTypeComp(struct ITypeComp ** );
    HRESULT GetFuncDesc(unsigned int ,struct tagFUNCDESC ** );
    HRESULT GetVarDesc(unsigned int ,struct tagVARDESC ** );
    HRESULT GetNames(long ,wchar_t ** ,unsigned int ,unsigned int * );
    HRESULT GetRefTypeOfImplType(unsigned int ,unsigned long * );
    HRESULT GetImplTypeFlags(unsigned int ,int * );
    HRESULT GetIDsOfNames(wchar_t ** ,unsigned int ,long * );
    HRESULT Invoke(void * ,long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    HRESULT GetDocumentation(long ,wchar_t ** ,wchar_t ** ,unsigned long * ,wchar_t ** );
    HRESULT GetDllEntry(long ,enum tagINVOKEKIND ,wchar_t ** ,wchar_t ** ,unsigned int * );
    HRESULT GetRefTypeInfo(unsigned long ,struct ITypeInfo ** );
    HRESULT AddressOfMember(long ,enum tagINVOKEKIND ,void ** );
    HRESULT CreateInstance(struct IUnknown * ,struct _GUID & ,void ** );
    HRESULT GetMops(long ,wchar_t ** );
    HRESULT GetContainingTypeLib(struct ITypeLib ** ,unsigned int * );
    void ReleaseTypeAttr(struct tagTYPEATTR * );
    void ReleaseFuncDesc(struct tagFUNCDESC * );
    void ReleaseVarDesc(struct tagVARDESC * );
    void ITypeInfo(struct ITypeInfo & );
    void ITypeInfo();
    struct ITypeInfo & operator=(struct ITypeInfo & );
};

struct IStream : public ISequentialStream
{
    HRESULT Seek(union _LARGE_INTEGER ,unsigned long ,union _ULARGE_INTEGER * );
    HRESULT SetSize(union _ULARGE_INTEGER );
    HRESULT CopyTo(struct IStream * ,union _ULARGE_INTEGER ,union _ULARGE_INTEGER * ,union _ULARGE_INTEGER * );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT LockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT UnlockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    HRESULT Clone(struct IStream ** );
    void IStream(struct IStream * );
    void IStream(struct IStream & );
    void IStream();
    struct IStream & operator=(struct IStream * );
    struct IStream & operator=(struct IStream & );
};

struct IStream : public ISequentialStream
{
    HRESULT Seek(union _LARGE_INTEGER ,unsigned long ,union _ULARGE_INTEGER * );
    HRESULT SetSize(union _ULARGE_INTEGER );
    HRESULT CopyTo(struct IStream * ,union _ULARGE_INTEGER ,union _ULARGE_INTEGER * ,union _ULARGE_INTEGER * );
    HRESULT Commit(unsigned long );
    HRESULT Revert();
    HRESULT LockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT UnlockRegion(union _ULARGE_INTEGER ,union _ULARGE_INTEGER ,unsigned long );
    HRESULT Stat(struct tagSTATSTG * ,unsigned long );
    HRESULT Clone(struct IStream ** );
    void IStream(struct IStream & );
    void IStream();
    struct IStream & operator=(struct IStream & );
};

struct tagCABSTRBLOB
{
    unsigned long cElems;
    struct tagBSTRBLOB * pElems;
};

struct tagVersionedStream
{
    struct _GUID guidVersion;
    struct IStream * pStream;
};

struct __s_GUID
{
    unsigned long Data1;
    unsigned int Data2;
    unsigned int Data3;
    unsigned int Data4[8];
};

struct tagCACLIPDATA
{
    unsigned long cElems;
    struct tagCLIPDATA * pElems;
};

struct IDispatch : public IUnknown
{
    HRESULT GetTypeInfoCount(unsigned int * );
    HRESULT GetTypeInfo(unsigned int ,unsigned long ,struct ITypeInfo ** );
    HRESULT GetIDsOfNames(struct _GUID & ,wchar_t ** ,unsigned int ,unsigned long ,long * );
    HRESULT Invoke(long ,struct _GUID & ,unsigned long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    void IDispatch(struct IDispatch * );
    void IDispatch(struct IDispatch & );
    void IDispatch();
    struct IDispatch & operator=(struct IDispatch * );
    struct IDispatch & operator=(struct IDispatch & );
};

struct IDispatch : public IUnknown
{
    HRESULT GetTypeInfoCount(unsigned int * );
    HRESULT GetTypeInfo(unsigned int ,unsigned long ,struct ITypeInfo ** );
    HRESULT GetIDsOfNames(struct _GUID & ,wchar_t ** ,unsigned int ,unsigned long ,long * );
    HRESULT Invoke(long ,struct _GUID & ,unsigned long ,unsigned int ,struct tagDISPPARAMS * ,struct tagVARIANT * ,struct tagEXCEPINFO * ,unsigned int * );
    void IDispatch(struct IDispatch & );
    void IDispatch();
    struct IDispatch & operator=(struct IDispatch & );
};

enum D2D1_ALPHA_MODE
{
    D2D1_ALPHA_MODE_UNKNOWN=0,
    D2D1_ALPHA_MODE_PREMULTIPLIED=1,
    D2D1_ALPHA_MODE_STRAIGHT=2,
    D2D1_ALPHA_MODE_IGNORE=3,
    D2D1_ALPHA_MODE_FORCE_DWORD=-1
};

enum D3D11_MESSAGE_CATEGORY
{
    D3D11_MESSAGE_CATEGORY_APPLICATION_DEFINED=0,
    D3D11_MESSAGE_CATEGORY_MISCELLANEOUS=1,
    D3D11_MESSAGE_CATEGORY_INITIALIZATION=2,
    D3D11_MESSAGE_CATEGORY_CLEANUP=3,
    D3D11_MESSAGE_CATEGORY_COMPILATION=4,
    D3D11_MESSAGE_CATEGORY_STATE_CREATION=5,
    D3D11_MESSAGE_CATEGORY_STATE_SETTING=6,
    D3D11_MESSAGE_CATEGORY_STATE_GETTING=7,
    D3D11_MESSAGE_CATEGORY_RESOURCE_MANIPULATION=8,
    D3D11_MESSAGE_CATEGORY_EXECUTION=9
};

enum D2D1_GAMMA
{
    D2D1_GAMMA_2_2=0,
    D2D1_GAMMA_1_0=1,
    D2D1_GAMMA_FORCE_DWORD=-1
};

enum D3D_SRV_DIMENSION
{
    D3D_SRV_DIMENSION_UNKNOWN=0,
    D3D_SRV_DIMENSION_BUFFER=1,
    D3D_SRV_DIMENSION_TEXTURE1D=2,
    D3D_SRV_DIMENSION_TEXTURE1DARRAY=3,
    D3D_SRV_DIMENSION_TEXTURE2D=4,
    D3D_SRV_DIMENSION_TEXTURE2DARRAY=5,
    D3D_SRV_DIMENSION_TEXTURE2DMS=6,
    D3D_SRV_DIMENSION_TEXTURE2DMSARRAY=7,
    D3D_SRV_DIMENSION_TEXTURE3D=8,
    D3D_SRV_DIMENSION_TEXTURECUBE=9,
    D3D_SRV_DIMENSION_TEXTURECUBEARRAY=10,
    D3D_SRV_DIMENSION_BUFFEREX=11,
    D3D10_SRV_DIMENSION_UNKNOWN=0,
    D3D10_SRV_DIMENSION_BUFFER=1,
    D3D10_SRV_DIMENSION_TEXTURE1D=2,
    D3D10_SRV_DIMENSION_TEXTURE1DARRAY=3,
    D3D10_SRV_DIMENSION_TEXTURE2D=4,
    D3D10_SRV_DIMENSION_TEXTURE2DARRAY=5,
    D3D10_SRV_DIMENSION_TEXTURE2DMS=6,
    D3D10_SRV_DIMENSION_TEXTURE2DMSARRAY=7,
    D3D10_SRV_DIMENSION_TEXTURE3D=8,
    D3D10_SRV_DIMENSION_TEXTURECUBE=9,
    D3D10_1_SRV_DIMENSION_UNKNOWN=0,
    D3D10_1_SRV_DIMENSION_BUFFER=1,
    D3D10_1_SRV_DIMENSION_TEXTURE1D=2,
    D3D10_1_SRV_DIMENSION_TEXTURE1DARRAY=3,
    D3D10_1_SRV_DIMENSION_TEXTURE2D=4,
    D3D10_1_SRV_DIMENSION_TEXTURE2DARRAY=5,
    D3D10_1_SRV_DIMENSION_TEXTURE2DMS=6,
    D3D10_1_SRV_DIMENSION_TEXTURE2DMSARRAY=7,
    D3D10_1_SRV_DIMENSION_TEXTURE3D=8,
    D3D10_1_SRV_DIMENSION_TEXTURECUBE=9,
    D3D10_1_SRV_DIMENSION_TEXTURECUBEARRAY=10,
    D3D11_SRV_DIMENSION_UNKNOWN=0,
    D3D11_SRV_DIMENSION_BUFFER=1,
    D3D11_SRV_DIMENSION_TEXTURE1D=2,
    D3D11_SRV_DIMENSION_TEXTURE1DARRAY=3,
    D3D11_SRV_DIMENSION_TEXTURE2D=4,
    D3D11_SRV_DIMENSION_TEXTURE2DARRAY=5,
    D3D11_SRV_DIMENSION_TEXTURE2DMS=6,
    D3D11_SRV_DIMENSION_TEXTURE2DMSARRAY=7,
    D3D11_SRV_DIMENSION_TEXTURE3D=8,
    D3D11_SRV_DIMENSION_TEXTURECUBE=9,
    D3D11_SRV_DIMENSION_TEXTURECUBEARRAY=10,
    D3D11_SRV_DIMENSION_BUFFEREX=11
};

enum D3D11_MESSAGE_SEVERITY
{
    D3D11_MESSAGE_SEVERITY_CORRUPTION=0,
    D3D11_MESSAGE_SEVERITY_ERROR=1,
    D3D11_MESSAGE_SEVERITY_WARNING=2,
    D3D11_MESSAGE_SEVERITY_INFO=3
};

enum D2D1_EXTEND_MODE
{
    D2D1_EXTEND_MODE_CLAMP=0,
    D2D1_EXTEND_MODE_WRAP=1,
    D2D1_EXTEND_MODE_MIRROR=2,
    D2D1_EXTEND_MODE_FORCE_DWORD=-1
};

enum D2D1_ANTIALIAS_MODE
{
    D2D1_ANTIALIAS_MODE_PER_PRIMITIVE=0,
    D2D1_ANTIALIAS_MODE_ALIASED=1,
    D2D1_ANTIALIAS_MODE_FORCE_DWORD=-1
};

enum D2D1_TEXT_ANTIALIAS_MODE
{
    D2D1_TEXT_ANTIALIAS_MODE_DEFAULT=0,
    D2D1_TEXT_ANTIALIAS_MODE_CLEARTYPE=1,
    D2D1_TEXT_ANTIALIAS_MODE_GRAYSCALE=2,
    D2D1_TEXT_ANTIALIAS_MODE_ALIASED=3,
    D2D1_TEXT_ANTIALIAS_MODE_FORCE_DWORD=-1
};

enum XAUDIO2_WINDOWS_PROCESSOR_SPECIFIER
{
    Processor1=1,
    Processor2=2,
    Processor3=4,
    Processor4=8,
    Processor5=16,
    Processor6=32,
    Processor7=64,
    Processor8=128,
    Processor9=256,
    Processor10=512,
    Processor11=1024,
    Processor12=2048,
    Processor13=4096,
    Processor14=8192,
    Processor15=16384,
    Processor16=32768,
    Processor17=65536,
    Processor18=131072,
    Processor19=262144,
    Processor20=524288,
    Processor21=1048576,
    Processor22=2097152,
    Processor23=4194304,
    Processor24=8388608,
    Processor25=16777216,
    Processor26=33554432,
    Processor27=67108864,
    Processor28=134217728,
    Processor29=268435456,
    Processor30=536870912,
    Processor31=1073741824,
    Processor32=-2147483648,
    XAUDIO2_ANY_PROCESSOR=-1,
    XAUDIO2_DEFAULT_PROCESSOR=-1
};

enum D3D11_MESSAGE_ID
{
    D3D11_MESSAGE_ID_UNKNOWN=0,
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD=1,
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD=2,
    D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD=3,
    D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD=4,
    D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD=5,
    D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD=6,
    D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD=7,
    D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD=8,
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD=9,
    D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD=10,
    D3D11_MESSAGE_ID_STRING_FROM_APPLICATION=11,
    D3D11_MESSAGE_ID_CORRUPTED_THIS=12,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER1=13,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER2=14,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER3=15,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER4=16,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER5=17,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER6=18,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER7=19,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER8=20,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER9=21,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER10=22,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER11=23,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER12=24,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER13=25,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER14=26,
    D3D11_MESSAGE_ID_CORRUPTED_PARAMETER15=27,
    D3D11_MESSAGE_ID_CORRUPTED_MULTITHREADING=28,
    D3D11_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY=29,
    D3D11_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT=30,
    D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT=31,
    D3D11_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT=32,
    D3D11_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT=33,
    D3D11_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=34,
    D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=35,
    D3D11_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT=36,
    D3D11_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT=37,
    D3D11_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=38,
    D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=39,
    D3D11_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT=40,
    D3D11_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT=41,
    D3D11_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT=42,
    D3D11_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=43,
    D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=44,
    D3D11_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT=45,
    D3D11_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT=46,
    D3D11_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT=47,
    D3D11_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT=48,
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT=49,
    D3D11_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT=50,
    D3D11_MESSAGE_ID_GETPRIVATEDATA_MOREDATA=51,
    D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA=52,
    D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN=53,
    D3D11_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS=54,
    D3D11_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS=55,
    D3D11_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY=56,
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT=57,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES=58,
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE=59,
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS=60,
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS=61,
    D3D11_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS=62,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS=63,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS=64,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA=65,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS=66,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS=67,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS=68,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN=69,
    D3D11_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN=70,
    D3D11_MESSAGE_ID_CREATEBUFFER_NULLDESC=71,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS=72,
    D3D11_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION=73,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT=74,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT=75,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES=76,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE=77,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS=78,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS=79,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS=80,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS=81,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS=82,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA=83,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS=84,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS=85,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS=86,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN=87,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN=88,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_NULLDESC=89,
    D3D11_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION=90,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT=91,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT=92,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES=93,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE=94,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS=95,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS=96,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS=97,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS=98,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS=99,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA=100,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS=101,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS=102,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS=103,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN=104,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN=105,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_NULLDESC=106,
    D3D11_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION=107,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT=108,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT=109,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES=110,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE=111,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS=112,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS=113,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS=114,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS=115,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS=116,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA=117,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS=118,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS=119,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS=120,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN=121,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN=122,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_NULLDESC=123,
    D3D11_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION=124,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT=125,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC=126,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT=127,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS=128,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE=129,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS=130,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN=131,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN=132,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT=133,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT=134,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC=135,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT=136,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS=137,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE=138,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS=139,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN=140,
    D3D11_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN=141,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT=142,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC=143,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT=144,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS=145,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE=146,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS=147,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN=148,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN=149,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY=150,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS=151,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT=152,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT=153,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT=154,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS=155,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH=156,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE=157,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE=158,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT=159,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC=160,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE=161,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC=162,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT=163,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC=164,
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY=165,
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE=166,
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE=167,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY=168,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE=169,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE=170,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY=171,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE=172,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE=173,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES=174,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED=175,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL=176,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL=177,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED=178,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT=179,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT=180,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT=181,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT=182,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION=183,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT=184,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE=185,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC=186,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH=187,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS=188,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX=189,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE=190,
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY=191,
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE=192,
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE=193,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE=194,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE=195,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP=196,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS=197,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS=198,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC=199,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK=200,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC=201,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP=202,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP=203,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP=204,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC=205,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP=206,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP=207,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP=208,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC=209,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS=210,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC=211,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND=212,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND=213,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP=214,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA=215,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA=216,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA=217,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK=218,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS=219,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC=220,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER=221,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU=222,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV=223,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW=224,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS=225,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY=226,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC=227,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD=228,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD=229,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS=230,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC=231,
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY=232,
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS=233,
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG=234,
    D3D11_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC=235,
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED=236,
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED=237,
    D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER=238,
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE=239,
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY=240,
    D3D11_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER=241,
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID=242,
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE=243,
    D3D11_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED=244,
    D3D11_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY=245,
    D3D11_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER=246,
    D3D11_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY=247,
    D3D11_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY=248,
    D3D11_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY=249,
    D3D11_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER=250,
    D3D11_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY=251,
    D3D11_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY=252,
    D3D11_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER=253,
    D3D11_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED=254,
    D3D11_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY=255,
    D3D11_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER=256,
    D3D11_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY=257,
    D3D11_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY=258,
    D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT=259,
    D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR=260,
    D3D11_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH=261,
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH=262,
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID=263,
    D3D11_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY=264,
    D3D11_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY=265,
    D3D11_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY=266,
    D3D11_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY=267,
    D3D11_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY=268,
    D3D11_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY=269,
    D3D11_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY=270,
    D3D11_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY=271,
    D3D11_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY=272,
    D3D11_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY=273,
    D3D11_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY=274,
    D3D11_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY=275,
    D3D11_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY=276,
    D3D11_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID=277,
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE=278,
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE=279,
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX=280,
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE=281,
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE=282,
    D3D11_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE=283,
    D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE=284,
    D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE=285,
    D3D11_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE=286,
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE=287,
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX=288,
    D3D11_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE=289,
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID=290,
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID=291,
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID=292,
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID=293,
    D3D11_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID=294,
    D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE=295,
    D3D11_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS=296,
    D3D11_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED=297,
    D3D11_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN=298,
    D3D11_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED=299,
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE=300,
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE=301,
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS=302,
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED=303,
    D3D11_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN=304,
    D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE=305,
    D3D11_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED=306,
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE=307,
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE=308,
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS=309,
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED=310,
    D3D11_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN=311,
    D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE=312,
    D3D11_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED=313,
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE=314,
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE=315,
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS=316,
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED=317,
    D3D11_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN=318,
    D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE=319,
    D3D11_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED=320,
    D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED=321,
    D3D11_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED=322,
    D3D11_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS=323,
    D3D11_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN=324,
    D3D11_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN=325,
    D3D11_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE=326,
    D3D11_MESSAGE_ID_REF_THREADING_MODE=327,
    D3D11_MESSAGE_ID_REF_UMDRIVER_EXCEPTION=328,
    D3D11_MESSAGE_ID_REF_KMDRIVER_EXCEPTION=329,
    D3D11_MESSAGE_ID_REF_HARDWARE_EXCEPTION=330,
    D3D11_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE=331,
    D3D11_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER=332,
    D3D11_MESSAGE_ID_REF_OUT_OF_MEMORY=333,
    D3D11_MESSAGE_ID_REF_INFO=334,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW=335,
    D3D11_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW=336,
    D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW=337,
    D3D11_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW=338,
    D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW=339,
    D3D11_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW=340,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET=341,
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND=342,
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX=343,
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE=344,
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK=345,
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE=346,
    D3D11_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS=347,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET=348,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET=349,
    D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET=350,
    D3D11_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL=351,
    D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET=352,
    D3D11_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET=353,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH=354,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL=355,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL=356,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET=357,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID=358,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL=359,
    D3D11_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH=360,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH=361,
    D3D11_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT=362,
    D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET=363,
    D3D11_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED=364,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY=365,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED=366,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED=367,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED=368,
    D3D11_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED=369,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED=370,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED=371,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED=372,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED=373,
    D3D11_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE=374,
    D3D11_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER=375,
    D3D11_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING=376,
    D3D11_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0=377,
    D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT=378,
    D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT=379,
    D3D11_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT=380,
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN=381,
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN=382,
    D3D11_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN=383,
    D3D11_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET=384,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC=385,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC=386,
    D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH=387,
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW=388,
    D3D11_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS=389,
    D3D11_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH=390,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH=391,
    D3D11_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY=392,
    D3D11_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY=393,
    D3D11_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN=394,
    D3D11_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN=395,
    D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER=396,
    D3D11_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED=397,
    D3D11_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER=398,
    D3D11_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN=399,
    D3D11_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN=400,
    D3D11_MESSAGE_ID_CREATECOUNTER_NULLDESC=401,
    D3D11_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER=402,
    D3D11_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER=403,
    D3D11_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE=404,
    D3D11_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED=405,
    D3D11_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION=406,
    D3D11_MESSAGE_ID_QUERY_BEGIN_DUPLICATE=407,
    D3D11_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS=408,
    D3D11_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION=409,
    D3D11_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS=410,
    D3D11_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN=411,
    D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE=412,
    D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS=413,
    D3D11_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL=414,
    D3D11_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH=415,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED=416,
    D3D11_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN=417,
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE=418,
    D3D11_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE=419,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT=420,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH=421,
    D3D11_MESSAGE_ID_D3D10_MESSAGES_END=422,
    D3D11_MESSAGE_ID_D3D10L9_MESSAGES_START=1048576,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED=1048577,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED=1048578,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT=1048579,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY=1048580,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE=1048581,
    D3D11_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED=1048582,
    D3D11_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS=1048583,
    D3D11_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS=1048584,
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS=1048585,
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND=1048586,
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D=1048587,
    D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE=1048588,
    D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE=1048589,
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS=1048590,
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS=1048591,
    D3D11_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX=1048592,
    D3D11_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS=1048593,
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED=1048594,
    D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS=1048595,
    D3D11_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY=1048596,
    D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK=1048597,
    D3D11_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK=1048598,
    D3D11_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT=1048599,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE=1048600,
    D3D11_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE=1048601,
    D3D11_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE=1048602,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD=1048603,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL=1048604,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX=1048605,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO=1048606,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES=1048607,
    D3D11_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET=1048608,
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER=1048609,
    D3D11_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE=1048610,
    D3D11_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE=1048611,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE=1048612,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS=1048613,
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT=1048614,
    D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS=1048615,
    D3D11_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES=1048616,
    D3D11_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED=1048617,
    D3D11_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED=1048618,
    D3D11_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED=1048619,
    D3D11_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED=1048620,
    D3D11_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED=1048621,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND=1048622,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND=1048623,
    D3D11_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED=1048624,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE=1048625,
    D3D11_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED=1048626,
    D3D11_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3=1048627,
    D3D11_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED=1048628,
    D3D11_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO=1048629,
    D3D11_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION=1048630,
    D3D11_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED=1048631,
    D3D11_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR=1048632,
    D3D11_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA=1048633,
    D3D11_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP=1048634,
    D3D11_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED=1048635,
    D3D11_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT=1048636,
    D3D11_MESSAGE_ID_D3D10L9_MESSAGES_END=1048637,
    D3D11_MESSAGE_ID_D3D11_MESSAGES_START=2097152,
    D3D11_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFLAGS=2097153,
    D3D11_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDCLASSLINKAGE=2097154,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDCLASSLINKAGE=2097155,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTREAMS=2097156,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAMTORASTERIZER=2097157,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTREAMS=2097158,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCLASSLINKAGE=2097159,
    D3D11_MESSAGE_ID_CREATEPIXELSHADER_INVALIDCLASSLINKAGE=2097160,
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_COMMANDLISTFLAGS=2097161,
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_SINGLETHREADED=2097162,
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALIDARG_RETURN=2097163,
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_INVALID_CALL_RETURN=2097164,
    D3D11_MESSAGE_ID_CREATEDEFERREDCONTEXT_OUTOFMEMORY_RETURN=2097165,
    D3D11_MESSAGE_ID_FINISHDISPLAYLIST_ONIMMEDIATECONTEXT=2097166,
    D3D11_MESSAGE_ID_FINISHDISPLAYLIST_OUTOFMEMORY_RETURN=2097167,
    D3D11_MESSAGE_ID_FINISHDISPLAYLIST_INVALID_CALL_RETURN=2097168,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTREAM=2097169,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDENTRIES=2097170,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDSTRIDES=2097171,
    D3D11_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMSTRIDES=2097172,
    D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_HAZARD=2097173,
    D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_HAZARD=2097174,
    D3D11_MESSAGE_ID_HSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=2097175,
    D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=2097176,
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCALL=2097177,
    D3D11_MESSAGE_ID_CREATEHULLSHADER_OUTOFMEMORY=2097178,
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERBYTECODE=2097179,
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDSHADERTYPE=2097180,
    D3D11_MESSAGE_ID_CREATEHULLSHADER_INVALIDCLASSLINKAGE=2097181,
    D3D11_MESSAGE_ID_DEVICE_HSSETSHADERRESOURCES_VIEWS_EMPTY=2097182,
    D3D11_MESSAGE_ID_HSSETCONSTANTBUFFERS_INVALIDBUFFER=2097183,
    D3D11_MESSAGE_ID_DEVICE_HSSETCONSTANTBUFFERS_BUFFERS_EMPTY=2097184,
    D3D11_MESSAGE_ID_DEVICE_HSSETSAMPLERS_SAMPLERS_EMPTY=2097185,
    D3D11_MESSAGE_ID_DEVICE_HSGETSHADERRESOURCES_VIEWS_EMPTY=2097186,
    D3D11_MESSAGE_ID_DEVICE_HSGETCONSTANTBUFFERS_BUFFERS_EMPTY=2097187,
    D3D11_MESSAGE_ID_DEVICE_HSGETSAMPLERS_SAMPLERS_EMPTY=2097188,
    D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_HAZARD=2097189,
    D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_HAZARD=2097190,
    D3D11_MESSAGE_ID_DSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=2097191,
    D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=2097192,
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCALL=2097193,
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_OUTOFMEMORY=2097194,
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERBYTECODE=2097195,
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDSHADERTYPE=2097196,
    D3D11_MESSAGE_ID_CREATEDOMAINSHADER_INVALIDCLASSLINKAGE=2097197,
    D3D11_MESSAGE_ID_DEVICE_DSSETSHADERRESOURCES_VIEWS_EMPTY=2097198,
    D3D11_MESSAGE_ID_DSSETCONSTANTBUFFERS_INVALIDBUFFER=2097199,
    D3D11_MESSAGE_ID_DEVICE_DSSETCONSTANTBUFFERS_BUFFERS_EMPTY=2097200,
    D3D11_MESSAGE_ID_DEVICE_DSSETSAMPLERS_SAMPLERS_EMPTY=2097201,
    D3D11_MESSAGE_ID_DEVICE_DSGETSHADERRESOURCES_VIEWS_EMPTY=2097202,
    D3D11_MESSAGE_ID_DEVICE_DSGETCONSTANTBUFFERS_BUFFERS_EMPTY=2097203,
    D3D11_MESSAGE_ID_DEVICE_DSGETSAMPLERS_SAMPLERS_EMPTY=2097204,
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_XOR_DS_MISMATCH=2097205,
    D3D11_MESSAGE_ID_DEFERRED_CONTEXT_REMOVAL_PROCESS_AT_FAULT=2097206,
    D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_INVALID_ARG_BUFFER=2097207,
    D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_UNALIGNED=2097208,
    D3D11_MESSAGE_ID_DEVICE_DRAWINDIRECT_OFFSET_OVERFLOW=2097209,
    D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDMAPTYPE=2097210,
    D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDSUBRESOURCE=2097211,
    D3D11_MESSAGE_ID_RESOURCE_MAP_INVALIDFLAGS=2097212,
    D3D11_MESSAGE_ID_RESOURCE_MAP_ALREADYMAPPED=2097213,
    D3D11_MESSAGE_ID_RESOURCE_MAP_DEVICEREMOVED_RETURN=2097214,
    D3D11_MESSAGE_ID_RESOURCE_MAP_OUTOFMEMORY_RETURN=2097215,
    D3D11_MESSAGE_ID_RESOURCE_MAP_WITHOUT_INITIAL_DISCARD=2097216,
    D3D11_MESSAGE_ID_RESOURCE_UNMAP_INVALIDSUBRESOURCE=2097217,
    D3D11_MESSAGE_ID_RESOURCE_UNMAP_NOTMAPPED=2097218,
    D3D11_MESSAGE_ID_DEVICE_DRAW_RASTERIZING_CONTROL_POINTS=2097219,
    D3D11_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNSUPPORTED=2097220,
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_SIGNATURE_MISMATCH=2097221,
    D3D11_MESSAGE_ID_DEVICE_DRAW_HULL_SHADER_INPUT_TOPOLOGY_MISMATCH=2097222,
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_CONTROL_POINT_COUNT_MISMATCH=2097223,
    D3D11_MESSAGE_ID_DEVICE_DRAW_HS_DS_TESSELLATOR_DOMAIN_MISMATCH=2097224,
    D3D11_MESSAGE_ID_CREATE_CONTEXT=2097225,
    D3D11_MESSAGE_ID_LIVE_CONTEXT=2097226,
    D3D11_MESSAGE_ID_DESTROY_CONTEXT=2097227,
    D3D11_MESSAGE_ID_CREATE_BUFFER=2097228,
    D3D11_MESSAGE_ID_LIVE_BUFFER=2097229,
    D3D11_MESSAGE_ID_DESTROY_BUFFER=2097230,
    D3D11_MESSAGE_ID_CREATE_TEXTURE1D=2097231,
    D3D11_MESSAGE_ID_LIVE_TEXTURE1D=2097232,
    D3D11_MESSAGE_ID_DESTROY_TEXTURE1D=2097233,
    D3D11_MESSAGE_ID_CREATE_TEXTURE2D=2097234,
    D3D11_MESSAGE_ID_LIVE_TEXTURE2D=2097235,
    D3D11_MESSAGE_ID_DESTROY_TEXTURE2D=2097236,
    D3D11_MESSAGE_ID_CREATE_TEXTURE3D=2097237,
    D3D11_MESSAGE_ID_LIVE_TEXTURE3D=2097238,
    D3D11_MESSAGE_ID_DESTROY_TEXTURE3D=2097239,
    D3D11_MESSAGE_ID_CREATE_SHADERRESOURCEVIEW=2097240,
    D3D11_MESSAGE_ID_LIVE_SHADERRESOURCEVIEW=2097241,
    D3D11_MESSAGE_ID_DESTROY_SHADERRESOURCEVIEW=2097242,
    D3D11_MESSAGE_ID_CREATE_RENDERTARGETVIEW=2097243,
    D3D11_MESSAGE_ID_LIVE_RENDERTARGETVIEW=2097244,
    D3D11_MESSAGE_ID_DESTROY_RENDERTARGETVIEW=2097245,
    D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILVIEW=2097246,
    D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILVIEW=2097247,
    D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILVIEW=2097248,
    D3D11_MESSAGE_ID_CREATE_VERTEXSHADER=2097249,
    D3D11_MESSAGE_ID_LIVE_VERTEXSHADER=2097250,
    D3D11_MESSAGE_ID_DESTROY_VERTEXSHADER=2097251,
    D3D11_MESSAGE_ID_CREATE_HULLSHADER=2097252,
    D3D11_MESSAGE_ID_LIVE_HULLSHADER=2097253,
    D3D11_MESSAGE_ID_DESTROY_HULLSHADER=2097254,
    D3D11_MESSAGE_ID_CREATE_DOMAINSHADER=2097255,
    D3D11_MESSAGE_ID_LIVE_DOMAINSHADER=2097256,
    D3D11_MESSAGE_ID_DESTROY_DOMAINSHADER=2097257,
    D3D11_MESSAGE_ID_CREATE_GEOMETRYSHADER=2097258,
    D3D11_MESSAGE_ID_LIVE_GEOMETRYSHADER=2097259,
    D3D11_MESSAGE_ID_DESTROY_GEOMETRYSHADER=2097260,
    D3D11_MESSAGE_ID_CREATE_PIXELSHADER=2097261,
    D3D11_MESSAGE_ID_LIVE_PIXELSHADER=2097262,
    D3D11_MESSAGE_ID_DESTROY_PIXELSHADER=2097263,
    D3D11_MESSAGE_ID_CREATE_INPUTLAYOUT=2097264,
    D3D11_MESSAGE_ID_LIVE_INPUTLAYOUT=2097265,
    D3D11_MESSAGE_ID_DESTROY_INPUTLAYOUT=2097266,
    D3D11_MESSAGE_ID_CREATE_SAMPLER=2097267,
    D3D11_MESSAGE_ID_LIVE_SAMPLER=2097268,
    D3D11_MESSAGE_ID_DESTROY_SAMPLER=2097269,
    D3D11_MESSAGE_ID_CREATE_BLENDSTATE=2097270,
    D3D11_MESSAGE_ID_LIVE_BLENDSTATE=2097271,
    D3D11_MESSAGE_ID_DESTROY_BLENDSTATE=2097272,
    D3D11_MESSAGE_ID_CREATE_DEPTHSTENCILSTATE=2097273,
    D3D11_MESSAGE_ID_LIVE_DEPTHSTENCILSTATE=2097274,
    D3D11_MESSAGE_ID_DESTROY_DEPTHSTENCILSTATE=2097275,
    D3D11_MESSAGE_ID_CREATE_RASTERIZERSTATE=2097276,
    D3D11_MESSAGE_ID_LIVE_RASTERIZERSTATE=2097277,
    D3D11_MESSAGE_ID_DESTROY_RASTERIZERSTATE=2097278,
    D3D11_MESSAGE_ID_CREATE_QUERY=2097279,
    D3D11_MESSAGE_ID_LIVE_QUERY=2097280,
    D3D11_MESSAGE_ID_DESTROY_QUERY=2097281,
    D3D11_MESSAGE_ID_CREATE_PREDICATE=2097282,
    D3D11_MESSAGE_ID_LIVE_PREDICATE=2097283,
    D3D11_MESSAGE_ID_DESTROY_PREDICATE=2097284,
    D3D11_MESSAGE_ID_CREATE_COUNTER=2097285,
    D3D11_MESSAGE_ID_LIVE_COUNTER=2097286,
    D3D11_MESSAGE_ID_DESTROY_COUNTER=2097287,
    D3D11_MESSAGE_ID_CREATE_COMMANDLIST=2097288,
    D3D11_MESSAGE_ID_LIVE_COMMANDLIST=2097289,
    D3D11_MESSAGE_ID_DESTROY_COMMANDLIST=2097290,
    D3D11_MESSAGE_ID_CREATE_CLASSINSTANCE=2097291,
    D3D11_MESSAGE_ID_LIVE_CLASSINSTANCE=2097292,
    D3D11_MESSAGE_ID_DESTROY_CLASSINSTANCE=2097293,
    D3D11_MESSAGE_ID_CREATE_CLASSLINKAGE=2097294,
    D3D11_MESSAGE_ID_LIVE_CLASSLINKAGE=2097295,
    D3D11_MESSAGE_ID_DESTROY_CLASSLINKAGE=2097296,
    D3D11_MESSAGE_ID_LIVE_DEVICE=2097297,
    D3D11_MESSAGE_ID_LIVE_OBJECT_SUMMARY=2097298,
    D3D11_MESSAGE_ID_CREATE_COMPUTESHADER=2097299,
    D3D11_MESSAGE_ID_LIVE_COMPUTESHADER=2097300,
    D3D11_MESSAGE_ID_DESTROY_COMPUTESHADER=2097301,
    D3D11_MESSAGE_ID_CREATE_UNORDEREDACCESSVIEW=2097302,
    D3D11_MESSAGE_ID_LIVE_UNORDEREDACCESSVIEW=2097303,
    D3D11_MESSAGE_ID_DESTROY_UNORDEREDACCESSVIEW=2097304,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACES_FEATURELEVEL=2097305,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INTERFACE_COUNT_MISMATCH=2097306,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE=2097307,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_INDEX=2097308,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_TYPE=2097309,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INVALID_INSTANCE_DATA=2097310,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_UNBOUND_INSTANCE_DATA=2097311,
    D3D11_MESSAGE_ID_DEVICE_SETSHADER_INSTANCE_DATA_BINDINGS=2097312,
    D3D11_MESSAGE_ID_DEVICE_CREATESHADER_CLASSLINKAGE_FULL=2097313,
    D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_UNRECOGNIZED_FEATURE=2097314,
    D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_MISMATCHED_DATA_SIZE=2097315,
    D3D11_MESSAGE_ID_DEVICE_CHECKFEATURESUPPORT_INVALIDARG_RETURN=2097316,
    D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_HAZARD=2097317,
    D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_HAZARD=2097318,
    D3D11_MESSAGE_ID_CSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=2097319,
    D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=2097320,
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCALL=2097321,
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_OUTOFMEMORY=2097322,
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERBYTECODE=2097323,
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDSHADERTYPE=2097324,
    D3D11_MESSAGE_ID_CREATECOMPUTESHADER_INVALIDCLASSLINKAGE=2097325,
    D3D11_MESSAGE_ID_DEVICE_CSSETSHADERRESOURCES_VIEWS_EMPTY=2097326,
    D3D11_MESSAGE_ID_CSSETCONSTANTBUFFERS_INVALIDBUFFER=2097327,
    D3D11_MESSAGE_ID_DEVICE_CSSETCONSTANTBUFFERS_BUFFERS_EMPTY=2097328,
    D3D11_MESSAGE_ID_DEVICE_CSSETSAMPLERS_SAMPLERS_EMPTY=2097329,
    D3D11_MESSAGE_ID_DEVICE_CSGETSHADERRESOURCES_VIEWS_EMPTY=2097330,
    D3D11_MESSAGE_ID_DEVICE_CSGETCONSTANTBUFFERS_BUFFERS_EMPTY=2097331,
    D3D11_MESSAGE_ID_DEVICE_CSGETSAMPLERS_SAMPLERS_EMPTY=2097332,
    D3D11_MESSAGE_ID_DEVICE_CREATEVERTEXSHADER_DOUBLEFLOATOPSNOTSUPPORTED=2097333,
    D3D11_MESSAGE_ID_DEVICE_CREATEHULLSHADER_DOUBLEFLOATOPSNOTSUPPORTED=2097334,
    D3D11_MESSAGE_ID_DEVICE_CREATEDOMAINSHADER_DOUBLEFLOATOPSNOTSUPPORTED=2097335,
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADER_DOUBLEFLOATOPSNOTSUPPORTED=2097336,
    D3D11_MESSAGE_ID_DEVICE_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DOUBLEFLOATOPSNOTSUPPORTED=2097337,
    D3D11_MESSAGE_ID_DEVICE_CREATEPIXELSHADER_DOUBLEFLOATOPSNOTSUPPORTED=2097338,
    D3D11_MESSAGE_ID_DEVICE_CREATECOMPUTESHADER_DOUBLEFLOATOPSNOTSUPPORTED=2097339,
    D3D11_MESSAGE_ID_CREATEBUFFER_INVALIDSTRUCTURESTRIDE=2097340,
    D3D11_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFLAGS=2097341,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDRESOURCE=2097342,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDESC=2097343,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFORMAT=2097344,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDDIMENSIONS=2097345,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_UNRECOGNIZEDFORMAT=2097346,
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_HAZARD=2097347,
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_OVERLAPPING_OLD_SLOTS=2097348,
    D3D11_MESSAGE_ID_DEVICE_OMSETRENDERTARGETSANDUNORDEREDACCESSVIEWS_NO_OP=2097349,
    D3D11_MESSAGE_ID_CSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT=2097350,
    D3D11_MESSAGE_ID_PSSETUNORDEREDACCESSVIEWS_UNBINDDELETINGOBJECT=2097351,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDARG_RETURN=2097352,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_OUTOFMEMORY_RETURN=2097353,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_TOOMANYOBJECTS=2097354,
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_HAZARD=2097355,
    D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEW_DENORMFLUSH=2097356,
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSS_VIEWS_EMPTY=2097357,
    D3D11_MESSAGE_ID_DEVICE_CSGETUNORDEREDACCESSS_VIEWS_EMPTY=2097358,
    D3D11_MESSAGE_ID_CREATEUNORDEREDACCESSVIEW_INVALIDFLAGS=2097359,
    D3D11_MESSAGE_ID_CREATESHADERRESESOURCEVIEW_TOOMANYOBJECTS=2097360,
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_INVALID_ARG_BUFFER=2097361,
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_UNALIGNED=2097362,
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_OFFSET_OVERFLOW=2097363,
    D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDCONTEXT=2097364,
    D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDRESOURCE=2097365,
    D3D11_MESSAGE_ID_DEVICE_SETRESOURCEMINLOD_INVALIDMINLOD=2097366,
    D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDCONTEXT=2097367,
    D3D11_MESSAGE_ID_DEVICE_GETRESOURCEMINLOD_INVALIDRESOURCE=2097368,
    D3D11_MESSAGE_ID_OMSETDEPTHSTENCIL_UNBINDDELETINGOBJECT=2097369,
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DEPTH_READONLY=2097370,
    D3D11_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_STENCIL_READONLY=2097371,
    D3D11_MESSAGE_ID_CHECKFEATURESUPPORT_FORMAT_DEPRECATED=2097372,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RETURN_TYPE_MISMATCH=2097373,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_NOT_SET=2097374,
    D3D11_MESSAGE_ID_DEVICE_DRAW_UNORDEREDACCESSVIEW_RENDERTARGETVIEW_OVERLAP=2097375,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_DIMENSION_MISMATCH=2097376,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_APPEND_UNSUPPORTED=2097377,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMICS_UNSUPPORTED=2097378,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_STRUCTURE_STRIDE_MISMATCH=2097379,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_BUFFER_TYPE_MISMATCH=2097380,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_RAW_UNSUPPORTED=2097381,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_LD_UNSUPPORTED=2097382,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_FORMAT_STORE_UNSUPPORTED=2097383,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_ADD_UNSUPPORTED=2097384,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_BITWISE_OPS_UNSUPPORTED=2097385,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_CMPSTORE_CMPEXCHANGE_UNSUPPORTED=2097386,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_EXCHANGE_UNSUPPORTED=2097387,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_SIGNED_MINMAX_UNSUPPORTED=2097388,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_ATOMIC_UNSIGNED_MINMAX_UNSUPPORTED=2097389,
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_BOUND_RESOURCE_MAPPED=2097390,
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_OVERFLOW=2097391,
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_THREADGROUPCOUNT_ZERO=2097392,
    D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_STRUCTURE_STRIDE_MISMATCH=2097393,
    D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_BUFFER_TYPE_MISMATCH=2097394,
    D3D11_MESSAGE_ID_DEVICE_SHADERRESOURCEVIEW_RAW_UNSUPPORTED=2097395,
    D3D11_MESSAGE_ID_DEVICE_DISPATCH_UNSUPPORTED=2097396,
    D3D11_MESSAGE_ID_DEVICE_DISPATCHINDIRECT_UNSUPPORTED=2097397,
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDOFFSET=2097398,
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_LARGEOFFSET=2097399,
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDDESTINATIONSTATE=2097400,
    D3D11_MESSAGE_ID_COPYSTRUCTURECOUNT_INVALIDSOURCESTATE=2097401,
    D3D11_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_NOT_SUPPORTED=2097402,
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDVIEW=2097403,
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_INVALIDOFFSET=2097404,
    D3D11_MESSAGE_ID_DEVICE_CSSETUNORDEREDACCESSVIEWS_TOOMANYVIEWS=2097405,
    D3D11_MESSAGE_ID_CLEARUNORDEREDACCESSVIEWFLOAT_INVALIDFORMAT=2097406,
    D3D11_MESSAGE_ID_DEVICE_UNORDEREDACCESSVIEW_COUNTER_UNSUPPORTED=2097407,
    D3D11_MESSAGE_ID_REF_WARNING=2097408,
    D3D11_MESSAGE_ID_D3D11_MESSAGES_END=2097409
};

enum D2D1_BITMAP_INTERPOLATION_MODE
{
    D2D1_BITMAP_INTERPOLATION_MODE_NEAREST_NEIGHBOR=0,
    D2D1_BITMAP_INTERPOLATION_MODE_LINEAR=1,
    D2D1_BITMAP_INTERPOLATION_MODE_FORCE_DWORD=-1
};

enum WICNamedWhitePoint
{
    WICWhitePointDefault=1,
    WICWhitePointDaylight=2,
    WICWhitePointCloudy=4,
    WICWhitePointShade=8,
    WICWhitePointTungsten=16,
    WICWhitePointFluorescent=32,
    WICWhitePointFlash=64,
    WICWhitePointUnderwater=128,
    WICWhitePointCustom=256,
    WICWhitePointAutoWhiteBalance=512,
    WICWhitePointAsShot=1,
    WICNAMEDWHITEPOINT_FORCE_DWORD=2147483647
};

enum D2D1_DRAW_TEXT_OPTIONS
{
    D2D1_DRAW_TEXT_OPTIONS_NO_SNAP=1,
    D2D1_DRAW_TEXT_OPTIONS_CLIP=2,
    D2D1_DRAW_TEXT_OPTIONS_NONE=0,
    D2D1_DRAW_TEXT_OPTIONS_FORCE_DWORD=-1
};

enum D3D10_MESSAGE_CATEGORY
{
    D3D10_MESSAGE_CATEGORY_APPLICATION_DEFINED=0,
    D3D10_MESSAGE_CATEGORY_MISCELLANEOUS=1,
    D3D10_MESSAGE_CATEGORY_INITIALIZATION=2,
    D3D10_MESSAGE_CATEGORY_CLEANUP=3,
    D3D10_MESSAGE_CATEGORY_COMPILATION=4,
    D3D10_MESSAGE_CATEGORY_STATE_CREATION=5,
    D3D10_MESSAGE_CATEGORY_STATE_SETTING=6,
    D3D10_MESSAGE_CATEGORY_STATE_GETTING=7,
    D3D10_MESSAGE_CATEGORY_RESOURCE_MANIPULATION=8,
    D3D10_MESSAGE_CATEGORY_EXECUTION=9
};

enum D3D11_QUERY
{
    D3D11_QUERY_EVENT=0,
    D3D11_QUERY_OCCLUSION=1,
    D3D11_QUERY_TIMESTAMP=2,
    D3D11_QUERY_TIMESTAMP_DISJOINT=3,
    D3D11_QUERY_PIPELINE_STATISTICS=4,
    D3D11_QUERY_OCCLUSION_PREDICATE=5,
    D3D11_QUERY_SO_STATISTICS=6,
    D3D11_QUERY_SO_OVERFLOW_PREDICATE=7,
    D3D11_QUERY_SO_STATISTICS_STREAM0=8,
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM0=9,
    D3D11_QUERY_SO_STATISTICS_STREAM1=10,
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM1=11,
    D3D11_QUERY_SO_STATISTICS_STREAM2=12,
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM2=13,
    D3D11_QUERY_SO_STATISTICS_STREAM3=14,
    D3D11_QUERY_SO_OVERFLOW_PREDICATE_STREAM3=15
};

enum D3D11_FILL_MODE
{
    D3D11_FILL_WIREFRAME=2,
    D3D11_FILL_SOLID=3
};

enum D3D11_CULL_MODE
{
    D3D11_CULL_NONE=1,
    D3D11_CULL_FRONT=2,
    D3D11_CULL_BACK=3
};

enum D3D10_MESSAGE_ID
{
    D3D10_MESSAGE_ID_UNKNOWN=0,
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_HAZARD=1,
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_HAZARD=2,
    D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_HAZARD=3,
    D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_HAZARD=4,
    D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_HAZARD=5,
    D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_HAZARD=6,
    D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_HAZARD=7,
    D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_HAZARD=8,
    D3D10_MESSAGE_ID_DEVICE_OMSETRENDERTARGETS_HAZARD=9,
    D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_HAZARD=10,
    D3D10_MESSAGE_ID_STRING_FROM_APPLICATION=11,
    D3D10_MESSAGE_ID_CORRUPTED_THIS=12,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER1=13,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER2=14,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER3=15,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER4=16,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER5=17,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER6=18,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER7=19,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER8=20,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER9=21,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER10=22,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER11=23,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER12=24,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER13=25,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER14=26,
    D3D10_MESSAGE_ID_CORRUPTED_PARAMETER15=27,
    D3D10_MESSAGE_ID_CORRUPTED_MULTITHREADING=28,
    D3D10_MESSAGE_ID_MESSAGE_REPORTING_OUTOFMEMORY=29,
    D3D10_MESSAGE_ID_IASETINPUTLAYOUT_UNBINDDELETINGOBJECT=30,
    D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_UNBINDDELETINGOBJECT=31,
    D3D10_MESSAGE_ID_IASETINDEXBUFFER_UNBINDDELETINGOBJECT=32,
    D3D10_MESSAGE_ID_VSSETSHADER_UNBINDDELETINGOBJECT=33,
    D3D10_MESSAGE_ID_VSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=34,
    D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=35,
    D3D10_MESSAGE_ID_VSSETSAMPLERS_UNBINDDELETINGOBJECT=36,
    D3D10_MESSAGE_ID_GSSETSHADER_UNBINDDELETINGOBJECT=37,
    D3D10_MESSAGE_ID_GSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=38,
    D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=39,
    D3D10_MESSAGE_ID_GSSETSAMPLERS_UNBINDDELETINGOBJECT=40,
    D3D10_MESSAGE_ID_SOSETTARGETS_UNBINDDELETINGOBJECT=41,
    D3D10_MESSAGE_ID_PSSETSHADER_UNBINDDELETINGOBJECT=42,
    D3D10_MESSAGE_ID_PSSETSHADERRESOURCES_UNBINDDELETINGOBJECT=43,
    D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_UNBINDDELETINGOBJECT=44,
    D3D10_MESSAGE_ID_PSSETSAMPLERS_UNBINDDELETINGOBJECT=45,
    D3D10_MESSAGE_ID_RSSETSTATE_UNBINDDELETINGOBJECT=46,
    D3D10_MESSAGE_ID_OMSETBLENDSTATE_UNBINDDELETINGOBJECT=47,
    D3D10_MESSAGE_ID_OMSETDEPTHSTENCILSTATE_UNBINDDELETINGOBJECT=48,
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_UNBINDDELETINGOBJECT=49,
    D3D10_MESSAGE_ID_SETPREDICATION_UNBINDDELETINGOBJECT=50,
    D3D10_MESSAGE_ID_GETPRIVATEDATA_MOREDATA=51,
    D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFREEDATA=52,
    D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDIUNKNOWN=53,
    D3D10_MESSAGE_ID_SETPRIVATEDATA_INVALIDFLAGS=54,
    D3D10_MESSAGE_ID_SETPRIVATEDATA_CHANGINGPARAMS=55,
    D3D10_MESSAGE_ID_SETPRIVATEDATA_OUTOFMEMORY=56,
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDFORMAT=57,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDSAMPLES=58,
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDUSAGE=59,
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDBINDFLAGS=60,
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDCPUACCESSFLAGS=61,
    D3D10_MESSAGE_ID_CREATEBUFFER_UNRECOGNIZEDMISCFLAGS=62,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCPUACCESSFLAGS=63,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDBINDFLAGS=64,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDINITIALDATA=65,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDDIMENSIONS=66,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMIPLEVELS=67,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDMISCFLAGS=68,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDARG_RETURN=69,
    D3D10_MESSAGE_ID_CREATEBUFFER_OUTOFMEMORY_RETURN=70,
    D3D10_MESSAGE_ID_CREATEBUFFER_NULLDESC=71,
    D3D10_MESSAGE_ID_CREATEBUFFER_INVALIDCONSTANTBUFFERBINDINGS=72,
    D3D10_MESSAGE_ID_CREATEBUFFER_LARGEALLOCATION=73,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDFORMAT=74,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNSUPPORTEDFORMAT=75,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDSAMPLES=76,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDUSAGE=77,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDBINDFLAGS=78,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDCPUACCESSFLAGS=79,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_UNRECOGNIZEDMISCFLAGS=80,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDCPUACCESSFLAGS=81,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDBINDFLAGS=82,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDINITIALDATA=83,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDDIMENSIONS=84,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMIPLEVELS=85,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDMISCFLAGS=86,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_INVALIDARG_RETURN=87,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_OUTOFMEMORY_RETURN=88,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_NULLDESC=89,
    D3D10_MESSAGE_ID_CREATETEXTURE1D_LARGEALLOCATION=90,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDFORMAT=91,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNSUPPORTEDFORMAT=92,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDSAMPLES=93,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDUSAGE=94,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDBINDFLAGS=95,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDCPUACCESSFLAGS=96,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_UNRECOGNIZEDMISCFLAGS=97,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDCPUACCESSFLAGS=98,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDBINDFLAGS=99,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDINITIALDATA=100,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDDIMENSIONS=101,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMIPLEVELS=102,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDMISCFLAGS=103,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_INVALIDARG_RETURN=104,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_OUTOFMEMORY_RETURN=105,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_NULLDESC=106,
    D3D10_MESSAGE_ID_CREATETEXTURE2D_LARGEALLOCATION=107,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDFORMAT=108,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNSUPPORTEDFORMAT=109,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDSAMPLES=110,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDUSAGE=111,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDBINDFLAGS=112,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDCPUACCESSFLAGS=113,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_UNRECOGNIZEDMISCFLAGS=114,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDCPUACCESSFLAGS=115,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDBINDFLAGS=116,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDINITIALDATA=117,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDDIMENSIONS=118,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMIPLEVELS=119,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDMISCFLAGS=120,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_INVALIDARG_RETURN=121,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_OUTOFMEMORY_RETURN=122,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_NULLDESC=123,
    D3D10_MESSAGE_ID_CREATETEXTURE3D_LARGEALLOCATION=124,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_UNRECOGNIZEDFORMAT=125,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDESC=126,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDFORMAT=127,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDDIMENSIONS=128,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDRESOURCE=129,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_TOOMANYOBJECTS=130,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_INVALIDARG_RETURN=131,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_OUTOFMEMORY_RETURN=132,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNRECOGNIZEDFORMAT=133,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_UNSUPPORTEDFORMAT=134,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDESC=135,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDFORMAT=136,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDDIMENSIONS=137,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDRESOURCE=138,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_TOOMANYOBJECTS=139,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_INVALIDARG_RETURN=140,
    D3D10_MESSAGE_ID_CREATERENDERTARGETVIEW_OUTOFMEMORY_RETURN=141,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_UNRECOGNIZEDFORMAT=142,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDESC=143,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDFORMAT=144,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDDIMENSIONS=145,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDRESOURCE=146,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_TOOMANYOBJECTS=147,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_INVALIDARG_RETURN=148,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILVIEW_OUTOFMEMORY_RETURN=149,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_OUTOFMEMORY=150,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TOOMANYELEMENTS=151,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDFORMAT=152,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INCOMPATIBLEFORMAT=153,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOT=154,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDINPUTSLOTCLASS=155,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_STEPRATESLOTCLASSMISMATCH=156,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSLOTCLASSCHANGE=157,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDSTEPRATECHANGE=158,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_INVALIDALIGNMENT=159,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_DUPLICATESEMANTIC=160,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNPARSEABLEINPUTSIGNATURE=161,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLSEMANTIC=162,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_MISSINGELEMENT=163,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_NULLDESC=164,
    D3D10_MESSAGE_ID_CREATEVERTEXSHADER_OUTOFMEMORY=165,
    D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERBYTECODE=166,
    D3D10_MESSAGE_ID_CREATEVERTEXSHADER_INVALIDSHADERTYPE=167,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_OUTOFMEMORY=168,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERBYTECODE=169,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADER_INVALIDSHADERTYPE=170,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTOFMEMORY=171,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERBYTECODE=172,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSHADERTYPE=173,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDNUMENTRIES=174,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSTREAMSTRIDEUNUSED=175,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_UNEXPECTEDDECL=176,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_EXPECTEDDECL=177,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_OUTPUTSLOT0EXPECTED=178,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSLOT=179,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_ONLYONEELEMENTPERSLOT=180,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDCOMPONENTCOUNT=181,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDSTARTCOMPONENTANDCOMPONENTCOUNT=182,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDGAPDEFINITION=183,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_REPEATEDOUTPUT=184,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_INVALIDOUTPUTSTREAMSTRIDE=185,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGSEMANTIC=186,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MASKMISMATCH=187,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_CANTHAVEONLYGAPS=188,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_DECLTOOCOMPLEX=189,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_MISSINGOUTPUTSIGNATURE=190,
    D3D10_MESSAGE_ID_CREATEPIXELSHADER_OUTOFMEMORY=191,
    D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERBYTECODE=192,
    D3D10_MESSAGE_ID_CREATEPIXELSHADER_INVALIDSHADERTYPE=193,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDFILLMODE=194,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDCULLMODE=195,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDDEPTHBIASCLAMP=196,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_INVALIDSLOPESCALEDDEPTHBIAS=197,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_TOOMANYOBJECTS=198,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_NULLDESC=199,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHWRITEMASK=200,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDDEPTHFUNC=201,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFAILOP=202,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILZFAILOP=203,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILPASSOP=204,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDFRONTFACESTENCILFUNC=205,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFAILOP=206,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILZFAILOP=207,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILPASSOP=208,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_INVALIDBACKFACESTENCILFUNC=209,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_TOOMANYOBJECTS=210,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_NULLDESC=211,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLEND=212,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLEND=213,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOP=214,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDSRCBLENDALPHA=215,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDDESTBLENDALPHA=216,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDBLENDOPALPHA=217,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_INVALIDRENDERTARGETWRITEMASK=218,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_TOOMANYOBJECTS=219,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NULLDESC=220,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDFILTER=221,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSU=222,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSV=223,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDADDRESSW=224,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMIPLODBIAS=225,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXANISOTROPY=226,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDCOMPARISONFUNC=227,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMINLOD=228,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_INVALIDMAXLOD=229,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_TOOMANYOBJECTS=230,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NULLDESC=231,
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDQUERY=232,
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_INVALIDMISCFLAGS=233,
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_UNEXPECTEDMISCFLAG=234,
    D3D10_MESSAGE_ID_CREATEQUERYORPREDICATE_NULLDESC=235,
    D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNRECOGNIZED=236,
    D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_TOPOLOGY_UNDEFINED=237,
    D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_INVALIDBUFFER=238,
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_OFFSET_TOO_LARGE=239,
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_BUFFERS_EMPTY=240,
    D3D10_MESSAGE_ID_IASETINDEXBUFFER_INVALIDBUFFER=241,
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_FORMAT_INVALID=242,
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_TOO_LARGE=243,
    D3D10_MESSAGE_ID_DEVICE_IASETINDEXBUFFER_OFFSET_UNALIGNED=244,
    D3D10_MESSAGE_ID_DEVICE_VSSETSHADERRESOURCES_VIEWS_EMPTY=245,
    D3D10_MESSAGE_ID_VSSETCONSTANTBUFFERS_INVALIDBUFFER=246,
    D3D10_MESSAGE_ID_DEVICE_VSSETCONSTANTBUFFERS_BUFFERS_EMPTY=247,
    D3D10_MESSAGE_ID_DEVICE_VSSETSAMPLERS_SAMPLERS_EMPTY=248,
    D3D10_MESSAGE_ID_DEVICE_GSSETSHADERRESOURCES_VIEWS_EMPTY=249,
    D3D10_MESSAGE_ID_GSSETCONSTANTBUFFERS_INVALIDBUFFER=250,
    D3D10_MESSAGE_ID_DEVICE_GSSETCONSTANTBUFFERS_BUFFERS_EMPTY=251,
    D3D10_MESSAGE_ID_DEVICE_GSSETSAMPLERS_SAMPLERS_EMPTY=252,
    D3D10_MESSAGE_ID_SOSETTARGETS_INVALIDBUFFER=253,
    D3D10_MESSAGE_ID_DEVICE_SOSETTARGETS_OFFSET_UNALIGNED=254,
    D3D10_MESSAGE_ID_DEVICE_PSSETSHADERRESOURCES_VIEWS_EMPTY=255,
    D3D10_MESSAGE_ID_PSSETCONSTANTBUFFERS_INVALIDBUFFER=256,
    D3D10_MESSAGE_ID_DEVICE_PSSETCONSTANTBUFFERS_BUFFERS_EMPTY=257,
    D3D10_MESSAGE_ID_DEVICE_PSSETSAMPLERS_SAMPLERS_EMPTY=258,
    D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_INVALIDVIEWPORT=259,
    D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_INVALIDSCISSOR=260,
    D3D10_MESSAGE_ID_CLEARRENDERTARGETVIEW_DENORMFLUSH=261,
    D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_DENORMFLUSH=262,
    D3D10_MESSAGE_ID_CLEARDEPTHSTENCILVIEW_INVALID=263,
    D3D10_MESSAGE_ID_DEVICE_IAGETVERTEXBUFFERS_BUFFERS_EMPTY=264,
    D3D10_MESSAGE_ID_DEVICE_VSGETSHADERRESOURCES_VIEWS_EMPTY=265,
    D3D10_MESSAGE_ID_DEVICE_VSGETCONSTANTBUFFERS_BUFFERS_EMPTY=266,
    D3D10_MESSAGE_ID_DEVICE_VSGETSAMPLERS_SAMPLERS_EMPTY=267,
    D3D10_MESSAGE_ID_DEVICE_GSGETSHADERRESOURCES_VIEWS_EMPTY=268,
    D3D10_MESSAGE_ID_DEVICE_GSGETCONSTANTBUFFERS_BUFFERS_EMPTY=269,
    D3D10_MESSAGE_ID_DEVICE_GSGETSAMPLERS_SAMPLERS_EMPTY=270,
    D3D10_MESSAGE_ID_DEVICE_SOGETTARGETS_BUFFERS_EMPTY=271,
    D3D10_MESSAGE_ID_DEVICE_PSGETSHADERRESOURCES_VIEWS_EMPTY=272,
    D3D10_MESSAGE_ID_DEVICE_PSGETCONSTANTBUFFERS_BUFFERS_EMPTY=273,
    D3D10_MESSAGE_ID_DEVICE_PSGETSAMPLERS_SAMPLERS_EMPTY=274,
    D3D10_MESSAGE_ID_DEVICE_RSGETVIEWPORTS_VIEWPORTS_EMPTY=275,
    D3D10_MESSAGE_ID_DEVICE_RSGETSCISSORRECTS_RECTS_EMPTY=276,
    D3D10_MESSAGE_ID_DEVICE_GENERATEMIPS_RESOURCE_INVALID=277,
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSUBRESOURCE=278,
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESUBRESOURCE=279,
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCEBOX=280,
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCE=281,
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDDESTINATIONSTATE=282,
    D3D10_MESSAGE_ID_COPYSUBRESOURCEREGION_INVALIDSOURCESTATE=283,
    D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCE=284,
    D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDDESTINATIONSTATE=285,
    D3D10_MESSAGE_ID_COPYRESOURCE_INVALIDSOURCESTATE=286,
    D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSUBRESOURCE=287,
    D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONBOX=288,
    D3D10_MESSAGE_ID_UPDATESUBRESOURCE_INVALIDDESTINATIONSTATE=289,
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_INVALID=290,
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_DESTINATION_SUBRESOURCE_INVALID=291,
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_INVALID=292,
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_SOURCE_SUBRESOURCE_INVALID=293,
    D3D10_MESSAGE_ID_DEVICE_RESOLVESUBRESOURCE_FORMAT_INVALID=294,
    D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDMAPTYPE=295,
    D3D10_MESSAGE_ID_BUFFER_MAP_INVALIDFLAGS=296,
    D3D10_MESSAGE_ID_BUFFER_MAP_ALREADYMAPPED=297,
    D3D10_MESSAGE_ID_BUFFER_MAP_DEVICEREMOVED_RETURN=298,
    D3D10_MESSAGE_ID_BUFFER_UNMAP_NOTMAPPED=299,
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDMAPTYPE=300,
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDSUBRESOURCE=301,
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_INVALIDFLAGS=302,
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_ALREADYMAPPED=303,
    D3D10_MESSAGE_ID_TEXTURE1D_MAP_DEVICEREMOVED_RETURN=304,
    D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_INVALIDSUBRESOURCE=305,
    D3D10_MESSAGE_ID_TEXTURE1D_UNMAP_NOTMAPPED=306,
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDMAPTYPE=307,
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDSUBRESOURCE=308,
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_INVALIDFLAGS=309,
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_ALREADYMAPPED=310,
    D3D10_MESSAGE_ID_TEXTURE2D_MAP_DEVICEREMOVED_RETURN=311,
    D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_INVALIDSUBRESOURCE=312,
    D3D10_MESSAGE_ID_TEXTURE2D_UNMAP_NOTMAPPED=313,
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDMAPTYPE=314,
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDSUBRESOURCE=315,
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_INVALIDFLAGS=316,
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_ALREADYMAPPED=317,
    D3D10_MESSAGE_ID_TEXTURE3D_MAP_DEVICEREMOVED_RETURN=318,
    D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_INVALIDSUBRESOURCE=319,
    D3D10_MESSAGE_ID_TEXTURE3D_UNMAP_NOTMAPPED=320,
    D3D10_MESSAGE_ID_CHECKFORMATSUPPORT_FORMAT_DEPRECATED=321,
    D3D10_MESSAGE_ID_CHECKMULTISAMPLEQUALITYLEVELS_FORMAT_DEPRECATED=322,
    D3D10_MESSAGE_ID_SETEXCEPTIONMODE_UNRECOGNIZEDFLAGS=323,
    D3D10_MESSAGE_ID_SETEXCEPTIONMODE_INVALIDARG_RETURN=324,
    D3D10_MESSAGE_ID_SETEXCEPTIONMODE_DEVICEREMOVED_RETURN=325,
    D3D10_MESSAGE_ID_REF_SIMULATING_INFINITELY_FAST_HARDWARE=326,
    D3D10_MESSAGE_ID_REF_THREADING_MODE=327,
    D3D10_MESSAGE_ID_REF_UMDRIVER_EXCEPTION=328,
    D3D10_MESSAGE_ID_REF_KMDRIVER_EXCEPTION=329,
    D3D10_MESSAGE_ID_REF_HARDWARE_EXCEPTION=330,
    D3D10_MESSAGE_ID_REF_ACCESSING_INDEXABLE_TEMP_OUT_OF_RANGE=331,
    D3D10_MESSAGE_ID_REF_PROBLEM_PARSING_SHADER=332,
    D3D10_MESSAGE_ID_REF_OUT_OF_MEMORY=333,
    D3D10_MESSAGE_ID_REF_INFO=334,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEXPOS_OVERFLOW=335,
    D3D10_MESSAGE_ID_DEVICE_DRAWINDEXED_INDEXPOS_OVERFLOW=336,
    D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_VERTEXPOS_OVERFLOW=337,
    D3D10_MESSAGE_ID_DEVICE_DRAWINSTANCED_INSTANCEPOS_OVERFLOW=338,
    D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INSTANCEPOS_OVERFLOW=339,
    D3D10_MESSAGE_ID_DEVICE_DRAWINDEXEDINSTANCED_INDEXPOS_OVERFLOW=340,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_SHADER_NOT_SET=341,
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SEMANTICNAME_NOT_FOUND=342,
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERINDEX=343,
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_COMPONENTTYPE=344,
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_REGISTERMASK=345,
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_SYSTEMVALUE=346,
    D3D10_MESSAGE_ID_DEVICE_SHADER_LINKAGE_NEVERWRITTEN_ALWAYSREADS=347,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_NOT_SET=348,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INPUTLAYOUT_NOT_SET=349,
    D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_NOT_SET=350,
    D3D10_MESSAGE_ID_DEVICE_DRAW_CONSTANT_BUFFER_TOO_SMALL=351,
    D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_NOT_SET=352,
    D3D10_MESSAGE_ID_DEVICE_DRAW_SHADERRESOURCEVIEW_NOT_SET=353,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VIEW_DIMENSION_MISMATCH=354,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_STRIDE_TOO_SMALL=355,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_BUFFER_TOO_SMALL=356,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_NOT_SET=357,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_FORMAT_INVALID=358,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_BUFFER_TOO_SMALL=359,
    D3D10_MESSAGE_ID_DEVICE_DRAW_GS_INPUT_PRIMITIVE_MISMATCH=360,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_RETURN_TYPE_MISMATCH=361,
    D3D10_MESSAGE_ID_DEVICE_DRAW_POSITION_NOT_PRESENT=362,
    D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_NOT_SET=363,
    D3D10_MESSAGE_ID_DEVICE_DRAW_BOUND_RESOURCE_MAPPED=364,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_PRIMITIVETOPOLOGY=365,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_OFFSET_UNALIGNED=366,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VERTEX_STRIDE_UNALIGNED=367,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INDEX_OFFSET_UNALIGNED=368,
    D3D10_MESSAGE_ID_DEVICE_DRAW_OUTPUT_STREAM_OFFSET_UNALIGNED=369,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_LD_UNSUPPORTED=370,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_UNSUPPORTED=371,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_SAMPLE_C_UNSUPPORTED=372,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_MULTISAMPLE_UNSUPPORTED=373,
    D3D10_MESSAGE_ID_DEVICE_DRAW_SO_TARGETS_BOUND_WITHOUT_SOURCE=374,
    D3D10_MESSAGE_ID_DEVICE_DRAW_SO_STRIDE_LARGER_THAN_BUFFER=375,
    D3D10_MESSAGE_ID_DEVICE_DRAW_OM_RENDER_TARGET_DOES_NOT_SUPPORT_BLENDING=376,
    D3D10_MESSAGE_ID_DEVICE_DRAW_OM_DUAL_SOURCE_BLENDING_CAN_ONLY_HAVE_RENDER_TARGET_0=377,
    D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_AT_FAULT=378,
    D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_POSSIBLY_AT_FAULT=379,
    D3D10_MESSAGE_ID_DEVICE_REMOVAL_PROCESS_NOT_AT_FAULT=380,
    D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_INVALIDARG_RETURN=381,
    D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_OUTOFMEMORY_RETURN=382,
    D3D10_MESSAGE_ID_DEVICE_OPEN_SHARED_RESOURCE_BADINTERFACE_RETURN=383,
    D3D10_MESSAGE_ID_DEVICE_DRAW_VIEWPORT_NOT_SET=384,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TRAILING_DIGIT_IN_SEMANTIC=385,
    D3D10_MESSAGE_ID_CREATEGEOMETRYSHADERWITHSTREAMOUTPUT_TRAILING_DIGIT_IN_SEMANTIC=386,
    D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_DENORMFLUSH=387,
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_INVALIDVIEW=388,
    D3D10_MESSAGE_ID_DEVICE_SETTEXTFILTERSIZE_INVALIDDIMENSIONS=389,
    D3D10_MESSAGE_ID_DEVICE_DRAW_SAMPLER_MISMATCH=390,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_TYPE_MISMATCH=391,
    D3D10_MESSAGE_ID_BLENDSTATE_GETDESC_LEGACY=392,
    D3D10_MESSAGE_ID_SHADERRESOURCEVIEW_GETDESC_LEGACY=393,
    D3D10_MESSAGE_ID_CREATEQUERY_OUTOFMEMORY_RETURN=394,
    D3D10_MESSAGE_ID_CREATEPREDICATE_OUTOFMEMORY_RETURN=395,
    D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFRANGE_COUNTER=396,
    D3D10_MESSAGE_ID_CREATECOUNTER_SIMULTANEOUS_ACTIVE_COUNTERS_EXHAUSTED=397,
    D3D10_MESSAGE_ID_CREATECOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER=398,
    D3D10_MESSAGE_ID_CREATECOUNTER_OUTOFMEMORY_RETURN=399,
    D3D10_MESSAGE_ID_CREATECOUNTER_NONEXCLUSIVE_RETURN=400,
    D3D10_MESSAGE_ID_CREATECOUNTER_NULLDESC=401,
    D3D10_MESSAGE_ID_CHECKCOUNTER_OUTOFRANGE_COUNTER=402,
    D3D10_MESSAGE_ID_CHECKCOUNTER_UNSUPPORTED_WELLKNOWN_COUNTER=403,
    D3D10_MESSAGE_ID_SETPREDICATION_INVALID_PREDICATE_STATE=404,
    D3D10_MESSAGE_ID_QUERY_BEGIN_UNSUPPORTED=405,
    D3D10_MESSAGE_ID_PREDICATE_BEGIN_DURING_PREDICATION=406,
    D3D10_MESSAGE_ID_QUERY_BEGIN_DUPLICATE=407,
    D3D10_MESSAGE_ID_QUERY_BEGIN_ABANDONING_PREVIOUS_RESULTS=408,
    D3D10_MESSAGE_ID_PREDICATE_END_DURING_PREDICATION=409,
    D3D10_MESSAGE_ID_QUERY_END_ABANDONING_PREVIOUS_RESULTS=410,
    D3D10_MESSAGE_ID_QUERY_END_WITHOUT_BEGIN=411,
    D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_DATASIZE=412,
    D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_FLAGS=413,
    D3D10_MESSAGE_ID_QUERY_GETDATA_INVALID_CALL=414,
    D3D10_MESSAGE_ID_DEVICE_DRAW_PS_OUTPUT_TYPE_MISMATCH=415,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_FORMAT_GATHER_UNSUPPORTED=416,
    D3D10_MESSAGE_ID_DEVICE_DRAW_INVALID_USE_OF_CENTER_MULTISAMPLE_PATTERN=417,
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_STRIDE_TOO_LARGE=418,
    D3D10_MESSAGE_ID_DEVICE_IASETVERTEXBUFFERS_INVALIDRANGE=419,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_EMPTY_LAYOUT=420,
    D3D10_MESSAGE_ID_DEVICE_DRAW_RESOURCE_SAMPLE_COUNT_MISMATCH=421,
    D3D10_MESSAGE_ID_D3D10_MESSAGES_END=422,
    D3D10_MESSAGE_ID_D3D10L9_MESSAGES_START=1048576,
    D3D10_MESSAGE_ID_CREATEDEPTHSTENCILSTATE_STENCIL_NO_TWO_SIDED=1048577,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthBiasClamp_NOT_SUPPORTED=1048578,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_COMPARISON_SUPPORT=1048579,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_EXCESSIVE_ANISOTROPY=1048580,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_OUT_OF_RANGE=1048581,
    D3D10_MESSAGE_ID_VSSETSAMPLERS_NOT_SUPPORTED=1048582,
    D3D10_MESSAGE_ID_VSSETSAMPLERS_TOO_MANY_SAMPLERS=1048583,
    D3D10_MESSAGE_ID_PSSETSAMPLERS_TOO_MANY_SAMPLERS=1048584,
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_ARRAYS=1048585,
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_VB_AND_IB_BIND=1048586,
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_TEXTURE_1D=1048587,
    D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_OUT_OF_RANGE=1048588,
    D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_SHADER_RESOURCE=1048589,
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_TOO_MANY_RENDER_TARGETS=1048590,
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_DIFFERING_BIT_DEPTHS=1048591,
    D3D10_MESSAGE_ID_IASETVERTEXBUFFERS_BAD_BUFFER_INDEX=1048592,
    D3D10_MESSAGE_ID_DEVICE_RSSETVIEWPORTS_TOO_MANY_VIEWPORTS=1048593,
    D3D10_MESSAGE_ID_DEVICE_IASETPRIMITIVETOPOLOGY_ADJACENCY_UNSUPPORTED=1048594,
    D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_TOO_MANY_SCISSORS=1048595,
    D3D10_MESSAGE_ID_COPYRESOURCE_ONLY_TEXTURE_2D_WITHIN_GPU_MEMORY=1048596,
    D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_3D_READBACK=1048597,
    D3D10_MESSAGE_ID_COPYRESOURCE_NO_TEXTURE_ONLY_READBACK=1048598,
    D3D10_MESSAGE_ID_CREATEINPUTLAYOUT_UNSUPPORTED_FORMAT=1048599,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_ALPHA_TO_COVERAGE=1048600,
    D3D10_MESSAGE_ID_CREATERASTERIZERSTATE_DepthClipEnable_MUST_BE_TRUE=1048601,
    D3D10_MESSAGE_ID_DRAWINDEXED_STARTINDEXLOCATION_MUST_BE_POSITIVE=1048602,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_MUST_USE_LOWEST_LOD=1048603,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MINLOD_MUST_NOT_BE_FRACTIONAL=1048604,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_MAXLOD_MUST_BE_FLT_MAX=1048605,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_FIRSTARRAYSLICE_MUST_BE_ZERO=1048606,
    D3D10_MESSAGE_ID_CREATESHADERRESOURCEVIEW_CUBES_MUST_HAVE_6_SIDES=1048607,
    D3D10_MESSAGE_ID_CREATERESOURCE_NOT_BINDABLE_AS_RENDER_TARGET=1048608,
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_DWORD_INDEX_BUFFER=1048609,
    D3D10_MESSAGE_ID_CREATERESOURCE_MSAA_PRECLUDES_SHADER_RESOURCE=1048610,
    D3D10_MESSAGE_ID_CREATERESOURCE_PRESENTATION_PRECLUDES_SHADER_RESOURCE=1048611,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_BLEND_ENABLE=1048612,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_INDEPENDENT_WRITE_MASKS=1048613,
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_STREAM_OUT=1048614,
    D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_VB_IB_FOR_BUFFERS=1048615,
    D3D10_MESSAGE_ID_CREATERESOURCE_NO_AUTOGEN_FOR_VOLUMES=1048616,
    D3D10_MESSAGE_ID_CREATERESOURCE_DXGI_FORMAT_R8G8B8A8_CANNOT_BE_SHARED=1048617,
    D3D10_MESSAGE_ID_VSSHADERRESOURCES_NOT_SUPPORTED=1048618,
    D3D10_MESSAGE_ID_GEOMETRY_SHADER_NOT_SUPPORTED=1048619,
    D3D10_MESSAGE_ID_STREAM_OUT_NOT_SUPPORTED=1048620,
    D3D10_MESSAGE_ID_TEXT_FILTER_NOT_SUPPORTED=1048621,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_SEPARATE_ALPHA_BLEND=1048622,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_NO_MRT_BLEND=1048623,
    D3D10_MESSAGE_ID_CREATEBLENDSTATE_OPERATION_NOT_SUPPORTED=1048624,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_NO_MIRRORONCE=1048625,
    D3D10_MESSAGE_ID_DRAWINSTANCED_NOT_SUPPORTED=1048626,
    D3D10_MESSAGE_ID_DRAWINDEXEDINSTANCED_NOT_SUPPORTED_BELOW_9_3=1048627,
    D3D10_MESSAGE_ID_DRAWINDEXED_POINTLIST_UNSUPPORTED=1048628,
    D3D10_MESSAGE_ID_SETBLENDSTATE_SAMPLE_MASK_CANNOT_BE_ZERO=1048629,
    D3D10_MESSAGE_ID_CREATERESOURCE_DIMENSION_EXCEEDS_FEATURE_LEVEL_DEFINITION=1048630,
    D3D10_MESSAGE_ID_CREATERESOURCE_ONLY_SINGLE_MIP_LEVEL_DEPTH_STENCIL_SUPPORTED=1048631,
    D3D10_MESSAGE_ID_DEVICE_RSSETSCISSORRECTS_NEGATIVESCISSOR=1048632,
    D3D10_MESSAGE_ID_SLOT_ZERO_MUST_BE_D3D10_INPUT_PER_VERTEX_DATA=1048633,
    D3D10_MESSAGE_ID_CREATERESOURCE_NON_POW_2_MIPMAP=1048634,
    D3D10_MESSAGE_ID_CREATESAMPLERSTATE_BORDER_NOT_SUPPORTED=1048635,
    D3D10_MESSAGE_ID_OMSETRENDERTARGETS_NO_SRGB_MRT=1048636,
    D3D10_MESSAGE_ID_D3D10L9_MESSAGES_END=1048637
};

enum _D3D_INCLUDE_TYPE
{
    D3D_INCLUDE_LOCAL=0,
    D3D_INCLUDE_SYSTEM=1,
    D3D10_INCLUDE_LOCAL=0,
    D3D10_INCLUDE_SYSTEM=1,
    D3D_INCLUDE_FORCE_DWORD=2147483647
};

enum _D3D_SHADER_VARIABLE_CLASS
{
    D3D_SVC_SCALAR=0,
    D3D_SVC_VECTOR=1,
    D3D_SVC_MATRIX_ROWS=2,
    D3D_SVC_MATRIX_COLUMNS=3,
    D3D_SVC_OBJECT=4,
    D3D_SVC_STRUCT=5,
    D3D_SVC_INTERFACE_CLASS=6,
    D3D_SVC_INTERFACE_POINTER=7,
    D3D10_SVC_SCALAR=0,
    D3D10_SVC_VECTOR=1,
    D3D10_SVC_MATRIX_ROWS=2,
    D3D10_SVC_MATRIX_COLUMNS=3,
    D3D10_SVC_OBJECT=4,
    D3D10_SVC_STRUCT=5,
    D3D11_SVC_INTERFACE_CLASS=6,
    D3D11_SVC_INTERFACE_POINTER=7,
    D3D_SVC_FORCE_DWORD=2147483647
};

enum D3D11_DSV_DIMENSION
{
    D3D11_DSV_DIMENSION_UNKNOWN=0,
    D3D11_DSV_DIMENSION_TEXTURE1D=1,
    D3D11_DSV_DIMENSION_TEXTURE1DARRAY=2,
    D3D11_DSV_DIMENSION_TEXTURE2D=3,
    D3D11_DSV_DIMENSION_TEXTURE2DARRAY=4,
    D3D11_DSV_DIMENSION_TEXTURE2DMS=5,
    D3D11_DSV_DIMENSION_TEXTURE2DMSARRAY=6
};

enum D3D11_RTV_DIMENSION
{
    D3D11_RTV_DIMENSION_UNKNOWN=0,
    D3D11_RTV_DIMENSION_BUFFER=1,
    D3D11_RTV_DIMENSION_TEXTURE1D=2,
    D3D11_RTV_DIMENSION_TEXTURE1DARRAY=3,
    D3D11_RTV_DIMENSION_TEXTURE2D=4,
    D3D11_RTV_DIMENSION_TEXTURE2DARRAY=5,
    D3D11_RTV_DIMENSION_TEXTURE2DMS=6,
    D3D11_RTV_DIMENSION_TEXTURE2DMSARRAY=7,
    D3D11_RTV_DIMENSION_TEXTURE3D=8
};

enum _D3D_SHADER_VARIABLE_FLAGS
{
    D3D_SVF_USERPACKED=1,
    D3D_SVF_USED=2,
    D3D_SVF_INTERFACE_POINTER=4,
    D3D_SVF_INTERFACE_PARAMETER=8,
    D3D10_SVF_USERPACKED=1,
    D3D10_SVF_USED=2,
    D3D11_SVF_INTERFACE_POINTER=4,
    D3D11_SVF_INTERFACE_PARAMETER=8,
    D3D_SVF_FORCE_DWORD=2147483647
};

enum D3D11_UAV_DIMENSION
{
    D3D11_UAV_DIMENSION_UNKNOWN=0,
    D3D11_UAV_DIMENSION_BUFFER=1,
    D3D11_UAV_DIMENSION_TEXTURE1D=2,
    D3D11_UAV_DIMENSION_TEXTURE1DARRAY=3,
    D3D11_UAV_DIMENSION_TEXTURE2D=4,
    D3D11_UAV_DIMENSION_TEXTURE2DARRAY=5,
    D3D11_UAV_DIMENSION_TEXTURE3D=8
};

enum _D3D_SHADER_VARIABLE_TYPE
{
    D3D_SVT_VOID=0,
    D3D_SVT_BOOL=1,
    D3D_SVT_INT=2,
    D3D_SVT_FLOAT=3,
    D3D_SVT_STRING=4,
    D3D_SVT_TEXTURE=5,
    D3D_SVT_TEXTURE1D=6,
    D3D_SVT_TEXTURE2D=7,
    D3D_SVT_TEXTURE3D=8,
    D3D_SVT_TEXTURECUBE=9,
    D3D_SVT_SAMPLER=10,
    D3D_SVT_SAMPLER1D=11,
    D3D_SVT_SAMPLER2D=12,
    D3D_SVT_SAMPLER3D=13,
    D3D_SVT_SAMPLERCUBE=14,
    D3D_SVT_PIXELSHADER=15,
    D3D_SVT_VERTEXSHADER=16,
    D3D_SVT_PIXELFRAGMENT=17,
    D3D_SVT_VERTEXFRAGMENT=18,
    D3D_SVT_UINT=19,
    D3D_SVT_UINT8=20,
    D3D_SVT_GEOMETRYSHADER=21,
    D3D_SVT_RASTERIZER=22,
    D3D_SVT_DEPTHSTENCIL=23,
    D3D_SVT_BLEND=24,
    D3D_SVT_BUFFER=25,
    D3D_SVT_CBUFFER=26,
    D3D_SVT_TBUFFER=27,
    D3D_SVT_TEXTURE1DARRAY=28,
    D3D_SVT_TEXTURE2DARRAY=29,
    D3D_SVT_RENDERTARGETVIEW=30,
    D3D_SVT_DEPTHSTENCILVIEW=31,
    D3D_SVT_TEXTURE2DMS=32,
    D3D_SVT_TEXTURE2DMSARRAY=33,
    D3D_SVT_TEXTURECUBEARRAY=34,
    D3D_SVT_HULLSHADER=35,
    D3D_SVT_DOMAINSHADER=36,
    D3D_SVT_INTERFACE_POINTER=37,
    D3D_SVT_COMPUTESHADER=38,
    D3D_SVT_DOUBLE=39,
    D3D_SVT_RWTEXTURE1D=40,
    D3D_SVT_RWTEXTURE1DARRAY=41,
    D3D_SVT_RWTEXTURE2D=42,
    D3D_SVT_RWTEXTURE2DARRAY=43,
    D3D_SVT_RWTEXTURE3D=44,
    D3D_SVT_RWBUFFER=45,
    D3D_SVT_BYTEADDRESS_BUFFER=46,
    D3D_SVT_RWBYTEADDRESS_BUFFER=47,
    D3D_SVT_STRUCTURED_BUFFER=48,
    D3D_SVT_RWSTRUCTURED_BUFFER=49,
    D3D_SVT_APPEND_STRUCTURED_BUFFER=50,
    D3D_SVT_CONSUME_STRUCTURED_BUFFER=51,
    D3D10_SVT_VOID=0,
    D3D10_SVT_BOOL=1,
    D3D10_SVT_INT=2,
    D3D10_SVT_FLOAT=3,
    D3D10_SVT_STRING=4,
    D3D10_SVT_TEXTURE=5,
    D3D10_SVT_TEXTURE1D=6,
    D3D10_SVT_TEXTURE2D=7,
    D3D10_SVT_TEXTURE3D=8,
    D3D10_SVT_TEXTURECUBE=9,
    D3D10_SVT_SAMPLER=10,
    D3D10_SVT_SAMPLER1D=11,
    D3D10_SVT_SAMPLER2D=12,
    D3D10_SVT_SAMPLER3D=13,
    D3D10_SVT_SAMPLERCUBE=14,
    D3D10_SVT_PIXELSHADER=15,
    D3D10_SVT_VERTEXSHADER=16,
    D3D10_SVT_PIXELFRAGMENT=17,
    D3D10_SVT_VERTEXFRAGMENT=18,
    D3D10_SVT_UINT=19,
    D3D10_SVT_UINT8=20,
    D3D10_SVT_GEOMETRYSHADER=21,
    D3D10_SVT_RASTERIZER=22,
    D3D10_SVT_DEPTHSTENCIL=23,
    D3D10_SVT_BLEND=24,
    D3D10_SVT_BUFFER=25,
    D3D10_SVT_CBUFFER=26,
    D3D10_SVT_TBUFFER=27,
    D3D10_SVT_TEXTURE1DARRAY=28,
    D3D10_SVT_TEXTURE2DARRAY=29,
    D3D10_SVT_RENDERTARGETVIEW=30,
    D3D10_SVT_DEPTHSTENCILVIEW=31,
    D3D10_SVT_TEXTURE2DMS=32,
    D3D10_SVT_TEXTURE2DMSARRAY=33,
    D3D10_SVT_TEXTURECUBEARRAY=34,
    D3D11_SVT_HULLSHADER=35,
    D3D11_SVT_DOMAINSHADER=36,
    D3D11_SVT_INTERFACE_POINTER=37,
    D3D11_SVT_COMPUTESHADER=38,
    D3D11_SVT_DOUBLE=39,
    D3D11_SVT_RWTEXTURE1D=40,
    D3D11_SVT_RWTEXTURE1DARRAY=41,
    D3D11_SVT_RWTEXTURE2D=42,
    D3D11_SVT_RWTEXTURE2DARRAY=43,
    D3D11_SVT_RWTEXTURE3D=44,
    D3D11_SVT_RWBUFFER=45,
    D3D11_SVT_BYTEADDRESS_BUFFER=46,
    D3D11_SVT_RWBYTEADDRESS_BUFFER=47,
    D3D11_SVT_STRUCTURED_BUFFER=48,
    D3D11_SVT_RWSTRUCTURED_BUFFER=49,
    D3D11_SVT_APPEND_STRUCTURED_BUFFER=50,
    D3D11_SVT_CONSUME_STRUCTURED_BUFFER=51,
    D3D_SVT_FORCE_DWORD=2147483647
};

enum D3D11_USAGE
{
    D3D11_USAGE_DEFAULT=0,
    D3D11_USAGE_IMMUTABLE=1,
    D3D11_USAGE_DYNAMIC=2,
    D3D11_USAGE_STAGING=3
};

enum D2D1_CAP_STYLE
{
    D2D1_CAP_STYLE_FLAT=0,
    D2D1_CAP_STYLE_SQUARE=1,
    D2D1_CAP_STYLE_ROUND=2,
    D2D1_CAP_STYLE_TRIANGLE=3,
    D2D1_CAP_STYLE_FORCE_DWORD=-1
};

enum D3D11_COUNTER_TYPE
{
    D3D11_COUNTER_TYPE_FLOAT32=0,
    D3D11_COUNTER_TYPE_UINT16=1,
    D3D11_COUNTER_TYPE_UINT32=2,
    D3D11_COUNTER_TYPE_UINT64=3
};

enum D2D1_DASH_STYLE
{
    D2D1_DASH_STYLE_SOLID=0,
    D2D1_DASH_STYLE_DASH=1,
    D2D1_DASH_STYLE_DOT=2,
    D2D1_DASH_STYLE_DASH_DOT=3,
    D2D1_DASH_STYLE_DASH_DOT_DOT=4,
    D2D1_DASH_STYLE_CUSTOM=5,
    D2D1_DASH_STYLE_FORCE_DWORD=-1
};

enum D2D1_LINE_JOIN
{
    D2D1_LINE_JOIN_MITER=0,
    D2D1_LINE_JOIN_BEVEL=1,
    D2D1_LINE_JOIN_ROUND=2,
    D2D1_LINE_JOIN_MITER_OR_BEVEL=3,
    D2D1_LINE_JOIN_FORCE_DWORD=-1
};

enum _D3D_SHADER_INPUT_FLAGS
{
    D3D_SIF_USERPACKED=1,
    D3D_SIF_COMPARISON_SAMPLER=2,
    D3D_SIF_TEXTURE_COMPONENT_0=4,
    D3D_SIF_TEXTURE_COMPONENT_1=8,
    D3D_SIF_TEXTURE_COMPONENTS=12,
    D3D10_SIF_USERPACKED=1,
    D3D10_SIF_COMPARISON_SAMPLER=2,
    D3D10_SIF_TEXTURE_COMPONENT_0=4,
    D3D10_SIF_TEXTURE_COMPONENT_1=8,
    D3D10_SIF_TEXTURE_COMPONENTS=12,
    D3D_SIF_FORCE_DWORD=2147483647
};

enum _D3D_SHADER_INPUT_TYPE
{
    D3D_SIT_CBUFFER=0,
    D3D_SIT_TBUFFER=1,
    D3D_SIT_TEXTURE=2,
    D3D_SIT_SAMPLER=3,
    D3D_SIT_UAV_RWTYPED=4,
    D3D_SIT_STRUCTURED=5,
    D3D_SIT_UAV_RWSTRUCTURED=6,
    D3D_SIT_BYTEADDRESS=7,
    D3D_SIT_UAV_RWBYTEADDRESS=8,
    D3D_SIT_UAV_APPEND_STRUCTURED=9,
    D3D_SIT_UAV_CONSUME_STRUCTURED=10,
    D3D_SIT_UAV_RWSTRUCTURED_WITH_COUNTER=11,
    D3D10_SIT_CBUFFER=0,
    D3D10_SIT_TBUFFER=1,
    D3D10_SIT_TEXTURE=2,
    D3D10_SIT_SAMPLER=3,
    D3D11_SIT_UAV_RWTYPED=4,
    D3D11_SIT_STRUCTURED=5,
    D3D11_SIT_UAV_RWSTRUCTURED=6,
    D3D11_SIT_BYTEADDRESS=7,
    D3D11_SIT_UAV_RWBYTEADDRESS=8,
    D3D11_SIT_UAV_APPEND_STRUCTURED=9,
    D3D11_SIT_UAV_CONSUME_STRUCTURED=10,
    D3D11_SIT_UAV_RWSTRUCTURED_WITH_COUNTER=11
};

enum _D3D_SHADER_CBUFFER_FLAGS
{
    D3D_CBF_USERPACKED=1,
    D3D10_CBF_USERPACKED=1,
    D3D_CBF_FORCE_DWORD=2147483647
};

enum _D3D_CBUFFER_TYPE
{
    D3D_CT_CBUFFER=0,
    D3D_CT_TBUFFER=1,
    D3D_CT_INTERFACE_POINTERS=2,
    D3D_CT_RESOURCE_BIND_INFO=3,
    D3D10_CT_CBUFFER=0,
    D3D10_CT_TBUFFER=1,
    D3D11_CT_CBUFFER=0,
    D3D11_CT_TBUFFER=1,
    D3D11_CT_INTERFACE_POINTERS=2,
    D3D11_CT_RESOURCE_BIND_INFO=3
};

enum D3D11_COMPARISON_FUNC
{
    D3D11_COMPARISON_NEVER=1,
    D3D11_COMPARISON_LESS=2,
    D3D11_COMPARISON_EQUAL=3,
    D3D11_COMPARISON_LESS_EQUAL=4,
    D3D11_COMPARISON_GREATER=5,
    D3D11_COMPARISON_NOT_EQUAL=6,
    D3D11_COMPARISON_GREATER_EQUAL=7,
    D3D11_COMPARISON_ALWAYS=8
};

enum D3D_NAME
{
    D3D_NAME_UNDEFINED=0,
    D3D_NAME_POSITION=1,
    D3D_NAME_CLIP_DISTANCE=2,
    D3D_NAME_CULL_DISTANCE=3,
    D3D_NAME_RENDER_TARGET_ARRAY_INDEX=4,
    D3D_NAME_VIEWPORT_ARRAY_INDEX=5,
    D3D_NAME_VERTEX_ID=6,
    D3D_NAME_PRIMITIVE_ID=7,
    D3D_NAME_INSTANCE_ID=8,
    D3D_NAME_IS_FRONT_FACE=9,
    D3D_NAME_SAMPLE_INDEX=10,
    D3D_NAME_FINAL_QUAD_EDGE_TESSFACTOR=11,
    D3D_NAME_FINAL_QUAD_INSIDE_TESSFACTOR=12,
    D3D_NAME_FINAL_TRI_EDGE_TESSFACTOR=13,
    D3D_NAME_FINAL_TRI_INSIDE_TESSFACTOR=14,
    D3D_NAME_FINAL_LINE_DETAIL_TESSFACTOR=15,
    D3D_NAME_FINAL_LINE_DENSITY_TESSFACTOR=16,
    D3D_NAME_TARGET=64,
    D3D_NAME_DEPTH=65,
    D3D_NAME_COVERAGE=66,
    D3D_NAME_DEPTH_GREATER_EQUAL=67,
    D3D_NAME_DEPTH_LESS_EQUAL=68,
    D3D10_NAME_UNDEFINED=0,
    D3D10_NAME_POSITION=1,
    D3D10_NAME_CLIP_DISTANCE=2,
    D3D10_NAME_CULL_DISTANCE=3,
    D3D10_NAME_RENDER_TARGET_ARRAY_INDEX=4,
    D3D10_NAME_VIEWPORT_ARRAY_INDEX=5,
    D3D10_NAME_VERTEX_ID=6,
    D3D10_NAME_PRIMITIVE_ID=7,
    D3D10_NAME_INSTANCE_ID=8,
    D3D10_NAME_IS_FRONT_FACE=9,
    D3D10_NAME_SAMPLE_INDEX=10,
    D3D10_NAME_TARGET=64,
    D3D10_NAME_DEPTH=65,
    D3D10_NAME_COVERAGE=66,
    D3D11_NAME_FINAL_QUAD_EDGE_TESSFACTOR=11,
    D3D11_NAME_FINAL_QUAD_INSIDE_TESSFACTOR=12,
    D3D11_NAME_FINAL_TRI_EDGE_TESSFACTOR=13,
    D3D11_NAME_FINAL_TRI_INSIDE_TESSFACTOR=14,
    D3D11_NAME_FINAL_LINE_DETAIL_TESSFACTOR=15,
    D3D11_NAME_FINAL_LINE_DENSITY_TESSFACTOR=16,
    D3D11_NAME_DEPTH_GREATER_EQUAL=67,
    D3D11_NAME_DEPTH_LESS_EQUAL=68
};

enum D3D11_FEATURE
{
    D3D11_FEATURE_THREADING=0,
    D3D11_FEATURE_DOUBLES=1,
    D3D11_FEATURE_FORMAT_SUPPORT=2,
    D3D11_FEATURE_FORMAT_SUPPORT2=3,
    D3D11_FEATURE_D3D10_X_HARDWARE_OPTIONS=4
};

enum D3D11_DEPTH_WRITE_MASK
{
    D3D11_DEPTH_WRITE_MASK_ZERO=0,
    D3D11_DEPTH_WRITE_MASK_ALL=1
};

enum D3D11_STENCIL_OP
{
    D3D11_STENCIL_OP_KEEP=1,
    D3D11_STENCIL_OP_ZERO=2,
    D3D11_STENCIL_OP_REPLACE=3,
    D3D11_STENCIL_OP_INCR_SAT=4,
    D3D11_STENCIL_OP_DECR_SAT=5,
    D3D11_STENCIL_OP_INVERT=6,
    D3D11_STENCIL_OP_INCR=7,
    D3D11_STENCIL_OP_DECR=8
};

enum _D3DXCLEANTYPE
{
    D3DXCLEAN_BACKFACING=1,
    D3DXCLEAN_BOWTIES=2,
    D3DXCLEAN_SKINNING=1,
    D3DXCLEAN_OPTIMIZATION=1,
    D3DXCLEAN_SIMPLIFICATION=3
};

enum DXGI_FORMAT
{
    DXGI_FORMAT_UNKNOWN=0,
    DXGI_FORMAT_R32G32B32A32_TYPELESS=1,
    DXGI_FORMAT_R32G32B32A32_FLOAT=2,
    DXGI_FORMAT_R32G32B32A32_UINT=3,
    DXGI_FORMAT_R32G32B32A32_SINT=4,
    DXGI_FORMAT_R32G32B32_TYPELESS=5,
    DXGI_FORMAT_R32G32B32_FLOAT=6,
    DXGI_FORMAT_R32G32B32_UINT=7,
    DXGI_FORMAT_R32G32B32_SINT=8,
    DXGI_FORMAT_R16G16B16A16_TYPELESS=9,
    DXGI_FORMAT_R16G16B16A16_FLOAT=10,
    DXGI_FORMAT_R16G16B16A16_UNORM=11,
    DXGI_FORMAT_R16G16B16A16_UINT=12,
    DXGI_FORMAT_R16G16B16A16_SNORM=13,
    DXGI_FORMAT_R16G16B16A16_SINT=14,
    DXGI_FORMAT_R32G32_TYPELESS=15,
    DXGI_FORMAT_R32G32_FLOAT=16,
    DXGI_FORMAT_R32G32_UINT=17,
    DXGI_FORMAT_R32G32_SINT=18,
    DXGI_FORMAT_R32G8X24_TYPELESS=19,
    DXGI_FORMAT_D32_FLOAT_S8X24_UINT=20,
    DXGI_FORMAT_R32_FLOAT_X8X24_TYPELESS=21,
    DXGI_FORMAT_X32_TYPELESS_G8X24_UINT=22,
    DXGI_FORMAT_R10G10B10A2_TYPELESS=23,
    DXGI_FORMAT_R10G10B10A2_UNORM=24,
    DXGI_FORMAT_R10G10B10A2_UINT=25,
    DXGI_FORMAT_R11G11B10_FLOAT=26,
    DXGI_FORMAT_R8G8B8A8_TYPELESS=27,
    DXGI_FORMAT_R8G8B8A8_UNORM=28,
    DXGI_FORMAT_R8G8B8A8_UNORM_SRGB=29,
    DXGI_FORMAT_R8G8B8A8_UINT=30,
    DXGI_FORMAT_R8G8B8A8_SNORM=31,
    DXGI_FORMAT_R8G8B8A8_SINT=32,
    DXGI_FORMAT_R16G16_TYPELESS=33,
    DXGI_FORMAT_R16G16_FLOAT=34,
    DXGI_FORMAT_R16G16_UNORM=35,
    DXGI_FORMAT_R16G16_UINT=36,
    DXGI_FORMAT_R16G16_SNORM=37,
    DXGI_FORMAT_R16G16_SINT=38,
    DXGI_FORMAT_R32_TYPELESS=39,
    DXGI_FORMAT_D32_FLOAT=40,
    DXGI_FORMAT_R32_FLOAT=41,
    DXGI_FORMAT_R32_UINT=42,
    DXGI_FORMAT_R32_SINT=43,
    DXGI_FORMAT_R24G8_TYPELESS=44,
    DXGI_FORMAT_D24_UNORM_S8_UINT=45,
    DXGI_FORMAT_R24_UNORM_X8_TYPELESS=46,
    DXGI_FORMAT_X24_TYPELESS_G8_UINT=47,
    DXGI_FORMAT_R8G8_TYPELESS=48,
    DXGI_FORMAT_R8G8_UNORM=49,
    DXGI_FORMAT_R8G8_UINT=50,
    DXGI_FORMAT_R8G8_SNORM=51,
    DXGI_FORMAT_R8G8_SINT=52,
    DXGI_FORMAT_R16_TYPELESS=53,
    DXGI_FORMAT_R16_FLOAT=54,
    DXGI_FORMAT_D16_UNORM=55,
    DXGI_FORMAT_R16_UNORM=56,
    DXGI_FORMAT_R16_UINT=57,
    DXGI_FORMAT_R16_SNORM=58,
    DXGI_FORMAT_R16_SINT=59,
    DXGI_FORMAT_R8_TYPELESS=60,
    DXGI_FORMAT_R8_UNORM=61,
    DXGI_FORMAT_R8_UINT=62,
    DXGI_FORMAT_R8_SNORM=63,
    DXGI_FORMAT_R8_SINT=64,
    DXGI_FORMAT_A8_UNORM=65,
    DXGI_FORMAT_R1_UNORM=66,
    DXGI_FORMAT_R9G9B9E5_SHAREDEXP=67,
    DXGI_FORMAT_R8G8_B8G8_UNORM=68,
    DXGI_FORMAT_G8R8_G8B8_UNORM=69,
    DXGI_FORMAT_BC1_TYPELESS=70,
    DXGI_FORMAT_BC1_UNORM=71,
    DXGI_FORMAT_BC1_UNORM_SRGB=72,
    DXGI_FORMAT_BC2_TYPELESS=73,
    DXGI_FORMAT_BC2_UNORM=74,
    DXGI_FORMAT_BC2_UNORM_SRGB=75,
    DXGI_FORMAT_BC3_TYPELESS=76,
    DXGI_FORMAT_BC3_UNORM=77,
    DXGI_FORMAT_BC3_UNORM_SRGB=78,
    DXGI_FORMAT_BC4_TYPELESS=79,
    DXGI_FORMAT_BC4_UNORM=80,
    DXGI_FORMAT_BC4_SNORM=81,
    DXGI_FORMAT_BC5_TYPELESS=82,
    DXGI_FORMAT_BC5_UNORM=83,
    DXGI_FORMAT_BC5_SNORM=84,
    DXGI_FORMAT_B5G6R5_UNORM=85,
    DXGI_FORMAT_B5G5R5A1_UNORM=86,
    DXGI_FORMAT_B8G8R8A8_UNORM=87,
    DXGI_FORMAT_B8G8R8X8_UNORM=88,
    DXGI_FORMAT_R10G10B10_XR_BIAS_A2_UNORM=89,
    DXGI_FORMAT_B8G8R8A8_TYPELESS=90,
    DXGI_FORMAT_B8G8R8A8_UNORM_SRGB=91,
    DXGI_FORMAT_B8G8R8X8_TYPELESS=92,
    DXGI_FORMAT_B8G8R8X8_UNORM_SRGB=93,
    DXGI_FORMAT_BC6H_TYPELESS=94,
    DXGI_FORMAT_BC6H_UF16=95,
    DXGI_FORMAT_BC6H_SF16=96,
    DXGI_FORMAT_BC7_TYPELESS=97,
    DXGI_FORMAT_BC7_UNORM=98,
    DXGI_FORMAT_BC7_UNORM_SRGB=99,
    DXGI_FORMAT_FORCE_UINT=-1
};

enum D3D_RESOURCE_RETURN_TYPE
{
    D3D_RETURN_TYPE_UNORM=1,
    D3D_RETURN_TYPE_SNORM=2,
    D3D_RETURN_TYPE_SINT=3,
    D3D_RETURN_TYPE_UINT=4,
    D3D_RETURN_TYPE_FLOAT=5,
    D3D_RETURN_TYPE_MIXED=6,
    D3D_RETURN_TYPE_DOUBLE=7,
    D3D_RETURN_TYPE_CONTINUED=8,
    D3D10_RETURN_TYPE_UNORM=1,
    D3D10_RETURN_TYPE_SNORM=2,
    D3D10_RETURN_TYPE_SINT=3,
    D3D10_RETURN_TYPE_UINT=4,
    D3D10_RETURN_TYPE_FLOAT=5,
    D3D10_RETURN_TYPE_MIXED=6,
    D3D11_RETURN_TYPE_UNORM=1,
    D3D11_RETURN_TYPE_SNORM=2,
    D3D11_RETURN_TYPE_SINT=3,
    D3D11_RETURN_TYPE_UINT=4,
    D3D11_RETURN_TYPE_FLOAT=5,
    D3D11_RETURN_TYPE_MIXED=6,
    D3D11_RETURN_TYPE_DOUBLE=7,
    D3D11_RETURN_TYPE_CONTINUED=8
};

enum D2D1_LAYER_OPTIONS
{
    D2D1_LAYER_OPTIONS_NONE=0,
    D2D1_LAYER_OPTIONS_INITIALIZE_FOR_CLEARTYPE=1,
    D2D1_LAYER_OPTIONS_FORCE_DWORD=-1
};

enum D3D_REGISTER_COMPONENT_TYPE
{
    D3D_REGISTER_COMPONENT_UNKNOWN=0,
    D3D_REGISTER_COMPONENT_UINT32=1,
    D3D_REGISTER_COMPONENT_SINT32=2,
    D3D_REGISTER_COMPONENT_FLOAT32=3,
    D3D10_REGISTER_COMPONENT_UNKNOWN=0,
    D3D10_REGISTER_COMPONENT_UINT32=1,
    D3D10_REGISTER_COMPONENT_SINT32=2,
    D3D10_REGISTER_COMPONENT_FLOAT32=3
};

enum D3D_TESSELLATOR_DOMAIN
{
    D3D_TESSELLATOR_DOMAIN_UNDEFINED=0,
    D3D_TESSELLATOR_DOMAIN_ISOLINE=1,
    D3D_TESSELLATOR_DOMAIN_TRI=2,
    D3D_TESSELLATOR_DOMAIN_QUAD=3,
    D3D11_TESSELLATOR_DOMAIN_UNDEFINED=0,
    D3D11_TESSELLATOR_DOMAIN_ISOLINE=1,
    D3D11_TESSELLATOR_DOMAIN_TRI=2,
    D3D11_TESSELLATOR_DOMAIN_QUAD=3
};

enum D3D_TESSELLATOR_PARTITIONING
{
    D3D_TESSELLATOR_PARTITIONING_UNDEFINED=0,
    D3D_TESSELLATOR_PARTITIONING_INTEGER=1,
    D3D_TESSELLATOR_PARTITIONING_POW2=2,
    D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD=3,
    D3D_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN=4,
    D3D11_TESSELLATOR_PARTITIONING_UNDEFINED=0,
    D3D11_TESSELLATOR_PARTITIONING_INTEGER=1,
    D3D11_TESSELLATOR_PARTITIONING_POW2=2,
    D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_ODD=3,
    D3D11_TESSELLATOR_PARTITIONING_FRACTIONAL_EVEN=4
};

enum D3D_TESSELLATOR_OUTPUT_PRIMITIVE
{
    D3D_TESSELLATOR_OUTPUT_UNDEFINED=0,
    D3D_TESSELLATOR_OUTPUT_POINT=1,
    D3D_TESSELLATOR_OUTPUT_LINE=2,
    D3D_TESSELLATOR_OUTPUT_TRIANGLE_CW=3,
    D3D_TESSELLATOR_OUTPUT_TRIANGLE_CCW=4,
    D3D11_TESSELLATOR_OUTPUT_UNDEFINED=0,
    D3D11_TESSELLATOR_OUTPUT_POINT=1,
    D3D11_TESSELLATOR_OUTPUT_LINE=2,
    D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CW=3,
    D3D11_TESSELLATOR_OUTPUT_TRIANGLE_CCW=4
};

enum D3D11_BLEND
{
    D3D11_BLEND_ZERO=1,
    D3D11_BLEND_ONE=2,
    D3D11_BLEND_SRC_COLOR=3,
    D3D11_BLEND_INV_SRC_COLOR=4,
    D3D11_BLEND_SRC_ALPHA=5,
    D3D11_BLEND_INV_SRC_ALPHA=6,
    D3D11_BLEND_DEST_ALPHA=7,
    D3D11_BLEND_INV_DEST_ALPHA=8,
    D3D11_BLEND_DEST_COLOR=9,
    D3D11_BLEND_INV_DEST_COLOR=10,
    D3D11_BLEND_SRC_ALPHA_SAT=11,
    D3D11_BLEND_BLEND_FACTOR=14,
    D3D11_BLEND_INV_BLEND_FACTOR=15,
    D3D11_BLEND_SRC1_COLOR=16,
    D3D11_BLEND_INV_SRC1_COLOR=17,
    D3D11_BLEND_SRC1_ALPHA=18,
    D3D11_BLEND_INV_SRC1_ALPHA=19
};

enum D3D10_FEATURE_LEVEL1
{
    D3D10_FEATURE_LEVEL_10_0=40960,
    D3D10_FEATURE_LEVEL_10_1=41216,
    D3D10_FEATURE_LEVEL_9_1=37120,
    D3D10_FEATURE_LEVEL_9_2=37376,
    D3D10_FEATURE_LEVEL_9_3=37632
};

enum D3D11_BLEND_OP
{
    D3D11_BLEND_OP_ADD=1,
    D3D11_BLEND_OP_SUBTRACT=2,
    D3D11_BLEND_OP_REV_SUBTRACT=3,
    D3D11_BLEND_OP_MIN=4,
    D3D11_BLEND_OP_MAX=5
};

enum D3D11_COLOR_WRITE_ENABLE
{
    D3D11_COLOR_WRITE_ENABLE_RED=1,
    D3D11_COLOR_WRITE_ENABLE_GREEN=2,
    D3D11_COLOR_WRITE_ENABLE_BLUE=4,
    D3D11_COLOR_WRITE_ENABLE_ALPHA=8,
    D3D11_COLOR_WRITE_ENABLE_ALL=15
};

enum DWRITE_MEASURING_MODE
{
    DWRITE_MEASURING_MODE_NATURAL=0,
    DWRITE_MEASURING_MODE_GDI_CLASSIC=1,
    DWRITE_MEASURING_MODE_GDI_NATURAL=2
};

enum D2D1_RENDER_TARGET_TYPE
{
    D2D1_RENDER_TARGET_TYPE_DEFAULT=0,
    D2D1_RENDER_TARGET_TYPE_SOFTWARE=1,
    D2D1_RENDER_TARGET_TYPE_HARDWARE=2,
    D2D1_RENDER_TARGET_TYPE_FORCE_DWORD=-1
};

enum D2D1_FEATURE_LEVEL
{
    D2D1_FEATURE_LEVEL_DEFAULT=0,
    D2D1_FEATURE_LEVEL_9=37120,
    D2D1_FEATURE_LEVEL_10=40960,
    D2D1_FEATURE_LEVEL_FORCE_DWORD=-1
};

enum D2D1_RENDER_TARGET_USAGE
{
    D2D1_RENDER_TARGET_USAGE_NONE=0,
    D2D1_RENDER_TARGET_USAGE_FORCE_BITMAP_REMOTING=1,
    D2D1_RENDER_TARGET_USAGE_GDI_COMPATIBLE=2,
    D2D1_RENDER_TARGET_USAGE_FORCE_DWORD=-1
};

enum D3D10_USAGE
{
    D3D10_USAGE_DEFAULT=0,
    D3D10_USAGE_IMMUTABLE=1,
    D3D10_USAGE_DYNAMIC=2,
    D3D10_USAGE_STAGING=3
};

enum tagExtentMode
{
    DVEXTENT_CONTENT=0,
    DVEXTENT_INTEGRAL=1
};

enum D3D10_QUERY
{
    D3D10_QUERY_EVENT=0,
    D3D10_QUERY_OCCLUSION=1,
    D3D10_QUERY_TIMESTAMP=2,
    D3D10_QUERY_TIMESTAMP_DISJOINT=3,
    D3D10_QUERY_PIPELINE_STATISTICS=4,
    D3D10_QUERY_OCCLUSION_PREDICATE=5,
    D3D10_QUERY_SO_STATISTICS=6,
    D3D10_QUERY_SO_OVERFLOW_PREDICATE=7
};

enum D2D1_PRESENT_OPTIONS
{
    D2D1_PRESENT_OPTIONS_NONE=0,
    D2D1_PRESENT_OPTIONS_RETAIN_CONTENTS=1,
    D2D1_PRESENT_OPTIONS_IMMEDIATELY=2,
    D2D1_PRESENT_OPTIONS_FORCE_DWORD=-1
};

enum D3D10_COUNTER
{
    D3D10_COUNTER_GPU_IDLE=0,
    D3D10_COUNTER_VERTEX_PROCESSING=1,
    D3D10_COUNTER_GEOMETRY_PROCESSING=2,
    D3D10_COUNTER_PIXEL_PROCESSING=3,
    D3D10_COUNTER_OTHER_GPU_PROCESSING=4,
    D3D10_COUNTER_HOST_ADAPTER_BANDWIDTH_UTILIZATION=5,
    D3D10_COUNTER_LOCAL_VIDMEM_BANDWIDTH_UTILIZATION=6,
    D3D10_COUNTER_VERTEX_THROUGHPUT_UTILIZATION=7,
    D3D10_COUNTER_TRIANGLE_SETUP_THROUGHPUT_UTILIZATION=8,
    D3D10_COUNTER_FILLRATE_THROUGHPUT_UTILIZATION=9,
    D3D10_COUNTER_VS_MEMORY_LIMITED=10,
    D3D10_COUNTER_VS_COMPUTATION_LIMITED=11,
    D3D10_COUNTER_GS_MEMORY_LIMITED=12,
    D3D10_COUNTER_GS_COMPUTATION_LIMITED=13,
    D3D10_COUNTER_PS_MEMORY_LIMITED=14,
    D3D10_COUNTER_PS_COMPUTATION_LIMITED=15,
    D3D10_COUNTER_POST_TRANSFORM_CACHE_HIT_RATE=16,
    D3D10_COUNTER_TEXTURE_CACHE_HIT_RATE=17,
    D3D10_COUNTER_DEVICE_DEPENDENT_0=1073741824
};

enum D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS
{
    D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_NONE=0,
    D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_GDI_COMPATIBLE=1,
    D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS_FORCE_DWORD=-1
};

enum D3D10_COUNTER_TYPE
{
    D3D10_COUNTER_TYPE_FLOAT32=0,
    D3D10_COUNTER_TYPE_UINT16=1,
    D3D10_COUNTER_TYPE_UINT32=2,
    D3D10_COUNTER_TYPE_UINT64=3
};

enum _D3DXERR
{
    D3DXERR_CANNOTMODIFYINDEXBUFFER=-2005529772,
    D3DXERR_INVALIDMESH=-2005529771,
    D3DXERR_CANNOTATTRSORT=-2005529770,
    D3DXERR_SKINNINGNOTSUPPORTED=-2005529769,
    D3DXERR_TOOMANYINFLUENCES=-2005529768,
    D3DXERR_INVALIDDATA=-2005529767,
    D3DXERR_LOADEDMESHASNODATA=-2005529766,
    D3DXERR_DUPLICATENAMEDFRAGMENT=-2005529765,
    D3DXERR_CANNOTREMOVELASTITEM=-2005529764
};

enum tag_WBEMSTATUS
{
    WBEM_NO_ERROR=0,
    WBEM_S_NO_ERROR=0,
    WBEM_S_SAME=0,
    WBEM_S_FALSE=1,
    WBEM_S_ALREADY_EXISTS=262145,
    WBEM_S_RESET_TO_DEFAULT=262146,
    WBEM_S_DIFFERENT=262147,
    WBEM_S_TIMEDOUT=262148,
    WBEM_S_NO_MORE_DATA=262149,
    WBEM_S_OPERATION_CANCELLED=262150,
    WBEM_S_PENDING=262151,
    WBEM_S_DUPLICATE_OBJECTS=262152,
    WBEM_S_ACCESS_DENIED=262153,
    WBEM_S_PARTIAL_RESULTS=262160,
    WBEM_S_SOURCE_NOT_AVAILABLE=262167,
    WBEM_E_FAILED=-2147217407,
    WBEM_E_NOT_FOUND=-2147217406,
    WBEM_E_ACCESS_DENIED=-2147217405,
    WBEM_E_PROVIDER_FAILURE=-2147217404,
    WBEM_E_TYPE_MISMATCH=-2147217403,
    WBEM_E_OUT_OF_MEMORY=-2147217402,
    WBEM_E_INVALID_CONTEXT=-2147217401,
    WBEM_E_INVALID_PARAMETER=-2147217400,
    WBEM_E_NOT_AVAILABLE=-2147217399,
    WBEM_E_CRITICAL_ERROR=-2147217398,
    WBEM_E_INVALID_STREAM=-2147217397,
    WBEM_E_NOT_SUPPORTED=-2147217396,
    WBEM_E_INVALID_SUPERCLASS=-2147217395,
    WBEM_E_INVALID_NAMESPACE=-2147217394,
    WBEM_E_INVALID_OBJECT=-2147217393,
    WBEM_E_INVALID_CLASS=-2147217392,
    WBEM_E_PROVIDER_NOT_FOUND=-2147217391,
    WBEM_E_INVALID_PROVIDER_REGISTRATION=-2147217390,
    WBEM_E_PROVIDER_LOAD_FAILURE=-2147217389,
    WBEM_E_INITIALIZATION_FAILURE=-2147217388,
    WBEM_E_TRANSPORT_FAILURE=-2147217387,
    WBEM_E_INVALID_OPERATION=-2147217386,
    WBEM_E_INVALID_QUERY=-2147217385,
    WBEM_E_INVALID_QUERY_TYPE=-2147217384,
    WBEM_E_ALREADY_EXISTS=-2147217383,
    WBEM_E_OVERRIDE_NOT_ALLOWED=-2147217382,
    WBEM_E_PROPAGATED_QUALIFIER=-2147217381,
    WBEM_E_PROPAGATED_PROPERTY=-2147217380,
    WBEM_E_UNEXPECTED=-2147217379,
    WBEM_E_ILLEGAL_OPERATION=-2147217378,
    WBEM_E_CANNOT_BE_KEY=-2147217377,
    WBEM_E_INCOMPLETE_CLASS=-2147217376,
    WBEM_E_INVALID_SYNTAX=-2147217375,
    WBEM_E_NONDECORATED_OBJECT=-2147217374,
    WBEM_E_READ_ONLY=-2147217373,
    WBEM_E_PROVIDER_NOT_CAPABLE=-2147217372,
    WBEM_E_CLASS_HAS_CHILDREN=-2147217371,
    WBEM_E_CLASS_HAS_INSTANCES=-2147217370,
    WBEM_E_QUERY_NOT_IMPLEMENTED=-2147217369,
    WBEM_E_ILLEGAL_NULL=-2147217368,
    WBEM_E_INVALID_QUALIFIER_TYPE=-2147217367,
    WBEM_E_INVALID_PROPERTY_TYPE=-2147217366,
    WBEM_E_VALUE_OUT_OF_RANGE=-2147217365,
    WBEM_E_CANNOT_BE_SINGLETON=-2147217364,
    WBEM_E_INVALID_CIM_TYPE=-2147217363,
    WBEM_E_INVALID_METHOD=-2147217362,
    WBEM_E_INVALID_METHOD_PARAMETERS=-2147217361,
    WBEM_E_SYSTEM_PROPERTY=-2147217360,
    WBEM_E_INVALID_PROPERTY=-2147217359,
    WBEM_E_CALL_CANCELLED=-2147217358,
    WBEM_E_SHUTTING_DOWN=-2147217357,
    WBEM_E_PROPAGATED_METHOD=-2147217356,
    WBEM_E_UNSUPPORTED_PARAMETER=-2147217355,
    WBEM_E_MISSING_PARAMETER_ID=-2147217354,
    WBEM_E_INVALID_PARAMETER_ID=-2147217353,
    WBEM_E_NONCONSECUTIVE_PARAMETER_IDS=-2147217352,
    WBEM_E_PARAMETER_ID_ON_RETVAL=-2147217351,
    WBEM_E_INVALID_OBJECT_PATH=-2147217350,
    WBEM_E_OUT_OF_DISK_SPACE=-2147217349,
    WBEM_E_BUFFER_TOO_SMALL=-2147217348,
    WBEM_E_UNSUPPORTED_PUT_EXTENSION=-2147217347,
    WBEM_E_UNKNOWN_OBJECT_TYPE=-2147217346,
    WBEM_E_UNKNOWN_PACKET_TYPE=-2147217345,
    WBEM_E_MARSHAL_VERSION_MISMATCH=-2147217344,
    WBEM_E_MARSHAL_INVALID_SIGNATURE=-2147217343,
    WBEM_E_INVALID_QUALIFIER=-2147217342,
    WBEM_E_INVALID_DUPLICATE_PARAMETER=-2147217341,
    WBEM_E_TOO_MUCH_DATA=-2147217340,
    WBEM_E_SERVER_TOO_BUSY=-2147217339,
    WBEM_E_INVALID_FLAVOR=-2147217338,
    WBEM_E_CIRCULAR_REFERENCE=-2147217337,
    WBEM_E_UNSUPPORTED_CLASS_UPDATE=-2147217336,
    WBEM_E_CANNOT_CHANGE_KEY_INHERITANCE=-2147217335,
    WBEM_E_CANNOT_CHANGE_INDEX_INHERITANCE=-2147217328,
    WBEM_E_TOO_MANY_PROPERTIES=-2147217327,
    WBEM_E_UPDATE_TYPE_MISMATCH=-2147217326,
    WBEM_E_UPDATE_OVERRIDE_NOT_ALLOWED=-2147217325,
    WBEM_E_UPDATE_PROPAGATED_METHOD=-2147217324,
    WBEM_E_METHOD_NOT_IMPLEMENTED=-2147217323,
    WBEM_E_METHOD_DISABLED=-2147217322,
    WBEM_E_REFRESHER_BUSY=-2147217321,
    WBEM_E_UNPARSABLE_QUERY=-2147217320,
    WBEM_E_NOT_EVENT_CLASS=-2147217319,
    WBEM_E_MISSING_GROUP_WITHIN=-2147217318,
    WBEM_E_MISSING_AGGREGATION_LIST=-2147217317,
    WBEM_E_PROPERTY_NOT_AN_OBJECT=-2147217316,
    WBEM_E_AGGREGATING_BY_OBJECT=-2147217315,
    WBEM_E_UNINTERPRETABLE_PROVIDER_QUERY=-2147217313,
    WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING=-2147217312,
    WBEM_E_QUEUE_OVERFLOW=-2147217311,
    WBEM_E_PRIVILEGE_NOT_HELD=-2147217310,
    WBEM_E_INVALID_OPERATOR=-2147217309,
    WBEM_E_LOCAL_CREDENTIALS=-2147217308,
    WBEM_E_CANNOT_BE_ABSTRACT=-2147217307,
    WBEM_E_AMENDED_OBJECT=-2147217306,
    WBEM_E_CLIENT_TOO_SLOW=-2147217305,
    WBEM_E_NULL_SECURITY_DESCRIPTOR=-2147217304,
    WBEM_E_TIMED_OUT=-2147217303,
    WBEM_E_INVALID_ASSOCIATION=-2147217302,
    WBEM_E_AMBIGUOUS_OPERATION=-2147217301,
    WBEM_E_QUOTA_VIOLATION=-2147217300,
    WBEM_E_RESERVED_001=-2147217299,
    WBEM_E_RESERVED_002=-2147217298,
    WBEM_E_UNSUPPORTED_LOCALE=-2147217297,
    WBEM_E_HANDLE_OUT_OF_DATE=-2147217296,
    WBEM_E_CONNECTION_FAILED=-2147217295,
    WBEM_E_INVALID_HANDLE_REQUEST=-2147217294,
    WBEM_E_PROPERTY_NAME_TOO_WIDE=-2147217293,
    WBEM_E_CLASS_NAME_TOO_WIDE=-2147217292,
    WBEM_E_METHOD_NAME_TOO_WIDE=-2147217291,
    WBEM_E_QUALIFIER_NAME_TOO_WIDE=-2147217290,
    WBEM_E_RERUN_COMMAND=-2147217289,
    WBEM_E_DATABASE_VER_MISMATCH=-2147217288,
    WBEM_E_VETO_DELETE=-2147217287,
    WBEM_E_VETO_PUT=-2147217286,
    WBEM_E_INVALID_LOCALE=-2147217280,
    WBEM_E_PROVIDER_SUSPENDED=-2147217279,
    WBEM_E_SYNCHRONIZATION_REQUIRED=-2147217278,
    WBEM_E_NO_SCHEMA=-2147217277,
    WBEM_E_PROVIDER_ALREADY_REGISTERED=-2147217276,
    WBEM_E_PROVIDER_NOT_REGISTERED=-2147217275,
    WBEM_E_FATAL_TRANSPORT_ERROR=-2147217274,
    WBEM_E_ENCRYPTED_CONNECTION_REQUIRED=-2147217273,
    WBEM_E_PROVIDER_TIMED_OUT=-2147217272,
    WBEM_E_NO_KEY=-2147217271,
    WBEM_E_PROVIDER_DISABLED=-2147217270,
    WBEMESS_E_REGISTRATION_TOO_BROAD=-2147213311,
    WBEMESS_E_REGISTRATION_TOO_PRECISE=-2147213310,
    WBEMESS_E_AUTHZ_NOT_PRIVILEGED=-2147213309,
    WBEMMOF_E_EXPECTED_QUALIFIER_NAME=-2147205119,
    WBEMMOF_E_EXPECTED_SEMI=-2147205118,
    WBEMMOF_E_EXPECTED_OPEN_BRACE=-2147205117,
    WBEMMOF_E_EXPECTED_CLOSE_BRACE=-2147205116,
    WBEMMOF_E_EXPECTED_CLOSE_BRACKET=-2147205115,
    WBEMMOF_E_EXPECTED_CLOSE_PAREN=-2147205114,
    WBEMMOF_E_ILLEGAL_CONSTANT_VALUE=-2147205113,
    WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER=-2147205112,
    WBEMMOF_E_EXPECTED_OPEN_PAREN=-2147205111,
    WBEMMOF_E_UNRECOGNIZED_TOKEN=-2147205110,
    WBEMMOF_E_UNRECOGNIZED_TYPE=-2147205109,
    WBEMMOF_E_EXPECTED_PROPERTY_NAME=-2147205108,
    WBEMMOF_E_TYPEDEF_NOT_SUPPORTED=-2147205107,
    WBEMMOF_E_UNEXPECTED_ALIAS=-2147205106,
    WBEMMOF_E_UNEXPECTED_ARRAY_INIT=-2147205105,
    WBEMMOF_E_INVALID_AMENDMENT_SYNTAX=-2147205104,
    WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT=-2147205103,
    WBEMMOF_E_INVALID_PRAGMA=-2147205102,
    WBEMMOF_E_INVALID_NAMESPACE_SYNTAX=-2147205101,
    WBEMMOF_E_EXPECTED_CLASS_NAME=-2147205100,
    WBEMMOF_E_TYPE_MISMATCH=-2147205099,
    WBEMMOF_E_EXPECTED_ALIAS_NAME=-2147205098,
    WBEMMOF_E_INVALID_CLASS_DECLARATION=-2147205097,
    WBEMMOF_E_INVALID_INSTANCE_DECLARATION=-2147205096,
    WBEMMOF_E_EXPECTED_DOLLAR=-2147205095,
    WBEMMOF_E_CIMTYPE_QUALIFIER=-2147205094,
    WBEMMOF_E_DUPLICATE_PROPERTY=-2147205093,
    WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION=-2147205092,
    WBEMMOF_E_OUT_OF_RANGE=-2147205091,
    WBEMMOF_E_INVALID_FILE=-2147205090,
    WBEMMOF_E_ALIASES_IN_EMBEDDED=-2147205089,
    WBEMMOF_E_NULL_ARRAY_ELEM=-2147205088,
    WBEMMOF_E_DUPLICATE_QUALIFIER=-2147205087,
    WBEMMOF_E_EXPECTED_FLAVOR_TYPE=-2147205086,
    WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES=-2147205085,
    WBEMMOF_E_MULTIPLE_ALIASES=-2147205084,
    WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2=-2147205083,
    WBEMMOF_E_NO_ARRAYS_RETURNED=-2147205082,
    WBEMMOF_E_MUST_BE_IN_OR_OUT=-2147205081,
    WBEMMOF_E_INVALID_FLAGS_SYNTAX=-2147205080,
    WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE=-2147205079,
    WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE=-2147205078,
    WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE=-2147205077,
    WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX=-2147205076,
    WBEMMOF_E_INVALID_QUALIFIER_SYNTAX=-2147205075,
    WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE=-2147205074,
    WBEMMOF_E_ERROR_CREATING_TEMP_FILE=-2147205073,
    WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE=-2147205072,
    WBEMMOF_E_INVALID_DELETECLASS_SYNTAX=-2147205071
};

enum D3D_DRIVER_TYPE
{
    D3D_DRIVER_TYPE_UNKNOWN=0,
    D3D_DRIVER_TYPE_HARDWARE=1,
    D3D_DRIVER_TYPE_REFERENCE=2,
    D3D_DRIVER_TYPE_NULL=3,
    D3D_DRIVER_TYPE_SOFTWARE=4,
    D3D_DRIVER_TYPE_WARP=5
};

enum D3D_PRIMITIVE_TOPOLOGY
{
    D3D_PRIMITIVE_TOPOLOGY_UNDEFINED=0,
    D3D_PRIMITIVE_TOPOLOGY_POINTLIST=1,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST=2,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP=3,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST=4,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP=5,
    D3D_PRIMITIVE_TOPOLOGY_LINELIST_ADJ=10,
    D3D_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ=11,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ=12,
    D3D_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ=13,
    D3D_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST=33,
    D3D_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST=34,
    D3D_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST=35,
    D3D_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST=36,
    D3D_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST=37,
    D3D_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST=38,
    D3D_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST=39,
    D3D_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST=40,
    D3D_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST=41,
    D3D_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST=42,
    D3D_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST=43,
    D3D_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST=44,
    D3D_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST=45,
    D3D_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST=46,
    D3D_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST=47,
    D3D_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST=48,
    D3D_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST=49,
    D3D_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST=50,
    D3D_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST=51,
    D3D_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST=52,
    D3D_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST=53,
    D3D_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST=54,
    D3D_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST=55,
    D3D_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST=56,
    D3D_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST=57,
    D3D_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST=58,
    D3D_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST=59,
    D3D_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST=60,
    D3D_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST=61,
    D3D_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST=62,
    D3D_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST=63,
    D3D_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST=64,
    D3D10_PRIMITIVE_TOPOLOGY_UNDEFINED=0,
    D3D10_PRIMITIVE_TOPOLOGY_POINTLIST=1,
    D3D10_PRIMITIVE_TOPOLOGY_LINELIST=2,
    D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP=3,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST=4,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP=5,
    D3D10_PRIMITIVE_TOPOLOGY_LINELIST_ADJ=10,
    D3D10_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ=11,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ=12,
    D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ=13,
    D3D11_PRIMITIVE_TOPOLOGY_UNDEFINED=0,
    D3D11_PRIMITIVE_TOPOLOGY_POINTLIST=1,
    D3D11_PRIMITIVE_TOPOLOGY_LINELIST=2,
    D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP=3,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST=4,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP=5,
    D3D11_PRIMITIVE_TOPOLOGY_LINELIST_ADJ=10,
    D3D11_PRIMITIVE_TOPOLOGY_LINESTRIP_ADJ=11,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST_ADJ=12,
    D3D11_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP_ADJ=13,
    D3D11_PRIMITIVE_TOPOLOGY_1_CONTROL_POINT_PATCHLIST=33,
    D3D11_PRIMITIVE_TOPOLOGY_2_CONTROL_POINT_PATCHLIST=34,
    D3D11_PRIMITIVE_TOPOLOGY_3_CONTROL_POINT_PATCHLIST=35,
    D3D11_PRIMITIVE_TOPOLOGY_4_CONTROL_POINT_PATCHLIST=36,
    D3D11_PRIMITIVE_TOPOLOGY_5_CONTROL_POINT_PATCHLIST=37,
    D3D11_PRIMITIVE_TOPOLOGY_6_CONTROL_POINT_PATCHLIST=38,
    D3D11_PRIMITIVE_TOPOLOGY_7_CONTROL_POINT_PATCHLIST=39,
    D3D11_PRIMITIVE_TOPOLOGY_8_CONTROL_POINT_PATCHLIST=40,
    D3D11_PRIMITIVE_TOPOLOGY_9_CONTROL_POINT_PATCHLIST=41,
    D3D11_PRIMITIVE_TOPOLOGY_10_CONTROL_POINT_PATCHLIST=42,
    D3D11_PRIMITIVE_TOPOLOGY_11_CONTROL_POINT_PATCHLIST=43,
    D3D11_PRIMITIVE_TOPOLOGY_12_CONTROL_POINT_PATCHLIST=44,
    D3D11_PRIMITIVE_TOPOLOGY_13_CONTROL_POINT_PATCHLIST=45,
    D3D11_PRIMITIVE_TOPOLOGY_14_CONTROL_POINT_PATCHLIST=46,
    D3D11_PRIMITIVE_TOPOLOGY_15_CONTROL_POINT_PATCHLIST=47,
    D3D11_PRIMITIVE_TOPOLOGY_16_CONTROL_POINT_PATCHLIST=48,
    D3D11_PRIMITIVE_TOPOLOGY_17_CONTROL_POINT_PATCHLIST=49,
    D3D11_PRIMITIVE_TOPOLOGY_18_CONTROL_POINT_PATCHLIST=50,
    D3D11_PRIMITIVE_TOPOLOGY_19_CONTROL_POINT_PATCHLIST=51,
    D3D11_PRIMITIVE_TOPOLOGY_20_CONTROL_POINT_PATCHLIST=52,
    D3D11_PRIMITIVE_TOPOLOGY_21_CONTROL_POINT_PATCHLIST=53,
    D3D11_PRIMITIVE_TOPOLOGY_22_CONTROL_POINT_PATCHLIST=54,
    D3D11_PRIMITIVE_TOPOLOGY_23_CONTROL_POINT_PATCHLIST=55,
    D3D11_PRIMITIVE_TOPOLOGY_24_CONTROL_POINT_PATCHLIST=56,
    D3D11_PRIMITIVE_TOPOLOGY_25_CONTROL_POINT_PATCHLIST=57,
    D3D11_PRIMITIVE_TOPOLOGY_26_CONTROL_POINT_PATCHLIST=58,
    D3D11_PRIMITIVE_TOPOLOGY_27_CONTROL_POINT_PATCHLIST=59,
    D3D11_PRIMITIVE_TOPOLOGY_28_CONTROL_POINT_PATCHLIST=60,
    D3D11_PRIMITIVE_TOPOLOGY_29_CONTROL_POINT_PATCHLIST=61,
    D3D11_PRIMITIVE_TOPOLOGY_30_CONTROL_POINT_PATCHLIST=62,
    D3D11_PRIMITIVE_TOPOLOGY_31_CONTROL_POINT_PATCHLIST=63,
    D3D11_PRIMITIVE_TOPOLOGY_32_CONTROL_POINT_PATCHLIST=64
};

enum D3D11_FILTER
{
    D3D11_FILTER_MIN_MAG_MIP_POINT=0,
    D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR=1,
    D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT=4,
    D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR=5,
    D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT=16,
    D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR=17,
    D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT=20,
    D3D11_FILTER_MIN_MAG_MIP_LINEAR=21,
    D3D11_FILTER_ANISOTROPIC=85,
    D3D11_FILTER_COMPARISON_MIN_MAG_MIP_POINT=128,
    D3D11_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR=129,
    D3D11_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT=132,
    D3D11_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR=133,
    D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT=144,
    D3D11_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR=145,
    D3D11_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT=148,
    D3D11_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR=149,
    D3D11_FILTER_COMPARISON_ANISOTROPIC=213
};

enum D3D_PRIMITIVE
{
    D3D_PRIMITIVE_UNDEFINED=0,
    D3D_PRIMITIVE_POINT=1,
    D3D_PRIMITIVE_LINE=2,
    D3D_PRIMITIVE_TRIANGLE=3,
    D3D_PRIMITIVE_LINE_ADJ=6,
    D3D_PRIMITIVE_TRIANGLE_ADJ=7,
    D3D_PRIMITIVE_1_CONTROL_POINT_PATCH=8,
    D3D_PRIMITIVE_2_CONTROL_POINT_PATCH=9,
    D3D_PRIMITIVE_3_CONTROL_POINT_PATCH=10,
    D3D_PRIMITIVE_4_CONTROL_POINT_PATCH=11,
    D3D_PRIMITIVE_5_CONTROL_POINT_PATCH=12,
    D3D_PRIMITIVE_6_CONTROL_POINT_PATCH=13,
    D3D_PRIMITIVE_7_CONTROL_POINT_PATCH=14,
    D3D_PRIMITIVE_8_CONTROL_POINT_PATCH=15,
    D3D_PRIMITIVE_9_CONTROL_POINT_PATCH=16,
    D3D_PRIMITIVE_10_CONTROL_POINT_PATCH=17,
    D3D_PRIMITIVE_11_CONTROL_POINT_PATCH=18,
    D3D_PRIMITIVE_12_CONTROL_POINT_PATCH=19,
    D3D_PRIMITIVE_13_CONTROL_POINT_PATCH=20,
    D3D_PRIMITIVE_14_CONTROL_POINT_PATCH=21,
    D3D_PRIMITIVE_15_CONTROL_POINT_PATCH=22,
    D3D_PRIMITIVE_16_CONTROL_POINT_PATCH=23,
    D3D_PRIMITIVE_17_CONTROL_POINT_PATCH=24,
    D3D_PRIMITIVE_18_CONTROL_POINT_PATCH=25,
    D3D_PRIMITIVE_19_CONTROL_POINT_PATCH=26,
    D3D_PRIMITIVE_20_CONTROL_POINT_PATCH=28,
    D3D_PRIMITIVE_21_CONTROL_POINT_PATCH=29,
    D3D_PRIMITIVE_22_CONTROL_POINT_PATCH=30,
    D3D_PRIMITIVE_23_CONTROL_POINT_PATCH=31,
    D3D_PRIMITIVE_24_CONTROL_POINT_PATCH=32,
    D3D_PRIMITIVE_25_CONTROL_POINT_PATCH=33,
    D3D_PRIMITIVE_26_CONTROL_POINT_PATCH=34,
    D3D_PRIMITIVE_27_CONTROL_POINT_PATCH=35,
    D3D_PRIMITIVE_28_CONTROL_POINT_PATCH=36,
    D3D_PRIMITIVE_29_CONTROL_POINT_PATCH=37,
    D3D_PRIMITIVE_30_CONTROL_POINT_PATCH=38,
    D3D_PRIMITIVE_31_CONTROL_POINT_PATCH=39,
    D3D_PRIMITIVE_32_CONTROL_POINT_PATCH=40,
    D3D10_PRIMITIVE_UNDEFINED=0,
    D3D10_PRIMITIVE_POINT=1,
    D3D10_PRIMITIVE_LINE=2,
    D3D10_PRIMITIVE_TRIANGLE=3,
    D3D10_PRIMITIVE_LINE_ADJ=6,
    D3D10_PRIMITIVE_TRIANGLE_ADJ=7,
    D3D11_PRIMITIVE_UNDEFINED=0,
    D3D11_PRIMITIVE_POINT=1,
    D3D11_PRIMITIVE_LINE=2,
    D3D11_PRIMITIVE_TRIANGLE=3,
    D3D11_PRIMITIVE_LINE_ADJ=6,
    D3D11_PRIMITIVE_TRIANGLE_ADJ=7,
    D3D11_PRIMITIVE_1_CONTROL_POINT_PATCH=8,
    D3D11_PRIMITIVE_2_CONTROL_POINT_PATCH=9,
    D3D11_PRIMITIVE_3_CONTROL_POINT_PATCH=10,
    D3D11_PRIMITIVE_4_CONTROL_POINT_PATCH=11,
    D3D11_PRIMITIVE_5_CONTROL_POINT_PATCH=12,
    D3D11_PRIMITIVE_6_CONTROL_POINT_PATCH=13,
    D3D11_PRIMITIVE_7_CONTROL_POINT_PATCH=14,
    D3D11_PRIMITIVE_8_CONTROL_POINT_PATCH=15,
    D3D11_PRIMITIVE_9_CONTROL_POINT_PATCH=16,
    D3D11_PRIMITIVE_10_CONTROL_POINT_PATCH=17,
    D3D11_PRIMITIVE_11_CONTROL_POINT_PATCH=18,
    D3D11_PRIMITIVE_12_CONTROL_POINT_PATCH=19,
    D3D11_PRIMITIVE_13_CONTROL_POINT_PATCH=20,
    D3D11_PRIMITIVE_14_CONTROL_POINT_PATCH=21,
    D3D11_PRIMITIVE_15_CONTROL_POINT_PATCH=22,
    D3D11_PRIMITIVE_16_CONTROL_POINT_PATCH=23,
    D3D11_PRIMITIVE_17_CONTROL_POINT_PATCH=24,
    D3D11_PRIMITIVE_18_CONTROL_POINT_PATCH=25,
    D3D11_PRIMITIVE_19_CONTROL_POINT_PATCH=26,
    D3D11_PRIMITIVE_20_CONTROL_POINT_PATCH=28,
    D3D11_PRIMITIVE_21_CONTROL_POINT_PATCH=29,
    D3D11_PRIMITIVE_22_CONTROL_POINT_PATCH=30,
    D3D11_PRIMITIVE_23_CONTROL_POINT_PATCH=31,
    D3D11_PRIMITIVE_24_CONTROL_POINT_PATCH=32,
    D3D11_PRIMITIVE_25_CONTROL_POINT_PATCH=33,
    D3D11_PRIMITIVE_26_CONTROL_POINT_PATCH=34,
    D3D11_PRIMITIVE_27_CONTROL_POINT_PATCH=35,
    D3D11_PRIMITIVE_28_CONTROL_POINT_PATCH=36,
    D3D11_PRIMITIVE_29_CONTROL_POINT_PATCH=37,
    D3D11_PRIMITIVE_30_CONTROL_POINT_PATCH=38,
    D3D11_PRIMITIVE_31_CONTROL_POINT_PATCH=39,
    D3D11_PRIMITIVE_32_CONTROL_POINT_PATCH=40
};

enum D3D11_TEXTURE_ADDRESS_MODE
{
    D3D11_TEXTURE_ADDRESS_WRAP=1,
    D3D11_TEXTURE_ADDRESS_MIRROR=2,
    D3D11_TEXTURE_ADDRESS_CLAMP=3,
    D3D11_TEXTURE_ADDRESS_BORDER=4,
    D3D11_TEXTURE_ADDRESS_MIRROR_ONCE=5
};

struct D3D10_TEXCUBE_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D3D10_TEX1D_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D3D10_TEX1D_ARRAY_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

enum DWRITE_FONT_FEATURE_TAG
{
    DWRITE_FONT_FEATURE_TAG_ALTERNATIVE_FRACTIONS=1668441697,
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS_FROM_CAPITALS=1668297315,
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS_FROM_CAPITALS=1668493923,
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_ALTERNATES=1953259875,
    DWRITE_FONT_FEATURE_TAG_CASE_SENSITIVE_FORMS=1702060387,
    DWRITE_FONT_FEATURE_TAG_GLYPH_COMPOSITION_DECOMPOSITION=1886217059,
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_LIGATURES=1734962275,
    DWRITE_FONT_FEATURE_TAG_CAPITAL_SPACING=1886613603,
    DWRITE_FONT_FEATURE_TAG_CONTEXTUAL_SWASH=1752658787,
    DWRITE_FONT_FEATURE_TAG_CURSIVE_POSITIONING=1936880995,
    DWRITE_FONT_FEATURE_TAG_DEFAULT=1953261156,
    DWRITE_FONT_FEATURE_TAG_DISCRETIONARY_LIGATURES=1734962276,
    DWRITE_FONT_FEATURE_TAG_EXPERT_FORMS=1953527909,
    DWRITE_FONT_FEATURE_TAG_FRACTIONS=1667330662,
    DWRITE_FONT_FEATURE_TAG_FULL_WIDTH=1684633446,
    DWRITE_FONT_FEATURE_TAG_HALF_FORMS=1718378856,
    DWRITE_FONT_FEATURE_TAG_HALANT_FORMS=1852596584,
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_HALF_WIDTH=1953259880,
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_FORMS=1953720680,
    DWRITE_FONT_FEATURE_TAG_HORIZONTAL_KANA_ALTERNATES=1634626408,
    DWRITE_FONT_FEATURE_TAG_HISTORICAL_LIGATURES=1734962280,
    DWRITE_FONT_FEATURE_TAG_HALF_WIDTH=1684633448,
    DWRITE_FONT_FEATURE_TAG_HOJO_KANJI_FORMS=1869246312,
    DWRITE_FONT_FEATURE_TAG_JIS04_FORMS=875589738,
    DWRITE_FONT_FEATURE_TAG_JIS78_FORMS=943157354,
    DWRITE_FONT_FEATURE_TAG_JIS83_FORMS=859336810,
    DWRITE_FONT_FEATURE_TAG_JIS90_FORMS=809070698,
    DWRITE_FONT_FEATURE_TAG_KERNING=1852990827,
    DWRITE_FONT_FEATURE_TAG_STANDARD_LIGATURES=1634167148,
    DWRITE_FONT_FEATURE_TAG_LINING_FIGURES=1836412524,
    DWRITE_FONT_FEATURE_TAG_LOCALIZED_FORMS=1818455916,
    DWRITE_FONT_FEATURE_TAG_MARK_POSITIONING=1802658157,
    DWRITE_FONT_FEATURE_TAG_MATHEMATICAL_GREEK=1802659693,
    DWRITE_FONT_FEATURE_TAG_MARK_TO_MARK_POSITIONING=1802333037,
    DWRITE_FONT_FEATURE_TAG_ALTERNATE_ANNOTATION_FORMS=1953259886,
    DWRITE_FONT_FEATURE_TAG_NLC_KANJI_FORMS=1801677934,
    DWRITE_FONT_FEATURE_TAG_OLD_STYLE_FIGURES=1836412527,
    DWRITE_FONT_FEATURE_TAG_ORDINALS=1852076655,
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_ALTERNATE_WIDTH=1953259888,
    DWRITE_FONT_FEATURE_TAG_PETITE_CAPITALS=1885430640,
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_FIGURES=1836412528,
    DWRITE_FONT_FEATURE_TAG_PROPORTIONAL_WIDTHS=1684633456,
    DWRITE_FONT_FEATURE_TAG_QUARTER_WIDTHS=1684633457,
    DWRITE_FONT_FEATURE_TAG_REQUIRED_LIGATURES=1734962290,
    DWRITE_FONT_FEATURE_TAG_RUBY_NOTATION_FORMS=2036495730,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_ALTERNATES=1953259891,
    DWRITE_FONT_FEATURE_TAG_SCIENTIFIC_INFERIORS=1718511987,
    DWRITE_FONT_FEATURE_TAG_SMALL_CAPITALS=1885564275,
    DWRITE_FONT_FEATURE_TAG_SIMPLIFIED_FORMS=1819307379,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_1=825258867,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_2=842036083,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_3=858813299,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_4=875590515,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_5=892367731,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_6=909144947,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_7=925922163,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_8=942699379,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_9=959476595,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_10=808547187,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_11=825324403,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_12=842101619,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_13=858878835,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_14=875656051,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_15=892433267,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_16=909210483,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_17=925987699,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_18=942764915,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_19=959542131,
    DWRITE_FONT_FEATURE_TAG_STYLISTIC_SET_20=808612723,
    DWRITE_FONT_FEATURE_TAG_SUBSCRIPT=1935832435,
    DWRITE_FONT_FEATURE_TAG_SUPERSCRIPT=1936749939,
    DWRITE_FONT_FEATURE_TAG_SWASH=1752397683,
    DWRITE_FONT_FEATURE_TAG_TITLING=1819568500,
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_NAME_FORMS=1835101812,
    DWRITE_FONT_FEATURE_TAG_TABULAR_FIGURES=1836412532,
    DWRITE_FONT_FEATURE_TAG_TRADITIONAL_FORMS=1684107892,
    DWRITE_FONT_FEATURE_TAG_THIRD_WIDTHS=1684633460,
    DWRITE_FONT_FEATURE_TAG_UNICASE=1667853941,
    DWRITE_FONT_FEATURE_TAG_SLASHED_ZERO=1869768058
};

struct DWRITE_FONT_FEATURE
{
    enum DWRITE_FONT_FEATURE_TAG nameTag;
    unsigned int parameter;
};

struct D3D10_TEX2D_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D3D10_TEX1D_RTV
{
    unsigned int MipSlice;
};

struct D3D10_BUFFER_SRV
{
    unsigned int FirstElement;
    unsigned int ElementOffset;
    unsigned int NumElements;
    unsigned int ElementWidth;
};

struct D3D10_TEX1D_ARRAY_DSV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct D3D10_TEX1D_ARRAY_RTV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct D3D10_TEX2DMS_SRV
{
    unsigned int UnusedField_NothingToDefine;
};

struct D3D10_MAPPED_TEXTURE3D
{
    void * pData;
    unsigned int RowPitch;
    unsigned int DepthPitch;
};

struct D3D10_BUFFER_RTV
{
    unsigned int FirstElement;
    unsigned int ElementOffset;
    unsigned int NumElements;
    unsigned int ElementWidth;
};

struct D3D10_MAPPED_TEXTURE2D
{
    void * pData;
    unsigned int RowPitch;
};

struct D3D10_TEX3D_RTV
{
    unsigned int MipSlice;
    unsigned int FirstWSlice;
    unsigned int WSize;
};

struct D3D10_TEX2DMS_ARRAY_SRV
{
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct D3D10_TEX2DMS_DSV
{
    unsigned int UnusedField_NothingToDefine;
};

struct D3D10_TEX1D_DSV
{
    unsigned int MipSlice;
};

struct ID3D10PixelShader : public ID3D10DeviceChild
{
    void ID3D10PixelShader(struct ID3D10PixelShader & );
    void ID3D10PixelShader();
    struct ID3D10PixelShader & operator=(struct ID3D10PixelShader & );
};

struct ID3D10PixelShader : public ID3D10DeviceChild
{
    void ID3D10PixelShader(struct ID3D10PixelShader & );
    void ID3D10PixelShader();
    struct ID3D10PixelShader & operator=(struct ID3D10PixelShader & );
};

struct D3D10_TEX3D_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D3D10_TEX2D_RTV
{
    unsigned int MipSlice;
};

struct D3D11_MAPPED_SUBRESOURCE
{
    void * pData;
    unsigned int RowPitch;
    unsigned int DepthPitch;
};

enum D3D10_MAP
{
    D3D10_MAP_READ=1,
    D3D10_MAP_WRITE=2,
    D3D10_MAP_READ_WRITE=3,
    D3D10_MAP_WRITE_DISCARD=4,
    D3D10_MAP_WRITE_NO_OVERWRITE=5
};

struct ID3D10Texture3D : public ID3D10Resource
{
    HRESULT Map(unsigned int ,enum D3D10_MAP ,unsigned int ,struct D3D10_MAPPED_TEXTURE3D * );
    void Unmap(unsigned int );
    void GetDesc(struct D3D10_TEXTURE3D_DESC * );
    void ID3D10Texture3D(struct ID3D10Texture3D & );
    void ID3D10Texture3D();
    struct ID3D10Texture3D & operator=(struct ID3D10Texture3D & );
};

struct ID3D10Texture3D : public ID3D10Resource
{
    HRESULT Map(unsigned int ,enum D3D10_MAP ,unsigned int ,struct D3D10_MAPPED_TEXTURE3D * );
    void Unmap(unsigned int );
    void GetDesc(struct D3D10_TEXTURE3D_DESC * );
    void ID3D10Texture3D(struct ID3D10Texture3D & );
    void ID3D10Texture3D();
    struct ID3D10Texture3D & operator=(struct ID3D10Texture3D & );
};

struct IDWriteLocalizedStrings : public IUnknown
{
    unsigned int GetCount();
    HRESULT FindLocaleName(wchar_t * ,unsigned int * ,int * );
    HRESULT GetLocaleNameLength(unsigned int ,unsigned int * );
    HRESULT GetLocaleName(unsigned int ,wchar_t * ,unsigned int );
    HRESULT GetStringLength(unsigned int ,unsigned int * );
    HRESULT GetString(unsigned int ,wchar_t * ,unsigned int );
    void IDWriteLocalizedStrings(struct IDWriteLocalizedStrings & );
    void IDWriteLocalizedStrings();
    struct IDWriteLocalizedStrings & operator=(struct IDWriteLocalizedStrings & );
};

struct IDWriteLocalizedStrings : public IUnknown
{
    unsigned int GetCount();
    HRESULT FindLocaleName(wchar_t * ,unsigned int * ,int * );
    HRESULT GetLocaleNameLength(unsigned int ,unsigned int * );
    HRESULT GetLocaleName(unsigned int ,wchar_t * ,unsigned int );
    HRESULT GetStringLength(unsigned int ,unsigned int * );
    HRESULT GetString(unsigned int ,wchar_t * ,unsigned int );
    void IDWriteLocalizedStrings(struct IDWriteLocalizedStrings & );
    void IDWriteLocalizedStrings();
    struct IDWriteLocalizedStrings & operator=(struct IDWriteLocalizedStrings & );
};

struct ID3D11CommandList : public ID3D11DeviceChild
{
    unsigned int GetContextFlags();
    void ID3D11CommandList(struct ID3D11CommandList & );
    void ID3D11CommandList();
    struct ID3D11CommandList & operator=(struct ID3D11CommandList & );
};

struct ID3D11CommandList : public ID3D11DeviceChild
{
    unsigned int GetContextFlags();
    void ID3D11CommandList(struct ID3D11CommandList & );
    void ID3D11CommandList();
    struct ID3D11CommandList & operator=(struct ID3D11CommandList & );
};

enum D3D10_FILL_MODE
{
    D3D10_FILL_WIREFRAME=2,
    D3D10_FILL_SOLID=3
};

enum D3D10_CULL_MODE
{
    D3D10_CULL_NONE=1,
    D3D10_CULL_FRONT=2,
    D3D10_CULL_BACK=3
};

struct D3D10_RASTERIZER_DESC
{
    enum D3D10_FILL_MODE FillMode;
    enum D3D10_CULL_MODE CullMode;
    int FrontCounterClockwise;
    int DepthBias;
    float DepthBiasClamp;
    float SlopeScaledDepthBias;
    int DepthClipEnable;
    int ScissorEnable;
    int MultisampleEnable;
    int AntialiasedLineEnable;
};

struct D3D10_TEX2D_ARRAY_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct ID3D10InputLayout : public ID3D10DeviceChild
{
    void ID3D10InputLayout(struct ID3D10InputLayout & );
    void ID3D10InputLayout();
    struct ID3D10InputLayout & operator=(struct ID3D10InputLayout & );
};

struct ID3D10InputLayout : public ID3D10DeviceChild
{
    void ID3D10InputLayout(struct ID3D10InputLayout & );
    void ID3D10InputLayout();
    struct ID3D10InputLayout & operator=(struct ID3D10InputLayout & );
};

enum D3D10_STENCIL_OP
{
    D3D10_STENCIL_OP_KEEP=1,
    D3D10_STENCIL_OP_ZERO=2,
    D3D10_STENCIL_OP_REPLACE=3,
    D3D10_STENCIL_OP_INCR_SAT=4,
    D3D10_STENCIL_OP_DECR_SAT=5,
    D3D10_STENCIL_OP_INVERT=6,
    D3D10_STENCIL_OP_INCR=7,
    D3D10_STENCIL_OP_DECR=8
};

enum D3D10_COMPARISON_FUNC
{
    D3D10_COMPARISON_NEVER=1,
    D3D10_COMPARISON_LESS=2,
    D3D10_COMPARISON_EQUAL=3,
    D3D10_COMPARISON_LESS_EQUAL=4,
    D3D10_COMPARISON_GREATER=5,
    D3D10_COMPARISON_NOT_EQUAL=6,
    D3D10_COMPARISON_GREATER_EQUAL=7,
    D3D10_COMPARISON_ALWAYS=8
};

struct D3D10_DEPTH_STENCILOP_DESC
{
    enum D3D10_STENCIL_OP StencilFailOp;
    enum D3D10_STENCIL_OP StencilDepthFailOp;
    enum D3D10_STENCIL_OP StencilPassOp;
    enum D3D10_COMPARISON_FUNC StencilFunc;
};

struct DWRITE_GLYPH_METRICS
{
    int leftSideBearing;
    unsigned int advanceWidth;
    int rightSideBearing;
    int topSideBearing;
    unsigned int advanceHeight;
    int bottomSideBearing;
    int verticalOriginY;
};

struct D3D11_CLASS_INSTANCE_DESC
{
    unsigned int InstanceId;
    unsigned int InstanceIndex;
    unsigned int TypeId;
    unsigned int ConstantBuffer;
    unsigned int BaseConstantBufferOffset;
    unsigned int BaseTexture;
    unsigned int BaseSampler;
    int Created;
};

struct D3D10_TEX2D_ARRAY_RTV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

enum D3D10_DEPTH_WRITE_MASK
{
    D3D10_DEPTH_WRITE_MASK_ZERO=0,
    D3D10_DEPTH_WRITE_MASK_ALL=1
};

struct D3D10_DEPTH_STENCIL_DESC
{
    int DepthEnable;
    enum D3D10_DEPTH_WRITE_MASK DepthWriteMask;
    enum D3D10_COMPARISON_FUNC DepthFunc;
    int StencilEnable;
    unsigned int StencilReadMask;
    unsigned int StencilWriteMask;
    struct D3D10_DEPTH_STENCILOP_DESC FrontFace;
    struct D3D10_DEPTH_STENCILOP_DESC BackFace;
};

struct D3D10_TEX2DMS_ARRAY_DSV
{
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct IDWriteFontFileStream : public IUnknown
{
    HRESULT ReadFileFragment(void ** ,unsigned int ,unsigned int ,void ** );
    void ReleaseFileFragment(void * );
    HRESULT GetFileSize(unsigned int * );
    HRESULT GetLastWriteTime(unsigned int * );
    void IDWriteFontFileStream(struct IDWriteFontFileStream & );
    void IDWriteFontFileStream();
    struct IDWriteFontFileStream & operator=(struct IDWriteFontFileStream & );
};

struct IDWriteFontFileStream : public IUnknown
{
    HRESULT ReadFileFragment(void ** ,unsigned int ,unsigned int ,void ** );
    void ReleaseFileFragment(void * );
    HRESULT GetFileSize(unsigned int * );
    HRESULT GetLastWriteTime(unsigned int * );
    void IDWriteFontFileStream(struct IDWriteFontFileStream & );
    void IDWriteFontFileStream();
    struct IDWriteFontFileStream & operator=(struct IDWriteFontFileStream & );
};

struct HMONITOR__
{
    int unused;
};

struct ID3D10Texture1D : public ID3D10Resource
{
    HRESULT Map(unsigned int ,enum D3D10_MAP ,unsigned int ,void ** );
    void Unmap(unsigned int );
    void GetDesc(struct D3D10_TEXTURE1D_DESC * );
    void ID3D10Texture1D(struct ID3D10Texture1D & );
    void ID3D10Texture1D();
    struct ID3D10Texture1D & operator=(struct ID3D10Texture1D & );
};

struct ID3D10Texture1D : public ID3D10Resource
{
    HRESULT Map(unsigned int ,enum D3D10_MAP ,unsigned int ,void ** );
    void Unmap(unsigned int );
    void GetDesc(struct D3D10_TEXTURE1D_DESC * );
    void ID3D10Texture1D(struct ID3D10Texture1D & );
    void ID3D10Texture1D();
    struct ID3D10Texture1D & operator=(struct ID3D10Texture1D & );
};

struct ID3D10Predicate : public ID3D10Query
{
    void ID3D10Predicate(struct ID3D10Predicate & );
    void ID3D10Predicate();
    struct ID3D10Predicate & operator=(struct ID3D10Predicate & );
};

struct ID3D10Predicate : public ID3D10Query
{
    void ID3D10Predicate(struct ID3D10Predicate & );
    void ID3D10Predicate();
    struct ID3D10Predicate & operator=(struct ID3D10Predicate & );
};

struct IDWriteFontList : public IUnknown
{
    HRESULT GetFontCollection(struct IDWriteFontCollection ** );
    unsigned int GetFontCount();
    HRESULT GetFont(unsigned int ,struct IDWriteFont ** );
    void IDWriteFontList(struct IDWriteFontList & );
    void IDWriteFontList();
    struct IDWriteFontList & operator=(struct IDWriteFontList & );
};

struct IDWriteFontList : public IUnknown
{
    HRESULT GetFontCollection(struct IDWriteFontCollection ** );
    unsigned int GetFontCount();
    HRESULT GetFont(unsigned int ,struct IDWriteFont ** );
    void IDWriteFontList(struct IDWriteFontList & );
    void IDWriteFontList();
    struct IDWriteFontList & operator=(struct IDWriteFontList & );
};

struct tagRECT
{
    long left;
    long top;
    long right;
    long bottom;
};

struct D3D10_COUNTER_INFO
{
    enum D3D10_COUNTER LastDeviceDependentCounter;
    unsigned int NumSimultaneousCounters;
    unsigned int NumDetectableParallelUnits;
};

enum DWRITE_READING_DIRECTION
{
    DWRITE_READING_DIRECTION_LEFT_TO_RIGHT=0,
    DWRITE_READING_DIRECTION_RIGHT_TO_LEFT=1
};

enum DWRITE_FLOW_DIRECTION
{
    DWRITE_FLOW_DIRECTION_TOP_TO_BOTTOM=0
};

struct DWRITE_UNDERLINE
{
    float width;
    float thickness;
    float offset;
    float runHeight;
    enum DWRITE_READING_DIRECTION readingDirection;
    enum DWRITE_FLOW_DIRECTION flowDirection;
    wchar_t * localeName;
    enum DWRITE_MEASURING_MODE measuringMode;
};

struct D3D10_SHADER_RESOURCE_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D_SRV_DIMENSION ViewDimension;
    struct D3D10_BUFFER_SRV Buffer;
    struct D3D10_TEX1D_SRV Texture1D;
    struct D3D10_TEX1D_ARRAY_SRV Texture1DArray;
    struct D3D10_TEX2D_SRV Texture2D;
    struct D3D10_TEX2D_ARRAY_SRV Texture2DArray;
    struct D3D10_TEX2DMS_SRV Texture2DMS;
    struct D3D10_TEX2DMS_ARRAY_SRV Texture2DMSArray;
    struct D3D10_TEX3D_SRV Texture3D;
    struct D3D10_TEXCUBE_SRV TextureCube;
};

struct D3D10_SO_DECLARATION_ENTRY
{
    char * SemanticName;
    unsigned int SemanticIndex;
    unsigned int StartComponent;
    unsigned int ComponentCount;
    unsigned int OutputSlot;
};

struct D3D10_TEX2DMS_ARRAY_RTV
{
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct ID3D10RenderTargetView : public ID3D10View
{
    void GetDesc(struct D3D10_RENDER_TARGET_VIEW_DESC * );
    void ID3D10RenderTargetView(struct ID3D10RenderTargetView & );
    void ID3D10RenderTargetView();
    struct ID3D10RenderTargetView & operator=(struct ID3D10RenderTargetView & );
};

struct ID3D10RenderTargetView : public ID3D10View
{
    void GetDesc(struct D3D10_RENDER_TARGET_VIEW_DESC * );
    void ID3D10RenderTargetView(struct ID3D10RenderTargetView & );
    void ID3D10RenderTargetView();
    struct ID3D10RenderTargetView & operator=(struct ID3D10RenderTargetView & );
};

struct ID3D10Buffer : public ID3D10Resource
{
    HRESULT Map(enum D3D10_MAP ,unsigned int ,void ** );
    void Unmap();
    void GetDesc(struct D3D10_BUFFER_DESC * );
    void ID3D10Buffer(struct ID3D10Buffer & );
    void ID3D10Buffer();
    struct ID3D10Buffer & operator=(struct ID3D10Buffer & );
};

struct ID3D10Buffer : public ID3D10Resource
{
    HRESULT Map(enum D3D10_MAP ,unsigned int ,void ** );
    void Unmap();
    void GetDesc(struct D3D10_BUFFER_DESC * );
    void ID3D10Buffer(struct ID3D10Buffer & );
    void ID3D10Buffer();
    struct ID3D10Buffer & operator=(struct ID3D10Buffer & );
};

struct ID3D10Texture2D : public ID3D10Resource
{
    HRESULT Map(unsigned int ,enum D3D10_MAP ,unsigned int ,struct D3D10_MAPPED_TEXTURE2D * );
    void Unmap(unsigned int );
    void GetDesc(struct D3D10_TEXTURE2D_DESC * );
    void ID3D10Texture2D(struct ID3D10Texture2D & );
    void ID3D10Texture2D();
    struct ID3D10Texture2D & operator=(struct ID3D10Texture2D & );
};

struct ID3D10Texture2D : public ID3D10Resource
{
    HRESULT Map(unsigned int ,enum D3D10_MAP ,unsigned int ,struct D3D10_MAPPED_TEXTURE2D * );
    void Unmap(unsigned int );
    void GetDesc(struct D3D10_TEXTURE2D_DESC * );
    void ID3D10Texture2D(struct ID3D10Texture2D & );
    void ID3D10Texture2D();
    struct ID3D10Texture2D & operator=(struct ID3D10Texture2D & );
};

struct D3D10_COUNTER_DESC
{
    enum D3D10_COUNTER Counter;
    unsigned int MiscFlags;
};

struct IDWriteTypography : public IUnknown
{
    HRESULT AddFontFeature(struct DWRITE_FONT_FEATURE );
    unsigned int GetFontFeatureCount();
    HRESULT GetFontFeature(unsigned int ,struct DWRITE_FONT_FEATURE * );
    void IDWriteTypography(struct IDWriteTypography & );
    void IDWriteTypography();
    struct IDWriteTypography & operator=(struct IDWriteTypography & );
};

struct IDWriteTypography : public IUnknown
{
    HRESULT AddFontFeature(struct DWRITE_FONT_FEATURE );
    unsigned int GetFontFeatureCount();
    HRESULT GetFontFeature(unsigned int ,struct DWRITE_FONT_FEATURE * );
    void IDWriteTypography(struct IDWriteTypography & );
    void IDWriteTypography();
    struct IDWriteTypography & operator=(struct IDWriteTypography & );
};

struct D3D10_TEX2D_ARRAY_DSV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct ID3D11DepthStencilView : public ID3D11View
{
    void GetDesc(struct D3D11_DEPTH_STENCIL_VIEW_DESC * );
    void ID3D11DepthStencilView(struct ID3D11DepthStencilView & );
    void ID3D11DepthStencilView();
    struct ID3D11DepthStencilView & operator=(struct ID3D11DepthStencilView & );
};

struct ID3D11DepthStencilView : public ID3D11View
{
    void GetDesc(struct D3D11_DEPTH_STENCIL_VIEW_DESC * );
    void ID3D11DepthStencilView(struct ID3D11DepthStencilView & );
    void ID3D11DepthStencilView();
    struct ID3D11DepthStencilView & operator=(struct ID3D11DepthStencilView & );
};

struct D3D10_TEX2DMS_RTV
{
    unsigned int UnusedField_NothingToDefine;
};

struct ID3D11VertexShader : public ID3D11DeviceChild
{
    void ID3D11VertexShader(struct ID3D11VertexShader & );
    void ID3D11VertexShader();
    struct ID3D11VertexShader & operator=(struct ID3D11VertexShader & );
};

struct ID3D11VertexShader : public ID3D11DeviceChild
{
    void ID3D11VertexShader(struct ID3D11VertexShader & );
    void ID3D11VertexShader();
    struct ID3D11VertexShader & operator=(struct ID3D11VertexShader & );
};

struct _D3DCOLORVALUE
{
    float r;
    float g;
    float b;
    float a;
};

struct D3D10_VIEWPORT
{
    int TopLeftX;
    int TopLeftY;
    unsigned int Width;
    unsigned int Height;
    float MinDepth;
    float MaxDepth;
};

struct D3D10_TEX2D_DSV
{
    unsigned int MipSlice;
};

struct ID3D11UnorderedAccessView : public ID3D11View
{
    void GetDesc(struct D3D11_UNORDERED_ACCESS_VIEW_DESC * );
    void ID3D11UnorderedAccessView(struct ID3D11UnorderedAccessView & );
    void ID3D11UnorderedAccessView();
    struct ID3D11UnorderedAccessView & operator=(struct ID3D11UnorderedAccessView & );
};

struct ID3D11UnorderedAccessView : public ID3D11View
{
    void GetDesc(struct D3D11_UNORDERED_ACCESS_VIEW_DESC * );
    void ID3D11UnorderedAccessView(struct ID3D11UnorderedAccessView & );
    void ID3D11UnorderedAccessView();
    struct ID3D11UnorderedAccessView & operator=(struct ID3D11UnorderedAccessView & );
};

struct _D3DPSHADERCAPS2_0
{
    unsigned long Caps;
    int DynamicFlowControlDepth;
    int NumTemps;
    int StaticFlowControlDepth;
    int NumInstructionSlots;
};

struct DWRITE_FONT_METRICS
{
    unsigned int designUnitsPerEm;
    unsigned int ascent;
    unsigned int descent;
    int lineGap;
    unsigned int capHeight;
    unsigned int xHeight;
    int underlinePosition;
    unsigned int underlineThickness;
    int strikethroughPosition;
    unsigned int strikethroughThickness;
};

struct IDWriteFontFileLoader : public IUnknown
{
    HRESULT CreateStreamFromKey(void * ,unsigned int ,struct IDWriteFontFileStream ** );
    void IDWriteFontFileLoader(struct IDWriteFontFileLoader & );
    void IDWriteFontFileLoader();
    struct IDWriteFontFileLoader & operator=(struct IDWriteFontFileLoader & );
};

struct IDWriteFontFileLoader : public IUnknown
{
    HRESULT CreateStreamFromKey(void * ,unsigned int ,struct IDWriteFontFileStream ** );
    void IDWriteFontFileLoader(struct IDWriteFontFileLoader & );
    void IDWriteFontFileLoader();
    struct IDWriteFontFileLoader & operator=(struct IDWriteFontFileLoader & );
};

enum D3D10_INPUT_CLASSIFICATION
{
    D3D10_INPUT_PER_VERTEX_DATA=0,
    D3D10_INPUT_PER_INSTANCE_DATA=1
};

struct D3D10_INPUT_ELEMENT_DESC
{
    char * SemanticName;
    unsigned int SemanticIndex;
    enum DXGI_FORMAT Format;
    unsigned int InputSlot;
    unsigned int AlignedByteOffset;
    enum D3D10_INPUT_CLASSIFICATION InputSlotClass;
    unsigned int InstanceDataStepRate;
};

struct DWRITE_TEXT_METRICS
{
    float left;
    float top;
    float width;
    float widthIncludingTrailingWhitespace;
    float height;
    float layoutWidth;
    float layoutHeight;
    unsigned int maxBidiReorderingDepth;
    unsigned int lineCount;
};

enum D3D10_RTV_DIMENSION
{
    D3D10_RTV_DIMENSION_UNKNOWN=0,
    D3D10_RTV_DIMENSION_BUFFER=1,
    D3D10_RTV_DIMENSION_TEXTURE1D=2,
    D3D10_RTV_DIMENSION_TEXTURE1DARRAY=3,
    D3D10_RTV_DIMENSION_TEXTURE2D=4,
    D3D10_RTV_DIMENSION_TEXTURE2DARRAY=5,
    D3D10_RTV_DIMENSION_TEXTURE2DMS=6,
    D3D10_RTV_DIMENSION_TEXTURE2DMSARRAY=7,
    D3D10_RTV_DIMENSION_TEXTURE3D=8
};

struct D3D10_RENDER_TARGET_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D10_RTV_DIMENSION ViewDimension;
    struct D3D10_BUFFER_RTV Buffer;
    struct D3D10_TEX1D_RTV Texture1D;
    struct D3D10_TEX1D_ARRAY_RTV Texture1DArray;
    struct D3D10_TEX2D_RTV Texture2D;
    struct D3D10_TEX2D_ARRAY_RTV Texture2DArray;
    struct D3D10_TEX2DMS_RTV Texture2DMS;
    struct D3D10_TEX2DMS_ARRAY_RTV Texture2DMSArray;
    struct D3D10_TEX3D_RTV Texture3D;
};

struct DWRITE_LINE_METRICS
{
    unsigned int length;
    unsigned int trailingWhitespaceLength;
    unsigned int newlineLength;
    float height;
    float baseline;
    int isTrimmed;
};

struct _D3DVSHADERCAPS2_0
{
    unsigned long Caps;
    int DynamicFlowControlDepth;
    int NumTemps;
    int StaticFlowControlDepth;
};

struct ID3D11BlendState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_BLEND_DESC * );
    void ID3D11BlendState(struct ID3D11BlendState & );
    void ID3D11BlendState();
    struct ID3D11BlendState & operator=(struct ID3D11BlendState & );
};

struct ID3D11BlendState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_BLEND_DESC * );
    void ID3D11BlendState(struct ID3D11BlendState & );
    void ID3D11BlendState();
    struct ID3D11BlendState & operator=(struct ID3D11BlendState & );
};

enum D3D10_DSV_DIMENSION
{
    D3D10_DSV_DIMENSION_UNKNOWN=0,
    D3D10_DSV_DIMENSION_TEXTURE1D=1,
    D3D10_DSV_DIMENSION_TEXTURE1DARRAY=2,
    D3D10_DSV_DIMENSION_TEXTURE2D=3,
    D3D10_DSV_DIMENSION_TEXTURE2DARRAY=4,
    D3D10_DSV_DIMENSION_TEXTURE2DMS=5,
    D3D10_DSV_DIMENSION_TEXTURE2DMSARRAY=6
};

struct D3D10_DEPTH_STENCIL_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D10_DSV_DIMENSION ViewDimension;
    struct D3D10_TEX1D_DSV Texture1D;
    struct D3D10_TEX1D_ARRAY_DSV Texture1DArray;
    struct D3D10_TEX2D_DSV Texture2D;
    struct D3D10_TEX2D_ARRAY_DSV Texture2DArray;
    struct D3D10_TEX2DMS_DSV Texture2DMS;
    struct D3D10_TEX2DMS_ARRAY_DSV Texture2DMSArray;
};

struct XAUDIO2_SEND_DESCRIPTOR
{
    unsigned int Flags;
    struct IXAudio2Voice * pOutputVoice;
};

struct DWRITE_GLYPH_OFFSET
{
    float advanceOffset;
    float ascenderOffset;
};

enum D2D1_FILL_MODE
{
    D2D1_FILL_MODE_ALTERNATE=0,
    D2D1_FILL_MODE_WINDING=1,
    D2D1_FILL_MODE_FORCE_DWORD=-1
};

enum D2D1_PATH_SEGMENT
{
    D2D1_PATH_SEGMENT_NONE=0,
    D2D1_PATH_SEGMENT_FORCE_UNSTROKED=1,
    D2D1_PATH_SEGMENT_FORCE_ROUND_LINE_JOIN=2,
    D2D1_PATH_SEGMENT_FORCE_DWORD=-1
};

enum D2D1_FIGURE_BEGIN
{
    D2D1_FIGURE_BEGIN_FILLED=0,
    D2D1_FIGURE_BEGIN_HOLLOW=1,
    D2D1_FIGURE_BEGIN_FORCE_DWORD=-1
};

struct D2D_POINT_2F
{
    float x;
    float y;
};

struct D2D1_BEZIER_SEGMENT
{
    struct D2D_POINT_2F point1;
    struct D2D_POINT_2F point2;
    struct D2D_POINT_2F point3;
};

enum D2D1_FIGURE_END
{
    D2D1_FIGURE_END_OPEN=0,
    D2D1_FIGURE_END_CLOSED=1,
    D2D1_FIGURE_END_FORCE_DWORD=-1
};

struct ID2D1SimplifiedGeometrySink : public IUnknown
{
    void SetFillMode(enum D2D1_FILL_MODE );
    void SetSegmentFlags(enum D2D1_PATH_SEGMENT );
    void BeginFigure(struct D2D_POINT_2F ,enum D2D1_FIGURE_BEGIN );
    void AddLines(struct D2D_POINT_2F * ,unsigned int );
    void AddBeziers(struct D2D1_BEZIER_SEGMENT * ,unsigned int );
    void EndFigure(enum D2D1_FIGURE_END );
    HRESULT Close();
    void ID2D1SimplifiedGeometrySink(struct ID2D1SimplifiedGeometrySink & );
    void ID2D1SimplifiedGeometrySink();
    struct ID2D1SimplifiedGeometrySink & operator=(struct ID2D1SimplifiedGeometrySink & );
};

struct ID2D1SimplifiedGeometrySink : public IUnknown
{
    void SetFillMode(enum D2D1_FILL_MODE );
    void SetSegmentFlags(enum D2D1_PATH_SEGMENT );
    void BeginFigure(struct D2D_POINT_2F ,enum D2D1_FIGURE_BEGIN );
    void AddLines(struct D2D_POINT_2F * ,unsigned int );
    void AddBeziers(struct D2D1_BEZIER_SEGMENT * ,unsigned int );
    void EndFigure(enum D2D1_FIGURE_END );
    HRESULT Close();
    void ID2D1SimplifiedGeometrySink(struct ID2D1SimplifiedGeometrySink & );
    void ID2D1SimplifiedGeometrySink();
    struct ID2D1SimplifiedGeometrySink & operator=(struct ID2D1SimplifiedGeometrySink & );
};

struct XAUDIO2_BUFFER_WMA
{
    unsigned int * pDecodedPacketCumulativeBytes;
    unsigned int PacketCount;
};

struct ID3D10SamplerState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_SAMPLER_DESC * );
    void ID3D10SamplerState(struct ID3D10SamplerState & );
    void ID3D10SamplerState();
    struct ID3D10SamplerState & operator=(struct ID3D10SamplerState & );
};

struct ID3D10SamplerState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_SAMPLER_DESC * );
    void ID3D10SamplerState(struct ID3D10SamplerState & );
    void ID3D10SamplerState();
    struct ID3D10SamplerState & operator=(struct ID3D10SamplerState & );
};

struct ID3D10RasterizerState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_RASTERIZER_DESC * );
    void ID3D10RasterizerState(struct ID3D10RasterizerState & );
    void ID3D10RasterizerState();
    struct ID3D10RasterizerState & operator=(struct ID3D10RasterizerState & );
};

struct ID3D10RasterizerState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_RASTERIZER_DESC * );
    void ID3D10RasterizerState(struct ID3D10RasterizerState & );
    void ID3D10RasterizerState();
    struct ID3D10RasterizerState & operator=(struct ID3D10RasterizerState & );
};

enum D3D10_FILTER
{
    D3D10_FILTER_MIN_MAG_MIP_POINT=0,
    D3D10_FILTER_MIN_MAG_POINT_MIP_LINEAR=1,
    D3D10_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT=4,
    D3D10_FILTER_MIN_POINT_MAG_MIP_LINEAR=5,
    D3D10_FILTER_MIN_LINEAR_MAG_MIP_POINT=16,
    D3D10_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR=17,
    D3D10_FILTER_MIN_MAG_LINEAR_MIP_POINT=20,
    D3D10_FILTER_MIN_MAG_MIP_LINEAR=21,
    D3D10_FILTER_ANISOTROPIC=85,
    D3D10_FILTER_COMPARISON_MIN_MAG_MIP_POINT=128,
    D3D10_FILTER_COMPARISON_MIN_MAG_POINT_MIP_LINEAR=129,
    D3D10_FILTER_COMPARISON_MIN_POINT_MAG_LINEAR_MIP_POINT=132,
    D3D10_FILTER_COMPARISON_MIN_POINT_MAG_MIP_LINEAR=133,
    D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_MIP_POINT=144,
    D3D10_FILTER_COMPARISON_MIN_LINEAR_MAG_POINT_MIP_LINEAR=145,
    D3D10_FILTER_COMPARISON_MIN_MAG_LINEAR_MIP_POINT=148,
    D3D10_FILTER_COMPARISON_MIN_MAG_MIP_LINEAR=149,
    D3D10_FILTER_COMPARISON_ANISOTROPIC=213,
    D3D10_FILTER_TEXT_1BIT=-2147483648
};

enum D3D10_TEXTURE_ADDRESS_MODE
{
    D3D10_TEXTURE_ADDRESS_WRAP=1,
    D3D10_TEXTURE_ADDRESS_MIRROR=2,
    D3D10_TEXTURE_ADDRESS_CLAMP=3,
    D3D10_TEXTURE_ADDRESS_BORDER=4,
    D3D10_TEXTURE_ADDRESS_MIRROR_ONCE=5
};

struct D3D10_SAMPLER_DESC
{
    enum D3D10_FILTER Filter;
    enum D3D10_TEXTURE_ADDRESS_MODE AddressU;
    enum D3D10_TEXTURE_ADDRESS_MODE AddressV;
    enum D3D10_TEXTURE_ADDRESS_MODE AddressW;
    float MipLODBias;
    unsigned int MaxAnisotropy;
    enum D3D10_COMPARISON_FUNC ComparisonFunc;
    float BorderColor[4];
    float MinLOD;
    float MaxLOD;
};

struct _RGNDATAHEADER
{
    unsigned long dwSize;
    unsigned long iType;
    unsigned long nCount;
    unsigned long nRgnSize;
    struct tagRECT rcBound;
};

enum _D3DFORMAT
{
    D3DFMT_UNKNOWN=0,
    D3DFMT_R8G8B8=20,
    D3DFMT_A8R8G8B8=21,
    D3DFMT_X8R8G8B8=22,
    D3DFMT_R5G6B5=23,
    D3DFMT_X1R5G5B5=24,
    D3DFMT_A1R5G5B5=25,
    D3DFMT_A4R4G4B4=26,
    D3DFMT_R3G3B2=27,
    D3DFMT_A8=28,
    D3DFMT_A8R3G3B2=29,
    D3DFMT_X4R4G4B4=30,
    D3DFMT_A2B10G10R10=31,
    D3DFMT_A8B8G8R8=32,
    D3DFMT_X8B8G8R8=33,
    D3DFMT_G16R16=34,
    D3DFMT_A2R10G10B10=35,
    D3DFMT_A16B16G16R16=36,
    D3DFMT_A8P8=40,
    D3DFMT_P8=41,
    D3DFMT_L8=50,
    D3DFMT_A8L8=51,
    D3DFMT_A4L4=52,
    D3DFMT_V8U8=60,
    D3DFMT_L6V5U5=61,
    D3DFMT_X8L8V8U8=62,
    D3DFMT_Q8W8V8U8=63,
    D3DFMT_V16U16=64,
    D3DFMT_A2W10V10U10=67,
    D3DFMT_UYVY=1498831189,
    D3DFMT_R8G8_B8G8=1195525970,
    D3DFMT_YUY2=844715353,
    D3DFMT_G8R8_G8B8=1111970375,
    D3DFMT_DXT1=827611204,
    D3DFMT_DXT2=844388420,
    D3DFMT_DXT3=861165636,
    D3DFMT_DXT4=877942852,
    D3DFMT_DXT5=894720068,
    D3DFMT_D16_LOCKABLE=70,
    D3DFMT_D32=71,
    D3DFMT_D15S1=73,
    D3DFMT_D24S8=75,
    D3DFMT_D24X8=77,
    D3DFMT_D24X4S4=79,
    D3DFMT_D16=80,
    D3DFMT_D32F_LOCKABLE=82,
    D3DFMT_D24FS8=83,
    D3DFMT_D32_LOCKABLE=84,
    D3DFMT_S8_LOCKABLE=85,
    D3DFMT_L16=81,
    D3DFMT_VERTEXDATA=100,
    D3DFMT_INDEX16=101,
    D3DFMT_INDEX32=102,
    D3DFMT_Q16W16V16U16=110,
    D3DFMT_MULTI2_ARGB8=827606349,
    D3DFMT_R16F=111,
    D3DFMT_G16R16F=112,
    D3DFMT_A16B16G16R16F=113,
    D3DFMT_R32F=114,
    D3DFMT_G32R32F=115,
    D3DFMT_A32B32G32R32F=116,
    D3DFMT_CxV8U8=117,
    D3DFMT_A1=118,
    D3DFMT_A2B10G10R10_XR_BIAS=119,
    D3DFMT_BINARYBUFFER=199,
    D3DFMT_FORCE_DWORD=2147483647
};

enum _D3DRESOURCETYPE
{
    D3DRTYPE_SURFACE=1,
    D3DRTYPE_VOLUME=2,
    D3DRTYPE_TEXTURE=3,
    D3DRTYPE_VOLUMETEXTURE=4,
    D3DRTYPE_CUBETEXTURE=5,
    D3DRTYPE_VERTEXBUFFER=6,
    D3DRTYPE_INDEXBUFFER=7,
    D3DRTYPE_FORCE_DWORD=2147483647
};

enum _D3DPOOL
{
    D3DPOOL_DEFAULT=0,
    D3DPOOL_MANAGED=1,
    D3DPOOL_SYSTEMMEM=2,
    D3DPOOL_SCRATCH=3,
    D3DPOOL_FORCE_DWORD=2147483647
};

struct _D3DINDEXBUFFER_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    unsigned int Size;
};

struct ID3D11PixelShader : public ID3D11DeviceChild
{
    void ID3D11PixelShader(struct ID3D11PixelShader & );
    void ID3D11PixelShader();
    struct ID3D11PixelShader & operator=(struct ID3D11PixelShader & );
};

struct ID3D11PixelShader : public ID3D11DeviceChild
{
    void ID3D11PixelShader(struct ID3D11PixelShader & );
    void ID3D11PixelShader();
    struct ID3D11PixelShader & operator=(struct ID3D11PixelShader & );
};

struct ID3D10DepthStencilState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_DEPTH_STENCIL_DESC * );
    void ID3D10DepthStencilState(struct ID3D10DepthStencilState & );
    void ID3D10DepthStencilState();
    struct ID3D10DepthStencilState & operator=(struct ID3D10DepthStencilState & );
};

struct ID3D10DepthStencilState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_DEPTH_STENCIL_DESC * );
    void ID3D10DepthStencilState(struct ID3D10DepthStencilState & );
    void ID3D10DepthStencilState();
    struct ID3D10DepthStencilState & operator=(struct ID3D10DepthStencilState & );
};

struct D3D10_QUERY_DESC
{
    enum D3D10_QUERY Query;
    unsigned int MiscFlags;
};

struct _D3DLOCKED_BOX
{
    int RowPitch;
    int SlicePitch;
    void * pBits;
};

struct _D3DRECT
{
    long x1;
    long y1;
    long x2;
    long y2;
};

struct D3D10_SUBRESOURCE_DATA
{
    void * pSysMem;
    unsigned int SysMemPitch;
    unsigned int SysMemSlicePitch;
};

struct ID3D10DeviceChild : public IUnknown
{
    void GetDevice(struct ID3D10Device ** );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    void ID3D10DeviceChild(struct ID3D10DeviceChild & );
    void ID3D10DeviceChild();
    struct ID3D10DeviceChild & operator=(struct ID3D10DeviceChild & );
};

struct ID3D10DeviceChild : public IUnknown
{
    void GetDevice(struct ID3D10Device ** );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    void ID3D10DeviceChild(struct ID3D10DeviceChild & );
    void ID3D10DeviceChild();
    struct ID3D10DeviceChild & operator=(struct ID3D10DeviceChild & );
};

struct _RGNDATA
{
    struct _RGNDATAHEADER rdh;
    char Buffer[1];
};

struct _D3DVIEWPORT9
{
    unsigned long X;
    unsigned long Y;
    unsigned long Width;
    unsigned long Height;
    float MinZ;
    float MaxZ;
};

struct _D3DBOX
{
    unsigned int Left;
    unsigned int Top;
    unsigned int Right;
    unsigned int Bottom;
    unsigned int Front;
    unsigned int Back;
};

struct ID3D10Asynchronous : public ID3D10DeviceChild
{
    void Begin();
    void End();
    HRESULT GetData(void * ,unsigned int ,unsigned int );
    unsigned int GetDataSize();
    void ID3D10Asynchronous(struct ID3D10Asynchronous & );
    void ID3D10Asynchronous();
    struct ID3D10Asynchronous & operator=(struct ID3D10Asynchronous & );
};

struct ID3D10Asynchronous : public ID3D10DeviceChild
{
    void Begin();
    void End();
    HRESULT GetData(void * ,unsigned int ,unsigned int );
    unsigned int GetDataSize();
    void ID3D10Asynchronous(struct ID3D10Asynchronous & );
    void ID3D10Asynchronous();
    struct ID3D10Asynchronous & operator=(struct ID3D10Asynchronous & );
};

struct WAVEFORMATEXTENSIBLE
{
    struct tWAVEFORMATEX Format;
    union <unnamed-type-Samples>
    {
        unsigned int wValidBitsPerSample;
        unsigned int wSamplesPerBlock;
        unsigned int wReserved;
    };
    union WAVEFORMATEXTENSIBLE::<unnamed-type-Samples> Samples;
    unsigned long dwChannelMask;
    struct _GUID SubFormat;
};

union WAVEFORMATEXTENSIBLE::<unnamed-type-Samples>
{
    unsigned int wValidBitsPerSample;
    unsigned int wSamplesPerBlock;
    unsigned int wReserved;
};

struct _D3DLOCKED_RECT
{
    int Pitch;
    void * pBits;
};

struct DWRITE_TEXT_RANGE
{
    unsigned int startPosition;
    unsigned int length;
};

struct ID3D10VertexShader : public ID3D10DeviceChild
{
    void ID3D10VertexShader(struct ID3D10VertexShader & );
    void ID3D10VertexShader();
    struct ID3D10VertexShader & operator=(struct ID3D10VertexShader & );
};

struct ID3D10VertexShader : public ID3D10DeviceChild
{
    void ID3D10VertexShader(struct ID3D10VertexShader & );
    void ID3D10VertexShader();
    struct ID3D10VertexShader & operator=(struct ID3D10VertexShader & );
};

struct ID3D11ClassInstance : public ID3D11DeviceChild
{
    void GetClassLinkage(struct ID3D11ClassLinkage ** );
    void GetDesc(struct D3D11_CLASS_INSTANCE_DESC * );
    void GetInstanceName(char * ,unsigned long * );
    void GetTypeName(char * ,unsigned long * );
    void ID3D11ClassInstance(struct ID3D11ClassInstance & );
    void ID3D11ClassInstance();
    struct ID3D11ClassInstance & operator=(struct ID3D11ClassInstance & );
};

struct ID3D11ClassInstance : public ID3D11DeviceChild
{
    void GetClassLinkage(struct ID3D11ClassLinkage ** );
    void GetDesc(struct D3D11_CLASS_INSTANCE_DESC * );
    void GetInstanceName(char * ,unsigned long * );
    void GetTypeName(char * ,unsigned long * );
    void ID3D11ClassInstance(struct ID3D11ClassInstance & );
    void ID3D11ClassInstance();
    struct ID3D11ClassInstance & operator=(struct ID3D11ClassInstance & );
};

struct _D3DCLIPSTATUS9
{
    unsigned long ClipUnion;
    unsigned long ClipIntersection;
};

enum _D3DBASISTYPE
{
    D3DBASIS_BEZIER=0,
    D3DBASIS_BSPLINE=1,
    D3DBASIS_CATMULL_ROM=2,
    D3DBASIS_FORCE_DWORD=2147483647
};

enum _D3DDEGREETYPE
{
    D3DDEGREE_LINEAR=1,
    D3DDEGREE_QUADRATIC=2,
    D3DDEGREE_CUBIC=3,
    D3DDEGREE_QUINTIC=5,
    D3DDEGREE_FORCE_DWORD=2147483647
};

struct _D3DTRIPATCH_INFO
{
    unsigned int StartVertexOffset;
    unsigned int NumVertices;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct D3D11_SUBRESOURCE_DATA
{
    void * pSysMem;
    unsigned int SysMemPitch;
    unsigned int SysMemSlicePitch;
};

struct ID3D10DepthStencilView : public ID3D10View
{
    void GetDesc(struct D3D10_DEPTH_STENCIL_VIEW_DESC * );
    void ID3D10DepthStencilView(struct ID3D10DepthStencilView & );
    void ID3D10DepthStencilView();
    struct ID3D10DepthStencilView & operator=(struct ID3D10DepthStencilView & );
};

struct ID3D10DepthStencilView : public ID3D10View
{
    void GetDesc(struct D3D10_DEPTH_STENCIL_VIEW_DESC * );
    void ID3D10DepthStencilView(struct ID3D10DepthStencilView & );
    void ID3D10DepthStencilView();
    struct ID3D10DepthStencilView & operator=(struct ID3D10DepthStencilView & );
};

enum _D3DMULTISAMPLE_TYPE
{
    D3DMULTISAMPLE_NONE=0,
    D3DMULTISAMPLE_NONMASKABLE=1,
    D3DMULTISAMPLE_2_SAMPLES=2,
    D3DMULTISAMPLE_3_SAMPLES=3,
    D3DMULTISAMPLE_4_SAMPLES=4,
    D3DMULTISAMPLE_5_SAMPLES=5,
    D3DMULTISAMPLE_6_SAMPLES=6,
    D3DMULTISAMPLE_7_SAMPLES=7,
    D3DMULTISAMPLE_8_SAMPLES=8,
    D3DMULTISAMPLE_9_SAMPLES=9,
    D3DMULTISAMPLE_10_SAMPLES=10,
    D3DMULTISAMPLE_11_SAMPLES=11,
    D3DMULTISAMPLE_12_SAMPLES=12,
    D3DMULTISAMPLE_13_SAMPLES=13,
    D3DMULTISAMPLE_14_SAMPLES=14,
    D3DMULTISAMPLE_15_SAMPLES=15,
    D3DMULTISAMPLE_16_SAMPLES=16,
    D3DMULTISAMPLE_FORCE_DWORD=2147483647
};

struct _D3DSURFACE_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    enum _D3DMULTISAMPLE_TYPE MultiSampleType;
    unsigned long MultiSampleQuality;
    unsigned int Width;
    unsigned int Height;
};

enum DWRITE_FONT_WEIGHT
{
    DWRITE_FONT_WEIGHT_THIN=100,
    DWRITE_FONT_WEIGHT_EXTRA_LIGHT=200,
    DWRITE_FONT_WEIGHT_ULTRA_LIGHT=200,
    DWRITE_FONT_WEIGHT_LIGHT=300,
    DWRITE_FONT_WEIGHT_NORMAL=400,
    DWRITE_FONT_WEIGHT_REGULAR=400,
    DWRITE_FONT_WEIGHT_MEDIUM=500,
    DWRITE_FONT_WEIGHT_DEMI_BOLD=600,
    DWRITE_FONT_WEIGHT_SEMI_BOLD=600,
    DWRITE_FONT_WEIGHT_BOLD=700,
    DWRITE_FONT_WEIGHT_EXTRA_BOLD=800,
    DWRITE_FONT_WEIGHT_ULTRA_BOLD=800,
    DWRITE_FONT_WEIGHT_BLACK=900,
    DWRITE_FONT_WEIGHT_HEAVY=900,
    DWRITE_FONT_WEIGHT_EXTRA_BLACK=950,
    DWRITE_FONT_WEIGHT_ULTRA_BLACK=950
};

enum DWRITE_FONT_STRETCH
{
    DWRITE_FONT_STRETCH_UNDEFINED=0,
    DWRITE_FONT_STRETCH_ULTRA_CONDENSED=1,
    DWRITE_FONT_STRETCH_EXTRA_CONDENSED=2,
    DWRITE_FONT_STRETCH_CONDENSED=3,
    DWRITE_FONT_STRETCH_SEMI_CONDENSED=4,
    DWRITE_FONT_STRETCH_NORMAL=5,
    DWRITE_FONT_STRETCH_MEDIUM=5,
    DWRITE_FONT_STRETCH_SEMI_EXPANDED=6,
    DWRITE_FONT_STRETCH_EXPANDED=7,
    DWRITE_FONT_STRETCH_EXTRA_EXPANDED=8,
    DWRITE_FONT_STRETCH_ULTRA_EXPANDED=9
};

enum DWRITE_FONT_STYLE
{
    DWRITE_FONT_STYLE_NORMAL=0,
    DWRITE_FONT_STYLE_OBLIQUE=1,
    DWRITE_FONT_STYLE_ITALIC=2
};

enum DWRITE_INFORMATIONAL_STRING_ID
{
    DWRITE_INFORMATIONAL_STRING_NONE=0,
    DWRITE_INFORMATIONAL_STRING_COPYRIGHT_NOTICE=1,
    DWRITE_INFORMATIONAL_STRING_VERSION_STRINGS=2,
    DWRITE_INFORMATIONAL_STRING_TRADEMARK=3,
    DWRITE_INFORMATIONAL_STRING_MANUFACTURER=4,
    DWRITE_INFORMATIONAL_STRING_DESIGNER=5,
    DWRITE_INFORMATIONAL_STRING_DESIGNER_URL=6,
    DWRITE_INFORMATIONAL_STRING_DESCRIPTION=7,
    DWRITE_INFORMATIONAL_STRING_FONT_VENDOR_URL=8,
    DWRITE_INFORMATIONAL_STRING_LICENSE_DESCRIPTION=9,
    DWRITE_INFORMATIONAL_STRING_LICENSE_INFO_URL=10,
    DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES=11,
    DWRITE_INFORMATIONAL_STRING_WIN32_SUBFAMILY_NAMES=12,
    DWRITE_INFORMATIONAL_STRING_PREFERRED_FAMILY_NAMES=13,
    DWRITE_INFORMATIONAL_STRING_PREFERRED_SUBFAMILY_NAMES=14,
    DWRITE_INFORMATIONAL_STRING_SAMPLE_TEXT=15
};

enum DWRITE_FONT_SIMULATIONS
{
    DWRITE_FONT_SIMULATIONS_NONE=0,
    DWRITE_FONT_SIMULATIONS_BOLD=1,
    DWRITE_FONT_SIMULATIONS_OBLIQUE=2
};

struct IDWriteFont : public IUnknown
{
    HRESULT GetFontFamily(struct IDWriteFontFamily ** );
    enum DWRITE_FONT_WEIGHT GetWeight();
    enum DWRITE_FONT_STRETCH GetStretch();
    enum DWRITE_FONT_STYLE GetStyle();
    int IsSymbolFont();
    HRESULT GetFaceNames(struct IDWriteLocalizedStrings ** );
    HRESULT GetInformationalStrings(enum DWRITE_INFORMATIONAL_STRING_ID ,struct IDWriteLocalizedStrings ** ,int * );
    enum DWRITE_FONT_SIMULATIONS GetSimulations();
    void GetMetrics(struct DWRITE_FONT_METRICS * );
    HRESULT HasCharacter(unsigned int ,int * );
    HRESULT CreateFontFace(struct IDWriteFontFace ** );
    void IDWriteFont(struct IDWriteFont & );
    void IDWriteFont();
    struct IDWriteFont & operator=(struct IDWriteFont & );
};

struct IDWriteFont : public IUnknown
{
    HRESULT GetFontFamily(struct IDWriteFontFamily ** );
    enum DWRITE_FONT_WEIGHT GetWeight();
    enum DWRITE_FONT_STRETCH GetStretch();
    enum DWRITE_FONT_STYLE GetStyle();
    int IsSymbolFont();
    HRESULT GetFaceNames(struct IDWriteLocalizedStrings ** );
    HRESULT GetInformationalStrings(enum DWRITE_INFORMATIONAL_STRING_ID ,struct IDWriteLocalizedStrings ** ,int * );
    enum DWRITE_FONT_SIMULATIONS GetSimulations();
    void GetMetrics(struct DWRITE_FONT_METRICS * );
    HRESULT HasCharacter(unsigned int ,int * );
    HRESULT CreateFontFace(struct IDWriteFontFace ** );
    void IDWriteFont(struct IDWriteFont & );
    void IDWriteFont();
    struct IDWriteFont & operator=(struct IDWriteFont & );
};

struct IDWritePixelSnapping : public IUnknown
{
    HRESULT IsPixelSnappingDisabled(void * ,int * );
    HRESULT GetCurrentTransform(void * ,struct DWRITE_MATRIX * );
    HRESULT GetPixelsPerDip(void * ,float * );
    void IDWritePixelSnapping(struct IDWritePixelSnapping & );
    void IDWritePixelSnapping();
    struct IDWritePixelSnapping & operator=(struct IDWritePixelSnapping & );
};

struct IDWritePixelSnapping : public IUnknown
{
    HRESULT IsPixelSnappingDisabled(void * ,int * );
    HRESULT GetCurrentTransform(void * ,struct DWRITE_MATRIX * );
    HRESULT GetPixelsPerDip(void * ,float * );
    void IDWritePixelSnapping(struct IDWritePixelSnapping & );
    void IDWritePixelSnapping();
    struct IDWritePixelSnapping & operator=(struct IDWritePixelSnapping & );
};

struct DWRITE_MATRIX
{
    float m11;
    float m12;
    float m21;
    float m22;
    float dx;
    float dy;
};

enum _D3DLIGHTTYPE
{
    D3DLIGHT_POINT=1,
    D3DLIGHT_SPOT=2,
    D3DLIGHT_DIRECTIONAL=3,
    D3DLIGHT_FORCE_DWORD=2147483647
};

struct ID3D11RasterizerState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_RASTERIZER_DESC * );
    void ID3D11RasterizerState(struct ID3D11RasterizerState & );
    void ID3D11RasterizerState();
    struct ID3D11RasterizerState & operator=(struct ID3D11RasterizerState & );
};

struct ID3D11RasterizerState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_RASTERIZER_DESC * );
    void ID3D11RasterizerState(struct ID3D11RasterizerState & );
    void ID3D11RasterizerState();
    struct ID3D11RasterizerState & operator=(struct ID3D11RasterizerState & );
};

struct _D3DVERTEXBUFFER_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    unsigned int Size;
    unsigned long FVF;
};

struct _D3DDISPLAYMODE
{
    unsigned int Width;
    unsigned int Height;
    unsigned int RefreshRate;
    enum _D3DFORMAT Format;
};

struct ID3D11Asynchronous : public ID3D11DeviceChild
{
    unsigned int GetDataSize();
    void ID3D11Asynchronous(struct ID3D11Asynchronous & );
    void ID3D11Asynchronous();
    struct ID3D11Asynchronous & operator=(struct ID3D11Asynchronous & );
};

struct ID3D11Asynchronous : public ID3D11DeviceChild
{
    unsigned int GetDataSize();
    void ID3D11Asynchronous(struct ID3D11Asynchronous & );
    void ID3D11Asynchronous();
    struct ID3D11Asynchronous & operator=(struct ID3D11Asynchronous & );
};

struct IDirect3DStateBlock9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT Capture();
    HRESULT Apply();
    void IDirect3DStateBlock9(struct IDirect3DStateBlock9 & );
    void IDirect3DStateBlock9();
    struct IDirect3DStateBlock9 & operator=(struct IDirect3DStateBlock9 & );
};

struct IDirect3DStateBlock9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT Capture();
    HRESULT Apply();
    void IDirect3DStateBlock9(struct IDirect3DStateBlock9 & );
    void IDirect3DStateBlock9();
    struct IDirect3DStateBlock9 & operator=(struct IDirect3DStateBlock9 & );
};

struct ID3D10Query : public ID3D10Asynchronous
{
    void GetDesc(struct D3D10_QUERY_DESC * );
    void ID3D10Query(struct ID3D10Query & );
    void ID3D10Query();
    struct ID3D10Query & operator=(struct ID3D10Query & );
};

struct ID3D10Query : public ID3D10Asynchronous
{
    void GetDesc(struct D3D10_QUERY_DESC * );
    void ID3D10Query(struct ID3D10Query & );
    void ID3D10Query();
    struct ID3D10Query & operator=(struct ID3D10Query & );
};

struct DWRITE_GLYPH_RUN_DESCRIPTION
{
    wchar_t * localeName;
    wchar_t * string;
    unsigned int stringLength;
    unsigned int * clusterMap;
    unsigned int textPosition;
};

struct ID3D11Query : public ID3D11Asynchronous
{
    void GetDesc(struct D3D11_QUERY_DESC * );
    void ID3D11Query(struct ID3D11Query & );
    void ID3D11Query();
    struct ID3D11Query & operator=(struct ID3D11Query & );
};

struct ID3D11Query : public ID3D11Asynchronous
{
    void GetDesc(struct D3D11_QUERY_DESC * );
    void ID3D11Query(struct ID3D11Query & );
    void ID3D11Query();
    struct ID3D11Query & operator=(struct ID3D11Query & );
};

struct ID3D11Counter : public ID3D11Asynchronous
{
    void GetDesc(struct D3D11_COUNTER_DESC * );
    void ID3D11Counter(struct ID3D11Counter & );
    void ID3D11Counter();
    struct ID3D11Counter & operator=(struct ID3D11Counter & );
};

struct ID3D11Counter : public ID3D11Asynchronous
{
    void GetDesc(struct D3D11_COUNTER_DESC * );
    void ID3D11Counter(struct ID3D11Counter & );
    void ID3D11Counter();
    struct ID3D11Counter & operator=(struct ID3D11Counter & );
};

struct ID3D10Counter : public ID3D10Asynchronous
{
    void GetDesc(struct D3D10_COUNTER_DESC * );
    void ID3D10Counter(struct ID3D10Counter & );
    void ID3D10Counter();
    struct ID3D10Counter & operator=(struct ID3D10Counter & );
};

struct ID3D10Counter : public ID3D10Asynchronous
{
    void GetDesc(struct D3D10_COUNTER_DESC * );
    void ID3D10Counter(struct ID3D10Counter & );
    void ID3D10Counter();
    struct ID3D10Counter & operator=(struct ID3D10Counter & );
};

struct DWRITE_HIT_TEST_METRICS
{
    unsigned int textPosition;
    unsigned int length;
    float left;
    float top;
    float width;
    float height;
    unsigned int bidiLevel;
    int isText;
    int isTrimmed;
};

struct ID3D10View : public ID3D10DeviceChild
{
    void GetResource(struct ID3D10Resource ** );
    void ID3D10View(struct ID3D10View & );
    void ID3D10View();
    struct ID3D10View & operator=(struct ID3D10View & );
};

struct ID3D10View : public ID3D10DeviceChild
{
    void GetResource(struct ID3D10Resource ** );
    void ID3D10View(struct ID3D10View & );
    void ID3D10View();
    struct ID3D10View & operator=(struct ID3D10View & );
};

enum D3D10_BLEND
{
    D3D10_BLEND_ZERO=1,
    D3D10_BLEND_ONE=2,
    D3D10_BLEND_SRC_COLOR=3,
    D3D10_BLEND_INV_SRC_COLOR=4,
    D3D10_BLEND_SRC_ALPHA=5,
    D3D10_BLEND_INV_SRC_ALPHA=6,
    D3D10_BLEND_DEST_ALPHA=7,
    D3D10_BLEND_INV_DEST_ALPHA=8,
    D3D10_BLEND_DEST_COLOR=9,
    D3D10_BLEND_INV_DEST_COLOR=10,
    D3D10_BLEND_SRC_ALPHA_SAT=11,
    D3D10_BLEND_BLEND_FACTOR=14,
    D3D10_BLEND_INV_BLEND_FACTOR=15,
    D3D10_BLEND_SRC1_COLOR=16,
    D3D10_BLEND_INV_SRC1_COLOR=17,
    D3D10_BLEND_SRC1_ALPHA=18,
    D3D10_BLEND_INV_SRC1_ALPHA=19
};

enum D3D10_BLEND_OP
{
    D3D10_BLEND_OP_ADD=1,
    D3D10_BLEND_OP_SUBTRACT=2,
    D3D10_BLEND_OP_REV_SUBTRACT=3,
    D3D10_BLEND_OP_MIN=4,
    D3D10_BLEND_OP_MAX=5
};

struct D3D10_BLEND_DESC
{
    int AlphaToCoverageEnable;
    int BlendEnable[8];
    enum D3D10_BLEND SrcBlend;
    enum D3D10_BLEND DestBlend;
    enum D3D10_BLEND_OP BlendOp;
    enum D3D10_BLEND SrcBlendAlpha;
    enum D3D10_BLEND DestBlendAlpha;
    enum D3D10_BLEND_OP BlendOpAlpha;
    unsigned int RenderTargetWriteMask[8];
};

struct _D3DVERTEXELEMENT9
{
    unsigned int Stream;
    unsigned int Offset;
    unsigned int Type;
    unsigned int Method;
    unsigned int Usage;
    unsigned int UsageIndex;
};

struct ID3D10BlendState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_BLEND_DESC * );
    void ID3D10BlendState(struct ID3D10BlendState & );
    void ID3D10BlendState();
    struct ID3D10BlendState & operator=(struct ID3D10BlendState & );
};

struct ID3D10BlendState : public ID3D10DeviceChild
{
    void GetDesc(struct D3D10_BLEND_DESC * );
    void ID3D10BlendState(struct ID3D10BlendState & );
    void ID3D10BlendState();
    struct ID3D10BlendState & operator=(struct ID3D10BlendState & );
};

struct _D3DGAMMARAMP
{
    unsigned int red[256];
    unsigned int green[256];
    unsigned int blue[256];
};

enum _D3DDEVTYPE
{
    D3DDEVTYPE_HAL=1,
    D3DDEVTYPE_REF=2,
    D3DDEVTYPE_SW=3,
    D3DDEVTYPE_NULLREF=4,
    D3DDEVTYPE_FORCE_DWORD=2147483647
};

struct _D3DDEVICE_CREATION_PARAMETERS
{
    unsigned int AdapterOrdinal;
    enum _D3DDEVTYPE DeviceType;
    struct HWND__ * hFocusWindow;
    unsigned long BehaviorFlags;
};

struct XAUDIO2_EFFECT_DESCRIPTOR
{
    struct IUnknown * pEffect;
    int InitialState;
    unsigned int OutputChannels;
};

struct IDWriteFontFamily : public IDWriteFontList
{
    HRESULT GetFamilyNames(struct IDWriteLocalizedStrings ** );
    HRESULT GetFirstMatchingFont(enum DWRITE_FONT_WEIGHT ,enum DWRITE_FONT_STRETCH ,enum DWRITE_FONT_STYLE ,struct IDWriteFont ** );
    HRESULT GetMatchingFonts(enum DWRITE_FONT_WEIGHT ,enum DWRITE_FONT_STRETCH ,enum DWRITE_FONT_STYLE ,struct IDWriteFontList ** );
    void IDWriteFontFamily(struct IDWriteFontFamily & );
    void IDWriteFontFamily();
    struct IDWriteFontFamily & operator=(struct IDWriteFontFamily & );
};

struct IDWriteFontFamily : public IDWriteFontList
{
    HRESULT GetFamilyNames(struct IDWriteLocalizedStrings ** );
    HRESULT GetFirstMatchingFont(enum DWRITE_FONT_WEIGHT ,enum DWRITE_FONT_STRETCH ,enum DWRITE_FONT_STYLE ,struct IDWriteFont ** );
    HRESULT GetMatchingFonts(enum DWRITE_FONT_WEIGHT ,enum DWRITE_FONT_STRETCH ,enum DWRITE_FONT_STYLE ,struct IDWriteFontList ** );
    void IDWriteFontFamily(struct IDWriteFontFamily & );
    void IDWriteFontFamily();
    struct IDWriteFontFamily & operator=(struct IDWriteFontFamily & );
};

struct ID3D10GeometryShader : public ID3D10DeviceChild
{
    void ID3D10GeometryShader(struct ID3D10GeometryShader & );
    void ID3D10GeometryShader();
    struct ID3D10GeometryShader & operator=(struct ID3D10GeometryShader & );
};

struct ID3D10GeometryShader : public ID3D10DeviceChild
{
    void ID3D10GeometryShader(struct ID3D10GeometryShader & );
    void ID3D10GeometryShader();
    struct ID3D10GeometryShader & operator=(struct ID3D10GeometryShader & );
};

struct _D3DADAPTER_IDENTIFIER9
{
    char Driver[512];
    char Description[512];
    char DeviceName[32];
    union _LARGE_INTEGER DriverVersion;
    unsigned long VendorId;
    unsigned long DeviceId;
    unsigned long SubSysId;
    unsigned long Revision;
    struct _GUID DeviceIdentifier;
    unsigned long WHQLLevel;
};

struct tagRECT
{
    long left;
    long top;
    long right;
    long bottom;
};

struct _RGNDATA
{
    struct _RGNDATAHEADER rdh;
    char Buffer[1];
};

enum _D3DBACKBUFFER_TYPE
{
    D3DBACKBUFFER_TYPE_MONO=0,
    D3DBACKBUFFER_TYPE_LEFT=1,
    D3DBACKBUFFER_TYPE_RIGHT=2,
    D3DBACKBUFFER_TYPE_FORCE_DWORD=2147483647
};

struct IDirect3DSwapChain9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * ,unsigned long );
    HRESULT GetFrontBufferData(struct IDirect3DSurface9 * );
    HRESULT GetBackBuffer(unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(struct _D3DRASTER_STATUS * );
    HRESULT GetDisplayMode(struct _D3DDISPLAYMODE * );
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetPresentParameters(struct _D3DPRESENT_PARAMETERS_ * );
    void IDirect3DSwapChain9(struct IDirect3DSwapChain9 & );
    void IDirect3DSwapChain9();
    struct IDirect3DSwapChain9 & operator=(struct IDirect3DSwapChain9 & );
};

struct IDirect3DSwapChain9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * ,unsigned long );
    HRESULT GetFrontBufferData(struct IDirect3DSurface9 * );
    HRESULT GetBackBuffer(unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(struct _D3DRASTER_STATUS * );
    HRESULT GetDisplayMode(struct _D3DDISPLAYMODE * );
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetPresentParameters(struct _D3DPRESENT_PARAMETERS_ * );
    void IDirect3DSwapChain9(struct IDirect3DSwapChain9 & );
    void IDirect3DSwapChain9();
    struct IDirect3DSwapChain9 & operator=(struct IDirect3DSwapChain9 & );
};

enum _D3DPRIMITIVETYPE
{
    D3DPT_POINTLIST=1,
    D3DPT_LINELIST=2,
    D3DPT_LINESTRIP=3,
    D3DPT_TRIANGLELIST=4,
    D3DPT_TRIANGLESTRIP=5,
    D3DPT_TRIANGLEFAN=6,
    D3DPT_FORCE_DWORD=2147483647
};

struct ID3D11ShaderResourceView : public ID3D11View
{
    void GetDesc(struct D3D11_SHADER_RESOURCE_VIEW_DESC * );
    void ID3D11ShaderResourceView(struct ID3D11ShaderResourceView & );
    void ID3D11ShaderResourceView();
    struct ID3D11ShaderResourceView & operator=(struct ID3D11ShaderResourceView & );
};

struct ID3D11ShaderResourceView : public ID3D11View
{
    void GetDesc(struct D3D11_SHADER_RESOURCE_VIEW_DESC * );
    void ID3D11ShaderResourceView(struct ID3D11ShaderResourceView & );
    void ID3D11ShaderResourceView();
    struct ID3D11ShaderResourceView & operator=(struct ID3D11ShaderResourceView & );
};

struct ID2D1DCRenderTarget : public ID2D1RenderTarget
{
    HRESULT BindDC(const struct HDC__ * ,struct tagRECT * );
    void ID2D1DCRenderTarget(struct ID2D1DCRenderTarget & );
    void ID2D1DCRenderTarget();
    struct ID2D1DCRenderTarget & operator=(struct ID2D1DCRenderTarget & );
};

struct ID2D1DCRenderTarget : public ID2D1RenderTarget
{
    HRESULT BindDC(const struct HDC__ * ,struct tagRECT * );
    void ID2D1DCRenderTarget(struct ID2D1DCRenderTarget & );
    void ID2D1DCRenderTarget();
    struct ID2D1DCRenderTarget & operator=(struct ID2D1DCRenderTarget & );
};

struct _D3DCOLORVALUE
{
    float r;
    float g;
    float b;
    float a;
};

struct D3DXFLOAT16
{
    void D3DXFLOAT16(struct D3DXFLOAT16 & );
    void D3DXFLOAT16(float );
    void D3DXFLOAT16();
    float operator float();
    int operator==(struct D3DXFLOAT16 & );
    int operator!=(struct D3DXFLOAT16 & );
    unsigned int value;
};

struct D3DXCOLOR
{
    void D3DXCOLOR(float ,float ,float ,float );
    void D3DXCOLOR(struct _D3DCOLORVALUE & );
    void D3DXCOLOR(struct D3DXFLOAT16 * );
    void D3DXCOLOR(float * );
    void D3DXCOLOR(unsigned long );
    void D3DXCOLOR();
    unsigned long operator unsigned long();
    float * operator float *();
    float * operator const float *();
    struct _D3DCOLORVALUE * operator struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE * operator const struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE & operator struct _D3DCOLORVALUE &();
    struct _D3DCOLORVALUE & operator const struct _D3DCOLORVALUE &();
    struct D3DXCOLOR & operator+=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator-=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator*=(float );
    struct D3DXCOLOR & operator/=(float );
    struct D3DXCOLOR operator+(struct D3DXCOLOR & );
    struct D3DXCOLOR operator+();
    struct D3DXCOLOR operator-(struct D3DXCOLOR & );
    struct D3DXCOLOR operator-();
    struct D3DXCOLOR operator*(float );
    struct D3DXCOLOR operator/(float );
    int operator==(struct D3DXCOLOR & );
    int operator!=(struct D3DXCOLOR & );
    float r;
    float g;
    float b;
    float a;
};

struct D3DXCOLOR
{
    void D3DXCOLOR(float ,float ,float ,float );
    void D3DXCOLOR(struct _D3DCOLORVALUE & );
    void D3DXCOLOR(struct D3DXFLOAT16 * );
    void D3DXCOLOR(float * );
    void D3DXCOLOR(unsigned long );
    void D3DXCOLOR();
    unsigned long operator unsigned long();
    float * operator float *();
    float * operator const float *();
    struct _D3DCOLORVALUE * operator struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE * operator const struct _D3DCOLORVALUE *();
    struct _D3DCOLORVALUE & operator struct _D3DCOLORVALUE &();
    struct _D3DCOLORVALUE & operator const struct _D3DCOLORVALUE &();
    struct D3DXCOLOR & operator+=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator-=(struct D3DXCOLOR & );
    struct D3DXCOLOR & operator*=(float );
    struct D3DXCOLOR & operator/=(float );
    struct D3DXCOLOR operator+(struct D3DXCOLOR & );
    struct D3DXCOLOR operator+();
    struct D3DXCOLOR operator-(struct D3DXCOLOR & );
    struct D3DXCOLOR operator-();
    struct D3DXCOLOR operator*(float );
    struct D3DXCOLOR operator/(float );
    int operator==(struct D3DXCOLOR & );
    int operator!=(struct D3DXCOLOR & );
    float r;
    float g;
    float b;
    float a;
};

struct ID2D1Layer : public ID2D1Resource
{
    struct D2D_SIZE_F GetSize();
    void ID2D1Layer(struct ID2D1Layer & );
    void ID2D1Layer();
    struct ID2D1Layer & operator=(struct ID2D1Layer & );
};

struct ID2D1Layer : public ID2D1Resource
{
    struct D2D_SIZE_F GetSize();
    void ID2D1Layer(struct ID2D1Layer & );
    void ID2D1Layer();
    struct ID2D1Layer & operator=(struct ID2D1Layer & );
};

enum D3D11_COUNTER
{
    D3D11_COUNTER_DEVICE_DEPENDENT_0=1073741824
};

struct D3D11_COUNTER_DESC
{
    enum D3D11_COUNTER Counter;
    unsigned int MiscFlags;
};

struct D2D_MATRIX_3X2_F
{
    float _11;
    float _12;
    float _21;
    float _22;
    float _31;
    float _32;
};

struct _D3DVECTOR
{
    float x;
    float y;
    float z;
};

struct D3DXVECTOR3 : public _D3DVECTOR
{
    void D3DXVECTOR3(float ,float ,float );
    void D3DXVECTOR3(struct D3DXFLOAT16 * );
    void D3DXVECTOR3(struct _D3DVECTOR & );
    void D3DXVECTOR3(float * );
    void D3DXVECTOR3();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR3 & operator+=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator-=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator*=(float );
    struct D3DXVECTOR3 & operator/=(float );
    struct D3DXVECTOR3 operator+(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator+();
    struct D3DXVECTOR3 operator-(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator-();
    struct D3DXVECTOR3 operator*(float );
    struct D3DXVECTOR3 operator/(float );
    int operator==(struct D3DXVECTOR3 & );
    int operator!=(struct D3DXVECTOR3 & );
};

struct D3DXVECTOR3 : public _D3DVECTOR
{
    void D3DXVECTOR3(float ,float ,float );
    void D3DXVECTOR3(struct D3DXFLOAT16 * );
    void D3DXVECTOR3(struct _D3DVECTOR & );
    void D3DXVECTOR3(float * );
    void D3DXVECTOR3();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR3 & operator+=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator-=(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 & operator*=(float );
    struct D3DXVECTOR3 & operator/=(float );
    struct D3DXVECTOR3 operator+(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator+();
    struct D3DXVECTOR3 operator-(struct D3DXVECTOR3 & );
    struct D3DXVECTOR3 operator-();
    struct D3DXVECTOR3 operator*(float );
    struct D3DXVECTOR3 operator/(float );
    int operator==(struct D3DXVECTOR3 & );
    int operator!=(struct D3DXVECTOR3 & );
};

struct D2D1_BITMAP_PROPERTIES
{
    struct D2D1_PIXEL_FORMAT pixelFormat;
    float dpiX;
    float dpiY;
};

struct _D3DXFONT_DESCA
{
    int Height;
    unsigned int Width;
    unsigned int Weight;
    unsigned int MipLevels;
    int Italic;
    unsigned int CharSet;
    unsigned int OutputPrecision;
    unsigned int Quality;
    unsigned int PitchAndFamily;
    char FaceName[32];
};

struct D2D1_PIXEL_FORMAT
{
    enum DXGI_FORMAT format;
    enum D2D1_ALPHA_MODE alphaMode;
};

struct XAUDIO2_VOICE_DETAILS
{
    unsigned int CreationFlags;
    unsigned int InputChannels;
    unsigned int InputSampleRate;
};

struct D3D10_VIEWPORT
{
    int TopLeftX;
    int TopLeftY;
    unsigned int Width;
    unsigned int Height;
    float MinDepth;
    float MaxDepth;
};

struct D3D10_BOX
{
    unsigned int left;
    unsigned int top;
    unsigned int front;
    unsigned int right;
    unsigned int bottom;
    unsigned int back;
};

struct D3D10_BUFFER_DESC
{
    unsigned int ByteWidth;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D10_SUBRESOURCE_DATA
{
    void * pSysMem;
    unsigned int SysMemPitch;
    unsigned int SysMemSlicePitch;
};

struct D3D10_TEXTURE1D_DESC
{
    unsigned int Width;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D10_TEXTURE2D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    struct DXGI_SAMPLE_DESC SampleDesc;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D10_TEXTURE3D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int MipLevels;
    enum DXGI_FORMAT Format;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D10_SHADER_RESOURCE_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D_SRV_DIMENSION ViewDimension;
    struct D3D10_BUFFER_SRV Buffer;
    struct D3D10_TEX1D_SRV Texture1D;
    struct D3D10_TEX1D_ARRAY_SRV Texture1DArray;
    struct D3D10_TEX2D_SRV Texture2D;
    struct D3D10_TEX2D_ARRAY_SRV Texture2DArray;
    struct D3D10_TEX2DMS_SRV Texture2DMS;
    struct D3D10_TEX2DMS_ARRAY_SRV Texture2DMSArray;
    struct D3D10_TEX3D_SRV Texture3D;
    struct D3D10_TEXCUBE_SRV TextureCube;
};

struct D3D10_RENDER_TARGET_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D10_RTV_DIMENSION ViewDimension;
    struct D3D10_BUFFER_RTV Buffer;
    struct D3D10_TEX1D_RTV Texture1D;
    struct D3D10_TEX1D_ARRAY_RTV Texture1DArray;
    struct D3D10_TEX2D_RTV Texture2D;
    struct D3D10_TEX2D_ARRAY_RTV Texture2DArray;
    struct D3D10_TEX2DMS_RTV Texture2DMS;
    struct D3D10_TEX2DMS_ARRAY_RTV Texture2DMSArray;
    struct D3D10_TEX3D_RTV Texture3D;
};

struct D3D10_DEPTH_STENCIL_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D10_DSV_DIMENSION ViewDimension;
    struct D3D10_TEX1D_DSV Texture1D;
    struct D3D10_TEX1D_ARRAY_DSV Texture1DArray;
    struct D3D10_TEX2D_DSV Texture2D;
    struct D3D10_TEX2D_ARRAY_DSV Texture2DArray;
    struct D3D10_TEX2DMS_DSV Texture2DMS;
    struct D3D10_TEX2DMS_ARRAY_DSV Texture2DMSArray;
};

struct D3D10_INPUT_ELEMENT_DESC
{
    char * SemanticName;
    unsigned int SemanticIndex;
    enum DXGI_FORMAT Format;
    unsigned int InputSlot;
    unsigned int AlignedByteOffset;
    enum D3D10_INPUT_CLASSIFICATION InputSlotClass;
    unsigned int InstanceDataStepRate;
};

struct D3D10_SO_DECLARATION_ENTRY
{
    char * SemanticName;
    unsigned int SemanticIndex;
    unsigned int StartComponent;
    unsigned int ComponentCount;
    unsigned int OutputSlot;
};

struct D3D10_BLEND_DESC
{
    int AlphaToCoverageEnable;
    int BlendEnable[8];
    enum D3D10_BLEND SrcBlend;
    enum D3D10_BLEND DestBlend;
    enum D3D10_BLEND_OP BlendOp;
    enum D3D10_BLEND SrcBlendAlpha;
    enum D3D10_BLEND DestBlendAlpha;
    enum D3D10_BLEND_OP BlendOpAlpha;
    unsigned int RenderTargetWriteMask[8];
};

struct D3D10_DEPTH_STENCIL_DESC
{
    int DepthEnable;
    enum D3D10_DEPTH_WRITE_MASK DepthWriteMask;
    enum D3D10_COMPARISON_FUNC DepthFunc;
    int StencilEnable;
    unsigned int StencilReadMask;
    unsigned int StencilWriteMask;
    struct D3D10_DEPTH_STENCILOP_DESC FrontFace;
    struct D3D10_DEPTH_STENCILOP_DESC BackFace;
};

struct D3D10_RASTERIZER_DESC
{
    enum D3D10_FILL_MODE FillMode;
    enum D3D10_CULL_MODE CullMode;
    int FrontCounterClockwise;
    int DepthBias;
    float DepthBiasClamp;
    float SlopeScaledDepthBias;
    int DepthClipEnable;
    int ScissorEnable;
    int MultisampleEnable;
    int AntialiasedLineEnable;
};

struct D3D10_SAMPLER_DESC
{
    enum D3D10_FILTER Filter;
    enum D3D10_TEXTURE_ADDRESS_MODE AddressU;
    enum D3D10_TEXTURE_ADDRESS_MODE AddressV;
    enum D3D10_TEXTURE_ADDRESS_MODE AddressW;
    float MipLODBias;
    unsigned int MaxAnisotropy;
    enum D3D10_COMPARISON_FUNC ComparisonFunc;
    float BorderColor[4];
    float MinLOD;
    float MaxLOD;
};

struct D3D10_QUERY_DESC
{
    enum D3D10_QUERY Query;
    unsigned int MiscFlags;
};

struct D3D10_COUNTER_DESC
{
    enum D3D10_COUNTER Counter;
    unsigned int MiscFlags;
};

struct ID3D10Device : public IUnknown
{
    void VSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void PSSetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void PSSetShader(struct ID3D10PixelShader * );
    void PSSetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void VSSetShader(struct ID3D10VertexShader * );
    void DrawIndexed(unsigned int ,unsigned int ,int );
    void Draw(unsigned int ,unsigned int );
    void PSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void IASetInputLayout(struct ID3D10InputLayout * );
    void IASetVertexBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** ,unsigned int * ,unsigned int * );
    void IASetIndexBuffer(struct ID3D10Buffer * ,enum DXGI_FORMAT ,unsigned int );
    void DrawIndexedInstanced(unsigned int ,unsigned int ,unsigned int ,int ,unsigned int );
    void DrawInstanced(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void GSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void GSSetShader(struct ID3D10GeometryShader * );
    void IASetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY );
    void VSSetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void VSSetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void SetPredication(struct ID3D10Predicate * ,int );
    void GSSetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void GSSetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void OMSetRenderTargets(unsigned int ,struct ID3D10RenderTargetView ** ,struct ID3D10DepthStencilView * );
    void OMSetBlendState(struct ID3D10BlendState * ,float * ,unsigned int );
    void OMSetDepthStencilState(struct ID3D10DepthStencilState * ,unsigned int );
    void SOSetTargets(unsigned int ,struct ID3D10Buffer ** ,unsigned int * );
    void DrawAuto();
    void RSSetState(struct ID3D10RasterizerState * );
    void RSSetViewports(unsigned int ,struct D3D10_VIEWPORT * );
    void RSSetScissorRects(unsigned int ,struct tagRECT * );
    void CopySubresourceRegion(struct ID3D10Resource * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct ID3D10Resource * ,unsigned int ,struct D3D10_BOX * );
    void CopyResource(struct ID3D10Resource * ,struct ID3D10Resource * );
    void UpdateSubresource(struct ID3D10Resource * ,unsigned int ,struct D3D10_BOX * ,void * ,unsigned int ,unsigned int );
    void ClearRenderTargetView(struct ID3D10RenderTargetView * ,float * );
    void ClearDepthStencilView(struct ID3D10DepthStencilView * ,unsigned int ,float ,unsigned int );
    void GenerateMips(struct ID3D10ShaderResourceView * );
    void ResolveSubresource(struct ID3D10Resource * ,unsigned int ,struct ID3D10Resource * ,unsigned int ,enum DXGI_FORMAT );
    void VSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void PSGetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void PSGetShader(struct ID3D10PixelShader ** );
    void PSGetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void VSGetShader(struct ID3D10VertexShader ** );
    void PSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void IAGetInputLayout(struct ID3D10InputLayout ** );
    void IAGetVertexBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** ,unsigned int * ,unsigned int * );
    void IAGetIndexBuffer(struct ID3D10Buffer ** ,enum DXGI_FORMAT * ,unsigned int * );
    void GSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void GSGetShader(struct ID3D10GeometryShader ** );
    void IAGetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY * );
    void VSGetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void VSGetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void GetPredication(struct ID3D10Predicate ** ,int * );
    void GSGetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void GSGetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void OMGetRenderTargets(unsigned int ,struct ID3D10RenderTargetView ** ,struct ID3D10DepthStencilView ** );
    void OMGetBlendState(struct ID3D10BlendState ** ,float * ,unsigned int * );
    void OMGetDepthStencilState(struct ID3D10DepthStencilState ** ,unsigned int * );
    void SOGetTargets(unsigned int ,struct ID3D10Buffer ** ,unsigned int * );
    void RSGetState(struct ID3D10RasterizerState ** );
    void RSGetViewports(unsigned int * ,struct D3D10_VIEWPORT * );
    void RSGetScissorRects(unsigned int * ,struct tagRECT * );
    HRESULT GetDeviceRemovedReason();
    HRESULT SetExceptionMode(unsigned int );
    unsigned int GetExceptionMode();
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    void ClearState();
    void Flush();
    HRESULT CreateBuffer(struct D3D10_BUFFER_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Buffer ** );
    HRESULT CreateTexture1D(struct D3D10_TEXTURE1D_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Texture1D ** );
    HRESULT CreateTexture2D(struct D3D10_TEXTURE2D_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Texture2D ** );
    HRESULT CreateTexture3D(struct D3D10_TEXTURE3D_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Texture3D ** );
    HRESULT CreateShaderResourceView(struct ID3D10Resource * ,struct D3D10_SHADER_RESOURCE_VIEW_DESC * ,struct ID3D10ShaderResourceView ** );
    HRESULT CreateRenderTargetView(struct ID3D10Resource * ,struct D3D10_RENDER_TARGET_VIEW_DESC * ,struct ID3D10RenderTargetView ** );
    HRESULT CreateDepthStencilView(struct ID3D10Resource * ,struct D3D10_DEPTH_STENCIL_VIEW_DESC * ,struct ID3D10DepthStencilView ** );
    HRESULT CreateInputLayout(struct D3D10_INPUT_ELEMENT_DESC * ,unsigned int ,void * ,unsigned long ,struct ID3D10InputLayout ** );
    HRESULT CreateVertexShader(void * ,unsigned long ,struct ID3D10VertexShader ** );
    HRESULT CreateGeometryShader(void * ,unsigned long ,struct ID3D10GeometryShader ** );
    HRESULT CreateGeometryShaderWithStreamOutput(void * ,unsigned long ,struct D3D10_SO_DECLARATION_ENTRY * ,unsigned int ,unsigned int ,struct ID3D10GeometryShader ** );
    HRESULT CreatePixelShader(void * ,unsigned long ,struct ID3D10PixelShader ** );
    HRESULT CreateBlendState(struct D3D10_BLEND_DESC * ,struct ID3D10BlendState ** );
    HRESULT CreateDepthStencilState(struct D3D10_DEPTH_STENCIL_DESC * ,struct ID3D10DepthStencilState ** );
    HRESULT CreateRasterizerState(struct D3D10_RASTERIZER_DESC * ,struct ID3D10RasterizerState ** );
    HRESULT CreateSamplerState(struct D3D10_SAMPLER_DESC * ,struct ID3D10SamplerState ** );
    HRESULT CreateQuery(struct D3D10_QUERY_DESC * ,struct ID3D10Query ** );
    HRESULT CreatePredicate(struct D3D10_QUERY_DESC * ,struct ID3D10Predicate ** );
    HRESULT CreateCounter(struct D3D10_COUNTER_DESC * ,struct ID3D10Counter ** );
    HRESULT CheckFormatSupport(enum DXGI_FORMAT ,unsigned int * );
    HRESULT CheckMultisampleQualityLevels(enum DXGI_FORMAT ,unsigned int ,unsigned int * );
    void CheckCounterInfo(struct D3D10_COUNTER_INFO * );
    HRESULT CheckCounter(struct D3D10_COUNTER_DESC * ,enum D3D10_COUNTER_TYPE * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * );
    unsigned int GetCreationFlags();
    HRESULT OpenSharedResource(void * ,struct _GUID & ,void ** );
    void SetTextFilterSize(unsigned int ,unsigned int );
    void GetTextFilterSize(unsigned int * ,unsigned int * );
    void ID3D10Device(struct ID3D10Device & );
    void ID3D10Device();
    struct ID3D10Device & operator=(struct ID3D10Device & );
};

struct ID3D10Device : public IUnknown
{
    void VSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void PSSetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void PSSetShader(struct ID3D10PixelShader * );
    void PSSetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void VSSetShader(struct ID3D10VertexShader * );
    void DrawIndexed(unsigned int ,unsigned int ,int );
    void Draw(unsigned int ,unsigned int );
    void PSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void IASetInputLayout(struct ID3D10InputLayout * );
    void IASetVertexBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** ,unsigned int * ,unsigned int * );
    void IASetIndexBuffer(struct ID3D10Buffer * ,enum DXGI_FORMAT ,unsigned int );
    void DrawIndexedInstanced(unsigned int ,unsigned int ,unsigned int ,int ,unsigned int );
    void DrawInstanced(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void GSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void GSSetShader(struct ID3D10GeometryShader * );
    void IASetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY );
    void VSSetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void VSSetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void SetPredication(struct ID3D10Predicate * ,int );
    void GSSetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void GSSetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void OMSetRenderTargets(unsigned int ,struct ID3D10RenderTargetView ** ,struct ID3D10DepthStencilView * );
    void OMSetBlendState(struct ID3D10BlendState * ,float * ,unsigned int );
    void OMSetDepthStencilState(struct ID3D10DepthStencilState * ,unsigned int );
    void SOSetTargets(unsigned int ,struct ID3D10Buffer ** ,unsigned int * );
    void DrawAuto();
    void RSSetState(struct ID3D10RasterizerState * );
    void RSSetViewports(unsigned int ,struct D3D10_VIEWPORT * );
    void RSSetScissorRects(unsigned int ,struct tagRECT * );
    void CopySubresourceRegion(struct ID3D10Resource * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct ID3D10Resource * ,unsigned int ,struct D3D10_BOX * );
    void CopyResource(struct ID3D10Resource * ,struct ID3D10Resource * );
    void UpdateSubresource(struct ID3D10Resource * ,unsigned int ,struct D3D10_BOX * ,void * ,unsigned int ,unsigned int );
    void ClearRenderTargetView(struct ID3D10RenderTargetView * ,float * );
    void ClearDepthStencilView(struct ID3D10DepthStencilView * ,unsigned int ,float ,unsigned int );
    void GenerateMips(struct ID3D10ShaderResourceView * );
    void ResolveSubresource(struct ID3D10Resource * ,unsigned int ,struct ID3D10Resource * ,unsigned int ,enum DXGI_FORMAT );
    void VSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void PSGetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void PSGetShader(struct ID3D10PixelShader ** );
    void PSGetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void VSGetShader(struct ID3D10VertexShader ** );
    void PSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void IAGetInputLayout(struct ID3D10InputLayout ** );
    void IAGetVertexBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** ,unsigned int * ,unsigned int * );
    void IAGetIndexBuffer(struct ID3D10Buffer ** ,enum DXGI_FORMAT * ,unsigned int * );
    void GSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D10Buffer ** );
    void GSGetShader(struct ID3D10GeometryShader ** );
    void IAGetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY * );
    void VSGetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void VSGetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void GetPredication(struct ID3D10Predicate ** ,int * );
    void GSGetShaderResources(unsigned int ,unsigned int ,struct ID3D10ShaderResourceView ** );
    void GSGetSamplers(unsigned int ,unsigned int ,struct ID3D10SamplerState ** );
    void OMGetRenderTargets(unsigned int ,struct ID3D10RenderTargetView ** ,struct ID3D10DepthStencilView ** );
    void OMGetBlendState(struct ID3D10BlendState ** ,float * ,unsigned int * );
    void OMGetDepthStencilState(struct ID3D10DepthStencilState ** ,unsigned int * );
    void SOGetTargets(unsigned int ,struct ID3D10Buffer ** ,unsigned int * );
    void RSGetState(struct ID3D10RasterizerState ** );
    void RSGetViewports(unsigned int * ,struct D3D10_VIEWPORT * );
    void RSGetScissorRects(unsigned int * ,struct tagRECT * );
    HRESULT GetDeviceRemovedReason();
    HRESULT SetExceptionMode(unsigned int );
    unsigned int GetExceptionMode();
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    void ClearState();
    void Flush();
    HRESULT CreateBuffer(struct D3D10_BUFFER_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Buffer ** );
    HRESULT CreateTexture1D(struct D3D10_TEXTURE1D_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Texture1D ** );
    HRESULT CreateTexture2D(struct D3D10_TEXTURE2D_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Texture2D ** );
    HRESULT CreateTexture3D(struct D3D10_TEXTURE3D_DESC * ,struct D3D10_SUBRESOURCE_DATA * ,struct ID3D10Texture3D ** );
    HRESULT CreateShaderResourceView(struct ID3D10Resource * ,struct D3D10_SHADER_RESOURCE_VIEW_DESC * ,struct ID3D10ShaderResourceView ** );
    HRESULT CreateRenderTargetView(struct ID3D10Resource * ,struct D3D10_RENDER_TARGET_VIEW_DESC * ,struct ID3D10RenderTargetView ** );
    HRESULT CreateDepthStencilView(struct ID3D10Resource * ,struct D3D10_DEPTH_STENCIL_VIEW_DESC * ,struct ID3D10DepthStencilView ** );
    HRESULT CreateInputLayout(struct D3D10_INPUT_ELEMENT_DESC * ,unsigned int ,void * ,unsigned long ,struct ID3D10InputLayout ** );
    HRESULT CreateVertexShader(void * ,unsigned long ,struct ID3D10VertexShader ** );
    HRESULT CreateGeometryShader(void * ,unsigned long ,struct ID3D10GeometryShader ** );
    HRESULT CreateGeometryShaderWithStreamOutput(void * ,unsigned long ,struct D3D10_SO_DECLARATION_ENTRY * ,unsigned int ,unsigned int ,struct ID3D10GeometryShader ** );
    HRESULT CreatePixelShader(void * ,unsigned long ,struct ID3D10PixelShader ** );
    HRESULT CreateBlendState(struct D3D10_BLEND_DESC * ,struct ID3D10BlendState ** );
    HRESULT CreateDepthStencilState(struct D3D10_DEPTH_STENCIL_DESC * ,struct ID3D10DepthStencilState ** );
    HRESULT CreateRasterizerState(struct D3D10_RASTERIZER_DESC * ,struct ID3D10RasterizerState ** );
    HRESULT CreateSamplerState(struct D3D10_SAMPLER_DESC * ,struct ID3D10SamplerState ** );
    HRESULT CreateQuery(struct D3D10_QUERY_DESC * ,struct ID3D10Query ** );
    HRESULT CreatePredicate(struct D3D10_QUERY_DESC * ,struct ID3D10Predicate ** );
    HRESULT CreateCounter(struct D3D10_COUNTER_DESC * ,struct ID3D10Counter ** );
    HRESULT CheckFormatSupport(enum DXGI_FORMAT ,unsigned int * );
    HRESULT CheckMultisampleQualityLevels(enum DXGI_FORMAT ,unsigned int ,unsigned int * );
    void CheckCounterInfo(struct D3D10_COUNTER_INFO * );
    HRESULT CheckCounter(struct D3D10_COUNTER_DESC * ,enum D3D10_COUNTER_TYPE * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * );
    unsigned int GetCreationFlags();
    HRESULT OpenSharedResource(void * ,struct _GUID & ,void ** );
    void SetTextFilterSize(unsigned int ,unsigned int );
    void GetTextFilterSize(unsigned int * ,unsigned int * );
    void ID3D10Device(struct ID3D10Device & );
    void ID3D10Device();
    struct ID3D10Device & operator=(struct ID3D10Device & );
};

struct ID3D11View : public ID3D11DeviceChild
{
    void GetResource(struct ID3D11Resource ** );
    void ID3D11View(struct ID3D11View & );
    void ID3D11View();
    struct ID3D11View & operator=(struct ID3D11View & );
};

struct ID3D11View : public ID3D11DeviceChild
{
    void GetResource(struct ID3D11Resource ** );
    void ID3D11View(struct ID3D11View & );
    void ID3D11View();
    struct ID3D11View & operator=(struct ID3D11View & );
};

struct IDirect3DPixelShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DPixelShader9(struct IDirect3DPixelShader9 & );
    void IDirect3DPixelShader9();
    struct IDirect3DPixelShader9 & operator=(struct IDirect3DPixelShader9 & );
};

struct IDirect3DPixelShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DPixelShader9(struct IDirect3DPixelShader9 & );
    void IDirect3DPixelShader9();
    struct IDirect3DPixelShader9 & operator=(struct IDirect3DPixelShader9 & );
};

struct tWAVEFORMATEX
{
    unsigned int wFormatTag;
    unsigned int nChannels;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
    unsigned int wBitsPerSample;
    unsigned int cbSize;
};

struct XAUDIO2_VOICE_SENDS
{
    unsigned int SendCount;
    struct XAUDIO2_SEND_DESCRIPTOR * pSends;
};

struct XAUDIO2_EFFECT_CHAIN
{
    unsigned int EffectCount;
    struct XAUDIO2_EFFECT_DESCRIPTOR * pEffectDescriptors;
};

struct XAUDIO2_DEBUG_CONFIGURATION
{
    unsigned int TraceMask;
    unsigned int BreakMask;
    int LogThreadID;
    int LogFileline;
    int LogFunctionName;
    int LogTiming;
};

struct IXAudio2 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDeviceCount(unsigned int * );
    HRESULT GetDeviceDetails(unsigned int ,struct XAUDIO2_DEVICE_DETAILS * );
    HRESULT Initialize(unsigned int ,enum XAUDIO2_WINDOWS_PROCESSOR_SPECIFIER );
    HRESULT RegisterForCallbacks(struct IXAudio2EngineCallback * );
    void UnregisterForCallbacks(struct IXAudio2EngineCallback * );
    HRESULT CreateSourceVoice(struct IXAudio2SourceVoice ** ,struct tWAVEFORMATEX * ,unsigned int ,float ,struct IXAudio2VoiceCallback * ,struct XAUDIO2_VOICE_SENDS * ,struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT CreateSubmixVoice(struct IXAudio2SubmixVoice ** ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct XAUDIO2_VOICE_SENDS * ,struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT CreateMasteringVoice(struct IXAudio2MasteringVoice ** ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT StartEngine();
    void StopEngine();
    HRESULT CommitChanges(unsigned int );
    void GetPerformanceData(struct XAUDIO2_PERFORMANCE_DATA * );
    void SetDebugConfiguration(struct XAUDIO2_DEBUG_CONFIGURATION * ,void * );
    void IXAudio2(struct IXAudio2 & );
    void IXAudio2();
    struct IXAudio2 & operator=(struct IXAudio2 & );
};

struct IXAudio2 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDeviceCount(unsigned int * );
    HRESULT GetDeviceDetails(unsigned int ,struct XAUDIO2_DEVICE_DETAILS * );
    HRESULT Initialize(unsigned int ,enum XAUDIO2_WINDOWS_PROCESSOR_SPECIFIER );
    HRESULT RegisterForCallbacks(struct IXAudio2EngineCallback * );
    void UnregisterForCallbacks(struct IXAudio2EngineCallback * );
    HRESULT CreateSourceVoice(struct IXAudio2SourceVoice ** ,struct tWAVEFORMATEX * ,unsigned int ,float ,struct IXAudio2VoiceCallback * ,struct XAUDIO2_VOICE_SENDS * ,struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT CreateSubmixVoice(struct IXAudio2SubmixVoice ** ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct XAUDIO2_VOICE_SENDS * ,struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT CreateMasteringVoice(struct IXAudio2MasteringVoice ** ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT StartEngine();
    void StopEngine();
    HRESULT CommitChanges(unsigned int );
    void GetPerformanceData(struct XAUDIO2_PERFORMANCE_DATA * );
    void SetDebugConfiguration(struct XAUDIO2_DEBUG_CONFIGURATION * ,void * );
    void IXAudio2(struct IXAudio2 & );
    void IXAudio2();
    struct IXAudio2 & operator=(struct IXAudio2 & );
};

struct tagTEXTMETRICA
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    unsigned int tmFirstChar;
    unsigned int tmLastChar;
    unsigned int tmDefaultChar;
    unsigned int tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
};

enum _D3DSWAPEFFECT
{
    D3DSWAPEFFECT_DISCARD=1,
    D3DSWAPEFFECT_FLIP=2,
    D3DSWAPEFFECT_COPY=3,
    D3DSWAPEFFECT_OVERLAY=4,
    D3DSWAPEFFECT_FLIPEX=5,
    D3DSWAPEFFECT_FORCE_DWORD=2147483647
};

struct _D3DPRESENT_PARAMETERS_
{
    unsigned int BackBufferWidth;
    unsigned int BackBufferHeight;
    enum _D3DFORMAT BackBufferFormat;
    unsigned int BackBufferCount;
    enum _D3DMULTISAMPLE_TYPE MultiSampleType;
    unsigned long MultiSampleQuality;
    enum _D3DSWAPEFFECT SwapEffect;
    struct HWND__ * hDeviceWindow;
    int Windowed;
    int EnableAutoDepthStencil;
    enum _D3DFORMAT AutoDepthStencilFormat;
    unsigned long Flags;
    unsigned int FullScreen_RefreshRateInHz;
    unsigned int PresentationInterval;
};

struct D2D_SIZE_U
{
    unsigned int width;
    unsigned int height;
};

struct D2D1_ROUNDED_RECT
{
    struct D2D_RECT_F rect;
    float radiusX;
    float radiusY;
};

enum DWRITE_FONT_FILE_TYPE
{
    DWRITE_FONT_FILE_TYPE_UNKNOWN=0,
    DWRITE_FONT_FILE_TYPE_CFF=1,
    DWRITE_FONT_FILE_TYPE_TRUETYPE=2,
    DWRITE_FONT_FILE_TYPE_TRUETYPE_COLLECTION=3,
    DWRITE_FONT_FILE_TYPE_TYPE1_PFM=4,
    DWRITE_FONT_FILE_TYPE_TYPE1_PFB=5,
    DWRITE_FONT_FILE_TYPE_VECTOR=6,
    DWRITE_FONT_FILE_TYPE_BITMAP=7
};

enum DWRITE_FONT_FACE_TYPE
{
    DWRITE_FONT_FACE_TYPE_CFF=0,
    DWRITE_FONT_FACE_TYPE_TRUETYPE=1,
    DWRITE_FONT_FACE_TYPE_TRUETYPE_COLLECTION=2,
    DWRITE_FONT_FACE_TYPE_TYPE1=3,
    DWRITE_FONT_FACE_TYPE_VECTOR=4,
    DWRITE_FONT_FACE_TYPE_BITMAP=5,
    DWRITE_FONT_FACE_TYPE_UNKNOWN=6
};

struct IDWriteFontFile : public IUnknown
{
    HRESULT GetReferenceKey(void ** ,unsigned int * );
    HRESULT GetLoader(struct IDWriteFontFileLoader ** );
    HRESULT Analyze(int * ,enum DWRITE_FONT_FILE_TYPE * ,enum DWRITE_FONT_FACE_TYPE * ,unsigned int * );
    void IDWriteFontFile(struct IDWriteFontFile & );
    void IDWriteFontFile();
    struct IDWriteFontFile & operator=(struct IDWriteFontFile & );
};

struct IDWriteFontFile : public IUnknown
{
    HRESULT GetReferenceKey(void ** ,unsigned int * );
    HRESULT GetLoader(struct IDWriteFontFileLoader ** );
    HRESULT Analyze(int * ,enum DWRITE_FONT_FILE_TYPE * ,enum DWRITE_FONT_FACE_TYPE * ,unsigned int * );
    void IDWriteFontFile(struct IDWriteFontFile & );
    void IDWriteFontFile();
    struct IDWriteFontFile & operator=(struct IDWriteFontFile & );
};

enum D3D11_MAP
{
    D3D11_MAP_READ=1,
    D3D11_MAP_WRITE=2,
    D3D11_MAP_READ_WRITE=3,
    D3D11_MAP_WRITE_DISCARD=4,
    D3D11_MAP_WRITE_NO_OVERWRITE=5
};

struct D3D11_VIEWPORT
{
    float TopLeftX;
    float TopLeftY;
    float Width;
    float Height;
    float MinDepth;
    float MaxDepth;
};

struct D3D11_BOX
{
    unsigned int left;
    unsigned int top;
    unsigned int front;
    unsigned int right;
    unsigned int bottom;
    unsigned int back;
};

enum D3D11_DEVICE_CONTEXT_TYPE
{
    D3D11_DEVICE_CONTEXT_IMMEDIATE=0,
    D3D11_DEVICE_CONTEXT_DEFERRED=1
};

struct ID3D11DeviceContext : public ID3D11DeviceChild
{
    void VSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void PSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void PSSetShader(struct ID3D11PixelShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void PSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void VSSetShader(struct ID3D11VertexShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void DrawIndexed(unsigned int ,unsigned int ,int );
    void Draw(unsigned int ,unsigned int );
    HRESULT Map(struct ID3D11Resource * ,unsigned int ,enum D3D11_MAP ,unsigned int ,struct D3D11_MAPPED_SUBRESOURCE * );
    void Unmap(struct ID3D11Resource * ,unsigned int );
    void PSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void IASetInputLayout(struct ID3D11InputLayout * );
    void IASetVertexBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** ,unsigned int * ,unsigned int * );
    void IASetIndexBuffer(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int );
    void DrawIndexedInstanced(unsigned int ,unsigned int ,unsigned int ,int ,unsigned int );
    void DrawInstanced(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void GSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void GSSetShader(struct ID3D11GeometryShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void IASetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY );
    void VSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void VSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void Begin(struct ID3D11Asynchronous * );
    void End(struct ID3D11Asynchronous * );
    HRESULT GetData(struct ID3D11Asynchronous * ,void * ,unsigned int ,unsigned int );
    void SetPredication(struct ID3D11Predicate * ,int );
    void GSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void GSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void OMSetRenderTargets(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView * );
    void OMSetRenderTargetsAndUnorderedAccessViews(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView * ,unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** ,unsigned int * );
    void OMSetBlendState(struct ID3D11BlendState * ,float * ,unsigned int );
    void OMSetDepthStencilState(struct ID3D11DepthStencilState * ,unsigned int );
    void SOSetTargets(unsigned int ,struct ID3D11Buffer ** ,unsigned int * );
    void DrawAuto();
    void DrawIndexedInstancedIndirect(struct ID3D11Buffer * ,unsigned int );
    void DrawInstancedIndirect(struct ID3D11Buffer * ,unsigned int );
    void Dispatch(unsigned int ,unsigned int ,unsigned int );
    void DispatchIndirect(struct ID3D11Buffer * ,unsigned int );
    void RSSetState(struct ID3D11RasterizerState * );
    void RSSetViewports(unsigned int ,struct D3D11_VIEWPORT * );
    void RSSetScissorRects(unsigned int ,struct tagRECT * );
    void CopySubresourceRegion(struct ID3D11Resource * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct ID3D11Resource * ,unsigned int ,struct D3D11_BOX * );
    void CopyResource(struct ID3D11Resource * ,struct ID3D11Resource * );
    void UpdateSubresource(struct ID3D11Resource * ,unsigned int ,struct D3D11_BOX * ,void * ,unsigned int ,unsigned int );
    void CopyStructureCount(struct ID3D11Buffer * ,unsigned int ,struct ID3D11UnorderedAccessView * );
    void ClearRenderTargetView(struct ID3D11RenderTargetView * ,float * );
    void ClearUnorderedAccessViewUint(struct ID3D11UnorderedAccessView * ,unsigned int * );
    void ClearUnorderedAccessViewFloat(struct ID3D11UnorderedAccessView * ,float * );
    void ClearDepthStencilView(struct ID3D11DepthStencilView * ,unsigned int ,float ,unsigned int );
    void GenerateMips(struct ID3D11ShaderResourceView * );
    void SetResourceMinLOD(struct ID3D11Resource * ,float );
    float GetResourceMinLOD(struct ID3D11Resource * );
    void ResolveSubresource(struct ID3D11Resource * ,unsigned int ,struct ID3D11Resource * ,unsigned int ,enum DXGI_FORMAT );
    void ExecuteCommandList(struct ID3D11CommandList * ,int );
    void HSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void HSSetShader(struct ID3D11HullShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void HSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void HSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void DSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void DSSetShader(struct ID3D11DomainShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void DSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void DSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void CSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void CSSetUnorderedAccessViews(unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** ,unsigned int * );
    void CSSetShader(struct ID3D11ComputeShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void CSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void CSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void VSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void PSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void PSGetShader(struct ID3D11PixelShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void PSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void VSGetShader(struct ID3D11VertexShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void PSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void IAGetInputLayout(struct ID3D11InputLayout ** );
    void IAGetVertexBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** ,unsigned int * ,unsigned int * );
    void IAGetIndexBuffer(struct ID3D11Buffer ** ,enum DXGI_FORMAT * ,unsigned int * );
    void GSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void GSGetShader(struct ID3D11GeometryShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void IAGetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY * );
    void VSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void VSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void GetPredication(struct ID3D11Predicate ** ,int * );
    void GSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void GSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void OMGetRenderTargets(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView ** );
    void OMGetRenderTargetsAndUnorderedAccessViews(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView ** ,unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** );
    void OMGetBlendState(struct ID3D11BlendState ** ,float * ,unsigned int * );
    void OMGetDepthStencilState(struct ID3D11DepthStencilState ** ,unsigned int * );
    void SOGetTargets(unsigned int ,struct ID3D11Buffer ** );
    void RSGetState(struct ID3D11RasterizerState ** );
    void RSGetViewports(unsigned int * ,struct D3D11_VIEWPORT * );
    void RSGetScissorRects(unsigned int * ,struct tagRECT * );
    void HSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void HSGetShader(struct ID3D11HullShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void HSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void HSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void DSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void DSGetShader(struct ID3D11DomainShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void DSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void DSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void CSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void CSGetUnorderedAccessViews(unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** );
    void CSGetShader(struct ID3D11ComputeShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void CSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void CSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void ClearState();
    void Flush();
    enum D3D11_DEVICE_CONTEXT_TYPE GetType();
    unsigned int GetContextFlags();
    HRESULT FinishCommandList(int ,struct ID3D11CommandList ** );
    void ID3D11DeviceContext(struct ID3D11DeviceContext & );
    void ID3D11DeviceContext();
    struct ID3D11DeviceContext & operator=(struct ID3D11DeviceContext & );
};

struct ID3D11DeviceContext : public ID3D11DeviceChild
{
    void VSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void PSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void PSSetShader(struct ID3D11PixelShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void PSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void VSSetShader(struct ID3D11VertexShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void DrawIndexed(unsigned int ,unsigned int ,int );
    void Draw(unsigned int ,unsigned int );
    HRESULT Map(struct ID3D11Resource * ,unsigned int ,enum D3D11_MAP ,unsigned int ,struct D3D11_MAPPED_SUBRESOURCE * );
    void Unmap(struct ID3D11Resource * ,unsigned int );
    void PSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void IASetInputLayout(struct ID3D11InputLayout * );
    void IASetVertexBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** ,unsigned int * ,unsigned int * );
    void IASetIndexBuffer(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int );
    void DrawIndexedInstanced(unsigned int ,unsigned int ,unsigned int ,int ,unsigned int );
    void DrawInstanced(unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void GSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void GSSetShader(struct ID3D11GeometryShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void IASetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY );
    void VSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void VSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void Begin(struct ID3D11Asynchronous * );
    void End(struct ID3D11Asynchronous * );
    HRESULT GetData(struct ID3D11Asynchronous * ,void * ,unsigned int ,unsigned int );
    void SetPredication(struct ID3D11Predicate * ,int );
    void GSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void GSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void OMSetRenderTargets(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView * );
    void OMSetRenderTargetsAndUnorderedAccessViews(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView * ,unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** ,unsigned int * );
    void OMSetBlendState(struct ID3D11BlendState * ,float * ,unsigned int );
    void OMSetDepthStencilState(struct ID3D11DepthStencilState * ,unsigned int );
    void SOSetTargets(unsigned int ,struct ID3D11Buffer ** ,unsigned int * );
    void DrawAuto();
    void DrawIndexedInstancedIndirect(struct ID3D11Buffer * ,unsigned int );
    void DrawInstancedIndirect(struct ID3D11Buffer * ,unsigned int );
    void Dispatch(unsigned int ,unsigned int ,unsigned int );
    void DispatchIndirect(struct ID3D11Buffer * ,unsigned int );
    void RSSetState(struct ID3D11RasterizerState * );
    void RSSetViewports(unsigned int ,struct D3D11_VIEWPORT * );
    void RSSetScissorRects(unsigned int ,struct tagRECT * );
    void CopySubresourceRegion(struct ID3D11Resource * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct ID3D11Resource * ,unsigned int ,struct D3D11_BOX * );
    void CopyResource(struct ID3D11Resource * ,struct ID3D11Resource * );
    void UpdateSubresource(struct ID3D11Resource * ,unsigned int ,struct D3D11_BOX * ,void * ,unsigned int ,unsigned int );
    void CopyStructureCount(struct ID3D11Buffer * ,unsigned int ,struct ID3D11UnorderedAccessView * );
    void ClearRenderTargetView(struct ID3D11RenderTargetView * ,float * );
    void ClearUnorderedAccessViewUint(struct ID3D11UnorderedAccessView * ,unsigned int * );
    void ClearUnorderedAccessViewFloat(struct ID3D11UnorderedAccessView * ,float * );
    void ClearDepthStencilView(struct ID3D11DepthStencilView * ,unsigned int ,float ,unsigned int );
    void GenerateMips(struct ID3D11ShaderResourceView * );
    void SetResourceMinLOD(struct ID3D11Resource * ,float );
    float GetResourceMinLOD(struct ID3D11Resource * );
    void ResolveSubresource(struct ID3D11Resource * ,unsigned int ,struct ID3D11Resource * ,unsigned int ,enum DXGI_FORMAT );
    void ExecuteCommandList(struct ID3D11CommandList * ,int );
    void HSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void HSSetShader(struct ID3D11HullShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void HSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void HSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void DSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void DSSetShader(struct ID3D11DomainShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void DSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void DSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void CSSetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void CSSetUnorderedAccessViews(unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** ,unsigned int * );
    void CSSetShader(struct ID3D11ComputeShader * ,struct ID3D11ClassInstance ** ,unsigned int );
    void CSSetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void CSSetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void VSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void PSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void PSGetShader(struct ID3D11PixelShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void PSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void VSGetShader(struct ID3D11VertexShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void PSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void IAGetInputLayout(struct ID3D11InputLayout ** );
    void IAGetVertexBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** ,unsigned int * ,unsigned int * );
    void IAGetIndexBuffer(struct ID3D11Buffer ** ,enum DXGI_FORMAT * ,unsigned int * );
    void GSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void GSGetShader(struct ID3D11GeometryShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void IAGetPrimitiveTopology(enum D3D_PRIMITIVE_TOPOLOGY * );
    void VSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void VSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void GetPredication(struct ID3D11Predicate ** ,int * );
    void GSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void GSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void OMGetRenderTargets(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView ** );
    void OMGetRenderTargetsAndUnorderedAccessViews(unsigned int ,struct ID3D11RenderTargetView ** ,struct ID3D11DepthStencilView ** ,unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** );
    void OMGetBlendState(struct ID3D11BlendState ** ,float * ,unsigned int * );
    void OMGetDepthStencilState(struct ID3D11DepthStencilState ** ,unsigned int * );
    void SOGetTargets(unsigned int ,struct ID3D11Buffer ** );
    void RSGetState(struct ID3D11RasterizerState ** );
    void RSGetViewports(unsigned int * ,struct D3D11_VIEWPORT * );
    void RSGetScissorRects(unsigned int * ,struct tagRECT * );
    void HSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void HSGetShader(struct ID3D11HullShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void HSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void HSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void DSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void DSGetShader(struct ID3D11DomainShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void DSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void DSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void CSGetShaderResources(unsigned int ,unsigned int ,struct ID3D11ShaderResourceView ** );
    void CSGetUnorderedAccessViews(unsigned int ,unsigned int ,struct ID3D11UnorderedAccessView ** );
    void CSGetShader(struct ID3D11ComputeShader ** ,struct ID3D11ClassInstance ** ,unsigned int * );
    void CSGetSamplers(unsigned int ,unsigned int ,struct ID3D11SamplerState ** );
    void CSGetConstantBuffers(unsigned int ,unsigned int ,struct ID3D11Buffer ** );
    void ClearState();
    void Flush();
    enum D3D11_DEVICE_CONTEXT_TYPE GetType();
    unsigned int GetContextFlags();
    HRESULT FinishCommandList(int ,struct ID3D11CommandList ** );
    void ID3D11DeviceContext(struct ID3D11DeviceContext & );
    void ID3D11DeviceContext();
    struct ID3D11DeviceContext & operator=(struct ID3D11DeviceContext & );
};

struct ID3D11Texture2D : public ID3D11Resource
{
    void GetDesc(struct D3D11_TEXTURE2D_DESC * );
    void ID3D11Texture2D(struct ID3D11Texture2D & );
    void ID3D11Texture2D();
    struct ID3D11Texture2D & operator=(struct ID3D11Texture2D & );
};

struct ID3D11Texture2D : public ID3D11Resource
{
    void GetDesc(struct D3D11_TEXTURE2D_DESC * );
    void ID3D11Texture2D(struct ID3D11Texture2D & );
    void ID3D11Texture2D();
    struct ID3D11Texture2D & operator=(struct ID3D11Texture2D & );
};

enum _MAX_FVF_DECL_SIZE
{
    MAX_FVF_DECL_SIZE=65
};

struct threadmbcinfostruct
{
};

struct localeinfo_struct
{
    struct threadlocaleinfostruct * locinfo;
    struct threadmbcinfostruct * mbcinfo;
};

enum D3D10_RESOURCE_DIMENSION
{
    D3D10_RESOURCE_DIMENSION_UNKNOWN=0,
    D3D10_RESOURCE_DIMENSION_BUFFER=1,
    D3D10_RESOURCE_DIMENSION_TEXTURE1D=2,
    D3D10_RESOURCE_DIMENSION_TEXTURE2D=3,
    D3D10_RESOURCE_DIMENSION_TEXTURE3D=4
};

struct ID3D10Resource : public ID3D10DeviceChild
{
    void GetType(enum D3D10_RESOURCE_DIMENSION * );
    void SetEvictionPriority(unsigned int );
    unsigned int GetEvictionPriority();
    void ID3D10Resource(struct ID3D10Resource & );
    void ID3D10Resource();
    struct ID3D10Resource & operator=(struct ID3D10Resource & );
};

struct ID3D10Resource : public ID3D10DeviceChild
{
    void GetType(enum D3D10_RESOURCE_DIMENSION * );
    void SetEvictionPriority(unsigned int );
    unsigned int GetEvictionPriority();
    void ID3D10Resource(struct ID3D10Resource & );
    void ID3D10Resource();
    struct ID3D10Resource & operator=(struct ID3D10Resource & );
};

enum D3D10_COLOR_WRITE_ENABLE
{
    D3D10_COLOR_WRITE_ENABLE_RED=1,
    D3D10_COLOR_WRITE_ENABLE_GREEN=2,
    D3D10_COLOR_WRITE_ENABLE_BLUE=4,
    D3D10_COLOR_WRITE_ENABLE_ALPHA=8,
    D3D10_COLOR_WRITE_ENABLE_ALL=15
};

enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER=1,
    CLSCTX_INPROC_HANDLER=2,
    CLSCTX_LOCAL_SERVER=4,
    CLSCTX_INPROC_SERVER16=8,
    CLSCTX_REMOTE_SERVER=16,
    CLSCTX_INPROC_HANDLER16=32,
    CLSCTX_RESERVED1=64,
    CLSCTX_RESERVED2=128,
    CLSCTX_RESERVED3=256,
    CLSCTX_RESERVED4=512,
    CLSCTX_NO_CODE_DOWNLOAD=1024,
    CLSCTX_RESERVED5=2048,
    CLSCTX_NO_CUSTOM_MARSHAL=4096,
    CLSCTX_ENABLE_CODE_DOWNLOAD=8192,
    CLSCTX_NO_FAILURE_LOG=16384,
    CLSCTX_DISABLE_AAA=32768,
    CLSCTX_ENABLE_AAA=65536,
    CLSCTX_FROM_DEFAULT_CONTEXT=131072,
    CLSCTX_ACTIVATE_32_BIT_SERVER=262144,
    CLSCTX_ACTIVATE_64_BIT_SERVER=524288,
    CLSCTX_ENABLE_CLOAKING=1048576,
    CLSCTX_PS_DLL=-2147483648
};

struct D3D10_TEXTURE1D_DESC
{
    unsigned int Width;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D11_DEPTH_STENCIL_DESC
{
    int DepthEnable;
    enum D3D11_DEPTH_WRITE_MASK DepthWriteMask;
    enum D3D11_COMPARISON_FUNC DepthFunc;
    int StencilEnable;
    unsigned int StencilReadMask;
    unsigned int StencilWriteMask;
    struct D3D11_DEPTH_STENCILOP_DESC FrontFace;
    struct D3D11_DEPTH_STENCILOP_DESC BackFace;
};

struct XAUDIO2_FILTER_PARAMETERS
{
    enum XAUDIO2_FILTER_TYPE Type;
    float Frequency;
    float OneOverQ;
};

struct IXAudio2SubmixVoice : public IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    void IXAudio2SubmixVoice(struct IXAudio2SubmixVoice & );
    void IXAudio2SubmixVoice();
    struct IXAudio2SubmixVoice & operator=(struct IXAudio2SubmixVoice & );
};

struct IXAudio2SubmixVoice : public IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    void IXAudio2SubmixVoice(struct IXAudio2SubmixVoice & );
    void IXAudio2SubmixVoice();
    struct IXAudio2SubmixVoice & operator=(struct IXAudio2SubmixVoice & );
};

struct _D3DMATRIX
{
    float _11;
    float _12;
    float _13;
    float _14;
    float _21;
    float _22;
    float _23;
    float _24;
    float _31;
    float _32;
    float _33;
    float _34;
    float _41;
    float _42;
    float _43;
    float _44;
    float m[4][4];
};

enum XAUDIO2_DEVICE_ROLE
{
    NotDefaultDevice=0,
    DefaultConsoleDevice=1,
    DefaultMultimediaDevice=2,
    DefaultCommunicationsDevice=4,
    DefaultGameDevice=8,
    GlobalDefaultDevice=15,
    InvalidDeviceRole=-16
};

struct _D3DX11_TEXTURE_LOAD_INFO
{
    struct D3D11_BOX * pSrcBox;
    struct D3D11_BOX * pDstBox;
    unsigned int SrcFirstMip;
    unsigned int DstFirstMip;
    unsigned int NumMips;
    unsigned int SrcFirstElement;
    unsigned int DstFirstElement;
    unsigned int NumElements;
    unsigned int Filter;
    unsigned int MipFilter;
    void _D3DX11_TEXTURE_LOAD_INFO();
};

struct D3D11_BOX
{
    unsigned int left;
    unsigned int top;
    unsigned int front;
    unsigned int right;
    unsigned int bottom;
    unsigned int back;
};

struct D3D11_TEX2DMS_SRV
{
    unsigned int UnusedField_NothingToDefine;
};

struct D3D11_BLEND_DESC
{
    int AlphaToCoverageEnable;
    int IndependentBlendEnable;
    struct D3D11_RENDER_TARGET_BLEND_DESC RenderTarget[8];
};

struct CD3D11_BLEND_DESC : public D3D11_BLEND_DESC
{
    void CD3D11_BLEND_DESC(struct CD3D11_DEFAULT );
    void CD3D11_BLEND_DESC(struct D3D11_BLEND_DESC & );
    void CD3D11_BLEND_DESC();
    void ~CD3D11_BLEND_DESC();
    struct D3D11_BLEND_DESC & operator const struct D3D11_BLEND_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_BLEND_DESC : public D3D11_BLEND_DESC
{
    void CD3D11_BLEND_DESC(struct CD3D11_DEFAULT );
    void CD3D11_BLEND_DESC(struct D3D11_BLEND_DESC & );
    void CD3D11_BLEND_DESC();
    void ~CD3D11_BLEND_DESC();
    struct D3D11_BLEND_DESC & operator const struct D3D11_BLEND_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3DX10_IMAGE_LOAD_INFO
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int FirstMipLevel;
    unsigned int MipLevels;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CpuAccessFlags;
    unsigned int MiscFlags;
    enum DXGI_FORMAT Format;
    unsigned int Filter;
    unsigned int MipFilter;
    struct D3DX10_IMAGE_INFO * pSrcInfo;
    void D3DX10_IMAGE_LOAD_INFO();
};

struct D3D11_TEXTURE3D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int MipLevels;
    enum DXGI_FORMAT Format;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct WICRect
{
    int X;
    int Y;
    int Width;
    int Height;
};

struct D3D11_DEPTH_STENCIL_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D11_DSV_DIMENSION ViewDimension;
    unsigned int Flags;
    struct D3D11_TEX1D_DSV Texture1D;
    struct D3D11_TEX1D_ARRAY_DSV Texture1DArray;
    struct D3D11_TEX2D_DSV Texture2D;
    struct D3D11_TEX2D_ARRAY_DSV Texture2DArray;
    struct D3D11_TEX2DMS_DSV Texture2DMS;
    struct D3D11_TEX2DMS_ARRAY_DSV Texture2DMSArray;
};

enum XAUDIO2_FILTER_TYPE
{
    LowPassFilter=0,
    BandPassFilter=1,
    HighPassFilter=2,
    NotchFilter=3
};

struct XAUDIO2_FILTER_PARAMETERS
{
    enum XAUDIO2_FILTER_TYPE Type;
    float Frequency;
    float OneOverQ;
};

struct ID3D11InputLayout : public ID3D11DeviceChild
{
    void ID3D11InputLayout(struct ID3D11InputLayout & );
    void ID3D11InputLayout();
    struct ID3D11InputLayout & operator=(struct ID3D11InputLayout & );
};

struct ID3D11InputLayout : public ID3D11DeviceChild
{
    void ID3D11InputLayout(struct ID3D11InputLayout & );
    void ID3D11InputLayout();
    struct ID3D11InputLayout & operator=(struct ID3D11InputLayout & );
};

struct _D3DX10_FONT_DESCA
{
    int Height;
    unsigned int Width;
    unsigned int Weight;
    unsigned int MipLevels;
    int Italic;
    unsigned int CharSet;
    unsigned int OutputPrecision;
    unsigned int Quality;
    unsigned int PitchAndFamily;
    char FaceName[32];
};

struct _D3DMATERIAL9
{
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Emissive;
    float Power;
};

struct IDXGIDeviceSubObject : public IDXGIObject
{
    HRESULT GetDevice(struct _GUID & ,void ** );
    void IDXGIDeviceSubObject(struct IDXGIDeviceSubObject & );
    void IDXGIDeviceSubObject();
    struct IDXGIDeviceSubObject & operator=(struct IDXGIDeviceSubObject & );
};

struct IDXGIDeviceSubObject : public IDXGIObject
{
    HRESULT GetDevice(struct _GUID & ,void ** );
    void IDXGIDeviceSubObject(struct IDXGIDeviceSubObject & );
    void IDXGIDeviceSubObject();
    struct IDXGIDeviceSubObject & operator=(struct IDXGIDeviceSubObject & );
};

struct D3DXVECTOR2
{
    void D3DXVECTOR2(float ,float );
    void D3DXVECTOR2(struct D3DXFLOAT16 * );
    void D3DXVECTOR2(float * );
    void D3DXVECTOR2();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR2 & operator+=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator-=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator*=(float );
    struct D3DXVECTOR2 & operator/=(float );
    struct D3DXVECTOR2 operator+(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator+();
    struct D3DXVECTOR2 operator-(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator-();
    struct D3DXVECTOR2 operator*(float );
    struct D3DXVECTOR2 operator/(float );
    int operator==(struct D3DXVECTOR2 & );
    int operator!=(struct D3DXVECTOR2 & );
    float x;
    float y;
};

struct D3DXVECTOR2
{
    void D3DXVECTOR2(float ,float );
    void D3DXVECTOR2(struct D3DXFLOAT16 * );
    void D3DXVECTOR2(float * );
    void D3DXVECTOR2();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR2 & operator+=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator-=(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 & operator*=(float );
    struct D3DXVECTOR2 & operator/=(float );
    struct D3DXVECTOR2 operator+(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator+();
    struct D3DXVECTOR2 operator-(struct D3DXVECTOR2 & );
    struct D3DXVECTOR2 operator-();
    struct D3DXVECTOR2 operator*(float );
    struct D3DXVECTOR2 operator/(float );
    int operator==(struct D3DXVECTOR2 & );
    int operator!=(struct D3DXVECTOR2 & );
    float x;
    float y;
};

struct D3D11_DEPTH_STENCILOP_DESC
{
    enum D3D11_STENCIL_OP StencilFailOp;
    enum D3D11_STENCIL_OP StencilDepthFailOp;
    enum D3D11_STENCIL_OP StencilPassOp;
    enum D3D11_COMPARISON_FUNC StencilFunc;
};

struct D3D11_TEX2D_UAV
{
    unsigned int MipSlice;
};

enum D2D1::ColorF::Enum
{
    AliceBlue=15792383,
    AntiqueWhite=16444375,
    Aqua=65535,
    Aquamarine=8388564,
    Azure=15794175,
    Beige=16119260,
    Bisque=16770244,
    Black=0,
    BlanchedAlmond=16772045,
    Blue=255,
    BlueViolet=9055202,
    Brown=10824234,
    BurlyWood=14596231,
    CadetBlue=6266528,
    Chartreuse=8388352,
    Chocolate=13789470,
    Coral=16744272,
    CornflowerBlue=6591981,
    Cornsilk=16775388,
    Crimson=14423100,
    Cyan=65535,
    DarkBlue=139,
    DarkCyan=35723,
    DarkGoldenrod=12092939,
    DarkGray=11119017,
    DarkGreen=25600,
    DarkKhaki=12433259,
    DarkMagenta=9109643,
    DarkOliveGreen=5597999,
    DarkOrange=16747520,
    DarkOrchid=10040012,
    DarkRed=9109504,
    DarkSalmon=15308410,
    DarkSeaGreen=9419919,
    DarkSlateBlue=4734347,
    DarkSlateGray=3100495,
    DarkTurquoise=52945,
    DarkViolet=9699539,
    DeepPink=16716947,
    DeepSkyBlue=49151,
    DimGray=6908265,
    DodgerBlue=2003199,
    Firebrick=11674146,
    FloralWhite=16775920,
    ForestGreen=2263842,
    Fuchsia=16711935,
    Gainsboro=14474460,
    GhostWhite=16316671,
    Gold=16766720,
    Goldenrod=14329120,
    Gray=8421504,
    Green=32768,
    GreenYellow=11403055,
    Honeydew=15794160,
    HotPink=16738740,
    IndianRed=13458524,
    Indigo=4915330,
    Ivory=16777200,
    Khaki=15787660,
    Lavender=15132410,
    LavenderBlush=16773365,
    LawnGreen=8190976,
    LemonChiffon=16775885,
    LightBlue=11393254,
    LightCoral=15761536,
    LightCyan=14745599,
    LightGoldenrodYellow=16448210,
    LightGreen=9498256,
    LightGray=13882323,
    LightPink=16758465,
    LightSalmon=16752762,
    LightSeaGreen=2142890,
    LightSkyBlue=8900346,
    LightSlateGray=7833753,
    LightSteelBlue=11584734,
    LightYellow=16777184,
    Lime=65280,
    LimeGreen=3329330,
    Linen=16445670,
    Magenta=16711935,
    Maroon=8388608,
    MediumAquamarine=6737322,
    MediumBlue=205,
    MediumOrchid=12211667,
    MediumPurple=9662683,
    MediumSeaGreen=3978097,
    MediumSlateBlue=8087790,
    MediumSpringGreen=64154,
    MediumTurquoise=4772300,
    MediumVioletRed=13047173,
    MidnightBlue=1644912,
    MintCream=16121850,
    MistyRose=16770273,
    Moccasin=16770229,
    NavajoWhite=16768685,
    Navy=128,
    OldLace=16643558,
    Olive=8421376,
    OliveDrab=7048739,
    Orange=16753920,
    OrangeRed=16729344,
    Orchid=14315734,
    PaleGoldenrod=15657130,
    PaleGreen=10025880,
    PaleTurquoise=11529966,
    PaleVioletRed=14381203,
    PapayaWhip=16773077,
    PeachPuff=16767673,
    Peru=13468991,
    Pink=16761035,
    Plum=14524637,
    PowderBlue=11591910,
    Purple=8388736,
    Red=16711680,
    RosyBrown=12357519,
    RoyalBlue=4286945,
    SaddleBrown=9127187,
    Salmon=16416882,
    SandyBrown=16032864,
    SeaGreen=3050327,
    SeaShell=16774638,
    Sienna=10506797,
    Silver=12632256,
    SkyBlue=8900331,
    SlateBlue=6970061,
    SlateGray=7372944,
    Snow=16775930,
    SpringGreen=65407,
    SteelBlue=4620980,
    Tan=13808780,
    Teal=32896,
    Thistle=14204888,
    Tomato=16737095,
    Turquoise=4251856,
    Violet=15631086,
    Wheat=16113331,
    White=16777215,
    WhiteSmoke=16119285,
    Yellow=16776960,
    YellowGreen=10145074
};

class D2D1::ColorF : public _D3DCOLORVALUE
{
    enum Enum
    {
        AliceBlue=15792383,
        AntiqueWhite=16444375,
        Aqua=65535,
        Aquamarine=8388564,
        Azure=15794175,
        Beige=16119260,
        Bisque=16770244,
        Black=0,
        BlanchedAlmond=16772045,
        Blue=255,
        BlueViolet=9055202,
        Brown=10824234,
        BurlyWood=14596231,
        CadetBlue=6266528,
        Chartreuse=8388352,
        Chocolate=13789470,
        Coral=16744272,
        CornflowerBlue=6591981,
        Cornsilk=16775388,
        Crimson=14423100,
        Cyan=65535,
        DarkBlue=139,
        DarkCyan=35723,
        DarkGoldenrod=12092939,
        DarkGray=11119017,
        DarkGreen=25600,
        DarkKhaki=12433259,
        DarkMagenta=9109643,
        DarkOliveGreen=5597999,
        DarkOrange=16747520,
        DarkOrchid=10040012,
        DarkRed=9109504,
        DarkSalmon=15308410,
        DarkSeaGreen=9419919,
        DarkSlateBlue=4734347,
        DarkSlateGray=3100495,
        DarkTurquoise=52945,
        DarkViolet=9699539,
        DeepPink=16716947,
        DeepSkyBlue=49151,
        DimGray=6908265,
        DodgerBlue=2003199,
        Firebrick=11674146,
        FloralWhite=16775920,
        ForestGreen=2263842,
        Fuchsia=16711935,
        Gainsboro=14474460,
        GhostWhite=16316671,
        Gold=16766720,
        Goldenrod=14329120,
        Gray=8421504,
        Green=32768,
        GreenYellow=11403055,
        Honeydew=15794160,
        HotPink=16738740,
        IndianRed=13458524,
        Indigo=4915330,
        Ivory=16777200,
        Khaki=15787660,
        Lavender=15132410,
        LavenderBlush=16773365,
        LawnGreen=8190976,
        LemonChiffon=16775885,
        LightBlue=11393254,
        LightCoral=15761536,
        LightCyan=14745599,
        LightGoldenrodYellow=16448210,
        LightGreen=9498256,
        LightGray=13882323,
        LightPink=16758465,
        LightSalmon=16752762,
        LightSeaGreen=2142890,
        LightSkyBlue=8900346,
        LightSlateGray=7833753,
        LightSteelBlue=11584734,
        LightYellow=16777184,
        Lime=65280,
        LimeGreen=3329330,
        Linen=16445670,
        Magenta=16711935,
        Maroon=8388608,
        MediumAquamarine=6737322,
        MediumBlue=205,
        MediumOrchid=12211667,
        MediumPurple=9662683,
        MediumSeaGreen=3978097,
        MediumSlateBlue=8087790,
        MediumSpringGreen=64154,
        MediumTurquoise=4772300,
        MediumVioletRed=13047173,
        MidnightBlue=1644912,
        MintCream=16121850,
        MistyRose=16770273,
        Moccasin=16770229,
        NavajoWhite=16768685,
        Navy=128,
        OldLace=16643558,
        Olive=8421376,
        OliveDrab=7048739,
        Orange=16753920,
        OrangeRed=16729344,
        Orchid=14315734,
        PaleGoldenrod=15657130,
        PaleGreen=10025880,
        PaleTurquoise=11529966,
        PaleVioletRed=14381203,
        PapayaWhip=16773077,
        PeachPuff=16767673,
        Peru=13468991,
        Pink=16761035,
        Plum=14524637,
        PowderBlue=11591910,
        Purple=8388736,
        Red=16711680,
        RosyBrown=12357519,
        RoyalBlue=4286945,
        SaddleBrown=9127187,
        Salmon=16416882,
        SandyBrown=16032864,
        SeaGreen=3050327,
        SeaShell=16774638,
        Sienna=10506797,
        Silver=12632256,
        SkyBlue=8900331,
        SlateBlue=6970061,
        SlateGray=7372944,
        Snow=16775930,
        SpringGreen=65407,
        SteelBlue=4620980,
        Tan=13808780,
        Teal=32896,
        Thistle=14204888,
        Tomato=16737095,
        Turquoise=4251856,
        Violet=15631086,
        Wheat=16113331,
        White=16777215,
        WhiteSmoke=16119285,
        Yellow=16776960,
        YellowGreen=10145074
    };
    public void ColorF(float ,float ,float ,float );
    public void ColorF(enum D2D1::ColorF::Enum ,float );
    public void ColorF(unsigned int ,float );
    private void Init(unsigned int ,float );
    private const unsigned int sc_redShift;
    private const unsigned int sc_greenShift;
    private const unsigned int sc_blueShift;
    private const unsigned int sc_redMask;
    private const unsigned int sc_greenMask;
    private const unsigned int sc_blueMask;
};

class D2D1::Matrix3x2F : public D2D_MATRIX_3X2_F
{
    public void Matrix3x2F();
    public void Matrix3x2F(float ,float ,float ,float ,float ,float );
    public class D2D1::Matrix3x2F Identity();
    public class D2D1::Matrix3x2F Translation(float ,float );
    public class D2D1::Matrix3x2F Translation(struct D2D_SIZE_F );
    public class D2D1::Matrix3x2F Scale(float ,float ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F Scale(struct D2D_SIZE_F ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F Rotation(float ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F Skew(float ,float ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F * ReinterpretBaseType(struct D2D_MATRIX_3X2_F * );
    public class D2D1::Matrix3x2F * ReinterpretBaseType(struct D2D_MATRIX_3X2_F * );
    public float Determinant();
    public bool IsInvertible();
    public bool Invert();
    public bool IsIdentity();
    public void SetProduct(class D2D1::Matrix3x2F & ,class D2D1::Matrix3x2F & );
    public class D2D1::Matrix3x2F operator*(class D2D1::Matrix3x2F & );
    public struct D2D_POINT_2F TransformPoint(struct D2D_POINT_2F );
};

struct D2D_MATRIX_3X2_F
{
    float _11;
    float _12;
    float _21;
    float _22;
    float _31;
    float _32;
};

class D2D1::Matrix3x2F : public D2D_MATRIX_3X2_F
{
    public void Matrix3x2F();
    public void Matrix3x2F(float ,float ,float ,float ,float ,float );
    public class D2D1::Matrix3x2F Identity();
    public class D2D1::Matrix3x2F Translation(float ,float );
    public class D2D1::Matrix3x2F Translation(struct D2D_SIZE_F );
    public class D2D1::Matrix3x2F Scale(float ,float ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F Scale(struct D2D_SIZE_F ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F Rotation(float ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F Skew(float ,float ,struct D2D_POINT_2F );
    public class D2D1::Matrix3x2F * ReinterpretBaseType(struct D2D_MATRIX_3X2_F * );
    public class D2D1::Matrix3x2F * ReinterpretBaseType(struct D2D_MATRIX_3X2_F * );
    public float Determinant();
    public bool IsInvertible();
    public bool Invert();
    public bool IsIdentity();
    public void SetProduct(class D2D1::Matrix3x2F & ,class D2D1::Matrix3x2F & );
    public class D2D1::Matrix3x2F operator*(class D2D1::Matrix3x2F & );
    public struct D2D_POINT_2F TransformPoint(struct D2D_POINT_2F );
};

struct IDirect3DResource9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    void IDirect3DResource9(struct IDirect3DResource9 & );
    void IDirect3DResource9();
    struct IDirect3DResource9 & operator=(struct IDirect3DResource9 & );
};

struct IDirect3DResource9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    void IDirect3DResource9(struct IDirect3DResource9 & );
    void IDirect3DResource9();
    struct IDirect3DResource9 & operator=(struct IDirect3DResource9 & );
};

enum _D3DSTATEBLOCKTYPE
{
    D3DSBT_ALL=1,
    D3DSBT_PIXELSTATE=2,
    D3DSBT_VERTEXSTATE=3,
    D3DSBT_FORCE_DWORD=2147483647
};

struct tagTEXTMETRICW
{
    long tmHeight;
    long tmAscent;
    long tmDescent;
    long tmInternalLeading;
    long tmExternalLeading;
    long tmAveCharWidth;
    long tmMaxCharWidth;
    long tmWeight;
    long tmOverhang;
    long tmDigitizedAspectX;
    long tmDigitizedAspectY;
    wchar_t tmFirstChar;
    wchar_t tmLastChar;
    wchar_t tmDefaultChar;
    wchar_t tmBreakChar;
    unsigned int tmItalic;
    unsigned int tmUnderlined;
    unsigned int tmStruckOut;
    unsigned int tmPitchAndFamily;
    unsigned int tmCharSet;
};

struct _D3DX10_FONT_DESCW
{
    int Height;
    unsigned int Width;
    unsigned int Weight;
    unsigned int MipLevels;
    int Italic;
    unsigned int CharSet;
    unsigned int OutputPrecision;
    unsigned int Quality;
    unsigned int PitchAndFamily;
    wchar_t FaceName[32];
};

struct D3D11_SAMPLER_DESC
{
    enum D3D11_FILTER Filter;
    enum D3D11_TEXTURE_ADDRESS_MODE AddressU;
    enum D3D11_TEXTURE_ADDRESS_MODE AddressV;
    enum D3D11_TEXTURE_ADDRESS_MODE AddressW;
    float MipLODBias;
    unsigned int MaxAnisotropy;
    enum D3D11_COMPARISON_FUNC ComparisonFunc;
    float BorderColor[4];
    float MinLOD;
    float MaxLOD;
};

struct XMA2WAVEFORMATEX
{
    struct tWAVEFORMATEX wfx;
    unsigned int NumStreams;
    unsigned long ChannelMask;
    unsigned long SamplesEncoded;
    unsigned long BytesPerBlock;
    unsigned long PlayBegin;
    unsigned long PlayLength;
    unsigned long LoopBegin;
    unsigned long LoopLength;
    unsigned int LoopCount;
    unsigned int EncoderVersion;
    unsigned int BlockCount;
};

struct ID2D1DrawingStateBlock : public ID2D1Resource
{
    void GetDescription(struct D2D1_DRAWING_STATE_DESCRIPTION * );
    void SetDescription(struct D2D1_DRAWING_STATE_DESCRIPTION & );
    void SetDescription(struct D2D1_DRAWING_STATE_DESCRIPTION * );
    void SetTextRenderingParams(struct IDWriteRenderingParams * );
    void GetTextRenderingParams(struct IDWriteRenderingParams ** );
    void ID2D1DrawingStateBlock(struct ID2D1DrawingStateBlock & );
    void ID2D1DrawingStateBlock();
    struct ID2D1DrawingStateBlock & operator=(struct ID2D1DrawingStateBlock & );
};

struct D2D1_DRAWING_STATE_DESCRIPTION
{
    enum D2D1_ANTIALIAS_MODE antialiasMode;
    enum D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode;
    unsigned int tag1;
    unsigned int tag2;
    struct D2D_MATRIX_3X2_F transform;
};

struct ID2D1DrawingStateBlock : public ID2D1Resource
{
    void GetDescription(struct D2D1_DRAWING_STATE_DESCRIPTION * );
    void SetDescription(struct D2D1_DRAWING_STATE_DESCRIPTION & );
    void SetDescription(struct D2D1_DRAWING_STATE_DESCRIPTION * );
    void SetTextRenderingParams(struct IDWriteRenderingParams * );
    void GetTextRenderingParams(struct IDWriteRenderingParams ** );
    void ID2D1DrawingStateBlock(struct ID2D1DrawingStateBlock & );
    void ID2D1DrawingStateBlock();
    struct ID2D1DrawingStateBlock & operator=(struct ID2D1DrawingStateBlock & );
};

struct D2D1_ELLIPSE
{
    struct D2D_POINT_2F point;
    float radiusX;
    float radiusY;
};

enum _D3DQUERYTYPE
{
    D3DQUERYTYPE_VCACHE=4,
    D3DQUERYTYPE_RESOURCEMANAGER=5,
    D3DQUERYTYPE_VERTEXSTATS=6,
    D3DQUERYTYPE_EVENT=8,
    D3DQUERYTYPE_OCCLUSION=9,
    D3DQUERYTYPE_TIMESTAMP=10,
    D3DQUERYTYPE_TIMESTAMPDISJOINT=11,
    D3DQUERYTYPE_TIMESTAMPFREQ=12,
    D3DQUERYTYPE_PIPELINETIMINGS=13,
    D3DQUERYTYPE_INTERFACETIMINGS=14,
    D3DQUERYTYPE_VERTEXTIMINGS=15,
    D3DQUERYTYPE_PIXELTIMINGS=16,
    D3DQUERYTYPE_BANDWIDTHTIMINGS=17,
    D3DQUERYTYPE_CACHEUTILIZATION=18,
    D3DQUERYTYPE_MEMORYPRESSURE=19
};

struct D3D11_TEX2DMS_DSV
{
    unsigned int UnusedField_NothingToDefine;
};

struct D2D_RECT_U
{
    unsigned int left;
    unsigned int top;
    unsigned int right;
    unsigned int bottom;
};

struct IDirect3DVertexDeclaration9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDeclaration(struct _D3DVERTEXELEMENT9 * ,unsigned int * );
    void IDirect3DVertexDeclaration9(struct IDirect3DVertexDeclaration9 & );
    void IDirect3DVertexDeclaration9();
    struct IDirect3DVertexDeclaration9 & operator=(struct IDirect3DVertexDeclaration9 & );
};

struct IDirect3DVertexDeclaration9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDeclaration(struct _D3DVERTEXELEMENT9 * ,unsigned int * );
    void IDirect3DVertexDeclaration9(struct IDirect3DVertexDeclaration9 & );
    void IDirect3DVertexDeclaration9();
    struct IDirect3DVertexDeclaration9 & operator=(struct IDirect3DVertexDeclaration9 & );
};

enum _D3DTEXTURESTAGESTATETYPE
{
    D3DTSS_COLOROP=1,
    D3DTSS_COLORARG1=2,
    D3DTSS_COLORARG2=3,
    D3DTSS_ALPHAOP=4,
    D3DTSS_ALPHAARG1=5,
    D3DTSS_ALPHAARG2=6,
    D3DTSS_BUMPENVMAT00=7,
    D3DTSS_BUMPENVMAT01=8,
    D3DTSS_BUMPENVMAT10=9,
    D3DTSS_BUMPENVMAT11=10,
    D3DTSS_TEXCOORDINDEX=11,
    D3DTSS_BUMPENVLSCALE=22,
    D3DTSS_BUMPENVLOFFSET=23,
    D3DTSS_TEXTURETRANSFORMFLAGS=24,
    D3DTSS_COLORARG0=26,
    D3DTSS_ALPHAARG0=27,
    D3DTSS_RESULTARG=28,
    D3DTSS_CONSTANT=32,
    D3DTSS_FORCE_DWORD=2147483647
};

struct D3D11_TEX2DMS_RTV
{
    unsigned int UnusedField_NothingToDefine;
};

struct DXGI_SURFACE_DESC
{
    unsigned int Width;
    unsigned int Height;
    enum DXGI_FORMAT Format;
    struct DXGI_SAMPLE_DESC SampleDesc;
};

struct IDirect3D9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT RegisterSoftwareDevice(void * );
    unsigned int GetAdapterCount();
    HRESULT GetAdapterIdentifier(unsigned int ,unsigned long ,struct _D3DADAPTER_IDENTIFIER9 * );
    unsigned int GetAdapterModeCount(unsigned int ,enum _D3DFORMAT );
    HRESULT EnumAdapterModes(unsigned int ,enum _D3DFORMAT ,unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetAdapterDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT CheckDeviceType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,int );
    HRESULT CheckDeviceFormat(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,unsigned long ,enum _D3DRESOURCETYPE ,enum _D3DFORMAT );
    HRESULT CheckDeviceMultiSampleType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,int ,enum _D3DMULTISAMPLE_TYPE ,unsigned long * );
    HRESULT CheckDepthStencilMatch(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT CheckDeviceFormatConversion(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT GetDeviceCaps(unsigned int ,enum _D3DDEVTYPE ,struct _D3DCAPS9 * );
    struct HMONITOR__ * GetAdapterMonitor(unsigned int );
    HRESULT CreateDevice(unsigned int ,enum _D3DDEVTYPE ,struct HWND__ * ,unsigned long ,struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DDevice9 ** );
    void IDirect3D9(struct IDirect3D9 & );
    void IDirect3D9();
    struct IDirect3D9 & operator=(struct IDirect3D9 & );
};

struct IDirect3D9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT RegisterSoftwareDevice(void * );
    unsigned int GetAdapterCount();
    HRESULT GetAdapterIdentifier(unsigned int ,unsigned long ,struct _D3DADAPTER_IDENTIFIER9 * );
    unsigned int GetAdapterModeCount(unsigned int ,enum _D3DFORMAT );
    HRESULT EnumAdapterModes(unsigned int ,enum _D3DFORMAT ,unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetAdapterDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT CheckDeviceType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,int );
    HRESULT CheckDeviceFormat(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,unsigned long ,enum _D3DRESOURCETYPE ,enum _D3DFORMAT );
    HRESULT CheckDeviceMultiSampleType(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,int ,enum _D3DMULTISAMPLE_TYPE ,unsigned long * );
    HRESULT CheckDepthStencilMatch(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT CheckDeviceFormatConversion(unsigned int ,enum _D3DDEVTYPE ,enum _D3DFORMAT ,enum _D3DFORMAT );
    HRESULT GetDeviceCaps(unsigned int ,enum _D3DDEVTYPE ,struct _D3DCAPS9 * );
    struct HMONITOR__ * GetAdapterMonitor(unsigned int );
    HRESULT CreateDevice(unsigned int ,enum _D3DDEVTYPE ,struct HWND__ * ,unsigned long ,struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DDevice9 ** );
    void IDirect3D9(struct IDirect3D9 & );
    void IDirect3D9();
    struct IDirect3D9 & operator=(struct IDirect3D9 & );
};

enum _D3DTEXTUREFILTERTYPE
{
    D3DTEXF_NONE=0,
    D3DTEXF_POINT=1,
    D3DTEXF_LINEAR=2,
    D3DTEXF_ANISOTROPIC=3,
    D3DTEXF_PYRAMIDALQUAD=6,
    D3DTEXF_GAUSSIANQUAD=7,
    D3DTEXF_CONVOLUTIONMONO=8,
    D3DTEXF_FORCE_DWORD=2147483647
};

struct IDirect3DBaseTexture9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    void IDirect3DBaseTexture9(struct IDirect3DBaseTexture9 & );
    void IDirect3DBaseTexture9();
    struct IDirect3DBaseTexture9 & operator=(struct IDirect3DBaseTexture9 & );
};

struct IDirect3DBaseTexture9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    void IDirect3DBaseTexture9(struct IDirect3DBaseTexture9 & );
    void IDirect3DBaseTexture9();
    struct IDirect3DBaseTexture9 & operator=(struct IDirect3DBaseTexture9 & );
};

struct ID3D11Texture1D : public ID3D11Resource
{
    void GetDesc(struct D3D11_TEXTURE1D_DESC * );
    void ID3D11Texture1D(struct ID3D11Texture1D & );
    void ID3D11Texture1D();
    struct ID3D11Texture1D & operator=(struct ID3D11Texture1D & );
};

struct ID3D11Texture1D : public ID3D11Resource
{
    void GetDesc(struct D3D11_TEXTURE1D_DESC * );
    void ID3D11Texture1D(struct ID3D11Texture1D & );
    void ID3D11Texture1D();
    struct ID3D11Texture1D & operator=(struct ID3D11Texture1D & );
};

struct D3D11_BUFFER_DESC
{
    unsigned int ByteWidth;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
    unsigned int StructureByteStride;
};

struct CD3D11_BUFFER_DESC : public D3D11_BUFFER_DESC
{
    void CD3D11_BUFFER_DESC(unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_BUFFER_DESC(struct D3D11_BUFFER_DESC & );
    void CD3D11_BUFFER_DESC();
    void ~CD3D11_BUFFER_DESC();
    struct D3D11_BUFFER_DESC & operator const struct D3D11_BUFFER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_BUFFER_DESC : public D3D11_BUFFER_DESC
{
    void CD3D11_BUFFER_DESC(unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_BUFFER_DESC(struct D3D11_BUFFER_DESC & );
    void CD3D11_BUFFER_DESC();
    void ~CD3D11_BUFFER_DESC();
    struct D3D11_BUFFER_DESC & operator const struct D3D11_BUFFER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct ID2D1StrokeStyle : public ID2D1Resource
{
    enum D2D1_CAP_STYLE GetStartCap();
    enum D2D1_CAP_STYLE GetEndCap();
    enum D2D1_CAP_STYLE GetDashCap();
    float GetMiterLimit();
    enum D2D1_LINE_JOIN GetLineJoin();
    float GetDashOffset();
    enum D2D1_DASH_STYLE GetDashStyle();
    unsigned int GetDashesCount();
    void GetDashes(float * ,unsigned int );
    void ID2D1StrokeStyle(struct ID2D1StrokeStyle & );
    void ID2D1StrokeStyle();
    struct ID2D1StrokeStyle & operator=(struct ID2D1StrokeStyle & );
};

struct ID2D1StrokeStyle : public ID2D1Resource
{
    enum D2D1_CAP_STYLE GetStartCap();
    enum D2D1_CAP_STYLE GetEndCap();
    enum D2D1_CAP_STYLE GetDashCap();
    float GetMiterLimit();
    enum D2D1_LINE_JOIN GetLineJoin();
    float GetDashOffset();
    enum D2D1_DASH_STYLE GetDashStyle();
    unsigned int GetDashesCount();
    void GetDashes(float * ,unsigned int );
    void ID2D1StrokeStyle(struct ID2D1StrokeStyle & );
    void ID2D1StrokeStyle();
    struct ID2D1StrokeStyle & operator=(struct ID2D1StrokeStyle & );
};

struct D3D11_TEX3D_UAV
{
    unsigned int MipSlice;
    unsigned int FirstWSlice;
    unsigned int WSize;
};

struct ID3D11DomainShader : public ID3D11DeviceChild
{
    void ID3D11DomainShader(struct ID3D11DomainShader & );
    void ID3D11DomainShader();
    struct ID3D11DomainShader & operator=(struct ID3D11DomainShader & );
};

struct ID3D11DomainShader : public ID3D11DeviceChild
{
    void ID3D11DomainShader(struct ID3D11DomainShader & );
    void ID3D11DomainShader();
    struct ID3D11DomainShader & operator=(struct ID3D11DomainShader & );
};

struct ID2D1BitmapRenderTarget : public ID2D1RenderTarget
{
    HRESULT GetBitmap(struct ID2D1Bitmap ** );
    void ID2D1BitmapRenderTarget(struct ID2D1BitmapRenderTarget & );
    void ID2D1BitmapRenderTarget();
    struct ID2D1BitmapRenderTarget & operator=(struct ID2D1BitmapRenderTarget & );
};

struct ID2D1BitmapRenderTarget : public ID2D1RenderTarget
{
    HRESULT GetBitmap(struct ID2D1Bitmap ** );
    void ID2D1BitmapRenderTarget(struct ID2D1BitmapRenderTarget & );
    void ID2D1BitmapRenderTarget();
    struct ID2D1BitmapRenderTarget & operator=(struct ID2D1BitmapRenderTarget & );
};

struct ID3D11DeviceChild : public IUnknown
{
    void GetDevice(struct ID3D11Device ** );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    void ID3D11DeviceChild(struct ID3D11DeviceChild & );
    void ID3D11DeviceChild();
    struct ID3D11DeviceChild & operator=(struct ID3D11DeviceChild & );
};

struct ID3D11DeviceChild : public IUnknown
{
    void GetDevice(struct ID3D11Device ** );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    void ID3D11DeviceChild(struct ID3D11DeviceChild & );
    void ID3D11DeviceChild();
    struct ID3D11DeviceChild & operator=(struct ID3D11DeviceChild & );
};

struct D3D11_TEX1D_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D3D11_TEXTURE1D_DESC
{
    unsigned int Width;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct CD3D11_TEXTURE1D_DESC : public D3D11_TEXTURE1D_DESC
{
    void CD3D11_TEXTURE1D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int );
    void CD3D11_TEXTURE1D_DESC(struct D3D11_TEXTURE1D_DESC & );
    void CD3D11_TEXTURE1D_DESC();
    void ~CD3D11_TEXTURE1D_DESC();
    struct D3D11_TEXTURE1D_DESC & operator const struct D3D11_TEXTURE1D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_TEXTURE1D_DESC : public D3D11_TEXTURE1D_DESC
{
    void CD3D11_TEXTURE1D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int );
    void CD3D11_TEXTURE1D_DESC(struct D3D11_TEXTURE1D_DESC & );
    void CD3D11_TEXTURE1D_DESC();
    void ~CD3D11_TEXTURE1D_DESC();
    struct D3D11_TEXTURE1D_DESC & operator const struct D3D11_TEXTURE1D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEX1D_DSV
{
    unsigned int MipSlice;
};

enum D3D11_INPUT_CLASSIFICATION
{
    D3D11_INPUT_PER_VERTEX_DATA=0,
    D3D11_INPUT_PER_INSTANCE_DATA=1
};

struct D3D11_INPUT_ELEMENT_DESC
{
    char * SemanticName;
    unsigned int SemanticIndex;
    enum DXGI_FORMAT Format;
    unsigned int InputSlot;
    unsigned int AlignedByteOffset;
    enum D3D11_INPUT_CLASSIFICATION InputSlotClass;
    unsigned int InstanceDataStepRate;
};

struct _D3DVOLUME_DESC
{
    enum _D3DFORMAT Format;
    enum _D3DRESOURCETYPE Type;
    unsigned long Usage;
    enum _D3DPOOL Pool;
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
};

struct tWAVEFORMATEX
{
    unsigned int wFormatTag;
    unsigned int nChannels;
    unsigned long nSamplesPerSec;
    unsigned long nAvgBytesPerSec;
    unsigned int nBlockAlign;
    unsigned int wBitsPerSample;
    unsigned int cbSize;
};

enum _D3DTRANSFORMSTATETYPE
{
    D3DTS_VIEW=2,
    D3DTS_PROJECTION=3,
    D3DTS_TEXTURE0=16,
    D3DTS_TEXTURE1=17,
    D3DTS_TEXTURE2=18,
    D3DTS_TEXTURE3=19,
    D3DTS_TEXTURE4=20,
    D3DTS_TEXTURE5=21,
    D3DTS_TEXTURE6=22,
    D3DTS_TEXTURE7=23,
    D3DTS_FORCE_DWORD=2147483647
};

struct DWRITE_GLYPH_OFFSET
{
    float advanceOffset;
    float ascenderOffset;
};

enum DWRITE_RENDERING_MODE
{
    DWRITE_RENDERING_MODE_DEFAULT=0,
    DWRITE_RENDERING_MODE_ALIASED=1,
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_CLASSIC=2,
    DWRITE_RENDERING_MODE_CLEARTYPE_GDI_NATURAL=3,
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL=4,
    DWRITE_RENDERING_MODE_CLEARTYPE_NATURAL_SYMMETRIC=5,
    DWRITE_RENDERING_MODE_OUTLINE=6
};

struct DWRITE_MATRIX
{
    float m11;
    float m12;
    float m21;
    float m22;
    float dx;
    float dy;
};

struct IDWriteFontFace : public IUnknown
{
    enum DWRITE_FONT_FACE_TYPE GetType();
    HRESULT GetFiles(unsigned int * ,struct IDWriteFontFile ** );
    unsigned int GetIndex();
    enum DWRITE_FONT_SIMULATIONS GetSimulations();
    int IsSymbolFont();
    void GetMetrics(struct DWRITE_FONT_METRICS * );
    unsigned int GetGlyphCount();
    HRESULT GetDesignGlyphMetrics(unsigned int * ,unsigned int ,struct DWRITE_GLYPH_METRICS * ,int );
    HRESULT GetGlyphIndicesA(unsigned int * ,unsigned int ,unsigned int * );
    HRESULT TryGetFontTable(unsigned int ,void ** ,unsigned int * ,void ** ,int * );
    void ReleaseFontTable(void * );
    HRESULT GetGlyphRunOutline(float ,unsigned int * ,float * ,struct DWRITE_GLYPH_OFFSET * ,unsigned int ,int ,int ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT GetRecommendedRenderingMode(float ,float ,enum DWRITE_MEASURING_MODE ,struct IDWriteRenderingParams * ,enum DWRITE_RENDERING_MODE * );
    HRESULT GetGdiCompatibleMetrics(float ,float ,struct DWRITE_MATRIX * ,struct DWRITE_FONT_METRICS * );
    HRESULT GetGdiCompatibleGlyphMetrics(float ,float ,struct DWRITE_MATRIX * ,int ,unsigned int * ,unsigned int ,struct DWRITE_GLYPH_METRICS * ,int );
    void IDWriteFontFace(struct IDWriteFontFace & );
    void IDWriteFontFace();
    struct IDWriteFontFace & operator=(struct IDWriteFontFace & );
};

struct IDWriteFontFace : public IUnknown
{
    enum DWRITE_FONT_FACE_TYPE GetType();
    HRESULT GetFiles(unsigned int * ,struct IDWriteFontFile ** );
    unsigned int GetIndex();
    enum DWRITE_FONT_SIMULATIONS GetSimulations();
    int IsSymbolFont();
    void GetMetrics(struct DWRITE_FONT_METRICS * );
    unsigned int GetGlyphCount();
    HRESULT GetDesignGlyphMetrics(unsigned int * ,unsigned int ,struct DWRITE_GLYPH_METRICS * ,int );
    HRESULT GetGlyphIndicesA(unsigned int * ,unsigned int ,unsigned int * );
    HRESULT TryGetFontTable(unsigned int ,void ** ,unsigned int * ,void ** ,int * );
    void ReleaseFontTable(void * );
    HRESULT GetGlyphRunOutline(float ,unsigned int * ,float * ,struct DWRITE_GLYPH_OFFSET * ,unsigned int ,int ,int ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT GetRecommendedRenderingMode(float ,float ,enum DWRITE_MEASURING_MODE ,struct IDWriteRenderingParams * ,enum DWRITE_RENDERING_MODE * );
    HRESULT GetGdiCompatibleMetrics(float ,float ,struct DWRITE_MATRIX * ,struct DWRITE_FONT_METRICS * );
    HRESULT GetGdiCompatibleGlyphMetrics(float ,float ,struct DWRITE_MATRIX * ,int ,unsigned int * ,unsigned int ,struct DWRITE_GLYPH_METRICS * ,int );
    void IDWriteFontFace(struct IDWriteFontFace & );
    void IDWriteFontFace();
    struct IDWriteFontFace & operator=(struct IDWriteFontFace & );
};

enum _D3DCUBEMAP_FACES
{
    D3DCUBEMAP_FACE_POSITIVE_X=0,
    D3DCUBEMAP_FACE_NEGATIVE_X=1,
    D3DCUBEMAP_FACE_POSITIVE_Y=2,
    D3DCUBEMAP_FACE_NEGATIVE_Y=3,
    D3DCUBEMAP_FACE_POSITIVE_Z=4,
    D3DCUBEMAP_FACE_NEGATIVE_Z=5,
    D3DCUBEMAP_FACE_FORCE_DWORD=2147483647
};

enum D3D10_BIND_FLAG
{
    D3D10_BIND_VERTEX_BUFFER=1,
    D3D10_BIND_INDEX_BUFFER=2,
    D3D10_BIND_CONSTANT_BUFFER=4,
    D3D10_BIND_SHADER_RESOURCE=8,
    D3D10_BIND_STREAM_OUTPUT=16,
    D3D10_BIND_RENDER_TARGET=32,
    D3D10_BIND_DEPTH_STENCIL=64
};

struct CD3D11_RECT : public tagRECT
{
    void CD3D11_RECT(long ,long ,long ,long );
    void CD3D11_RECT(struct tagRECT & );
    void CD3D11_RECT();
    void ~CD3D11_RECT();
    struct tagRECT & operator const struct tagRECT &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_RECT : public tagRECT
{
    void CD3D11_RECT(long ,long ,long ,long );
    void CD3D11_RECT(struct tagRECT & );
    void CD3D11_RECT();
    void ~CD3D11_RECT();
    struct tagRECT & operator const struct tagRECT &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_BOX : public D3D11_BOX
{
    void CD3D11_BOX(long ,long ,long ,long ,long ,long );
    void CD3D11_BOX(struct D3D11_BOX & );
    void CD3D11_BOX();
    void ~CD3D11_BOX();
    struct D3D11_BOX & operator const struct D3D11_BOX &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_BOX : public D3D11_BOX
{
    void CD3D11_BOX(long ,long ,long ,long ,long ,long );
    void CD3D11_BOX(struct D3D11_BOX & );
    void CD3D11_BOX();
    void ~CD3D11_BOX();
    struct D3D11_BOX & operator const struct D3D11_BOX &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEX1D_ARRAY_RTV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct ID2D1PathGeometry : public ID2D1Geometry
{
    HRESULT Open(struct ID2D1GeometrySink ** );
    HRESULT Stream(struct ID2D1GeometrySink * );
    HRESULT GetSegmentCount(unsigned int * );
    HRESULT GetFigureCount(unsigned int * );
    void ID2D1PathGeometry(struct ID2D1PathGeometry & );
    void ID2D1PathGeometry();
    struct ID2D1PathGeometry & operator=(struct ID2D1PathGeometry & );
};

struct ID2D1PathGeometry : public ID2D1Geometry
{
    HRESULT Open(struct ID2D1GeometrySink ** );
    HRESULT Stream(struct ID2D1GeometrySink * );
    HRESULT GetSegmentCount(unsigned int * );
    HRESULT GetFigureCount(unsigned int * );
    void ID2D1PathGeometry(struct ID2D1PathGeometry & );
    void ID2D1PathGeometry();
    struct ID2D1PathGeometry & operator=(struct ID2D1PathGeometry & );
};

struct D3D11_QUERY_DESC
{
    enum D3D11_QUERY Query;
    unsigned int MiscFlags;
};

struct D3DXVECTOR4_16F
{
    void D3DXVECTOR4_16F(struct D3DXVECTOR4_16F & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXVECTOR3_16F & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR4_16F(float * );
    void D3DXVECTOR4_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR4_16F & );
    int operator!=(struct D3DXVECTOR4_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
    struct D3DXFLOAT16 w;
};

struct D3DXVECTOR3_16F
{
    void D3DXVECTOR3_16F(struct D3DXVECTOR3_16F & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR3_16F(struct _D3DVECTOR & );
    void D3DXVECTOR3_16F(float * );
    void D3DXVECTOR3_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR3_16F & );
    int operator!=(struct D3DXVECTOR3_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
};

struct D3DXVECTOR4_16F
{
    void D3DXVECTOR4_16F(struct D3DXVECTOR4_16F & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXVECTOR3_16F & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR4_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR4_16F(float * );
    void D3DXVECTOR4_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR4_16F & );
    int operator!=(struct D3DXVECTOR4_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
    struct D3DXFLOAT16 w;
};

struct D3D11_TEX1D_RTV
{
    unsigned int MipSlice;
};

struct ID3D11ClassLinkage : public ID3D11DeviceChild
{
    HRESULT GetClassInstance(char * ,unsigned int ,struct ID3D11ClassInstance ** );
    HRESULT CreateClassInstance(char * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct ID3D11ClassInstance ** );
    void ID3D11ClassLinkage(struct ID3D11ClassLinkage & );
    void ID3D11ClassLinkage();
    struct ID3D11ClassLinkage & operator=(struct ID3D11ClassLinkage & );
};

struct ID3D11ClassLinkage : public ID3D11DeviceChild
{
    HRESULT GetClassInstance(char * ,unsigned int ,struct ID3D11ClassInstance ** );
    HRESULT CreateClassInstance(char * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,struct ID3D11ClassInstance ** );
    void ID3D11ClassLinkage(struct ID3D11ClassLinkage & );
    void ID3D11ClassLinkage();
    struct ID3D11ClassLinkage & operator=(struct ID3D11ClassLinkage & );
};

struct ID3D11Predicate : public ID3D11Query
{
    void ID3D11Predicate(struct ID3D11Predicate & );
    void ID3D11Predicate();
    struct ID3D11Predicate & operator=(struct ID3D11Predicate & );
};

struct ID3D11Predicate : public ID3D11Query
{
    void ID3D11Predicate(struct ID3D11Predicate & );
    void ID3D11Predicate();
    struct ID3D11Predicate & operator=(struct ID3D11Predicate & );
};

enum DWRITE_TEXT_ALIGNMENT
{
    DWRITE_TEXT_ALIGNMENT_LEADING=0,
    DWRITE_TEXT_ALIGNMENT_TRAILING=1,
    DWRITE_TEXT_ALIGNMENT_CENTER=2
};

enum DWRITE_PARAGRAPH_ALIGNMENT
{
    DWRITE_PARAGRAPH_ALIGNMENT_NEAR=0,
    DWRITE_PARAGRAPH_ALIGNMENT_FAR=1,
    DWRITE_PARAGRAPH_ALIGNMENT_CENTER=2
};

enum DWRITE_WORD_WRAPPING
{
    DWRITE_WORD_WRAPPING_WRAP=0,
    DWRITE_WORD_WRAPPING_NO_WRAP=1
};

struct DWRITE_TRIMMING
{
    enum DWRITE_TRIMMING_GRANULARITY granularity;
    unsigned int delimiter;
    unsigned int delimiterCount;
};

enum DWRITE_LINE_SPACING_METHOD
{
    DWRITE_LINE_SPACING_METHOD_DEFAULT=0,
    DWRITE_LINE_SPACING_METHOD_UNIFORM=1
};

struct IDWriteTextFormat : public IUnknown
{
    HRESULT SetTextAlignment(enum DWRITE_TEXT_ALIGNMENT );
    HRESULT SetParagraphAlignment(enum DWRITE_PARAGRAPH_ALIGNMENT );
    HRESULT SetWordWrapping(enum DWRITE_WORD_WRAPPING );
    HRESULT SetReadingDirection(enum DWRITE_READING_DIRECTION );
    HRESULT SetFlowDirection(enum DWRITE_FLOW_DIRECTION );
    HRESULT SetIncrementalTabStop(float );
    HRESULT SetTrimming(struct DWRITE_TRIMMING * ,struct IDWriteInlineObject * );
    HRESULT SetLineSpacing(enum DWRITE_LINE_SPACING_METHOD ,float ,float );
    enum DWRITE_TEXT_ALIGNMENT GetTextAlignment();
    enum DWRITE_PARAGRAPH_ALIGNMENT GetParagraphAlignment();
    enum DWRITE_WORD_WRAPPING GetWordWrapping();
    enum DWRITE_READING_DIRECTION GetReadingDirection();
    enum DWRITE_FLOW_DIRECTION GetFlowDirection();
    float GetIncrementalTabStop();
    HRESULT GetTrimming(struct DWRITE_TRIMMING * ,struct IDWriteInlineObject ** );
    HRESULT GetLineSpacing(enum DWRITE_LINE_SPACING_METHOD * ,float * ,float * );
    HRESULT GetFontCollection(struct IDWriteFontCollection ** );
    unsigned int GetFontFamilyNameLength();
    HRESULT GetFontFamilyName(wchar_t * ,unsigned int );
    enum DWRITE_FONT_WEIGHT GetFontWeight();
    enum DWRITE_FONT_STYLE GetFontStyle();
    enum DWRITE_FONT_STRETCH GetFontStretch();
    float GetFontSize();
    unsigned int GetLocaleNameLength();
    HRESULT GetLocaleName(wchar_t * ,unsigned int );
    void IDWriteTextFormat(struct IDWriteTextFormat & );
    void IDWriteTextFormat();
    struct IDWriteTextFormat & operator=(struct IDWriteTextFormat & );
};

struct IDWriteTextFormat : public IUnknown
{
    HRESULT SetTextAlignment(enum DWRITE_TEXT_ALIGNMENT );
    HRESULT SetParagraphAlignment(enum DWRITE_PARAGRAPH_ALIGNMENT );
    HRESULT SetWordWrapping(enum DWRITE_WORD_WRAPPING );
    HRESULT SetReadingDirection(enum DWRITE_READING_DIRECTION );
    HRESULT SetFlowDirection(enum DWRITE_FLOW_DIRECTION );
    HRESULT SetIncrementalTabStop(float );
    HRESULT SetTrimming(struct DWRITE_TRIMMING * ,struct IDWriteInlineObject * );
    HRESULT SetLineSpacing(enum DWRITE_LINE_SPACING_METHOD ,float ,float );
    enum DWRITE_TEXT_ALIGNMENT GetTextAlignment();
    enum DWRITE_PARAGRAPH_ALIGNMENT GetParagraphAlignment();
    enum DWRITE_WORD_WRAPPING GetWordWrapping();
    enum DWRITE_READING_DIRECTION GetReadingDirection();
    enum DWRITE_FLOW_DIRECTION GetFlowDirection();
    float GetIncrementalTabStop();
    HRESULT GetTrimming(struct DWRITE_TRIMMING * ,struct IDWriteInlineObject ** );
    HRESULT GetLineSpacing(enum DWRITE_LINE_SPACING_METHOD * ,float * ,float * );
    HRESULT GetFontCollection(struct IDWriteFontCollection ** );
    unsigned int GetFontFamilyNameLength();
    HRESULT GetFontFamilyName(wchar_t * ,unsigned int );
    enum DWRITE_FONT_WEIGHT GetFontWeight();
    enum DWRITE_FONT_STYLE GetFontStyle();
    enum DWRITE_FONT_STRETCH GetFontStretch();
    float GetFontSize();
    unsigned int GetLocaleNameLength();
    HRESULT GetLocaleName(wchar_t * ,unsigned int );
    void IDWriteTextFormat(struct IDWriteTextFormat & );
    void IDWriteTextFormat();
    struct IDWriteTextFormat & operator=(struct IDWriteTextFormat & );
};

struct DWRITE_STRIKETHROUGH
{
    float width;
    float thickness;
    float offset;
    enum DWRITE_READING_DIRECTION readingDirection;
    enum DWRITE_FLOW_DIRECTION flowDirection;
    wchar_t * localeName;
    enum DWRITE_MEASURING_MODE measuringMode;
};

struct IXAudio2VoiceCallback
{
    void OnVoiceProcessingPassStart(unsigned int );
    void OnVoiceProcessingPassEnd();
    void OnStreamEnd();
    void OnBufferStart(void * );
    void OnBufferEnd(void * );
    void OnLoopEnd(void * );
    void OnVoiceError(void * ,HRESULT );
    void IXAudio2VoiceCallback(struct IXAudio2VoiceCallback & );
    void IXAudio2VoiceCallback();
    struct IXAudio2VoiceCallback & operator=(struct IXAudio2VoiceCallback & );
};

struct IXAudio2VoiceCallback
{
    void OnVoiceProcessingPassStart(unsigned int );
    void OnVoiceProcessingPassEnd();
    void OnStreamEnd();
    void OnBufferStart(void * );
    void OnBufferEnd(void * );
    void OnLoopEnd(void * );
    void OnVoiceError(void * ,HRESULT );
    void IXAudio2VoiceCallback(struct IXAudio2VoiceCallback & );
    void IXAudio2VoiceCallback();
    struct IXAudio2VoiceCallback & operator=(struct IXAudio2VoiceCallback & );
};

struct D3D11_COUNTER_INFO
{
    enum D3D11_COUNTER LastDeviceDependentCounter;
    unsigned int NumSimultaneousCounters;
    unsigned int NumDetectableParallelUnits;
};

struct DWRITE_GLYPH_RUN
{
    struct IDWriteFontFace * fontFace;
    float fontEmSize;
    unsigned int glyphCount;
    unsigned int * glyphIndices;
    float * glyphAdvances;
    struct DWRITE_GLYPH_OFFSET * glyphOffsets;
    int isSideways;
    unsigned int bidiLevel;
};

struct D3D11_BUFFER_UAV
{
    unsigned int FirstElement;
    unsigned int NumElements;
    unsigned int Flags;
};

struct D3DXQUATERNION
{
    void D3DXQUATERNION(float ,float ,float ,float );
    void D3DXQUATERNION(struct D3DXFLOAT16 * );
    void D3DXQUATERNION(float * );
    void D3DXQUATERNION();
    float * operator float *();
    float * operator const float *();
    struct D3DXQUATERNION & operator+=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator-=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator*=(float );
    struct D3DXQUATERNION & operator*=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator/=(float );
    struct D3DXQUATERNION operator+(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator+();
    struct D3DXQUATERNION operator-(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator-();
    struct D3DXQUATERNION operator*(float );
    struct D3DXQUATERNION operator*(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator/(float );
    int operator==(struct D3DXQUATERNION & );
    int operator!=(struct D3DXQUATERNION & );
    float x;
    float y;
    float z;
    float w;
};

struct D3DXQUATERNION
{
    void D3DXQUATERNION(float ,float ,float ,float );
    void D3DXQUATERNION(struct D3DXFLOAT16 * );
    void D3DXQUATERNION(float * );
    void D3DXQUATERNION();
    float * operator float *();
    float * operator const float *();
    struct D3DXQUATERNION & operator+=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator-=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator*=(float );
    struct D3DXQUATERNION & operator*=(struct D3DXQUATERNION & );
    struct D3DXQUATERNION & operator/=(float );
    struct D3DXQUATERNION operator+(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator+();
    struct D3DXQUATERNION operator-(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator-();
    struct D3DXQUATERNION operator*(float );
    struct D3DXQUATERNION operator*(struct D3DXQUATERNION & );
    struct D3DXQUATERNION operator/(float );
    int operator==(struct D3DXQUATERNION & );
    int operator!=(struct D3DXQUATERNION & );
    float x;
    float y;
    float z;
    float w;
};

struct ID2D1RadialGradientBrush : public ID2D1Brush
{
    void SetCenter(struct D2D_POINT_2F );
    void SetGradientOriginOffset(struct D2D_POINT_2F );
    void SetRadiusX(float );
    void SetRadiusY(float );
    struct D2D_POINT_2F GetCenter();
    struct D2D_POINT_2F GetGradientOriginOffset();
    float GetRadiusX();
    float GetRadiusY();
    void GetGradientStopCollection(struct ID2D1GradientStopCollection ** );
    void ID2D1RadialGradientBrush(struct ID2D1RadialGradientBrush & );
    void ID2D1RadialGradientBrush();
    struct ID2D1RadialGradientBrush & operator=(struct ID2D1RadialGradientBrush & );
};

struct ID2D1RadialGradientBrush : public ID2D1Brush
{
    void SetCenter(struct D2D_POINT_2F );
    void SetGradientOriginOffset(struct D2D_POINT_2F );
    void SetRadiusX(float );
    void SetRadiusY(float );
    struct D2D_POINT_2F GetCenter();
    struct D2D_POINT_2F GetGradientOriginOffset();
    float GetRadiusX();
    float GetRadiusY();
    void GetGradientStopCollection(struct ID2D1GradientStopCollection ** );
    void ID2D1RadialGradientBrush(struct ID2D1RadialGradientBrush & );
    void ID2D1RadialGradientBrush();
    struct ID2D1RadialGradientBrush & operator=(struct ID2D1RadialGradientBrush & );
};

struct D3D11_TEX2DMS_ARRAY_RTV
{
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct D3D11_TEXTURE1D_DESC
{
    unsigned int Width;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D11_SHADER_RESOURCE_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D_SRV_DIMENSION ViewDimension;
    struct D3D11_BUFFER_SRV Buffer;
    struct D3D11_TEX1D_SRV Texture1D;
    struct D3D11_TEX1D_ARRAY_SRV Texture1DArray;
    struct D3D11_TEX2D_SRV Texture2D;
    struct D3D11_TEX2D_ARRAY_SRV Texture2DArray;
    struct D3D11_TEX2DMS_SRV Texture2DMS;
    struct D3D11_TEX2DMS_ARRAY_SRV Texture2DMSArray;
    struct D3D11_TEX3D_SRV Texture3D;
    struct D3D11_TEXCUBE_SRV TextureCube;
    struct D3D11_TEXCUBE_ARRAY_SRV TextureCubeArray;
    struct D3D11_BUFFEREX_SRV BufferEx;
};

struct CD3D11_SHADER_RESOURCE_VIEW_DESC : public D3D11_SHADER_RESOURCE_VIEW_DESC
{
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Texture3D * ,enum DXGI_FORMAT ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D_SRV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D_SRV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(enum D3D_SRV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct D3D11_SHADER_RESOURCE_VIEW_DESC & );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC();
    void ~CD3D11_SHADER_RESOURCE_VIEW_DESC();
    struct D3D11_SHADER_RESOURCE_VIEW_DESC & operator const struct D3D11_SHADER_RESOURCE_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_SHADER_RESOURCE_VIEW_DESC : public D3D11_SHADER_RESOURCE_VIEW_DESC
{
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Texture3D * ,enum DXGI_FORMAT ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D_SRV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D_SRV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(enum D3D_SRV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC(struct D3D11_SHADER_RESOURCE_VIEW_DESC & );
    void CD3D11_SHADER_RESOURCE_VIEW_DESC();
    void ~CD3D11_SHADER_RESOURCE_VIEW_DESC();
    struct D3D11_SHADER_RESOURCE_VIEW_DESC & operator const struct D3D11_SHADER_RESOURCE_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct _D3DVECTOR
{
    float x;
    float y;
    float z;
};

struct D3D11_TEX2D_ARRAY_DSV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct IXAudio2EngineCallback
{
    void OnProcessingPassStart();
    void OnProcessingPassEnd();
    void OnCriticalError(HRESULT );
    void IXAudio2EngineCallback(struct IXAudio2EngineCallback & );
    void IXAudio2EngineCallback();
    struct IXAudio2EngineCallback & operator=(struct IXAudio2EngineCallback & );
};

struct IXAudio2EngineCallback
{
    void OnProcessingPassStart();
    void OnProcessingPassEnd();
    void OnCriticalError(HRESULT );
    void IXAudio2EngineCallback(struct IXAudio2EngineCallback & );
    void IXAudio2EngineCallback();
    struct IXAudio2EngineCallback & operator=(struct IXAudio2EngineCallback & );
};

struct D3D11_TEXCUBE_ARRAY_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
    unsigned int First2DArrayFace;
    unsigned int NumCubes;
};

struct DWRITE_CLUSTER_METRICS
{
    float width;
    unsigned int length;
    unsigned int canWrapLineAfter:1;
    unsigned int isWhitespace:1;
    unsigned int isNewline:1;
    unsigned int isSoftHyphen:1;
    unsigned int isRightToLeft:1;
    unsigned int padding:11;
};

struct XAUDIO2_DEVICE_DETAILS
{
    wchar_t DeviceID[256];
    wchar_t DisplayName[256];
    enum XAUDIO2_DEVICE_ROLE Role;
    struct WAVEFORMATEXTENSIBLE OutputFormat;
};

enum D3D10_MESSAGE_SEVERITY
{
    D3D10_MESSAGE_SEVERITY_CORRUPTION=0,
    D3D10_MESSAGE_SEVERITY_ERROR=1,
    D3D10_MESSAGE_SEVERITY_WARNING=2,
    D3D10_MESSAGE_SEVERITY_INFO=3
};

struct ID3D10ShaderResourceView : public ID3D10View
{
    void GetDesc(struct D3D10_SHADER_RESOURCE_VIEW_DESC * );
    void ID3D10ShaderResourceView(struct ID3D10ShaderResourceView & );
    void ID3D10ShaderResourceView();
    struct ID3D10ShaderResourceView & operator=(struct ID3D10ShaderResourceView & );
};

struct ID3D10ShaderResourceView : public ID3D10View
{
    void GetDesc(struct D3D10_SHADER_RESOURCE_VIEW_DESC * );
    void ID3D10ShaderResourceView(struct ID3D10ShaderResourceView & );
    void ID3D10ShaderResourceView();
    struct ID3D10ShaderResourceView & operator=(struct ID3D10ShaderResourceView & );
};

struct _D3DXFONT_DESCW
{
    int Height;
    unsigned int Width;
    unsigned int Weight;
    unsigned int MipLevels;
    int Italic;
    unsigned int CharSet;
    unsigned int OutputPrecision;
    unsigned int Quality;
    unsigned int PitchAndFamily;
    wchar_t FaceName[32];
};

struct D3D11_TEX2D_ARRAY_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

enum WICBitmapPaletteType
{
    WICBitmapPaletteTypeCustom=0,
    WICBitmapPaletteTypeMedianCut=1,
    WICBitmapPaletteTypeFixedBW=2,
    WICBitmapPaletteTypeFixedHalftone8=3,
    WICBitmapPaletteTypeFixedHalftone27=4,
    WICBitmapPaletteTypeFixedHalftone64=5,
    WICBitmapPaletteTypeFixedHalftone125=6,
    WICBitmapPaletteTypeFixedHalftone216=7,
    WICBitmapPaletteTypeFixedWebPalette=7,
    WICBitmapPaletteTypeFixedHalftone252=8,
    WICBitmapPaletteTypeFixedHalftone256=9,
    WICBitmapPaletteTypeFixedGray4=10,
    WICBitmapPaletteTypeFixedGray16=11,
    WICBitmapPaletteTypeFixedGray256=12,
    WICBITMAPPALETTETYPE_FORCE_DWORD=2147483647
};

struct IWICPalette : public IUnknown
{
    HRESULT InitializePredefined(enum WICBitmapPaletteType ,int );
    HRESULT InitializeCustom(unsigned int * ,unsigned int );
    HRESULT InitializeFromBitmap(struct IWICBitmapSource * ,unsigned int ,int );
    HRESULT InitializeFromPalette(struct IWICPalette * );
    HRESULT GetType(enum WICBitmapPaletteType * );
    HRESULT GetColorCount(unsigned int * );
    HRESULT GetColors(unsigned int ,unsigned int * ,unsigned int * );
    HRESULT IsBlackWhite(int * );
    HRESULT IsGrayscale(int * );
    HRESULT HasAlpha(int * );
    void IWICPalette(struct IWICPalette & );
    void IWICPalette();
    struct IWICPalette & operator=(struct IWICPalette & );
};

struct IWICPalette : public IUnknown
{
    HRESULT InitializePredefined(enum WICBitmapPaletteType ,int );
    HRESULT InitializeCustom(unsigned int * ,unsigned int );
    HRESULT InitializeFromBitmap(struct IWICBitmapSource * ,unsigned int ,int );
    HRESULT InitializeFromPalette(struct IWICPalette * );
    HRESULT GetType(enum WICBitmapPaletteType * );
    HRESULT GetColorCount(unsigned int * );
    HRESULT GetColors(unsigned int ,unsigned int * ,unsigned int * );
    HRESULT IsBlackWhite(int * );
    HRESULT IsGrayscale(int * );
    HRESULT HasAlpha(int * );
    void IWICPalette(struct IWICPalette & );
    void IWICPalette();
    struct IWICPalette & operator=(struct IWICPalette & );
};

struct HWND__
{
    int unused;
};

struct IDWriteFontCollection : public IUnknown
{
    unsigned int GetFontFamilyCount();
    HRESULT GetFontFamily(unsigned int ,struct IDWriteFontFamily ** );
    HRESULT FindFamilyName(wchar_t * ,unsigned int * ,int * );
    HRESULT GetFontFromFontFace(struct IDWriteFontFace * ,struct IDWriteFont ** );
    void IDWriteFontCollection(struct IDWriteFontCollection & );
    void IDWriteFontCollection();
    struct IDWriteFontCollection & operator=(struct IDWriteFontCollection & );
};

struct IDWriteFontCollection : public IUnknown
{
    unsigned int GetFontFamilyCount();
    HRESULT GetFontFamily(unsigned int ,struct IDWriteFontFamily ** );
    HRESULT FindFamilyName(wchar_t * ,unsigned int * ,int * );
    HRESULT GetFontFromFontFace(struct IDWriteFontFace * ,struct IDWriteFont ** );
    void IDWriteFontCollection(struct IDWriteFontCollection & );
    void IDWriteFontCollection();
    struct IDWriteFontCollection & operator=(struct IDWriteFontCollection & );
};

struct _D3DX10_SPRITE
{
    struct D3DXMATRIX matWorld;
    struct D3DXVECTOR2 TexCoord;
    struct D3DXVECTOR2 TexSize;
    struct D3DXCOLOR ColorModulate;
    struct ID3D10ShaderResourceView * pTexture;
    unsigned int TextureIndex;
    void _D3DX10_SPRITE();
};

struct ID3D11DepthStencilState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_DEPTH_STENCIL_DESC * );
    void ID3D11DepthStencilState(struct ID3D11DepthStencilState & );
    void ID3D11DepthStencilState();
    struct ID3D11DepthStencilState & operator=(struct ID3D11DepthStencilState & );
};

struct ID3D11DepthStencilState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_DEPTH_STENCIL_DESC * );
    void ID3D11DepthStencilState(struct ID3D11DepthStencilState & );
    void ID3D11DepthStencilState();
    struct ID3D11DepthStencilState & operator=(struct ID3D11DepthStencilState & );
};

struct tagPALETTEENTRY
{
    unsigned int peRed;
    unsigned int peGreen;
    unsigned int peBlue;
    unsigned int peFlags;
};

enum D3D11_RESOURCE_DIMENSION
{
    D3D11_RESOURCE_DIMENSION_UNKNOWN=0,
    D3D11_RESOURCE_DIMENSION_BUFFER=1,
    D3D11_RESOURCE_DIMENSION_TEXTURE1D=2,
    D3D11_RESOURCE_DIMENSION_TEXTURE2D=3,
    D3D11_RESOURCE_DIMENSION_TEXTURE3D=4
};

enum D3DX11_IMAGE_FILE_FORMAT
{
    D3DX11_IFF_BMP=0,
    D3DX11_IFF_JPG=1,
    D3DX11_IFF_PNG=3,
    D3DX11_IFF_DDS=4,
    D3DX11_IFF_TIFF=10,
    D3DX11_IFF_GIF=11,
    D3DX11_IFF_WMP=12,
    D3DX11_IFF_FORCE_DWORD=2147483647
};

struct D3DX11_IMAGE_INFO
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int ArraySize;
    unsigned int MipLevels;
    unsigned int MiscFlags;
    enum DXGI_FORMAT Format;
    enum D3D11_RESOURCE_DIMENSION ResourceDimension;
    enum D3DX11_IMAGE_FILE_FORMAT ImageFileFormat;
};

struct D2D_RECT_F
{
    float left;
    float top;
    float right;
    float bottom;
};

struct ID3DX10Font : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct ID3D10Device ** );
    HRESULT GetDescA(struct _D3DX10_FONT_DESCA * );
    HRESULT GetDescW(struct _D3DX10_FONT_DESCW * );
    int GetTextMetricsA(struct tagTEXTMETRICA * );
    int GetTextMetricsW(struct tagTEXTMETRICW * );
    struct HDC__ * GetDC();
    HRESULT GetGlyphData(unsigned int ,struct ID3D10ShaderResourceView ** ,struct tagRECT * ,struct tagPOINT * );
    HRESULT PreloadCharacters(unsigned int ,unsigned int );
    HRESULT PreloadGlyphs(unsigned int ,unsigned int );
    HRESULT PreloadTextA(char * ,int );
    HRESULT PreloadTextW(wchar_t * ,int );
    int DrawTextA(struct ID3DX10Sprite * ,char * ,int ,struct tagRECT * ,unsigned int ,struct D3DXCOLOR );
    int DrawTextW(struct ID3DX10Sprite * ,wchar_t * ,int ,struct tagRECT * ,unsigned int ,struct D3DXCOLOR );
    HRESULT GetDesc(struct _D3DX10_FONT_DESCA * );
    HRESULT PreloadText(char * ,int );
    void ID3DX10Font(struct ID3DX10Font & );
    void ID3DX10Font();
    struct ID3DX10Font & operator=(struct ID3DX10Font & );
};

struct ID3DX10Font : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct ID3D10Device ** );
    HRESULT GetDescA(struct _D3DX10_FONT_DESCA * );
    HRESULT GetDescW(struct _D3DX10_FONT_DESCW * );
    int GetTextMetricsA(struct tagTEXTMETRICA * );
    int GetTextMetricsW(struct tagTEXTMETRICW * );
    struct HDC__ * GetDC();
    HRESULT GetGlyphData(unsigned int ,struct ID3D10ShaderResourceView ** ,struct tagRECT * ,struct tagPOINT * );
    HRESULT PreloadCharacters(unsigned int ,unsigned int );
    HRESULT PreloadGlyphs(unsigned int ,unsigned int );
    HRESULT PreloadTextA(char * ,int );
    HRESULT PreloadTextW(wchar_t * ,int );
    int DrawTextA(struct ID3DX10Sprite * ,char * ,int ,struct tagRECT * ,unsigned int ,struct D3DXCOLOR );
    int DrawTextW(struct ID3DX10Sprite * ,wchar_t * ,int ,struct tagRECT * ,unsigned int ,struct D3DXCOLOR );
    HRESULT GetDesc(struct _D3DX10_FONT_DESCA * );
    HRESULT PreloadText(char * ,int );
    void ID3DX10Font(struct ID3DX10Font & );
    void ID3DX10Font();
    struct ID3DX10Font & operator=(struct ID3DX10Font & );
};

struct D3D11_DEPTH_STENCIL_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D11_DSV_DIMENSION ViewDimension;
    unsigned int Flags;
    struct D3D11_TEX1D_DSV Texture1D;
    struct D3D11_TEX1D_ARRAY_DSV Texture1DArray;
    struct D3D11_TEX2D_DSV Texture2D;
    struct D3D11_TEX2D_ARRAY_DSV Texture2DArray;
    struct D3D11_TEX2DMS_DSV Texture2DMS;
    struct D3D11_TEX2DMS_ARRAY_DSV Texture2DMSArray;
};

struct CD3D11_DEPTH_STENCIL_VIEW_DESC : public D3D11_DEPTH_STENCIL_VIEW_DESC
{
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D11_DSV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D11_DSV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(enum D3D11_DSV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(struct D3D11_DEPTH_STENCIL_VIEW_DESC & );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC();
    void ~CD3D11_DEPTH_STENCIL_VIEW_DESC();
    struct D3D11_DEPTH_STENCIL_VIEW_DESC & operator const struct D3D11_DEPTH_STENCIL_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_DEPTH_STENCIL_VIEW_DESC : public D3D11_DEPTH_STENCIL_VIEW_DESC
{
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D11_DSV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D11_DSV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(enum D3D11_DSV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC(struct D3D11_DEPTH_STENCIL_VIEW_DESC & );
    void CD3D11_DEPTH_STENCIL_VIEW_DESC();
    void ~CD3D11_DEPTH_STENCIL_VIEW_DESC();
    struct D3D11_DEPTH_STENCIL_VIEW_DESC & operator const struct D3D11_DEPTH_STENCIL_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct _D3DCAPS9
{
    enum _D3DDEVTYPE DeviceType;
    unsigned int AdapterOrdinal;
    unsigned long Caps;
    unsigned long Caps2;
    unsigned long Caps3;
    unsigned long PresentationIntervals;
    unsigned long CursorCaps;
    unsigned long DevCaps;
    unsigned long PrimitiveMiscCaps;
    unsigned long RasterCaps;
    unsigned long ZCmpCaps;
    unsigned long SrcBlendCaps;
    unsigned long DestBlendCaps;
    unsigned long AlphaCmpCaps;
    unsigned long ShadeCaps;
    unsigned long TextureCaps;
    unsigned long TextureFilterCaps;
    unsigned long CubeTextureFilterCaps;
    unsigned long VolumeTextureFilterCaps;
    unsigned long TextureAddressCaps;
    unsigned long VolumeTextureAddressCaps;
    unsigned long LineCaps;
    unsigned long MaxTextureWidth;
    unsigned long MaxTextureHeight;
    unsigned long MaxVolumeExtent;
    unsigned long MaxTextureRepeat;
    unsigned long MaxTextureAspectRatio;
    unsigned long MaxAnisotropy;
    float MaxVertexW;
    float GuardBandLeft;
    float GuardBandTop;
    float GuardBandRight;
    float GuardBandBottom;
    float ExtentsAdjust;
    unsigned long StencilCaps;
    unsigned long FVFCaps;
    unsigned long TextureOpCaps;
    unsigned long MaxTextureBlendStages;
    unsigned long MaxSimultaneousTextures;
    unsigned long VertexProcessingCaps;
    unsigned long MaxActiveLights;
    unsigned long MaxUserClipPlanes;
    unsigned long MaxVertexBlendMatrices;
    unsigned long MaxVertexBlendMatrixIndex;
    float MaxPointSize;
    unsigned long MaxPrimitiveCount;
    unsigned long MaxVertexIndex;
    unsigned long MaxStreams;
    unsigned long MaxStreamStride;
    unsigned long VertexShaderVersion;
    unsigned long MaxVertexShaderConst;
    unsigned long PixelShaderVersion;
    float PixelShader1xMaxValue;
    unsigned long DevCaps2;
    float MaxNpatchTessellationLevel;
    unsigned long Reserved5;
    unsigned int MasterAdapterOrdinal;
    unsigned int AdapterOrdinalInGroup;
    unsigned int NumberOfAdaptersInGroup;
    unsigned long DeclTypes;
    unsigned long NumSimultaneousRTs;
    unsigned long StretchRectFilterCaps;
    struct _D3DVSHADERCAPS2_0 VS20Caps;
    struct _D3DPSHADERCAPS2_0 PS20Caps;
    unsigned long VertexTextureFilterCaps;
    unsigned long MaxVShaderInstructionsExecuted;
    unsigned long MaxPShaderInstructionsExecuted;
    unsigned long MaxVertexShader30InstructionSlots;
    unsigned long MaxPixelShader30InstructionSlots;
};

struct ID3D11ComputeShader : public ID3D11DeviceChild
{
    void ID3D11ComputeShader(struct ID3D11ComputeShader & );
    void ID3D11ComputeShader();
    struct ID3D11ComputeShader & operator=(struct ID3D11ComputeShader & );
};

struct ID3D11ComputeShader : public ID3D11DeviceChild
{
    void ID3D11ComputeShader(struct ID3D11ComputeShader & );
    void ID3D11ComputeShader();
    struct ID3D11ComputeShader & operator=(struct ID3D11ComputeShader & );
};

enum D2D1_WINDOW_STATE
{
    D2D1_WINDOW_STATE_NONE=0,
    D2D1_WINDOW_STATE_OCCLUDED=1,
    D2D1_WINDOW_STATE_FORCE_DWORD=-1
};

struct D2D_SIZE_U
{
    unsigned int width;
    unsigned int height;
};

struct ID2D1HwndRenderTarget : public ID2D1RenderTarget
{
    enum D2D1_WINDOW_STATE CheckWindowState();
    HRESULT Resize(struct D2D_SIZE_U & );
    HRESULT Resize(struct D2D_SIZE_U * );
    struct HWND__ * GetHwnd();
    void ID2D1HwndRenderTarget(struct ID2D1HwndRenderTarget & );
    void ID2D1HwndRenderTarget();
    struct ID2D1HwndRenderTarget & operator=(struct ID2D1HwndRenderTarget & );
};

struct ID2D1HwndRenderTarget : public ID2D1RenderTarget
{
    enum D2D1_WINDOW_STATE CheckWindowState();
    HRESULT Resize(struct D2D_SIZE_U & );
    HRESULT Resize(struct D2D_SIZE_U * );
    struct HWND__ * GetHwnd();
    void ID2D1HwndRenderTarget(struct ID2D1HwndRenderTarget & );
    void ID2D1HwndRenderTarget();
    struct ID2D1HwndRenderTarget & operator=(struct ID2D1HwndRenderTarget & );
};

struct ID3D11HullShader : public ID3D11DeviceChild
{
    void ID3D11HullShader(struct ID3D11HullShader & );
    void ID3D11HullShader();
    struct ID3D11HullShader & operator=(struct ID3D11HullShader & );
};

struct ID3D11HullShader : public ID3D11DeviceChild
{
    void ID3D11HullShader(struct ID3D11HullShader & );
    void ID3D11HullShader();
    struct ID3D11HullShader & operator=(struct ID3D11HullShader & );
};

struct D2D_POINT_2F
{
    float x;
    float y;
};

struct D3D11_TEXTURE3D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int MipLevels;
    enum DXGI_FORMAT Format;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct CD3D11_TEXTURE3D_DESC : public D3D11_TEXTURE3D_DESC
{
    void CD3D11_TEXTURE3D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int );
    void CD3D11_TEXTURE3D_DESC(struct D3D11_TEXTURE3D_DESC & );
    void CD3D11_TEXTURE3D_DESC();
    void ~CD3D11_TEXTURE3D_DESC();
    struct D3D11_TEXTURE3D_DESC & operator const struct D3D11_TEXTURE3D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_TEXTURE3D_DESC : public D3D11_TEXTURE3D_DESC
{
    void CD3D11_TEXTURE3D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int );
    void CD3D11_TEXTURE3D_DESC(struct D3D11_TEXTURE3D_DESC & );
    void CD3D11_TEXTURE3D_DESC();
    void ~CD3D11_TEXTURE3D_DESC();
    struct D3D11_TEXTURE3D_DESC & operator const struct D3D11_TEXTURE3D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct tagLC_ID
{
    unsigned int wLanguage;
    unsigned int wCountry;
    unsigned int wCodePage;
};

struct tagPOINT
{
    long x;
    long y;
};

struct _D3DBOX
{
    unsigned int Left;
    unsigned int Top;
    unsigned int Right;
    unsigned int Bottom;
    unsigned int Front;
    unsigned int Back;
};

struct IDirect3DVolume9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DVOLUME_DESC * );
    HRESULT LockBox(struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox();
    void IDirect3DVolume9(struct IDirect3DVolume9 & );
    void IDirect3DVolume9();
    struct IDirect3DVolume9 & operator=(struct IDirect3DVolume9 & );
};

struct IDirect3DVolume9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DVOLUME_DESC * );
    HRESULT LockBox(struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox();
    void IDirect3DVolume9(struct IDirect3DVolume9 & );
    void IDirect3DVolume9();
    struct IDirect3DVolume9 & operator=(struct IDirect3DVolume9 & );
};

struct ID3D11SamplerState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_SAMPLER_DESC * );
    void ID3D11SamplerState(struct ID3D11SamplerState & );
    void ID3D11SamplerState();
    struct ID3D11SamplerState & operator=(struct ID3D11SamplerState & );
};

struct ID3D11SamplerState : public ID3D11DeviceChild
{
    void GetDesc(struct D3D11_SAMPLER_DESC * );
    void ID3D11SamplerState(struct ID3D11SamplerState & );
    void ID3D11SamplerState();
    struct ID3D11SamplerState & operator=(struct ID3D11SamplerState & );
};

struct DWRITE_GLYPH_RUN
{
    struct IDWriteFontFace * fontFace;
    float fontEmSize;
    unsigned int glyphCount;
    unsigned int * glyphIndices;
    float * glyphAdvances;
    struct DWRITE_GLYPH_OFFSET * glyphOffsets;
    int isSideways;
    unsigned int bidiLevel;
};

struct DWRITE_GLYPH_RUN_DESCRIPTION
{
    wchar_t * localeName;
    wchar_t * string;
    unsigned int stringLength;
    unsigned int * clusterMap;
    unsigned int textPosition;
};

struct DWRITE_UNDERLINE
{
    float width;
    float thickness;
    float offset;
    float runHeight;
    enum DWRITE_READING_DIRECTION readingDirection;
    enum DWRITE_FLOW_DIRECTION flowDirection;
    wchar_t * localeName;
    enum DWRITE_MEASURING_MODE measuringMode;
};

struct DWRITE_STRIKETHROUGH
{
    float width;
    float thickness;
    float offset;
    enum DWRITE_READING_DIRECTION readingDirection;
    enum DWRITE_FLOW_DIRECTION flowDirection;
    wchar_t * localeName;
    enum DWRITE_MEASURING_MODE measuringMode;
};

struct IDWriteTextRenderer : public IDWritePixelSnapping
{
    HRESULT DrawGlyphRun(void * ,float ,float ,enum DWRITE_MEASURING_MODE ,struct DWRITE_GLYPH_RUN * ,struct DWRITE_GLYPH_RUN_DESCRIPTION * ,struct IUnknown * );
    HRESULT DrawUnderline(void * ,float ,float ,struct DWRITE_UNDERLINE * ,struct IUnknown * );
    HRESULT DrawStrikethrough(void * ,float ,float ,struct DWRITE_STRIKETHROUGH * ,struct IUnknown * );
    HRESULT DrawInlineObject(void * ,float ,float ,struct IDWriteInlineObject * ,int ,int ,struct IUnknown * );
    void IDWriteTextRenderer(struct IDWriteTextRenderer & );
    void IDWriteTextRenderer();
    struct IDWriteTextRenderer & operator=(struct IDWriteTextRenderer & );
};

struct IDWriteTextRenderer : public IDWritePixelSnapping
{
    HRESULT DrawGlyphRun(void * ,float ,float ,enum DWRITE_MEASURING_MODE ,struct DWRITE_GLYPH_RUN * ,struct DWRITE_GLYPH_RUN_DESCRIPTION * ,struct IUnknown * );
    HRESULT DrawUnderline(void * ,float ,float ,struct DWRITE_UNDERLINE * ,struct IUnknown * );
    HRESULT DrawStrikethrough(void * ,float ,float ,struct DWRITE_STRIKETHROUGH * ,struct IUnknown * );
    HRESULT DrawInlineObject(void * ,float ,float ,struct IDWriteInlineObject * ,int ,int ,struct IUnknown * );
    void IDWriteTextRenderer(struct IDWriteTextRenderer & );
    void IDWriteTextRenderer();
    struct IDWriteTextRenderer & operator=(struct IDWriteTextRenderer & );
};

enum _D3DRENDERSTATETYPE
{
    D3DRS_ZENABLE=7,
    D3DRS_FILLMODE=8,
    D3DRS_SHADEMODE=9,
    D3DRS_ZWRITEENABLE=14,
    D3DRS_ALPHATESTENABLE=15,
    D3DRS_LASTPIXEL=16,
    D3DRS_SRCBLEND=19,
    D3DRS_DESTBLEND=20,
    D3DRS_CULLMODE=22,
    D3DRS_ZFUNC=23,
    D3DRS_ALPHAREF=24,
    D3DRS_ALPHAFUNC=25,
    D3DRS_DITHERENABLE=26,
    D3DRS_ALPHABLENDENABLE=27,
    D3DRS_FOGENABLE=28,
    D3DRS_SPECULARENABLE=29,
    D3DRS_FOGCOLOR=34,
    D3DRS_FOGTABLEMODE=35,
    D3DRS_FOGSTART=36,
    D3DRS_FOGEND=37,
    D3DRS_FOGDENSITY=38,
    D3DRS_RANGEFOGENABLE=48,
    D3DRS_STENCILENABLE=52,
    D3DRS_STENCILFAIL=53,
    D3DRS_STENCILZFAIL=54,
    D3DRS_STENCILPASS=55,
    D3DRS_STENCILFUNC=56,
    D3DRS_STENCILREF=57,
    D3DRS_STENCILMASK=58,
    D3DRS_STENCILWRITEMASK=59,
    D3DRS_TEXTUREFACTOR=60,
    D3DRS_WRAP0=128,
    D3DRS_WRAP1=129,
    D3DRS_WRAP2=130,
    D3DRS_WRAP3=131,
    D3DRS_WRAP4=132,
    D3DRS_WRAP5=133,
    D3DRS_WRAP6=134,
    D3DRS_WRAP7=135,
    D3DRS_CLIPPING=136,
    D3DRS_LIGHTING=137,
    D3DRS_AMBIENT=139,
    D3DRS_FOGVERTEXMODE=140,
    D3DRS_COLORVERTEX=141,
    D3DRS_LOCALVIEWER=142,
    D3DRS_NORMALIZENORMALS=143,
    D3DRS_DIFFUSEMATERIALSOURCE=145,
    D3DRS_SPECULARMATERIALSOURCE=146,
    D3DRS_AMBIENTMATERIALSOURCE=147,
    D3DRS_EMISSIVEMATERIALSOURCE=148,
    D3DRS_VERTEXBLEND=151,
    D3DRS_CLIPPLANEENABLE=152,
    D3DRS_POINTSIZE=154,
    D3DRS_POINTSIZE_MIN=155,
    D3DRS_POINTSPRITEENABLE=156,
    D3DRS_POINTSCALEENABLE=157,
    D3DRS_POINTSCALE_A=158,
    D3DRS_POINTSCALE_B=159,
    D3DRS_POINTSCALE_C=160,
    D3DRS_MULTISAMPLEANTIALIAS=161,
    D3DRS_MULTISAMPLEMASK=162,
    D3DRS_PATCHEDGESTYLE=163,
    D3DRS_DEBUGMONITORTOKEN=165,
    D3DRS_POINTSIZE_MAX=166,
    D3DRS_INDEXEDVERTEXBLENDENABLE=167,
    D3DRS_COLORWRITEENABLE=168,
    D3DRS_TWEENFACTOR=170,
    D3DRS_BLENDOP=171,
    D3DRS_POSITIONDEGREE=172,
    D3DRS_NORMALDEGREE=173,
    D3DRS_SCISSORTESTENABLE=174,
    D3DRS_SLOPESCALEDEPTHBIAS=175,
    D3DRS_ANTIALIASEDLINEENABLE=176,
    D3DRS_MINTESSELLATIONLEVEL=178,
    D3DRS_MAXTESSELLATIONLEVEL=179,
    D3DRS_ADAPTIVETESS_X=180,
    D3DRS_ADAPTIVETESS_Y=181,
    D3DRS_ADAPTIVETESS_Z=182,
    D3DRS_ADAPTIVETESS_W=183,
    D3DRS_ENABLEADAPTIVETESSELLATION=184,
    D3DRS_TWOSIDEDSTENCILMODE=185,
    D3DRS_CCW_STENCILFAIL=186,
    D3DRS_CCW_STENCILZFAIL=187,
    D3DRS_CCW_STENCILPASS=188,
    D3DRS_CCW_STENCILFUNC=189,
    D3DRS_COLORWRITEENABLE1=190,
    D3DRS_COLORWRITEENABLE2=191,
    D3DRS_COLORWRITEENABLE3=192,
    D3DRS_BLENDFACTOR=193,
    D3DRS_SRGBWRITEENABLE=194,
    D3DRS_DEPTHBIAS=195,
    D3DRS_WRAP8=198,
    D3DRS_WRAP9=199,
    D3DRS_WRAP10=200,
    D3DRS_WRAP11=201,
    D3DRS_WRAP12=202,
    D3DRS_WRAP13=203,
    D3DRS_WRAP14=204,
    D3DRS_WRAP15=205,
    D3DRS_SEPARATEALPHABLENDENABLE=206,
    D3DRS_SRCBLENDALPHA=207,
    D3DRS_DESTBLENDALPHA=208,
    D3DRS_BLENDOPALPHA=209,
    D3DRS_FORCE_DWORD=2147483647
};

struct _D3DLIGHT9
{
    enum _D3DLIGHTTYPE Type;
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DVECTOR Position;
    struct _D3DVECTOR Direction;
    float Range;
    float Falloff;
    float Attenuation0;
    float Attenuation1;
    float Attenuation2;
    float Theta;
    float Phi;
};

struct IDirect3DCubeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetCubeMapSurface(enum _D3DCUBEMAP_FACES ,unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(enum _D3DCUBEMAP_FACES ,unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(enum _D3DCUBEMAP_FACES ,unsigned int );
    HRESULT AddDirtyRect(enum _D3DCUBEMAP_FACES ,struct tagRECT * );
    void IDirect3DCubeTexture9(struct IDirect3DCubeTexture9 & );
    void IDirect3DCubeTexture9();
    struct IDirect3DCubeTexture9 & operator=(struct IDirect3DCubeTexture9 & );
};

struct IDirect3DCubeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetCubeMapSurface(enum _D3DCUBEMAP_FACES ,unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(enum _D3DCUBEMAP_FACES ,unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(enum _D3DCUBEMAP_FACES ,unsigned int );
    HRESULT AddDirtyRect(enum _D3DCUBEMAP_FACES ,struct tagRECT * );
    void IDirect3DCubeTexture9(struct IDirect3DCubeTexture9 & );
    void IDirect3DCubeTexture9();
    struct IDirect3DCubeTexture9 & operator=(struct IDirect3DCubeTexture9 & );
};

struct ID2D1RectangleGeometry : public ID2D1Geometry
{
    void GetRect(struct D2D_RECT_F * );
    void ID2D1RectangleGeometry(struct ID2D1RectangleGeometry & );
    void ID2D1RectangleGeometry();
    struct ID2D1RectangleGeometry & operator=(struct ID2D1RectangleGeometry & );
};

struct ID2D1RectangleGeometry : public ID2D1Geometry
{
    void GetRect(struct D2D_RECT_F * );
    void ID2D1RectangleGeometry(struct ID2D1RectangleGeometry & );
    void ID2D1RectangleGeometry();
    struct ID2D1RectangleGeometry & operator=(struct ID2D1RectangleGeometry & );
};

struct D2D1_HWND_RENDER_TARGET_PROPERTIES
{
    struct HWND__ * hwnd;
    struct D2D_SIZE_U pixelSize;
    enum D2D1_PRESENT_OPTIONS presentOptions;
};

struct ID3D11Texture3D : public ID3D11Resource
{
    void GetDesc(struct D3D11_TEXTURE3D_DESC * );
    void ID3D11Texture3D(struct ID3D11Texture3D & );
    void ID3D11Texture3D();
    struct ID3D11Texture3D & operator=(struct ID3D11Texture3D & );
};

struct ID3D11Texture3D : public ID3D11Resource
{
    void GetDesc(struct D3D11_TEXTURE3D_DESC * );
    void ID3D11Texture3D(struct ID3D11Texture3D & );
    void ID3D11Texture3D();
    struct ID3D11Texture3D & operator=(struct ID3D11Texture3D & );
};

struct XAUDIO2_VOICE_STATE
{
    void * pCurrentBufferContext;
    unsigned int BuffersQueued;
    unsigned int SamplesPlayed;
};

struct IDWriteTextLayout : public IDWriteTextFormat
{
    HRESULT SetMaxWidth(float );
    HRESULT SetMaxHeight(float );
    HRESULT SetFontCollection(struct IDWriteFontCollection * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontFamilyName(wchar_t * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontWeight(enum DWRITE_FONT_WEIGHT ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontStyle(enum DWRITE_FONT_STYLE ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontStretch(enum DWRITE_FONT_STRETCH ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontSize(float ,struct DWRITE_TEXT_RANGE );
    HRESULT SetUnderline(int ,struct DWRITE_TEXT_RANGE );
    HRESULT SetStrikethrough(int ,struct DWRITE_TEXT_RANGE );
    HRESULT SetDrawingEffect(struct IUnknown * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetInlineObject(struct IDWriteInlineObject * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetTypography(struct IDWriteTypography * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetLocaleName(wchar_t * ,struct DWRITE_TEXT_RANGE );
    float GetMaxWidth();
    float GetMaxHeight();
    HRESULT GetFontCollection(unsigned int ,struct IDWriteFontCollection ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontFamilyNameLength(unsigned int ,unsigned int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontFamilyName(unsigned int ,wchar_t * ,unsigned int ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontWeight(unsigned int ,enum DWRITE_FONT_WEIGHT * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontStyle(unsigned int ,enum DWRITE_FONT_STYLE * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontStretch(unsigned int ,enum DWRITE_FONT_STRETCH * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontSize(unsigned int ,float * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetUnderline(unsigned int ,int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetStrikethrough(unsigned int ,int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetDrawingEffect(unsigned int ,struct IUnknown ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetInlineObject(unsigned int ,struct IDWriteInlineObject ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetTypography(unsigned int ,struct IDWriteTypography ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetLocaleNameLength(unsigned int ,unsigned int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetLocaleName(unsigned int ,wchar_t * ,unsigned int ,struct DWRITE_TEXT_RANGE * );
    HRESULT Draw(void * ,struct IDWriteTextRenderer * ,float ,float );
    HRESULT GetLineMetrics(struct DWRITE_LINE_METRICS * ,unsigned int ,unsigned int * );
    HRESULT GetMetrics(struct DWRITE_TEXT_METRICS * );
    HRESULT GetOverhangMetrics(struct DWRITE_OVERHANG_METRICS * );
    HRESULT GetClusterMetrics(struct DWRITE_CLUSTER_METRICS * ,unsigned int ,unsigned int * );
    HRESULT DetermineMinWidth(float * );
    HRESULT HitTestPoint(float ,float ,int * ,int * ,struct DWRITE_HIT_TEST_METRICS * );
    HRESULT HitTestTextPosition(unsigned int ,int ,float * ,float * ,struct DWRITE_HIT_TEST_METRICS * );
    HRESULT HitTestTextRange(unsigned int ,unsigned int ,float ,float ,struct DWRITE_HIT_TEST_METRICS * ,unsigned int ,unsigned int * );
    void IDWriteTextLayout(struct IDWriteTextLayout & );
    void IDWriteTextLayout();
    struct IDWriteTextLayout & operator=(struct IDWriteTextLayout & );
};

struct IDWriteTextLayout : public IDWriteTextFormat
{
    HRESULT SetMaxWidth(float );
    HRESULT SetMaxHeight(float );
    HRESULT SetFontCollection(struct IDWriteFontCollection * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontFamilyName(wchar_t * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontWeight(enum DWRITE_FONT_WEIGHT ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontStyle(enum DWRITE_FONT_STYLE ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontStretch(enum DWRITE_FONT_STRETCH ,struct DWRITE_TEXT_RANGE );
    HRESULT SetFontSize(float ,struct DWRITE_TEXT_RANGE );
    HRESULT SetUnderline(int ,struct DWRITE_TEXT_RANGE );
    HRESULT SetStrikethrough(int ,struct DWRITE_TEXT_RANGE );
    HRESULT SetDrawingEffect(struct IUnknown * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetInlineObject(struct IDWriteInlineObject * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetTypography(struct IDWriteTypography * ,struct DWRITE_TEXT_RANGE );
    HRESULT SetLocaleName(wchar_t * ,struct DWRITE_TEXT_RANGE );
    float GetMaxWidth();
    float GetMaxHeight();
    HRESULT GetFontCollection(unsigned int ,struct IDWriteFontCollection ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontFamilyNameLength(unsigned int ,unsigned int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontFamilyName(unsigned int ,wchar_t * ,unsigned int ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontWeight(unsigned int ,enum DWRITE_FONT_WEIGHT * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontStyle(unsigned int ,enum DWRITE_FONT_STYLE * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontStretch(unsigned int ,enum DWRITE_FONT_STRETCH * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetFontSize(unsigned int ,float * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetUnderline(unsigned int ,int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetStrikethrough(unsigned int ,int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetDrawingEffect(unsigned int ,struct IUnknown ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetInlineObject(unsigned int ,struct IDWriteInlineObject ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetTypography(unsigned int ,struct IDWriteTypography ** ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetLocaleNameLength(unsigned int ,unsigned int * ,struct DWRITE_TEXT_RANGE * );
    HRESULT GetLocaleName(unsigned int ,wchar_t * ,unsigned int ,struct DWRITE_TEXT_RANGE * );
    HRESULT Draw(void * ,struct IDWriteTextRenderer * ,float ,float );
    HRESULT GetLineMetrics(struct DWRITE_LINE_METRICS * ,unsigned int ,unsigned int * );
    HRESULT GetMetrics(struct DWRITE_TEXT_METRICS * );
    HRESULT GetOverhangMetrics(struct DWRITE_OVERHANG_METRICS * );
    HRESULT GetClusterMetrics(struct DWRITE_CLUSTER_METRICS * ,unsigned int ,unsigned int * );
    HRESULT DetermineMinWidth(float * );
    HRESULT HitTestPoint(float ,float ,int * ,int * ,struct DWRITE_HIT_TEST_METRICS * );
    HRESULT HitTestTextPosition(unsigned int ,int ,float * ,float * ,struct DWRITE_HIT_TEST_METRICS * );
    HRESULT HitTestTextRange(unsigned int ,unsigned int ,float ,float ,struct DWRITE_HIT_TEST_METRICS * ,unsigned int ,unsigned int * );
    void IDWriteTextLayout(struct IDWriteTextLayout & );
    void IDWriteTextLayout();
    struct IDWriteTextLayout & operator=(struct IDWriteTextLayout & );
};

struct _D3DX10_TEXTURE_LOAD_INFO
{
    struct D3D10_BOX * pSrcBox;
    struct D3D10_BOX * pDstBox;
    unsigned int SrcFirstMip;
    unsigned int DstFirstMip;
    unsigned int NumMips;
    unsigned int SrcFirstElement;
    unsigned int DstFirstElement;
    unsigned int NumElements;
    unsigned int Filter;
    unsigned int MipFilter;
    void _D3DX10_TEXTURE_LOAD_INFO();
};

struct XAUDIO2_EFFECT_CHAIN
{
    unsigned int EffectCount;
    struct XAUDIO2_EFFECT_DESCRIPTOR * pEffectDescriptors;
};

struct D3DX11_IMAGE_LOAD_INFO
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int FirstMipLevel;
    unsigned int MipLevels;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CpuAccessFlags;
    unsigned int MiscFlags;
    enum DXGI_FORMAT Format;
    unsigned int Filter;
    unsigned int MipFilter;
    struct D3DX11_IMAGE_INFO * pSrcInfo;
    void D3DX11_IMAGE_LOAD_INFO();
};

struct __lc_time_data
{
};

struct threadlocaleinfostruct
{
    int refcount;
    unsigned int lc_codepage;
    unsigned int lc_collate_cp;
    unsigned long lc_handle[6];
    struct tagLC_ID lc_id[6];
    struct <unnamed-type-lc_category>
    {
        char * locale;
        wchar_t * wlocale;
        int * refcount;
        int * wrefcount;
    };
    struct threadlocaleinfostruct::<unnamed-type-lc_category> lc_category[6];
    int lc_clike;
    int mb_cur_max;
    int * lconv_intl_refcount;
    int * lconv_num_refcount;
    int * lconv_mon_refcount;
    struct lconv * lconv;
    int * ctype1_refcount;
    unsigned int * ctype1;
    unsigned int * pctype;
    unsigned int * pclmap;
    unsigned int * pcumap;
    struct __lc_time_data * lc_time_curr;
};

struct threadlocaleinfostruct::<unnamed-type-lc_category>
{
    char * locale;
    wchar_t * wlocale;
    int * refcount;
    int * wrefcount;
};

struct _D3DRASTER_STATUS
{
    int InVBlank;
    unsigned int ScanLine;
};

struct D3D11_SO_DECLARATION_ENTRY
{
    unsigned int Stream;
    char * SemanticName;
    unsigned int SemanticIndex;
    unsigned int StartComponent;
    unsigned int ComponentCount;
    unsigned int OutputSlot;
};

struct IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    void IXAudio2Voice(struct IXAudio2Voice & );
    void IXAudio2Voice();
    struct IXAudio2Voice & operator=(struct IXAudio2Voice & );
};

struct IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    void IXAudio2Voice(struct IXAudio2Voice & );
    void IXAudio2Voice();
    struct IXAudio2Voice & operator=(struct IXAudio2Voice & );
};

struct ID3D11RenderTargetView : public ID3D11View
{
    void GetDesc(struct D3D11_RENDER_TARGET_VIEW_DESC * );
    void ID3D11RenderTargetView(struct ID3D11RenderTargetView & );
    void ID3D11RenderTargetView();
    struct ID3D11RenderTargetView & operator=(struct ID3D11RenderTargetView & );
};

struct ID3D11RenderTargetView : public ID3D11View
{
    void GetDesc(struct D3D11_RENDER_TARGET_VIEW_DESC * );
    void ID3D11RenderTargetView(struct ID3D11RenderTargetView & );
    void ID3D11RenderTargetView();
    struct ID3D11RenderTargetView & operator=(struct ID3D11RenderTargetView & );
};

struct D3D11_BLEND_DESC
{
    int AlphaToCoverageEnable;
    int IndependentBlendEnable;
    struct D3D11_RENDER_TARGET_BLEND_DESC RenderTarget[8];
};

struct D3D11_TEX1D_ARRAY_DSV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct _D3DMATRIX
{
    float _11;
    float _12;
    float _13;
    float _14;
    float _21;
    float _22;
    float _23;
    float _24;
    float _31;
    float _32;
    float _33;
    float _34;
    float _41;
    float _42;
    float _43;
    float _44;
    float m[4][4];
};

struct _D3DXMATRIXA16 : public D3DXMATRIX
{
    void _D3DXMATRIXA16(float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    void _D3DXMATRIXA16(struct D3DXFLOAT16 * );
    void _D3DXMATRIXA16(struct _D3DMATRIX & );
    void _D3DXMATRIXA16(float * );
    void _D3DXMATRIXA16();
    void * operator new(unsigned int );
    void * operator new[](unsigned int );
    void operator delete(void * );
    void operator delete[](void * );
};

struct ID3D11GeometryShader : public ID3D11DeviceChild
{
    void ID3D11GeometryShader(struct ID3D11GeometryShader & );
    void ID3D11GeometryShader();
    struct ID3D11GeometryShader & operator=(struct ID3D11GeometryShader & );
};

struct ID3D11GeometryShader : public ID3D11DeviceChild
{
    void ID3D11GeometryShader(struct ID3D11GeometryShader & );
    void ID3D11GeometryShader();
    struct ID3D11GeometryShader & operator=(struct ID3D11GeometryShader & );
};

struct IDXGISurface : public IDXGIDeviceSubObject
{
    HRESULT GetDesc(struct DXGI_SURFACE_DESC * );
    HRESULT Map(struct DXGI_MAPPED_RECT * ,unsigned int );
    HRESULT Unmap();
    void IDXGISurface(struct IDXGISurface & );
    void IDXGISurface();
    struct IDXGISurface & operator=(struct IDXGISurface & );
};

struct IDXGISurface : public IDXGIDeviceSubObject
{
    HRESULT GetDesc(struct DXGI_SURFACE_DESC * );
    HRESULT Map(struct DXGI_MAPPED_RECT * ,unsigned int );
    HRESULT Unmap();
    void IDXGISurface(struct IDXGISurface & );
    void IDXGISurface();
    struct IDXGISurface & operator=(struct IDXGISurface & );
};

struct D3D11_TEX1D_UAV
{
    unsigned int MipSlice;
};

struct _iobuf
{
    char * _ptr;
    int _cnt;
    char * _base;
    int _flag;
    int _file;
    int _charbuf;
    int _bufsiz;
    char * _tmpfname;
};

struct D2D1_BRUSH_PROPERTIES
{
    float opacity;
    struct D2D_MATRIX_3X2_F transform;
};

struct D3D11_SUBRESOURCE_DATA
{
    void * pSysMem;
    unsigned int SysMemPitch;
    unsigned int SysMemSlicePitch;
};

struct D3D11_TEXTURE2D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    struct DXGI_SAMPLE_DESC SampleDesc;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct D3D11_UNORDERED_ACCESS_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D11_UAV_DIMENSION ViewDimension;
    struct D3D11_BUFFER_UAV Buffer;
    struct D3D11_TEX1D_UAV Texture1D;
    struct D3D11_TEX1D_ARRAY_UAV Texture1DArray;
    struct D3D11_TEX2D_UAV Texture2D;
    struct D3D11_TEX2D_ARRAY_UAV Texture2DArray;
    struct D3D11_TEX3D_UAV Texture3D;
};

struct D3D11_RENDER_TARGET_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D11_RTV_DIMENSION ViewDimension;
    struct D3D11_BUFFER_RTV Buffer;
    struct D3D11_TEX1D_RTV Texture1D;
    struct D3D11_TEX1D_ARRAY_RTV Texture1DArray;
    struct D3D11_TEX2D_RTV Texture2D;
    struct D3D11_TEX2D_ARRAY_RTV Texture2DArray;
    struct D3D11_TEX2DMS_RTV Texture2DMS;
    struct D3D11_TEX2DMS_ARRAY_RTV Texture2DMSArray;
    struct D3D11_TEX3D_RTV Texture3D;
};

struct D3D11_INPUT_ELEMENT_DESC
{
    char * SemanticName;
    unsigned int SemanticIndex;
    enum DXGI_FORMAT Format;
    unsigned int InputSlot;
    unsigned int AlignedByteOffset;
    enum D3D11_INPUT_CLASSIFICATION InputSlotClass;
    unsigned int InstanceDataStepRate;
};

struct D3D11_SO_DECLARATION_ENTRY
{
    unsigned int Stream;
    char * SemanticName;
    unsigned int SemanticIndex;
    unsigned int StartComponent;
    unsigned int ComponentCount;
    unsigned int OutputSlot;
};

struct D3D11_DEPTH_STENCIL_DESC
{
    int DepthEnable;
    enum D3D11_DEPTH_WRITE_MASK DepthWriteMask;
    enum D3D11_COMPARISON_FUNC DepthFunc;
    int StencilEnable;
    unsigned int StencilReadMask;
    unsigned int StencilWriteMask;
    struct D3D11_DEPTH_STENCILOP_DESC FrontFace;
    struct D3D11_DEPTH_STENCILOP_DESC BackFace;
};

struct D3D11_RASTERIZER_DESC
{
    enum D3D11_FILL_MODE FillMode;
    enum D3D11_CULL_MODE CullMode;
    int FrontCounterClockwise;
    int DepthBias;
    float DepthBiasClamp;
    float SlopeScaledDepthBias;
    int DepthClipEnable;
    int ScissorEnable;
    int MultisampleEnable;
    int AntialiasedLineEnable;
};

struct D3D11_SAMPLER_DESC
{
    enum D3D11_FILTER Filter;
    enum D3D11_TEXTURE_ADDRESS_MODE AddressU;
    enum D3D11_TEXTURE_ADDRESS_MODE AddressV;
    enum D3D11_TEXTURE_ADDRESS_MODE AddressW;
    float MipLODBias;
    unsigned int MaxAnisotropy;
    enum D3D11_COMPARISON_FUNC ComparisonFunc;
    float BorderColor[4];
    float MinLOD;
    float MaxLOD;
};

struct D3D11_QUERY_DESC
{
    enum D3D11_QUERY Query;
    unsigned int MiscFlags;
};

struct D3D11_COUNTER_DESC
{
    enum D3D11_COUNTER Counter;
    unsigned int MiscFlags;
};

enum D3D_FEATURE_LEVEL
{
    D3D_FEATURE_LEVEL_9_1=37120,
    D3D_FEATURE_LEVEL_9_2=37376,
    D3D_FEATURE_LEVEL_9_3=37632,
    D3D_FEATURE_LEVEL_10_0=40960,
    D3D_FEATURE_LEVEL_10_1=41216,
    D3D_FEATURE_LEVEL_11_0=45056
};

struct ID3D11Device : public IUnknown
{
    HRESULT CreateBuffer(struct D3D11_BUFFER_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Buffer ** );
    HRESULT CreateTexture1D(struct D3D11_TEXTURE1D_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Texture1D ** );
    HRESULT CreateTexture2D(struct D3D11_TEXTURE2D_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Texture2D ** );
    HRESULT CreateTexture3D(struct D3D11_TEXTURE3D_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Texture3D ** );
    HRESULT CreateShaderResourceView(struct ID3D11Resource * ,struct D3D11_SHADER_RESOURCE_VIEW_DESC * ,struct ID3D11ShaderResourceView ** );
    HRESULT CreateUnorderedAccessView(struct ID3D11Resource * ,struct D3D11_UNORDERED_ACCESS_VIEW_DESC * ,struct ID3D11UnorderedAccessView ** );
    HRESULT CreateRenderTargetView(struct ID3D11Resource * ,struct D3D11_RENDER_TARGET_VIEW_DESC * ,struct ID3D11RenderTargetView ** );
    HRESULT CreateDepthStencilView(struct ID3D11Resource * ,struct D3D11_DEPTH_STENCIL_VIEW_DESC * ,struct ID3D11DepthStencilView ** );
    HRESULT CreateInputLayout(struct D3D11_INPUT_ELEMENT_DESC * ,unsigned int ,void * ,unsigned long ,struct ID3D11InputLayout ** );
    HRESULT CreateVertexShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11VertexShader ** );
    HRESULT CreateGeometryShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11GeometryShader ** );
    HRESULT CreateGeometryShaderWithStreamOutput(void * ,unsigned long ,struct D3D11_SO_DECLARATION_ENTRY * ,unsigned int ,unsigned int * ,unsigned int ,unsigned int ,struct ID3D11ClassLinkage * ,struct ID3D11GeometryShader ** );
    HRESULT CreatePixelShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11PixelShader ** );
    HRESULT CreateHullShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11HullShader ** );
    HRESULT CreateDomainShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11DomainShader ** );
    HRESULT CreateComputeShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11ComputeShader ** );
    HRESULT CreateClassLinkage(struct ID3D11ClassLinkage ** );
    HRESULT CreateBlendState(struct D3D11_BLEND_DESC * ,struct ID3D11BlendState ** );
    HRESULT CreateDepthStencilState(struct D3D11_DEPTH_STENCIL_DESC * ,struct ID3D11DepthStencilState ** );
    HRESULT CreateRasterizerState(struct D3D11_RASTERIZER_DESC * ,struct ID3D11RasterizerState ** );
    HRESULT CreateSamplerState(struct D3D11_SAMPLER_DESC * ,struct ID3D11SamplerState ** );
    HRESULT CreateQuery(struct D3D11_QUERY_DESC * ,struct ID3D11Query ** );
    HRESULT CreatePredicate(struct D3D11_QUERY_DESC * ,struct ID3D11Predicate ** );
    HRESULT CreateCounter(struct D3D11_COUNTER_DESC * ,struct ID3D11Counter ** );
    HRESULT CreateDeferredContext(unsigned int ,struct ID3D11DeviceContext ** );
    HRESULT OpenSharedResource(void * ,struct _GUID & ,void ** );
    HRESULT CheckFormatSupport(enum DXGI_FORMAT ,unsigned int * );
    HRESULT CheckMultisampleQualityLevels(enum DXGI_FORMAT ,unsigned int ,unsigned int * );
    void CheckCounterInfo(struct D3D11_COUNTER_INFO * );
    HRESULT CheckCounter(struct D3D11_COUNTER_DESC * ,enum D3D11_COUNTER_TYPE * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * );
    HRESULT CheckFeatureSupport(enum D3D11_FEATURE ,void * ,unsigned int );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    enum D3D_FEATURE_LEVEL GetFeatureLevel();
    unsigned int GetCreationFlags();
    HRESULT GetDeviceRemovedReason();
    void GetImmediateContext(struct ID3D11DeviceContext ** );
    HRESULT SetExceptionMode(unsigned int );
    unsigned int GetExceptionMode();
    void ID3D11Device(struct ID3D11Device & );
    void ID3D11Device();
    struct ID3D11Device & operator=(struct ID3D11Device & );
};

struct ID3D11Device : public IUnknown
{
    HRESULT CreateBuffer(struct D3D11_BUFFER_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Buffer ** );
    HRESULT CreateTexture1D(struct D3D11_TEXTURE1D_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Texture1D ** );
    HRESULT CreateTexture2D(struct D3D11_TEXTURE2D_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Texture2D ** );
    HRESULT CreateTexture3D(struct D3D11_TEXTURE3D_DESC * ,struct D3D11_SUBRESOURCE_DATA * ,struct ID3D11Texture3D ** );
    HRESULT CreateShaderResourceView(struct ID3D11Resource * ,struct D3D11_SHADER_RESOURCE_VIEW_DESC * ,struct ID3D11ShaderResourceView ** );
    HRESULT CreateUnorderedAccessView(struct ID3D11Resource * ,struct D3D11_UNORDERED_ACCESS_VIEW_DESC * ,struct ID3D11UnorderedAccessView ** );
    HRESULT CreateRenderTargetView(struct ID3D11Resource * ,struct D3D11_RENDER_TARGET_VIEW_DESC * ,struct ID3D11RenderTargetView ** );
    HRESULT CreateDepthStencilView(struct ID3D11Resource * ,struct D3D11_DEPTH_STENCIL_VIEW_DESC * ,struct ID3D11DepthStencilView ** );
    HRESULT CreateInputLayout(struct D3D11_INPUT_ELEMENT_DESC * ,unsigned int ,void * ,unsigned long ,struct ID3D11InputLayout ** );
    HRESULT CreateVertexShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11VertexShader ** );
    HRESULT CreateGeometryShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11GeometryShader ** );
    HRESULT CreateGeometryShaderWithStreamOutput(void * ,unsigned long ,struct D3D11_SO_DECLARATION_ENTRY * ,unsigned int ,unsigned int * ,unsigned int ,unsigned int ,struct ID3D11ClassLinkage * ,struct ID3D11GeometryShader ** );
    HRESULT CreatePixelShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11PixelShader ** );
    HRESULT CreateHullShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11HullShader ** );
    HRESULT CreateDomainShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11DomainShader ** );
    HRESULT CreateComputeShader(void * ,unsigned long ,struct ID3D11ClassLinkage * ,struct ID3D11ComputeShader ** );
    HRESULT CreateClassLinkage(struct ID3D11ClassLinkage ** );
    HRESULT CreateBlendState(struct D3D11_BLEND_DESC * ,struct ID3D11BlendState ** );
    HRESULT CreateDepthStencilState(struct D3D11_DEPTH_STENCIL_DESC * ,struct ID3D11DepthStencilState ** );
    HRESULT CreateRasterizerState(struct D3D11_RASTERIZER_DESC * ,struct ID3D11RasterizerState ** );
    HRESULT CreateSamplerState(struct D3D11_SAMPLER_DESC * ,struct ID3D11SamplerState ** );
    HRESULT CreateQuery(struct D3D11_QUERY_DESC * ,struct ID3D11Query ** );
    HRESULT CreatePredicate(struct D3D11_QUERY_DESC * ,struct ID3D11Predicate ** );
    HRESULT CreateCounter(struct D3D11_COUNTER_DESC * ,struct ID3D11Counter ** );
    HRESULT CreateDeferredContext(unsigned int ,struct ID3D11DeviceContext ** );
    HRESULT OpenSharedResource(void * ,struct _GUID & ,void ** );
    HRESULT CheckFormatSupport(enum DXGI_FORMAT ,unsigned int * );
    HRESULT CheckMultisampleQualityLevels(enum DXGI_FORMAT ,unsigned int ,unsigned int * );
    void CheckCounterInfo(struct D3D11_COUNTER_INFO * );
    HRESULT CheckCounter(struct D3D11_COUNTER_DESC * ,enum D3D11_COUNTER_TYPE * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * ,char * ,unsigned int * );
    HRESULT CheckFeatureSupport(enum D3D11_FEATURE ,void * ,unsigned int );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    enum D3D_FEATURE_LEVEL GetFeatureLevel();
    unsigned int GetCreationFlags();
    HRESULT GetDeviceRemovedReason();
    void GetImmediateContext(struct ID3D11DeviceContext ** );
    HRESULT SetExceptionMode(unsigned int );
    unsigned int GetExceptionMode();
    void ID3D11Device(struct ID3D11Device & );
    void ID3D11Device();
    struct ID3D11Device & operator=(struct ID3D11Device & );
};

struct D2D_RECT_F
{
    float left;
    float top;
    float right;
    float bottom;
};

struct D2D1_ROUNDED_RECT
{
    struct D2D_RECT_F rect;
    float radiusX;
    float radiusY;
};

struct D2D1_ELLIPSE
{
    struct D2D_POINT_2F point;
    float radiusX;
    float radiusY;
};

struct D2D1_STROKE_STYLE_PROPERTIES
{
    enum D2D1_CAP_STYLE startCap;
    enum D2D1_CAP_STYLE endCap;
    enum D2D1_CAP_STYLE dashCap;
    enum D2D1_LINE_JOIN lineJoin;
    float miterLimit;
    enum D2D1_DASH_STYLE dashStyle;
    float dashOffset;
};

struct D2D1_RENDER_TARGET_PROPERTIES
{
    enum D2D1_RENDER_TARGET_TYPE type;
    struct D2D1_PIXEL_FORMAT pixelFormat;
    float dpiX;
    float dpiY;
    enum D2D1_RENDER_TARGET_USAGE usage;
    enum D2D1_FEATURE_LEVEL minLevel;
};

struct D2D1_HWND_RENDER_TARGET_PROPERTIES
{
    struct HWND__ * hwnd;
    struct D2D_SIZE_U pixelSize;
    enum D2D1_PRESENT_OPTIONS presentOptions;
};

struct ID2D1Factory : public IUnknown
{
    HRESULT ReloadSystemMetrics();
    void GetDesktopDpi(float * ,float * );
    HRESULT CreateRectangleGeometry(struct D2D_RECT_F & ,struct ID2D1RectangleGeometry ** );
    HRESULT CreateRectangleGeometry(struct D2D_RECT_F * ,struct ID2D1RectangleGeometry ** );
    HRESULT CreateRoundedRectangleGeometry(struct D2D1_ROUNDED_RECT & ,struct ID2D1RoundedRectangleGeometry ** );
    HRESULT CreateRoundedRectangleGeometry(struct D2D1_ROUNDED_RECT * ,struct ID2D1RoundedRectangleGeometry ** );
    HRESULT CreateEllipseGeometry(struct D2D1_ELLIPSE & ,struct ID2D1EllipseGeometry ** );
    HRESULT CreateEllipseGeometry(struct D2D1_ELLIPSE * ,struct ID2D1EllipseGeometry ** );
    HRESULT CreateGeometryGroup(enum D2D1_FILL_MODE ,struct ID2D1Geometry ** ,unsigned int ,struct ID2D1GeometryGroup ** );
    HRESULT CreateTransformedGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F & ,struct ID2D1TransformedGeometry ** );
    HRESULT CreateTransformedGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F * ,struct ID2D1TransformedGeometry ** );
    HRESULT CreatePathGeometry(struct ID2D1PathGeometry ** );
    HRESULT CreateStrokeStyle(struct D2D1_STROKE_STYLE_PROPERTIES & ,float * ,unsigned int ,struct ID2D1StrokeStyle ** );
    HRESULT CreateStrokeStyle(struct D2D1_STROKE_STYLE_PROPERTIES * ,float * ,unsigned int ,struct ID2D1StrokeStyle ** );
    HRESULT CreateDrawingStateBlock(struct ID2D1DrawingStateBlock ** );
    HRESULT CreateDrawingStateBlock(struct D2D1_DRAWING_STATE_DESCRIPTION & ,struct ID2D1DrawingStateBlock ** );
    HRESULT CreateDrawingStateBlock(struct D2D1_DRAWING_STATE_DESCRIPTION * ,struct IDWriteRenderingParams * ,struct ID2D1DrawingStateBlock ** );
    HRESULT CreateWicBitmapRenderTarget(struct IWICBitmap * ,struct D2D1_RENDER_TARGET_PROPERTIES & ,struct ID2D1RenderTarget ** );
    HRESULT CreateWicBitmapRenderTarget(struct IWICBitmap * ,struct D2D1_RENDER_TARGET_PROPERTIES * ,struct ID2D1RenderTarget ** );
    HRESULT CreateHwndRenderTarget(struct D2D1_RENDER_TARGET_PROPERTIES & ,struct D2D1_HWND_RENDER_TARGET_PROPERTIES & ,struct ID2D1HwndRenderTarget ** );
    HRESULT CreateHwndRenderTarget(struct D2D1_RENDER_TARGET_PROPERTIES * ,struct D2D1_HWND_RENDER_TARGET_PROPERTIES * ,struct ID2D1HwndRenderTarget ** );
    HRESULT CreateDxgiSurfaceRenderTarget(struct IDXGISurface * ,struct D2D1_RENDER_TARGET_PROPERTIES & ,struct ID2D1RenderTarget ** );
    HRESULT CreateDxgiSurfaceRenderTarget(struct IDXGISurface * ,struct D2D1_RENDER_TARGET_PROPERTIES * ,struct ID2D1RenderTarget ** );
    HRESULT CreateDCRenderTarget(struct D2D1_RENDER_TARGET_PROPERTIES * ,struct ID2D1DCRenderTarget ** );
    void ID2D1Factory(struct ID2D1Factory & );
    void ID2D1Factory();
    struct ID2D1Factory & operator=(struct ID2D1Factory & );
};

struct ID2D1Factory : public IUnknown
{
    HRESULT ReloadSystemMetrics();
    void GetDesktopDpi(float * ,float * );
    HRESULT CreateRectangleGeometry(struct D2D_RECT_F & ,struct ID2D1RectangleGeometry ** );
    HRESULT CreateRectangleGeometry(struct D2D_RECT_F * ,struct ID2D1RectangleGeometry ** );
    HRESULT CreateRoundedRectangleGeometry(struct D2D1_ROUNDED_RECT & ,struct ID2D1RoundedRectangleGeometry ** );
    HRESULT CreateRoundedRectangleGeometry(struct D2D1_ROUNDED_RECT * ,struct ID2D1RoundedRectangleGeometry ** );
    HRESULT CreateEllipseGeometry(struct D2D1_ELLIPSE & ,struct ID2D1EllipseGeometry ** );
    HRESULT CreateEllipseGeometry(struct D2D1_ELLIPSE * ,struct ID2D1EllipseGeometry ** );
    HRESULT CreateGeometryGroup(enum D2D1_FILL_MODE ,struct ID2D1Geometry ** ,unsigned int ,struct ID2D1GeometryGroup ** );
    HRESULT CreateTransformedGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F & ,struct ID2D1TransformedGeometry ** );
    HRESULT CreateTransformedGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F * ,struct ID2D1TransformedGeometry ** );
    HRESULT CreatePathGeometry(struct ID2D1PathGeometry ** );
    HRESULT CreateStrokeStyle(struct D2D1_STROKE_STYLE_PROPERTIES & ,float * ,unsigned int ,struct ID2D1StrokeStyle ** );
    HRESULT CreateStrokeStyle(struct D2D1_STROKE_STYLE_PROPERTIES * ,float * ,unsigned int ,struct ID2D1StrokeStyle ** );
    HRESULT CreateDrawingStateBlock(struct ID2D1DrawingStateBlock ** );
    HRESULT CreateDrawingStateBlock(struct D2D1_DRAWING_STATE_DESCRIPTION & ,struct ID2D1DrawingStateBlock ** );
    HRESULT CreateDrawingStateBlock(struct D2D1_DRAWING_STATE_DESCRIPTION * ,struct IDWriteRenderingParams * ,struct ID2D1DrawingStateBlock ** );
    HRESULT CreateWicBitmapRenderTarget(struct IWICBitmap * ,struct D2D1_RENDER_TARGET_PROPERTIES & ,struct ID2D1RenderTarget ** );
    HRESULT CreateWicBitmapRenderTarget(struct IWICBitmap * ,struct D2D1_RENDER_TARGET_PROPERTIES * ,struct ID2D1RenderTarget ** );
    HRESULT CreateHwndRenderTarget(struct D2D1_RENDER_TARGET_PROPERTIES & ,struct D2D1_HWND_RENDER_TARGET_PROPERTIES & ,struct ID2D1HwndRenderTarget ** );
    HRESULT CreateHwndRenderTarget(struct D2D1_RENDER_TARGET_PROPERTIES * ,struct D2D1_HWND_RENDER_TARGET_PROPERTIES * ,struct ID2D1HwndRenderTarget ** );
    HRESULT CreateDxgiSurfaceRenderTarget(struct IDXGISurface * ,struct D2D1_RENDER_TARGET_PROPERTIES & ,struct ID2D1RenderTarget ** );
    HRESULT CreateDxgiSurfaceRenderTarget(struct IDXGISurface * ,struct D2D1_RENDER_TARGET_PROPERTIES * ,struct ID2D1RenderTarget ** );
    HRESULT CreateDCRenderTarget(struct D2D1_RENDER_TARGET_PROPERTIES * ,struct ID2D1DCRenderTarget ** );
    void ID2D1Factory(struct ID2D1Factory & );
    void ID2D1Factory();
    struct ID2D1Factory & operator=(struct ID2D1Factory & );
};

struct D3D11_UNORDERED_ACCESS_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D11_UAV_DIMENSION ViewDimension;
    struct D3D11_BUFFER_UAV Buffer;
    struct D3D11_TEX1D_UAV Texture1D;
    struct D3D11_TEX1D_ARRAY_UAV Texture1DArray;
    struct D3D11_TEX2D_UAV Texture2D;
    struct D3D11_TEX2D_ARRAY_UAV Texture2DArray;
    struct D3D11_TEX3D_UAV Texture3D;
};

struct D3D10_BOX
{
    unsigned int left;
    unsigned int top;
    unsigned int front;
    unsigned int right;
    unsigned int bottom;
    unsigned int back;
};

struct CD3D11_QUERY_DESC : public D3D11_QUERY_DESC
{
    void CD3D11_QUERY_DESC(enum D3D11_QUERY ,unsigned int );
    void CD3D11_QUERY_DESC(struct D3D11_QUERY_DESC & );
    void CD3D11_QUERY_DESC();
    void ~CD3D11_QUERY_DESC();
    struct D3D11_QUERY_DESC & operator const struct D3D11_QUERY_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_QUERY_DESC : public D3D11_QUERY_DESC
{
    void CD3D11_QUERY_DESC(enum D3D11_QUERY ,unsigned int );
    void CD3D11_QUERY_DESC(struct D3D11_QUERY_DESC & );
    void CD3D11_QUERY_DESC();
    void ~CD3D11_QUERY_DESC();
    struct D3D11_QUERY_DESC & operator const struct D3D11_QUERY_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEX2DMS_ARRAY_DSV
{
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct D3D11_SHADER_RESOURCE_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D_SRV_DIMENSION ViewDimension;
    struct D3D11_BUFFER_SRV Buffer;
    struct D3D11_TEX1D_SRV Texture1D;
    struct D3D11_TEX1D_ARRAY_SRV Texture1DArray;
    struct D3D11_TEX2D_SRV Texture2D;
    struct D3D11_TEX2D_ARRAY_SRV Texture2DArray;
    struct D3D11_TEX2DMS_SRV Texture2DMS;
    struct D3D11_TEX2DMS_ARRAY_SRV Texture2DMSArray;
    struct D3D11_TEX3D_SRV Texture3D;
    struct D3D11_TEXCUBE_SRV TextureCube;
    struct D3D11_TEXCUBE_ARRAY_SRV TextureCubeArray;
    struct D3D11_BUFFEREX_SRV BufferEx;
};

struct CD3D11_VIEWPORT : public D3D11_VIEWPORT
{
    void CD3D11_VIEWPORT(struct ID3D11Texture3D * ,struct ID3D11RenderTargetView * ,float ,float ,float ,float );
    void CD3D11_VIEWPORT(struct ID3D11Texture2D * ,struct ID3D11RenderTargetView * ,float ,float ,float ,float );
    void CD3D11_VIEWPORT(struct ID3D11Texture1D * ,struct ID3D11RenderTargetView * ,float ,float ,float );
    void CD3D11_VIEWPORT(struct ID3D11Buffer * ,struct ID3D11RenderTargetView * ,float ,float ,float );
    void CD3D11_VIEWPORT(float ,float ,float ,float ,float ,float );
    void CD3D11_VIEWPORT(struct D3D11_VIEWPORT & );
    void CD3D11_VIEWPORT();
    void ~CD3D11_VIEWPORT();
    struct D3D11_VIEWPORT & operator const struct D3D11_VIEWPORT &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_VIEWPORT : public D3D11_VIEWPORT
{
    void CD3D11_VIEWPORT(struct ID3D11Texture3D * ,struct ID3D11RenderTargetView * ,float ,float ,float ,float );
    void CD3D11_VIEWPORT(struct ID3D11Texture2D * ,struct ID3D11RenderTargetView * ,float ,float ,float ,float );
    void CD3D11_VIEWPORT(struct ID3D11Texture1D * ,struct ID3D11RenderTargetView * ,float ,float ,float );
    void CD3D11_VIEWPORT(struct ID3D11Buffer * ,struct ID3D11RenderTargetView * ,float ,float ,float );
    void CD3D11_VIEWPORT(float ,float ,float ,float ,float ,float );
    void CD3D11_VIEWPORT(struct D3D11_VIEWPORT & );
    void CD3D11_VIEWPORT();
    void ~CD3D11_VIEWPORT();
    struct D3D11_VIEWPORT & operator const struct D3D11_VIEWPORT &();
    void * __vecDelDtor(unsigned int );
};

struct IDirect3DVertexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DVERTEXBUFFER_DESC * );
    void IDirect3DVertexBuffer9(struct IDirect3DVertexBuffer9 & );
    void IDirect3DVertexBuffer9();
    struct IDirect3DVertexBuffer9 & operator=(struct IDirect3DVertexBuffer9 & );
};

struct IDirect3DVertexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DVERTEXBUFFER_DESC * );
    void IDirect3DVertexBuffer9(struct IDirect3DVertexBuffer9 & );
    void IDirect3DVertexBuffer9();
    struct IDirect3DVertexBuffer9 & operator=(struct IDirect3DVertexBuffer9 & );
};

struct D2D1_BITMAP_BRUSH_PROPERTIES
{
    enum D2D1_EXTEND_MODE extendModeX;
    enum D2D1_EXTEND_MODE extendModeY;
    enum D2D1_BITMAP_INTERPOLATION_MODE interpolationMode;
};

struct D2D_SIZE_F
{
    float width;
    float height;
};

struct D3D11_TEX3D_RTV
{
    unsigned int MipSlice;
    unsigned int FirstWSlice;
    unsigned int WSize;
};

struct ID2D1EllipseGeometry : public ID2D1Geometry
{
    void GetEllipse(struct D2D1_ELLIPSE * );
    void ID2D1EllipseGeometry(struct ID2D1EllipseGeometry & );
    void ID2D1EllipseGeometry();
    struct ID2D1EllipseGeometry & operator=(struct ID2D1EllipseGeometry & );
};

struct ID2D1EllipseGeometry : public ID2D1Geometry
{
    void GetEllipse(struct D2D1_ELLIPSE * );
    void ID2D1EllipseGeometry(struct ID2D1EllipseGeometry & );
    void ID2D1EllipseGeometry();
    struct ID2D1EllipseGeometry & operator=(struct ID2D1EllipseGeometry & );
};

struct D3D11_TEXTURE2D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    struct DXGI_SAMPLE_DESC SampleDesc;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct IDirect3DQuery9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    enum _D3DQUERYTYPE GetType();
    unsigned long GetDataSize();
    HRESULT Issue(unsigned long );
    HRESULT GetData(void * ,unsigned long ,unsigned long );
    void IDirect3DQuery9(struct IDirect3DQuery9 & );
    void IDirect3DQuery9();
    struct IDirect3DQuery9 & operator=(struct IDirect3DQuery9 & );
};

struct IDirect3DQuery9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    enum _D3DQUERYTYPE GetType();
    unsigned long GetDataSize();
    HRESULT Issue(unsigned long );
    HRESULT GetData(void * ,unsigned long ,unsigned long );
    void IDirect3DQuery9(struct IDirect3DQuery9 & );
    void IDirect3DQuery9();
    struct IDirect3DQuery9 & operator=(struct IDirect3DQuery9 & );
};

struct D3D11_TEX2D_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct WICRect
{
    int X;
    int Y;
    int Width;
    int Height;
};

struct IWICBitmap : public IWICBitmapSource
{
    HRESULT Lock(struct WICRect * ,unsigned long ,struct IWICBitmapLock ** );
    HRESULT SetPalette(struct IWICPalette * );
    HRESULT SetResolution(float ,float );
    void IWICBitmap(struct IWICBitmap & );
    void IWICBitmap();
    struct IWICBitmap & operator=(struct IWICBitmap & );
};

struct IWICBitmap : public IWICBitmapSource
{
    HRESULT Lock(struct WICRect * ,unsigned long ,struct IWICBitmapLock ** );
    HRESULT SetPalette(struct IWICPalette * );
    HRESULT SetResolution(float ,float );
    void IWICBitmap(struct IWICBitmap & );
    void IWICBitmap();
    struct IWICBitmap & operator=(struct IWICBitmap & );
};

struct D3DXVECTOR2_16F
{
    void D3DXVECTOR2_16F(struct D3DXVECTOR2_16F & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR2_16F(float * );
    void D3DXVECTOR2_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR2_16F & );
    int operator!=(struct D3DXVECTOR2_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
};

struct D3DXVECTOR2_16F
{
    void D3DXVECTOR2_16F(struct D3DXVECTOR2_16F & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR2_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR2_16F(float * );
    void D3DXVECTOR2_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR2_16F & );
    int operator!=(struct D3DXVECTOR2_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
};

struct DWRITE_OVERHANG_METRICS
{
    float left;
    float top;
    float right;
    float bottom;
};

struct CD3D11_DEPTH_STENCIL_DESC : public D3D11_DEPTH_STENCIL_DESC
{
    void CD3D11_DEPTH_STENCIL_DESC(int ,enum D3D11_DEPTH_WRITE_MASK ,enum D3D11_COMPARISON_FUNC ,int ,unsigned int ,unsigned int ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_COMPARISON_FUNC ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_COMPARISON_FUNC );
    void CD3D11_DEPTH_STENCIL_DESC(struct CD3D11_DEFAULT );
    void CD3D11_DEPTH_STENCIL_DESC(struct D3D11_DEPTH_STENCIL_DESC & );
    void CD3D11_DEPTH_STENCIL_DESC();
    void ~CD3D11_DEPTH_STENCIL_DESC();
    struct D3D11_DEPTH_STENCIL_DESC & operator const struct D3D11_DEPTH_STENCIL_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_DEPTH_STENCIL_DESC : public D3D11_DEPTH_STENCIL_DESC
{
    void CD3D11_DEPTH_STENCIL_DESC(int ,enum D3D11_DEPTH_WRITE_MASK ,enum D3D11_COMPARISON_FUNC ,int ,unsigned int ,unsigned int ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_COMPARISON_FUNC ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_STENCIL_OP ,enum D3D11_COMPARISON_FUNC );
    void CD3D11_DEPTH_STENCIL_DESC(struct CD3D11_DEFAULT );
    void CD3D11_DEPTH_STENCIL_DESC(struct D3D11_DEPTH_STENCIL_DESC & );
    void CD3D11_DEPTH_STENCIL_DESC();
    void ~CD3D11_DEPTH_STENCIL_DESC();
    struct D3D11_DEPTH_STENCIL_DESC & operator const struct D3D11_DEPTH_STENCIL_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_BUFFER_DESC
{
    unsigned int ByteWidth;
    enum D3D11_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
    unsigned int StructureByteStride;
};

struct _D3DRECTPATCH_INFO
{
    unsigned int StartVertexOffsetWidth;
    unsigned int StartVertexOffsetHeight;
    unsigned int Width;
    unsigned int Height;
    unsigned int Stride;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

enum DWRITE_TRIMMING_GRANULARITY
{
    DWRITE_TRIMMING_GRANULARITY_NONE=0,
    DWRITE_TRIMMING_GRANULARITY_CHARACTER=1,
    DWRITE_TRIMMING_GRANULARITY_WORD=2
};

struct DWRITE_TRIMMING
{
    enum DWRITE_TRIMMING_GRANULARITY granularity;
    unsigned int delimiter;
    unsigned int delimiterCount;
};

struct D2D1_TRIANGLE
{
    struct D2D_POINT_2F point1;
    struct D2D_POINT_2F point2;
    struct D2D_POINT_2F point3;
};

struct DXGI_SAMPLE_DESC
{
    unsigned int Count;
    unsigned int Quality;
};

struct XAUDIO2_BUFFER
{
    unsigned int Flags;
    unsigned int AudioBytes;
    unsigned int * pAudioData;
    unsigned int PlayBegin;
    unsigned int PlayLength;
    unsigned int LoopBegin;
    unsigned int LoopLength;
    unsigned int LoopCount;
    void * pContext;
};

struct ID2D1Geometry : public ID2D1Resource
{
    HRESULT GetBounds(struct D2D_MATRIX_3X2_F & ,struct D2D_RECT_F * );
    HRESULT GetBounds(struct D2D_MATRIX_3X2_F * ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,float ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,float ,struct D2D_RECT_F * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,int * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,int * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,float ,int * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,float ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F & ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F * ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F & ,float ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F * ,float ,int * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F & ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F * ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F & ,float ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F * ,float ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F & ,struct ID2D1TessellationSink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F * ,struct ID2D1TessellationSink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1TessellationSink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1TessellationSink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F & ,float * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F * ,float * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F & ,float ,float * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F * ,float ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F & ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F * ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F & ,float ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F * ,float ,float * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F & ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F * ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F & ,float ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F * ,float ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    void ID2D1Geometry(struct ID2D1Geometry & );
    void ID2D1Geometry();
    struct ID2D1Geometry & operator=(struct ID2D1Geometry & );
};

enum D2D1_GEOMETRY_RELATION
{
    D2D1_GEOMETRY_RELATION_UNKNOWN=0,
    D2D1_GEOMETRY_RELATION_DISJOINT=1,
    D2D1_GEOMETRY_RELATION_IS_CONTAINED=2,
    D2D1_GEOMETRY_RELATION_CONTAINS=3,
    D2D1_GEOMETRY_RELATION_OVERLAP=4,
    D2D1_GEOMETRY_RELATION_FORCE_DWORD=-1
};

enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION
{
    D2D1_GEOMETRY_SIMPLIFICATION_OPTION_CUBICS_AND_LINES=0,
    D2D1_GEOMETRY_SIMPLIFICATION_OPTION_LINES=1,
    D2D1_GEOMETRY_SIMPLIFICATION_OPTION_FORCE_DWORD=-1
};

enum D2D1_COMBINE_MODE
{
    D2D1_COMBINE_MODE_UNION=0,
    D2D1_COMBINE_MODE_INTERSECT=1,
    D2D1_COMBINE_MODE_XOR=2,
    D2D1_COMBINE_MODE_EXCLUDE=3,
    D2D1_COMBINE_MODE_FORCE_DWORD=-1
};

struct ID2D1Geometry : public ID2D1Resource
{
    HRESULT GetBounds(struct D2D_MATRIX_3X2_F & ,struct D2D_RECT_F * );
    HRESULT GetBounds(struct D2D_MATRIX_3X2_F * ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,float ,struct D2D_RECT_F * );
    HRESULT GetWidenedBounds(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,float ,struct D2D_RECT_F * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,int * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,int * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,float ,int * );
    HRESULT StrokeContainsPoint(struct D2D_POINT_2F ,float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,float ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F & ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F * ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F & ,float ,int * );
    HRESULT FillContainsPoint(struct D2D_POINT_2F ,struct D2D_MATRIX_3X2_F * ,float ,int * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F & ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F * ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F & ,float ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT CompareWithGeometry(struct ID2D1Geometry * ,struct D2D_MATRIX_3X2_F * ,float ,enum D2D1_GEOMETRY_RELATION * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Simplify(enum D2D1_GEOMETRY_SIMPLIFICATION_OPTION ,struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F & ,struct ID2D1TessellationSink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F * ,struct ID2D1TessellationSink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1TessellationSink * );
    HRESULT Tessellate(struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1TessellationSink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT CombineWithGeometry(struct ID2D1Geometry * ,enum D2D1_COMBINE_MODE ,struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Outline(struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F & ,float * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F * ,float * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F & ,float ,float * );
    HRESULT ComputeArea(struct D2D_MATRIX_3X2_F * ,float ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F & ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F * ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F & ,float ,float * );
    HRESULT ComputeLength(struct D2D_MATRIX_3X2_F * ,float ,float * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F & ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F * ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F & ,float ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT ComputePointAtLength(float ,struct D2D_MATRIX_3X2_F * ,float ,struct D2D_POINT_2F * ,struct D2D_POINT_2F * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F & ,float ,struct ID2D1SimplifiedGeometrySink * );
    HRESULT Widen(float ,struct ID2D1StrokeStyle * ,struct D2D_MATRIX_3X2_F * ,float ,struct ID2D1SimplifiedGeometrySink * );
    void ID2D1Geometry(struct ID2D1Geometry & );
    void ID2D1Geometry();
    struct ID2D1Geometry & operator=(struct ID2D1Geometry & );
};

struct D3DXVECTOR4
{
    void D3DXVECTOR4(float ,float ,float ,float );
    void D3DXVECTOR4(struct _D3DVECTOR & ,float );
    void D3DXVECTOR4(struct D3DXFLOAT16 * );
    void D3DXVECTOR4(float * );
    void D3DXVECTOR4();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR4 & operator+=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator-=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator*=(float );
    struct D3DXVECTOR4 & operator/=(float );
    struct D3DXVECTOR4 operator+(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator+();
    struct D3DXVECTOR4 operator-(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator-();
    struct D3DXVECTOR4 operator*(float );
    struct D3DXVECTOR4 operator/(float );
    int operator==(struct D3DXVECTOR4 & );
    int operator!=(struct D3DXVECTOR4 & );
    float x;
    float y;
    float z;
    float w;
};

struct D3DXVECTOR4
{
    void D3DXVECTOR4(float ,float ,float ,float );
    void D3DXVECTOR4(struct _D3DVECTOR & ,float );
    void D3DXVECTOR4(struct D3DXFLOAT16 * );
    void D3DXVECTOR4(float * );
    void D3DXVECTOR4();
    float * operator float *();
    float * operator const float *();
    struct D3DXVECTOR4 & operator+=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator-=(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 & operator*=(float );
    struct D3DXVECTOR4 & operator/=(float );
    struct D3DXVECTOR4 operator+(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator+();
    struct D3DXVECTOR4 operator-(struct D3DXVECTOR4 & );
    struct D3DXVECTOR4 operator-();
    struct D3DXVECTOR4 operator*(float );
    struct D3DXVECTOR4 operator/(float );
    int operator==(struct D3DXVECTOR4 & );
    int operator!=(struct D3DXVECTOR4 & );
    float x;
    float y;
    float z;
    float w;
};

struct D3D11_TEX2D_ARRAY_UAV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct DWRITE_INLINE_OBJECT_METRICS
{
    float width;
    float height;
    float baseline;
    int supportsSideways;
};

struct XAUDIO2_VOICE_SENDS
{
    unsigned int SendCount;
    struct XAUDIO2_SEND_DESCRIPTOR * pSends;
};

struct D2D_POINT_2U
{
    unsigned int x;
    unsigned int y;
};

struct D2D1_BEZIER_SEGMENT
{
    struct D2D_POINT_2F point1;
    struct D2D_POINT_2F point2;
    struct D2D_POINT_2F point3;
};

struct IDirect3DIndexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DINDEXBUFFER_DESC * );
    void IDirect3DIndexBuffer9(struct IDirect3DIndexBuffer9 & );
    void IDirect3DIndexBuffer9();
    struct IDirect3DIndexBuffer9 & operator=(struct IDirect3DIndexBuffer9 & );
};

struct IDirect3DIndexBuffer9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT Lock(unsigned int ,unsigned int ,void ** ,unsigned long );
    HRESULT Unlock();
    HRESULT GetDesc(struct _D3DINDEXBUFFER_DESC * );
    void IDirect3DIndexBuffer9(struct IDirect3DIndexBuffer9 & );
    void IDirect3DIndexBuffer9();
    struct IDirect3DIndexBuffer9 & operator=(struct IDirect3DIndexBuffer9 & );
};

struct D3D11_BUFFER_SRV
{
    unsigned int FirstElement;
    unsigned int ElementOffset;
    unsigned int NumElements;
    unsigned int ElementWidth;
};

struct IDirect3DVolumeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DVOLUME_DESC * );
    HRESULT GetVolumeLevel(unsigned int ,struct IDirect3DVolume9 ** );
    HRESULT LockBox(unsigned int ,struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox(unsigned int );
    HRESULT AddDirtyBox(struct _D3DBOX * );
    void IDirect3DVolumeTexture9(struct IDirect3DVolumeTexture9 & );
    void IDirect3DVolumeTexture9();
    struct IDirect3DVolumeTexture9 & operator=(struct IDirect3DVolumeTexture9 & );
};

struct IDirect3DVolumeTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DVOLUME_DESC * );
    HRESULT GetVolumeLevel(unsigned int ,struct IDirect3DVolume9 ** );
    HRESULT LockBox(unsigned int ,struct _D3DLOCKED_BOX * ,struct _D3DBOX * ,unsigned long );
    HRESULT UnlockBox(unsigned int );
    HRESULT AddDirtyBox(struct _D3DBOX * );
    void IDirect3DVolumeTexture9(struct IDirect3DVolumeTexture9 & );
    void IDirect3DVolumeTexture9();
    struct IDirect3DVolumeTexture9 & operator=(struct IDirect3DVolumeTexture9 & );
};

enum D3DX10_IMAGE_FILE_FORMAT
{
    D3DX10_IFF_BMP=0,
    D3DX10_IFF_JPG=1,
    D3DX10_IFF_PNG=3,
    D3DX10_IFF_DDS=4,
    D3DX10_IFF_TIFF=10,
    D3DX10_IFF_GIF=11,
    D3DX10_IFF_WMP=12,
    D3DX10_IFF_FORCE_DWORD=2147483647
};

struct D3DX10_IMAGE_INFO
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int ArraySize;
    unsigned int MipLevels;
    unsigned int MiscFlags;
    enum DXGI_FORMAT Format;
    enum D3D10_RESOURCE_DIMENSION ResourceDimension;
    enum D3DX10_IMAGE_FILE_FORMAT ImageFileFormat;
};

struct D2D1_RENDER_TARGET_PROPERTIES
{
    enum D2D1_RENDER_TARGET_TYPE type;
    struct D2D1_PIXEL_FORMAT pixelFormat;
    float dpiX;
    float dpiY;
    enum D2D1_RENDER_TARGET_USAGE usage;
    enum D2D1_FEATURE_LEVEL minLevel;
};

struct ID2D1SolidColorBrush : public ID2D1Brush
{
    void SetColor(struct _D3DCOLORVALUE & );
    void SetColor(struct _D3DCOLORVALUE * );
    struct _D3DCOLORVALUE GetColor();
    void ID2D1SolidColorBrush(struct ID2D1SolidColorBrush & );
    void ID2D1SolidColorBrush();
    struct ID2D1SolidColorBrush & operator=(struct ID2D1SolidColorBrush & );
};

struct ID2D1SolidColorBrush : public ID2D1Brush
{
    void SetColor(struct _D3DCOLORVALUE & );
    void SetColor(struct _D3DCOLORVALUE * );
    struct _D3DCOLORVALUE GetColor();
    void ID2D1SolidColorBrush(struct ID2D1SolidColorBrush & );
    void ID2D1SolidColorBrush();
    struct ID2D1SolidColorBrush & operator=(struct ID2D1SolidColorBrush & );
};

struct CD3D11_SAMPLER_DESC : public D3D11_SAMPLER_DESC
{
    void CD3D11_SAMPLER_DESC(enum D3D11_FILTER ,enum D3D11_TEXTURE_ADDRESS_MODE ,enum D3D11_TEXTURE_ADDRESS_MODE ,enum D3D11_TEXTURE_ADDRESS_MODE ,float ,unsigned int ,enum D3D11_COMPARISON_FUNC ,float * ,float ,float );
    void CD3D11_SAMPLER_DESC(struct CD3D11_DEFAULT );
    void CD3D11_SAMPLER_DESC(struct D3D11_SAMPLER_DESC & );
    void CD3D11_SAMPLER_DESC();
    void ~CD3D11_SAMPLER_DESC();
    struct D3D11_SAMPLER_DESC & operator const struct D3D11_SAMPLER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_SAMPLER_DESC : public D3D11_SAMPLER_DESC
{
    void CD3D11_SAMPLER_DESC(enum D3D11_FILTER ,enum D3D11_TEXTURE_ADDRESS_MODE ,enum D3D11_TEXTURE_ADDRESS_MODE ,enum D3D11_TEXTURE_ADDRESS_MODE ,float ,unsigned int ,enum D3D11_COMPARISON_FUNC ,float * ,float ,float );
    void CD3D11_SAMPLER_DESC(struct CD3D11_DEFAULT );
    void CD3D11_SAMPLER_DESC(struct D3D11_SAMPLER_DESC & );
    void CD3D11_SAMPLER_DESC();
    void ~CD3D11_SAMPLER_DESC();
    struct D3D11_SAMPLER_DESC & operator const struct D3D11_SAMPLER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_VIEWPORT
{
    float TopLeftX;
    float TopLeftY;
    float Width;
    float Height;
    float MinDepth;
    float MaxDepth;
};

struct D3D11_RENDER_TARGET_BLEND_DESC
{
    int BlendEnable;
    enum D3D11_BLEND SrcBlend;
    enum D3D11_BLEND DestBlend;
    enum D3D11_BLEND_OP BlendOp;
    enum D3D11_BLEND SrcBlendAlpha;
    enum D3D11_BLEND DestBlendAlpha;
    enum D3D11_BLEND_OP BlendOpAlpha;
    unsigned int RenderTargetWriteMask;
};

struct ID2D1RoundedRectangleGeometry : public ID2D1Geometry
{
    void GetRoundedRect(struct D2D1_ROUNDED_RECT * );
    void ID2D1RoundedRectangleGeometry(struct ID2D1RoundedRectangleGeometry & );
    void ID2D1RoundedRectangleGeometry();
    struct ID2D1RoundedRectangleGeometry & operator=(struct ID2D1RoundedRectangleGeometry & );
};

struct ID2D1RoundedRectangleGeometry : public ID2D1Geometry
{
    void GetRoundedRect(struct D2D1_ROUNDED_RECT * );
    void ID2D1RoundedRectangleGeometry(struct ID2D1RoundedRectangleGeometry & );
    void ID2D1RoundedRectangleGeometry();
    struct ID2D1RoundedRectangleGeometry & operator=(struct ID2D1RoundedRectangleGeometry & );
};

struct D2D1_QUADRATIC_BEZIER_SEGMENT
{
    struct D2D_POINT_2F point1;
    struct D2D_POINT_2F point2;
};

struct D2D1_ARC_SEGMENT
{
    struct D2D_POINT_2F point;
    struct D2D_SIZE_F size;
    float rotationAngle;
    enum D2D1_SWEEP_DIRECTION sweepDirection;
    enum D2D1_ARC_SIZE arcSize;
};

struct ID2D1GeometrySink : public ID2D1SimplifiedGeometrySink
{
    void AddLine(struct D2D_POINT_2F );
    void AddBezier(struct D2D1_BEZIER_SEGMENT & );
    void AddBezier(struct D2D1_BEZIER_SEGMENT * );
    void AddQuadraticBezier(struct D2D1_QUADRATIC_BEZIER_SEGMENT & );
    void AddQuadraticBezier(struct D2D1_QUADRATIC_BEZIER_SEGMENT * );
    void AddQuadraticBeziers(struct D2D1_QUADRATIC_BEZIER_SEGMENT * ,unsigned int );
    void AddArc(struct D2D1_ARC_SEGMENT & );
    void AddArc(struct D2D1_ARC_SEGMENT * );
    void ID2D1GeometrySink(struct ID2D1GeometrySink & );
    void ID2D1GeometrySink();
    struct ID2D1GeometrySink & operator=(struct ID2D1GeometrySink & );
};

struct ID2D1GeometrySink : public ID2D1SimplifiedGeometrySink
{
    void AddLine(struct D2D_POINT_2F );
    void AddBezier(struct D2D1_BEZIER_SEGMENT & );
    void AddBezier(struct D2D1_BEZIER_SEGMENT * );
    void AddQuadraticBezier(struct D2D1_QUADRATIC_BEZIER_SEGMENT & );
    void AddQuadraticBezier(struct D2D1_QUADRATIC_BEZIER_SEGMENT * );
    void AddQuadraticBeziers(struct D2D1_QUADRATIC_BEZIER_SEGMENT * ,unsigned int );
    void AddArc(struct D2D1_ARC_SEGMENT & );
    void AddArc(struct D2D1_ARC_SEGMENT * );
    void ID2D1GeometrySink(struct ID2D1GeometrySink & );
    void ID2D1GeometrySink();
    struct ID2D1GeometrySink & operator=(struct ID2D1GeometrySink & );
};

enum _D3DSAMPLERSTATETYPE
{
    D3DSAMP_ADDRESSU=1,
    D3DSAMP_ADDRESSV=2,
    D3DSAMP_ADDRESSW=3,
    D3DSAMP_BORDERCOLOR=4,
    D3DSAMP_MAGFILTER=5,
    D3DSAMP_MINFILTER=6,
    D3DSAMP_MIPFILTER=7,
    D3DSAMP_MIPMAPLODBIAS=8,
    D3DSAMP_MAXMIPLEVEL=9,
    D3DSAMP_MAXANISOTROPY=10,
    D3DSAMP_SRGBTEXTURE=11,
    D3DSAMP_ELEMENTINDEX=12,
    D3DSAMP_DMAPOFFSET=13,
    D3DSAMP_FORCE_DWORD=2147483647
};

struct D2D1_BITMAP_PROPERTIES
{
    struct D2D1_PIXEL_FORMAT pixelFormat;
    float dpiX;
    float dpiY;
};

struct D2D1_BITMAP_BRUSH_PROPERTIES
{
    enum D2D1_EXTEND_MODE extendModeX;
    enum D2D1_EXTEND_MODE extendModeY;
    enum D2D1_BITMAP_INTERPOLATION_MODE interpolationMode;
};

struct D2D1_BRUSH_PROPERTIES
{
    float opacity;
    struct D2D_MATRIX_3X2_F transform;
};

struct D2D1_GRADIENT_STOP
{
    float position;
    struct _D3DCOLORVALUE color;
};

struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES
{
    struct D2D_POINT_2F startPoint;
    struct D2D_POINT_2F endPoint;
};

struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES
{
    struct D2D_POINT_2F center;
    struct D2D_POINT_2F gradientOriginOffset;
    float radiusX;
    float radiusY;
};

struct D2D_SIZE_F
{
    float width;
    float height;
};

struct D2D1_PIXEL_FORMAT
{
    enum DXGI_FORMAT format;
    enum D2D1_ALPHA_MODE alphaMode;
};

enum D2D1_OPACITY_MASK_CONTENT
{
    D2D1_OPACITY_MASK_CONTENT_GRAPHICS=0,
    D2D1_OPACITY_MASK_CONTENT_TEXT_NATURAL=1,
    D2D1_OPACITY_MASK_CONTENT_TEXT_GDI_COMPATIBLE=2,
    D2D1_OPACITY_MASK_CONTENT_FORCE_DWORD=-1
};

struct ID2D1RenderTarget : public ID2D1Resource
{
    HRESULT CreateBitmap(struct D2D_SIZE_U ,struct D2D1_BITMAP_PROPERTIES & ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmap(struct D2D_SIZE_U ,void * ,unsigned int ,struct D2D1_BITMAP_PROPERTIES & ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmap(struct D2D_SIZE_U ,void * ,unsigned int ,struct D2D1_BITMAP_PROPERTIES * ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapFromWicBitmap(struct IWICBitmapSource * ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapFromWicBitmap(struct IWICBitmapSource * ,struct D2D1_BITMAP_PROPERTIES & ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapFromWicBitmap(struct IWICBitmapSource * ,struct D2D1_BITMAP_PROPERTIES * ,struct ID2D1Bitmap ** );
    HRESULT CreateSharedBitmap(struct _GUID & ,void * ,struct D2D1_BITMAP_PROPERTIES * ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct D2D1_BITMAP_BRUSH_PROPERTIES & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1BitmapBrush ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct D2D1_BITMAP_BRUSH_PROPERTIES & ,struct ID2D1BitmapBrush ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct ID2D1BitmapBrush ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct D2D1_BITMAP_BRUSH_PROPERTIES * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1BitmapBrush ** );
    HRESULT CreateSolidColorBrush(struct _D3DCOLORVALUE & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1SolidColorBrush ** );
    HRESULT CreateSolidColorBrush(struct _D3DCOLORVALUE & ,struct ID2D1SolidColorBrush ** );
    HRESULT CreateSolidColorBrush(struct _D3DCOLORVALUE * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1SolidColorBrush ** );
    HRESULT CreateGradientStopCollection(struct D2D1_GRADIENT_STOP * ,unsigned int ,struct ID2D1GradientStopCollection ** );
    HRESULT CreateGradientStopCollection(struct D2D1_GRADIENT_STOP * ,unsigned int ,enum D2D1_GAMMA ,enum D2D1_EXTEND_MODE ,struct ID2D1GradientStopCollection ** );
    HRESULT CreateLinearGradientBrush(struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1LinearGradientBrush ** );
    HRESULT CreateLinearGradientBrush(struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1LinearGradientBrush ** );
    HRESULT CreateLinearGradientBrush(struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1GradientStopCollection * ,struct ID2D1LinearGradientBrush ** );
    HRESULT CreateRadialGradientBrush(struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1RadialGradientBrush ** );
    HRESULT CreateRadialGradientBrush(struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1RadialGradientBrush ** );
    HRESULT CreateRadialGradientBrush(struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1GradientStopCollection * ,struct ID2D1RadialGradientBrush ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct D2D_SIZE_U ,struct D2D1_PIXEL_FORMAT ,enum D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct D2D_SIZE_U ,struct D2D1_PIXEL_FORMAT ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct D2D_SIZE_U ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F * ,struct D2D_SIZE_U * ,struct D2D1_PIXEL_FORMAT * ,enum D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateLayer(struct ID2D1Layer ** );
    HRESULT CreateLayer(struct D2D_SIZE_F ,struct ID2D1Layer ** );
    HRESULT CreateLayer(struct D2D_SIZE_F * ,struct ID2D1Layer ** );
    HRESULT CreateMesh(struct ID2D1Mesh ** );
    void DrawLine(struct D2D_POINT_2F ,struct D2D_POINT_2F ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawRectangle(struct D2D_RECT_F & ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawRectangle(struct D2D_RECT_F * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillRectangle(struct D2D_RECT_F & ,struct ID2D1Brush * );
    void FillRectangle(struct D2D_RECT_F * ,struct ID2D1Brush * );
    void DrawRoundedRectangle(struct D2D1_ROUNDED_RECT & ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawRoundedRectangle(struct D2D1_ROUNDED_RECT * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillRoundedRectangle(struct D2D1_ROUNDED_RECT & ,struct ID2D1Brush * );
    void FillRoundedRectangle(struct D2D1_ROUNDED_RECT * ,struct ID2D1Brush * );
    void DrawEllipse(struct D2D1_ELLIPSE & ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawEllipse(struct D2D1_ELLIPSE * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillEllipse(struct D2D1_ELLIPSE & ,struct ID2D1Brush * );
    void FillEllipse(struct D2D1_ELLIPSE * ,struct ID2D1Brush * );
    void DrawGeometry(struct ID2D1Geometry * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillGeometry(struct ID2D1Geometry * ,struct ID2D1Brush * ,struct ID2D1Brush * );
    void FillMesh(struct ID2D1Mesh * ,struct ID2D1Brush * );
    void FillOpacityMask(struct ID2D1Bitmap * ,struct ID2D1Brush * ,enum D2D1_OPACITY_MASK_CONTENT ,struct D2D_RECT_F & ,struct D2D_RECT_F & );
    void FillOpacityMask(struct ID2D1Bitmap * ,struct ID2D1Brush * ,enum D2D1_OPACITY_MASK_CONTENT ,struct D2D_RECT_F * ,struct D2D_RECT_F * );
    void DrawBitmap(struct ID2D1Bitmap * ,struct D2D_RECT_F & ,float ,enum D2D1_BITMAP_INTERPOLATION_MODE ,struct D2D_RECT_F & );
    void DrawBitmap(struct ID2D1Bitmap * ,struct D2D_RECT_F & ,float ,enum D2D1_BITMAP_INTERPOLATION_MODE ,struct D2D_RECT_F * );
    void DrawBitmap(struct ID2D1Bitmap * ,struct D2D_RECT_F * ,float ,enum D2D1_BITMAP_INTERPOLATION_MODE ,struct D2D_RECT_F * );
    void DrawTextA(wchar_t * ,unsigned int ,struct IDWriteTextFormat * ,struct D2D_RECT_F & ,struct ID2D1Brush * ,enum D2D1_DRAW_TEXT_OPTIONS ,enum DWRITE_MEASURING_MODE );
    void DrawTextA(wchar_t * ,unsigned int ,struct IDWriteTextFormat * ,struct D2D_RECT_F * ,struct ID2D1Brush * ,enum D2D1_DRAW_TEXT_OPTIONS ,enum DWRITE_MEASURING_MODE );
    void DrawTextLayout(struct D2D_POINT_2F ,struct IDWriteTextLayout * ,struct ID2D1Brush * ,enum D2D1_DRAW_TEXT_OPTIONS );
    void DrawGlyphRun(struct D2D_POINT_2F ,struct DWRITE_GLYPH_RUN * ,struct ID2D1Brush * ,enum DWRITE_MEASURING_MODE );
    void SetTransform(struct D2D_MATRIX_3X2_F & );
    void SetTransform(struct D2D_MATRIX_3X2_F * );
    void GetTransform(struct D2D_MATRIX_3X2_F * );
    void SetAntialiasMode(enum D2D1_ANTIALIAS_MODE );
    enum D2D1_ANTIALIAS_MODE GetAntialiasMode();
    void SetTextAntialiasMode(enum D2D1_TEXT_ANTIALIAS_MODE );
    enum D2D1_TEXT_ANTIALIAS_MODE GetTextAntialiasMode();
    void SetTextRenderingParams(struct IDWriteRenderingParams * );
    void GetTextRenderingParams(struct IDWriteRenderingParams ** );
    void SetTags(unsigned int ,unsigned int );
    void GetTags(unsigned int * ,unsigned int * );
    void PushLayer(struct D2D1_LAYER_PARAMETERS & ,struct ID2D1Layer * );
    void PushLayer(struct D2D1_LAYER_PARAMETERS * ,struct ID2D1Layer * );
    void PopLayer();
    HRESULT Flush(unsigned int * ,unsigned int * );
    void SaveDrawingState(struct ID2D1DrawingStateBlock * );
    void RestoreDrawingState(struct ID2D1DrawingStateBlock * );
    void PushAxisAlignedClip(struct D2D_RECT_F & ,enum D2D1_ANTIALIAS_MODE );
    void PushAxisAlignedClip(struct D2D_RECT_F * ,enum D2D1_ANTIALIAS_MODE );
    void PopAxisAlignedClip();
    void Clear(struct _D3DCOLORVALUE & );
    void Clear(struct _D3DCOLORVALUE * );
    void BeginDraw();
    HRESULT EndDraw(unsigned int * ,unsigned int * );
    struct D2D1_PIXEL_FORMAT GetPixelFormat();
    void SetDpi(float ,float );
    void GetDpi(float * ,float * );
    struct D2D_SIZE_F GetSize();
    struct D2D_SIZE_U GetPixelSize();
    unsigned int GetMaximumBitmapSize();
    int IsSupported(struct D2D1_RENDER_TARGET_PROPERTIES & );
    int IsSupported(struct D2D1_RENDER_TARGET_PROPERTIES * );
    void ID2D1RenderTarget(struct ID2D1RenderTarget & );
    void ID2D1RenderTarget();
    struct ID2D1RenderTarget & operator=(struct ID2D1RenderTarget & );
};

struct D2D1_LAYER_PARAMETERS
{
    struct D2D_RECT_F contentBounds;
    struct ID2D1Geometry * geometricMask;
    enum D2D1_ANTIALIAS_MODE maskAntialiasMode;
    struct D2D_MATRIX_3X2_F maskTransform;
    float opacity;
    struct ID2D1Brush * opacityBrush;
    enum D2D1_LAYER_OPTIONS layerOptions;
};

struct ID2D1RenderTarget : public ID2D1Resource
{
    HRESULT CreateBitmap(struct D2D_SIZE_U ,struct D2D1_BITMAP_PROPERTIES & ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmap(struct D2D_SIZE_U ,void * ,unsigned int ,struct D2D1_BITMAP_PROPERTIES & ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmap(struct D2D_SIZE_U ,void * ,unsigned int ,struct D2D1_BITMAP_PROPERTIES * ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapFromWicBitmap(struct IWICBitmapSource * ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapFromWicBitmap(struct IWICBitmapSource * ,struct D2D1_BITMAP_PROPERTIES & ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapFromWicBitmap(struct IWICBitmapSource * ,struct D2D1_BITMAP_PROPERTIES * ,struct ID2D1Bitmap ** );
    HRESULT CreateSharedBitmap(struct _GUID & ,void * ,struct D2D1_BITMAP_PROPERTIES * ,struct ID2D1Bitmap ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct D2D1_BITMAP_BRUSH_PROPERTIES & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1BitmapBrush ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct D2D1_BITMAP_BRUSH_PROPERTIES & ,struct ID2D1BitmapBrush ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct ID2D1BitmapBrush ** );
    HRESULT CreateBitmapBrush(struct ID2D1Bitmap * ,struct D2D1_BITMAP_BRUSH_PROPERTIES * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1BitmapBrush ** );
    HRESULT CreateSolidColorBrush(struct _D3DCOLORVALUE & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1SolidColorBrush ** );
    HRESULT CreateSolidColorBrush(struct _D3DCOLORVALUE & ,struct ID2D1SolidColorBrush ** );
    HRESULT CreateSolidColorBrush(struct _D3DCOLORVALUE * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1SolidColorBrush ** );
    HRESULT CreateGradientStopCollection(struct D2D1_GRADIENT_STOP * ,unsigned int ,struct ID2D1GradientStopCollection ** );
    HRESULT CreateGradientStopCollection(struct D2D1_GRADIENT_STOP * ,unsigned int ,enum D2D1_GAMMA ,enum D2D1_EXTEND_MODE ,struct ID2D1GradientStopCollection ** );
    HRESULT CreateLinearGradientBrush(struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1LinearGradientBrush ** );
    HRESULT CreateLinearGradientBrush(struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1LinearGradientBrush ** );
    HRESULT CreateLinearGradientBrush(struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1GradientStopCollection * ,struct ID2D1LinearGradientBrush ** );
    HRESULT CreateRadialGradientBrush(struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES & ,struct D2D1_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1RadialGradientBrush ** );
    HRESULT CreateRadialGradientBrush(struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES & ,struct ID2D1GradientStopCollection * ,struct ID2D1RadialGradientBrush ** );
    HRESULT CreateRadialGradientBrush(struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES * ,struct D2D1_BRUSH_PROPERTIES * ,struct ID2D1GradientStopCollection * ,struct ID2D1RadialGradientBrush ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct D2D_SIZE_U ,struct D2D1_PIXEL_FORMAT ,enum D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct D2D_SIZE_U ,struct D2D1_PIXEL_FORMAT ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct D2D_SIZE_U ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateCompatibleRenderTarget(struct D2D_SIZE_F * ,struct D2D_SIZE_U * ,struct D2D1_PIXEL_FORMAT * ,enum D2D1_COMPATIBLE_RENDER_TARGET_OPTIONS ,struct ID2D1BitmapRenderTarget ** );
    HRESULT CreateLayer(struct ID2D1Layer ** );
    HRESULT CreateLayer(struct D2D_SIZE_F ,struct ID2D1Layer ** );
    HRESULT CreateLayer(struct D2D_SIZE_F * ,struct ID2D1Layer ** );
    HRESULT CreateMesh(struct ID2D1Mesh ** );
    void DrawLine(struct D2D_POINT_2F ,struct D2D_POINT_2F ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawRectangle(struct D2D_RECT_F & ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawRectangle(struct D2D_RECT_F * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillRectangle(struct D2D_RECT_F & ,struct ID2D1Brush * );
    void FillRectangle(struct D2D_RECT_F * ,struct ID2D1Brush * );
    void DrawRoundedRectangle(struct D2D1_ROUNDED_RECT & ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawRoundedRectangle(struct D2D1_ROUNDED_RECT * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillRoundedRectangle(struct D2D1_ROUNDED_RECT & ,struct ID2D1Brush * );
    void FillRoundedRectangle(struct D2D1_ROUNDED_RECT * ,struct ID2D1Brush * );
    void DrawEllipse(struct D2D1_ELLIPSE & ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void DrawEllipse(struct D2D1_ELLIPSE * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillEllipse(struct D2D1_ELLIPSE & ,struct ID2D1Brush * );
    void FillEllipse(struct D2D1_ELLIPSE * ,struct ID2D1Brush * );
    void DrawGeometry(struct ID2D1Geometry * ,struct ID2D1Brush * ,float ,struct ID2D1StrokeStyle * );
    void FillGeometry(struct ID2D1Geometry * ,struct ID2D1Brush * ,struct ID2D1Brush * );
    void FillMesh(struct ID2D1Mesh * ,struct ID2D1Brush * );
    void FillOpacityMask(struct ID2D1Bitmap * ,struct ID2D1Brush * ,enum D2D1_OPACITY_MASK_CONTENT ,struct D2D_RECT_F & ,struct D2D_RECT_F & );
    void FillOpacityMask(struct ID2D1Bitmap * ,struct ID2D1Brush * ,enum D2D1_OPACITY_MASK_CONTENT ,struct D2D_RECT_F * ,struct D2D_RECT_F * );
    void DrawBitmap(struct ID2D1Bitmap * ,struct D2D_RECT_F & ,float ,enum D2D1_BITMAP_INTERPOLATION_MODE ,struct D2D_RECT_F & );
    void DrawBitmap(struct ID2D1Bitmap * ,struct D2D_RECT_F & ,float ,enum D2D1_BITMAP_INTERPOLATION_MODE ,struct D2D_RECT_F * );
    void DrawBitmap(struct ID2D1Bitmap * ,struct D2D_RECT_F * ,float ,enum D2D1_BITMAP_INTERPOLATION_MODE ,struct D2D_RECT_F * );
    void DrawTextA(wchar_t * ,unsigned int ,struct IDWriteTextFormat * ,struct D2D_RECT_F & ,struct ID2D1Brush * ,enum D2D1_DRAW_TEXT_OPTIONS ,enum DWRITE_MEASURING_MODE );
    void DrawTextA(wchar_t * ,unsigned int ,struct IDWriteTextFormat * ,struct D2D_RECT_F * ,struct ID2D1Brush * ,enum D2D1_DRAW_TEXT_OPTIONS ,enum DWRITE_MEASURING_MODE );
    void DrawTextLayout(struct D2D_POINT_2F ,struct IDWriteTextLayout * ,struct ID2D1Brush * ,enum D2D1_DRAW_TEXT_OPTIONS );
    void DrawGlyphRun(struct D2D_POINT_2F ,struct DWRITE_GLYPH_RUN * ,struct ID2D1Brush * ,enum DWRITE_MEASURING_MODE );
    void SetTransform(struct D2D_MATRIX_3X2_F & );
    void SetTransform(struct D2D_MATRIX_3X2_F * );
    void GetTransform(struct D2D_MATRIX_3X2_F * );
    void SetAntialiasMode(enum D2D1_ANTIALIAS_MODE );
    enum D2D1_ANTIALIAS_MODE GetAntialiasMode();
    void SetTextAntialiasMode(enum D2D1_TEXT_ANTIALIAS_MODE );
    enum D2D1_TEXT_ANTIALIAS_MODE GetTextAntialiasMode();
    void SetTextRenderingParams(struct IDWriteRenderingParams * );
    void GetTextRenderingParams(struct IDWriteRenderingParams ** );
    void SetTags(unsigned int ,unsigned int );
    void GetTags(unsigned int * ,unsigned int * );
    void PushLayer(struct D2D1_LAYER_PARAMETERS & ,struct ID2D1Layer * );
    void PushLayer(struct D2D1_LAYER_PARAMETERS * ,struct ID2D1Layer * );
    void PopLayer();
    HRESULT Flush(unsigned int * ,unsigned int * );
    void SaveDrawingState(struct ID2D1DrawingStateBlock * );
    void RestoreDrawingState(struct ID2D1DrawingStateBlock * );
    void PushAxisAlignedClip(struct D2D_RECT_F & ,enum D2D1_ANTIALIAS_MODE );
    void PushAxisAlignedClip(struct D2D_RECT_F * ,enum D2D1_ANTIALIAS_MODE );
    void PopAxisAlignedClip();
    void Clear(struct _D3DCOLORVALUE & );
    void Clear(struct _D3DCOLORVALUE * );
    void BeginDraw();
    HRESULT EndDraw(unsigned int * ,unsigned int * );
    struct D2D1_PIXEL_FORMAT GetPixelFormat();
    void SetDpi(float ,float );
    void GetDpi(float * ,float * );
    struct D2D_SIZE_F GetSize();
    struct D2D_SIZE_U GetPixelSize();
    unsigned int GetMaximumBitmapSize();
    int IsSupported(struct D2D1_RENDER_TARGET_PROPERTIES & );
    int IsSupported(struct D2D1_RENDER_TARGET_PROPERTIES * );
    void ID2D1RenderTarget(struct ID2D1RenderTarget & );
    void ID2D1RenderTarget();
    struct ID2D1RenderTarget & operator=(struct ID2D1RenderTarget & );
};

struct XAUDIO2_BUFFER
{
    unsigned int Flags;
    unsigned int AudioBytes;
    unsigned int * pAudioData;
    unsigned int PlayBegin;
    unsigned int PlayLength;
    unsigned int LoopBegin;
    unsigned int LoopLength;
    unsigned int LoopCount;
    void * pContext;
};

struct XAUDIO2_BUFFER_WMA
{
    unsigned int * pDecodedPacketCumulativeBytes;
    unsigned int PacketCount;
};

struct IXAudio2SourceVoice : public IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    HRESULT Start(unsigned int ,unsigned int );
    HRESULT Stop(unsigned int ,unsigned int );
    HRESULT SubmitSourceBuffer(struct XAUDIO2_BUFFER * ,struct XAUDIO2_BUFFER_WMA * );
    HRESULT FlushSourceBuffers();
    HRESULT Discontinuity();
    HRESULT ExitLoop(unsigned int );
    void GetState(struct XAUDIO2_VOICE_STATE * );
    HRESULT SetFrequencyRatio(float ,unsigned int );
    void GetFrequencyRatio(float * );
    HRESULT SetSourceSampleRate(unsigned int );
    void IXAudio2SourceVoice(struct IXAudio2SourceVoice & );
    void IXAudio2SourceVoice();
    struct IXAudio2SourceVoice & operator=(struct IXAudio2SourceVoice & );
};

struct IXAudio2SourceVoice : public IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    HRESULT Start(unsigned int ,unsigned int );
    HRESULT Stop(unsigned int ,unsigned int );
    HRESULT SubmitSourceBuffer(struct XAUDIO2_BUFFER * ,struct XAUDIO2_BUFFER_WMA * );
    HRESULT FlushSourceBuffers();
    HRESULT Discontinuity();
    HRESULT ExitLoop(unsigned int );
    void GetState(struct XAUDIO2_VOICE_STATE * );
    HRESULT SetFrequencyRatio(float ,unsigned int );
    void GetFrequencyRatio(float * );
    HRESULT SetSourceSampleRate(unsigned int );
    void IXAudio2SourceVoice(struct IXAudio2SourceVoice & );
    void IXAudio2SourceVoice();
    struct IXAudio2SourceVoice & operator=(struct IXAudio2SourceVoice & );
};

struct CD3D10_TEXTURE3D_DESC : public D3D10_TEXTURE3D_DESC
{
    void CD3D10_TEXTURE3D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int );
    void CD3D10_TEXTURE3D_DESC(struct D3D10_TEXTURE3D_DESC & );
    void CD3D10_TEXTURE3D_DESC();
    void ~CD3D10_TEXTURE3D_DESC();
    struct D3D10_TEXTURE3D_DESC & operator const struct D3D10_TEXTURE3D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D10_TEXTURE3D_DESC : public D3D10_TEXTURE3D_DESC
{
    void CD3D10_TEXTURE3D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int );
    void CD3D10_TEXTURE3D_DESC(struct D3D10_TEXTURE3D_DESC & );
    void CD3D10_TEXTURE3D_DESC();
    void ~CD3D10_TEXTURE3D_DESC();
    struct D3D10_TEXTURE3D_DESC & operator const struct D3D10_TEXTURE3D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEX3D_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D3D11_RENDER_TARGET_VIEW_DESC
{
    enum DXGI_FORMAT Format;
    enum D3D11_RTV_DIMENSION ViewDimension;
    struct D3D11_BUFFER_RTV Buffer;
    struct D3D11_TEX1D_RTV Texture1D;
    struct D3D11_TEX1D_ARRAY_RTV Texture1DArray;
    struct D3D11_TEX2D_RTV Texture2D;
    struct D3D11_TEX2D_ARRAY_RTV Texture2DArray;
    struct D3D11_TEX2DMS_RTV Texture2DMS;
    struct D3D11_TEX2DMS_ARRAY_RTV Texture2DMSArray;
    struct D3D11_TEX3D_RTV Texture3D;
};

struct ID2D1LinearGradientBrush : public ID2D1Brush
{
    void SetStartPoint(struct D2D_POINT_2F );
    void SetEndPoint(struct D2D_POINT_2F );
    struct D2D_POINT_2F GetStartPoint();
    struct D2D_POINT_2F GetEndPoint();
    void GetGradientStopCollection(struct ID2D1GradientStopCollection ** );
    void ID2D1LinearGradientBrush(struct ID2D1LinearGradientBrush & );
    void ID2D1LinearGradientBrush();
    struct ID2D1LinearGradientBrush & operator=(struct ID2D1LinearGradientBrush & );
};

struct ID2D1LinearGradientBrush : public ID2D1Brush
{
    void SetStartPoint(struct D2D_POINT_2F );
    void SetEndPoint(struct D2D_POINT_2F );
    struct D2D_POINT_2F GetStartPoint();
    struct D2D_POINT_2F GetEndPoint();
    void GetGradientStopCollection(struct ID2D1GradientStopCollection ** );
    void ID2D1LinearGradientBrush(struct ID2D1LinearGradientBrush & );
    void ID2D1LinearGradientBrush();
    struct ID2D1LinearGradientBrush & operator=(struct ID2D1LinearGradientBrush & );
};

enum D3D11_BIND_FLAG
{
    D3D11_BIND_VERTEX_BUFFER=1,
    D3D11_BIND_INDEX_BUFFER=2,
    D3D11_BIND_CONSTANT_BUFFER=4,
    D3D11_BIND_SHADER_RESOURCE=8,
    D3D11_BIND_STREAM_OUTPUT=16,
    D3D11_BIND_RENDER_TARGET=32,
    D3D11_BIND_DEPTH_STENCIL=64,
    D3D11_BIND_UNORDERED_ACCESS=128
};

struct ID2D1Resource : public IUnknown
{
    void GetFactory(struct ID2D1Factory ** );
    void ID2D1Resource(struct ID2D1Resource & );
    void ID2D1Resource();
    struct ID2D1Resource & operator=(struct ID2D1Resource & );
};

struct ID2D1Resource : public IUnknown
{
    void GetFactory(struct ID2D1Factory ** );
    void ID2D1Resource(struct ID2D1Resource & );
    void ID2D1Resource();
    struct ID2D1Resource & operator=(struct ID2D1Resource & );
};

struct IDirect3DVertexShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DVertexShader9(struct IDirect3DVertexShader9 & );
    void IDirect3DVertexShader9();
    struct IDirect3DVertexShader9 & operator=(struct IDirect3DVertexShader9 & );
};

struct IDirect3DVertexShader9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetFunction(void * ,unsigned int * );
    void IDirect3DVertexShader9(struct IDirect3DVertexShader9 & );
    void IDirect3DVertexShader9();
    struct IDirect3DVertexShader9 & operator=(struct IDirect3DVertexShader9 & );
};

struct _D3DGAMMARAMP
{
    unsigned int red[256];
    unsigned int green[256];
    unsigned int blue[256];
};

struct tagPOINT
{
    long x;
    long y;
};

struct _D3DRECT
{
    long x1;
    long y1;
    long x2;
    long y2;
};

struct _D3DVIEWPORT9
{
    unsigned long X;
    unsigned long Y;
    unsigned long Width;
    unsigned long Height;
    float MinZ;
    float MaxZ;
};

struct _D3DMATERIAL9
{
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Emissive;
    float Power;
};

struct _D3DLIGHT9
{
    enum _D3DLIGHTTYPE Type;
    struct _D3DCOLORVALUE Diffuse;
    struct _D3DCOLORVALUE Specular;
    struct _D3DCOLORVALUE Ambient;
    struct _D3DVECTOR Position;
    struct _D3DVECTOR Direction;
    float Range;
    float Falloff;
    float Attenuation0;
    float Attenuation1;
    float Attenuation2;
    float Theta;
    float Phi;
};

struct _D3DCLIPSTATUS9
{
    unsigned long ClipUnion;
    unsigned long ClipIntersection;
};

struct tagPALETTEENTRY
{
    unsigned int peRed;
    unsigned int peGreen;
    unsigned int peBlue;
    unsigned int peFlags;
};

struct _D3DVERTEXELEMENT9
{
    unsigned int Stream;
    unsigned int Offset;
    unsigned int Type;
    unsigned int Method;
    unsigned int Usage;
    unsigned int UsageIndex;
};

struct _D3DRECTPATCH_INFO
{
    unsigned int StartVertexOffsetWidth;
    unsigned int StartVertexOffsetHeight;
    unsigned int Width;
    unsigned int Height;
    unsigned int Stride;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct _D3DTRIPATCH_INFO
{
    unsigned int StartVertexOffset;
    unsigned int NumVertices;
    enum _D3DBASISTYPE Basis;
    enum _D3DDEGREETYPE Degree;
};

struct IDirect3DDevice9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT TestCooperativeLevel();
    unsigned int GetAvailableTextureMem();
    HRESULT EvictManagedResources();
    HRESULT GetDirect3D(struct IDirect3D9 ** );
    HRESULT GetDeviceCaps(struct _D3DCAPS9 * );
    HRESULT GetDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetCreationParameters(struct _D3DDEVICE_CREATION_PARAMETERS * );
    HRESULT SetCursorProperties(unsigned int ,unsigned int ,struct IDirect3DSurface9 * );
    void SetCursorPosition(int ,int ,unsigned long );
    int ShowCursor(int );
    HRESULT CreateAdditionalSwapChain(struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DSwapChain9 ** );
    HRESULT GetSwapChain(unsigned int ,struct IDirect3DSwapChain9 ** );
    unsigned int GetNumberOfSwapChains();
    HRESULT Reset(struct _D3DPRESENT_PARAMETERS_ * );
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * );
    HRESULT GetBackBuffer(unsigned int ,unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(unsigned int ,struct _D3DRASTER_STATUS * );
    HRESULT SetDialogBoxMode(int );
    void SetGammaRamp(unsigned int ,unsigned long ,struct _D3DGAMMARAMP * );
    void GetGammaRamp(unsigned int ,struct _D3DGAMMARAMP * );
    HRESULT CreateTexture(unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DTexture9 ** ,void ** );
    HRESULT CreateVolumeTexture(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DVolumeTexture9 ** ,void ** );
    HRESULT CreateCubeTexture(unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DCubeTexture9 ** ,void ** );
    HRESULT CreateVertexBuffer(unsigned int ,unsigned long ,unsigned long ,enum _D3DPOOL ,struct IDirect3DVertexBuffer9 ** ,void ** );
    HRESULT CreateIndexBuffer(unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DIndexBuffer9 ** ,void ** );
    HRESULT CreateRenderTarget(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT CreateDepthStencilSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT UpdateSurface(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagPOINT * );
    HRESULT UpdateTexture(struct IDirect3DBaseTexture9 * ,struct IDirect3DBaseTexture9 * );
    HRESULT GetRenderTargetData(struct IDirect3DSurface9 * ,struct IDirect3DSurface9 * );
    HRESULT GetFrontBufferData(unsigned int ,struct IDirect3DSurface9 * );
    HRESULT StretchRect(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagRECT * ,enum _D3DTEXTUREFILTERTYPE );
    HRESULT ColorFill(struct IDirect3DSurface9 * ,struct tagRECT * ,unsigned long );
    HRESULT CreateOffscreenPlainSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT SetRenderTarget(unsigned long ,struct IDirect3DSurface9 * );
    HRESULT GetRenderTarget(unsigned long ,struct IDirect3DSurface9 ** );
    HRESULT SetDepthStencilSurface(struct IDirect3DSurface9 * );
    HRESULT GetDepthStencilSurface(struct IDirect3DSurface9 ** );
    HRESULT BeginScene();
    HRESULT EndScene();
    HRESULT Clear(unsigned long ,struct _D3DRECT * ,unsigned long ,unsigned long ,float ,unsigned long );
    HRESULT SetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT GetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT MultiplyTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT SetViewport(struct _D3DVIEWPORT9 * );
    HRESULT GetViewport(struct _D3DVIEWPORT9 * );
    HRESULT SetMaterial(struct _D3DMATERIAL9 * );
    HRESULT GetMaterial(struct _D3DMATERIAL9 * );
    HRESULT SetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT GetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT LightEnable(unsigned long ,int );
    HRESULT GetLightEnable(unsigned long ,int * );
    HRESULT SetClipPlane(unsigned long ,float * );
    HRESULT GetClipPlane(unsigned long ,float * );
    HRESULT SetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long );
    HRESULT GetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long * );
    HRESULT CreateStateBlock(enum _D3DSTATEBLOCKTYPE ,struct IDirect3DStateBlock9 ** );
    HRESULT BeginStateBlock();
    HRESULT EndStateBlock(struct IDirect3DStateBlock9 ** );
    HRESULT SetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetTexture(unsigned long ,struct IDirect3DBaseTexture9 ** );
    HRESULT SetTexture(unsigned long ,struct IDirect3DBaseTexture9 * );
    HRESULT GetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long * );
    HRESULT SetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long );
    HRESULT GetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long * );
    HRESULT SetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long );
    HRESULT ValidateDevice(unsigned long * );
    HRESULT SetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT GetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT SetCurrentTexturePalette(unsigned int );
    HRESULT GetCurrentTexturePalette(unsigned int * );
    HRESULT SetScissorRect(struct tagRECT * );
    HRESULT GetScissorRect(struct tagRECT * );
    HRESULT SetSoftwareVertexProcessing(int );
    int GetSoftwareVertexProcessing();
    HRESULT SetNPatchMode(float );
    float GetNPatchMode();
    HRESULT DrawPrimitive(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int );
    HRESULT DrawIndexedPrimitive(enum _D3DPRIMITIVETYPE ,int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    HRESULT DrawPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,void * ,unsigned int );
    HRESULT DrawIndexedPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int ,unsigned int ,void * ,enum _D3DFORMAT ,void * ,unsigned int );
    HRESULT ProcessVertices(unsigned int ,unsigned int ,unsigned int ,struct IDirect3DVertexBuffer9 * ,struct IDirect3DVertexDeclaration9 * ,unsigned long );
    HRESULT CreateVertexDeclaration(struct _D3DVERTEXELEMENT9 * ,struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetVertexDeclaration(struct IDirect3DVertexDeclaration9 * );
    HRESULT GetVertexDeclaration(struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetFVF(unsigned long );
    HRESULT GetFVF(unsigned long * );
    HRESULT CreateVertexShader(unsigned long * ,struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShader(struct IDirect3DVertexShader9 * );
    HRESULT GetVertexShader(struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT SetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 * ,unsigned int ,unsigned int );
    HRESULT GetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 ** ,unsigned int * ,unsigned int * );
    HRESULT SetStreamSourceFreq(unsigned int ,unsigned int );
    HRESULT GetStreamSourceFreq(unsigned int ,unsigned int * );
    HRESULT SetIndices(struct IDirect3DIndexBuffer9 * );
    HRESULT GetIndices(struct IDirect3DIndexBuffer9 ** );
    HRESULT CreatePixelShader(unsigned long * ,struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShader(struct IDirect3DPixelShader9 * );
    HRESULT GetPixelShader(struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT DrawRectPatch(unsigned int ,float * ,struct _D3DRECTPATCH_INFO * );
    HRESULT DrawTriPatch(unsigned int ,float * ,struct _D3DTRIPATCH_INFO * );
    HRESULT DeletePatch(unsigned int );
    HRESULT CreateQuery(enum _D3DQUERYTYPE ,struct IDirect3DQuery9 ** );
    void IDirect3DDevice9(struct IDirect3DDevice9 & );
    void IDirect3DDevice9();
    struct IDirect3DDevice9 & operator=(struct IDirect3DDevice9 & );
};

struct IDirect3DDevice9 : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT TestCooperativeLevel();
    unsigned int GetAvailableTextureMem();
    HRESULT EvictManagedResources();
    HRESULT GetDirect3D(struct IDirect3D9 ** );
    HRESULT GetDeviceCaps(struct _D3DCAPS9 * );
    HRESULT GetDisplayMode(unsigned int ,struct _D3DDISPLAYMODE * );
    HRESULT GetCreationParameters(struct _D3DDEVICE_CREATION_PARAMETERS * );
    HRESULT SetCursorProperties(unsigned int ,unsigned int ,struct IDirect3DSurface9 * );
    void SetCursorPosition(int ,int ,unsigned long );
    int ShowCursor(int );
    HRESULT CreateAdditionalSwapChain(struct _D3DPRESENT_PARAMETERS_ * ,struct IDirect3DSwapChain9 ** );
    HRESULT GetSwapChain(unsigned int ,struct IDirect3DSwapChain9 ** );
    unsigned int GetNumberOfSwapChains();
    HRESULT Reset(struct _D3DPRESENT_PARAMETERS_ * );
    HRESULT Present(struct tagRECT * ,struct tagRECT * ,struct HWND__ * ,struct _RGNDATA * );
    HRESULT GetBackBuffer(unsigned int ,unsigned int ,enum _D3DBACKBUFFER_TYPE ,struct IDirect3DSurface9 ** );
    HRESULT GetRasterStatus(unsigned int ,struct _D3DRASTER_STATUS * );
    HRESULT SetDialogBoxMode(int );
    void SetGammaRamp(unsigned int ,unsigned long ,struct _D3DGAMMARAMP * );
    void GetGammaRamp(unsigned int ,struct _D3DGAMMARAMP * );
    HRESULT CreateTexture(unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DTexture9 ** ,void ** );
    HRESULT CreateVolumeTexture(unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DVolumeTexture9 ** ,void ** );
    HRESULT CreateCubeTexture(unsigned int ,unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DCubeTexture9 ** ,void ** );
    HRESULT CreateVertexBuffer(unsigned int ,unsigned long ,unsigned long ,enum _D3DPOOL ,struct IDirect3DVertexBuffer9 ** ,void ** );
    HRESULT CreateIndexBuffer(unsigned int ,unsigned long ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DIndexBuffer9 ** ,void ** );
    HRESULT CreateRenderTarget(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT CreateDepthStencilSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DMULTISAMPLE_TYPE ,unsigned long ,int ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT UpdateSurface(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagPOINT * );
    HRESULT UpdateTexture(struct IDirect3DBaseTexture9 * ,struct IDirect3DBaseTexture9 * );
    HRESULT GetRenderTargetData(struct IDirect3DSurface9 * ,struct IDirect3DSurface9 * );
    HRESULT GetFrontBufferData(unsigned int ,struct IDirect3DSurface9 * );
    HRESULT StretchRect(struct IDirect3DSurface9 * ,struct tagRECT * ,struct IDirect3DSurface9 * ,struct tagRECT * ,enum _D3DTEXTUREFILTERTYPE );
    HRESULT ColorFill(struct IDirect3DSurface9 * ,struct tagRECT * ,unsigned long );
    HRESULT CreateOffscreenPlainSurface(unsigned int ,unsigned int ,enum _D3DFORMAT ,enum _D3DPOOL ,struct IDirect3DSurface9 ** ,void ** );
    HRESULT SetRenderTarget(unsigned long ,struct IDirect3DSurface9 * );
    HRESULT GetRenderTarget(unsigned long ,struct IDirect3DSurface9 ** );
    HRESULT SetDepthStencilSurface(struct IDirect3DSurface9 * );
    HRESULT GetDepthStencilSurface(struct IDirect3DSurface9 ** );
    HRESULT BeginScene();
    HRESULT EndScene();
    HRESULT Clear(unsigned long ,struct _D3DRECT * ,unsigned long ,unsigned long ,float ,unsigned long );
    HRESULT SetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT GetTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT MultiplyTransform(enum _D3DTRANSFORMSTATETYPE ,struct _D3DMATRIX * );
    HRESULT SetViewport(struct _D3DVIEWPORT9 * );
    HRESULT GetViewport(struct _D3DVIEWPORT9 * );
    HRESULT SetMaterial(struct _D3DMATERIAL9 * );
    HRESULT GetMaterial(struct _D3DMATERIAL9 * );
    HRESULT SetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT GetLight(unsigned long ,struct _D3DLIGHT9 * );
    HRESULT LightEnable(unsigned long ,int );
    HRESULT GetLightEnable(unsigned long ,int * );
    HRESULT SetClipPlane(unsigned long ,float * );
    HRESULT GetClipPlane(unsigned long ,float * );
    HRESULT SetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long );
    HRESULT GetRenderState(enum _D3DRENDERSTATETYPE ,unsigned long * );
    HRESULT CreateStateBlock(enum _D3DSTATEBLOCKTYPE ,struct IDirect3DStateBlock9 ** );
    HRESULT BeginStateBlock();
    HRESULT EndStateBlock(struct IDirect3DStateBlock9 ** );
    HRESULT SetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetClipStatus(struct _D3DCLIPSTATUS9 * );
    HRESULT GetTexture(unsigned long ,struct IDirect3DBaseTexture9 ** );
    HRESULT SetTexture(unsigned long ,struct IDirect3DBaseTexture9 * );
    HRESULT GetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long * );
    HRESULT SetTextureStageState(unsigned long ,enum _D3DTEXTURESTAGESTATETYPE ,unsigned long );
    HRESULT GetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long * );
    HRESULT SetSamplerState(unsigned long ,enum _D3DSAMPLERSTATETYPE ,unsigned long );
    HRESULT ValidateDevice(unsigned long * );
    HRESULT SetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT GetPaletteEntries(unsigned int ,struct tagPALETTEENTRY * );
    HRESULT SetCurrentTexturePalette(unsigned int );
    HRESULT GetCurrentTexturePalette(unsigned int * );
    HRESULT SetScissorRect(struct tagRECT * );
    HRESULT GetScissorRect(struct tagRECT * );
    HRESULT SetSoftwareVertexProcessing(int );
    int GetSoftwareVertexProcessing();
    HRESULT SetNPatchMode(float );
    float GetNPatchMode();
    HRESULT DrawPrimitive(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int );
    HRESULT DrawIndexedPrimitive(enum _D3DPRIMITIVETYPE ,int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    HRESULT DrawPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,void * ,unsigned int );
    HRESULT DrawIndexedPrimitiveUP(enum _D3DPRIMITIVETYPE ,unsigned int ,unsigned int ,unsigned int ,void * ,enum _D3DFORMAT ,void * ,unsigned int );
    HRESULT ProcessVertices(unsigned int ,unsigned int ,unsigned int ,struct IDirect3DVertexBuffer9 * ,struct IDirect3DVertexDeclaration9 * ,unsigned long );
    HRESULT CreateVertexDeclaration(struct _D3DVERTEXELEMENT9 * ,struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetVertexDeclaration(struct IDirect3DVertexDeclaration9 * );
    HRESULT GetVertexDeclaration(struct IDirect3DVertexDeclaration9 ** );
    HRESULT SetFVF(unsigned long );
    HRESULT GetFVF(unsigned long * );
    HRESULT CreateVertexShader(unsigned long * ,struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShader(struct IDirect3DVertexShader9 * );
    HRESULT GetVertexShader(struct IDirect3DVertexShader9 ** );
    HRESULT SetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetVertexShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetVertexShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT SetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 * ,unsigned int ,unsigned int );
    HRESULT GetStreamSource(unsigned int ,struct IDirect3DVertexBuffer9 ** ,unsigned int * ,unsigned int * );
    HRESULT SetStreamSourceFreq(unsigned int ,unsigned int );
    HRESULT GetStreamSourceFreq(unsigned int ,unsigned int * );
    HRESULT SetIndices(struct IDirect3DIndexBuffer9 * );
    HRESULT GetIndices(struct IDirect3DIndexBuffer9 ** );
    HRESULT CreatePixelShader(unsigned long * ,struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShader(struct IDirect3DPixelShader9 * );
    HRESULT GetPixelShader(struct IDirect3DPixelShader9 ** );
    HRESULT SetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT GetPixelShaderConstantF(unsigned int ,float * ,unsigned int );
    HRESULT SetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantI(unsigned int ,int * ,unsigned int );
    HRESULT SetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT GetPixelShaderConstantB(unsigned int ,int * ,unsigned int );
    HRESULT DrawRectPatch(unsigned int ,float * ,struct _D3DRECTPATCH_INFO * );
    HRESULT DrawTriPatch(unsigned int ,float * ,struct _D3DTRIPATCH_INFO * );
    HRESULT DeletePatch(unsigned int );
    HRESULT CreateQuery(enum _D3DQUERYTYPE ,struct IDirect3DQuery9 ** );
    void IDirect3DDevice9(struct IDirect3DDevice9 & );
    void IDirect3DDevice9();
    struct IDirect3DDevice9 & operator=(struct IDirect3DDevice9 & );
};

struct IDirect3DSurface9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DSURFACE_DESC * );
    HRESULT LockRect(struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect();
    HRESULT GetDC(struct HDC__ ** );
    HRESULT ReleaseDC(struct HDC__ * );
    void IDirect3DSurface9(struct IDirect3DSurface9 & );
    void IDirect3DSurface9();
    struct IDirect3DSurface9 & operator=(struct IDirect3DSurface9 & );
};

struct IDirect3DSurface9 : public IDirect3DResource9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    HRESULT GetContainer(struct _GUID & ,void ** );
    HRESULT GetDesc(struct _D3DSURFACE_DESC * );
    HRESULT LockRect(struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect();
    HRESULT GetDC(struct HDC__ ** );
    HRESULT ReleaseDC(struct HDC__ * );
    void IDirect3DSurface9(struct IDirect3DSurface9 & );
    void IDirect3DSurface9();
    struct IDirect3DSurface9 & operator=(struct IDirect3DSurface9 & );
};

struct ID3DXFont : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDescA(struct _D3DXFONT_DESCA * );
    HRESULT GetDescW(struct _D3DXFONT_DESCW * );
    int GetTextMetricsA(struct tagTEXTMETRICA * );
    int GetTextMetricsW(struct tagTEXTMETRICW * );
    struct HDC__ * GetDC();
    HRESULT GetGlyphData(unsigned int ,struct IDirect3DTexture9 ** ,struct tagRECT * ,struct tagPOINT * );
    HRESULT PreloadCharacters(unsigned int ,unsigned int );
    HRESULT PreloadGlyphs(unsigned int ,unsigned int );
    HRESULT PreloadTextA(char * ,int );
    HRESULT PreloadTextW(wchar_t * ,int );
    int DrawTextA(struct ID3DXSprite * ,char * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    int DrawTextW(struct ID3DXSprite * ,wchar_t * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    HRESULT GetDesc(struct _D3DXFONT_DESCA * );
    HRESULT PreloadText(char * ,int );
    void ID3DXFont(struct ID3DXFont & );
    void ID3DXFont();
    struct ID3DXFont & operator=(struct ID3DXFont & );
};

struct ID3DXFont : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetDescA(struct _D3DXFONT_DESCA * );
    HRESULT GetDescW(struct _D3DXFONT_DESCW * );
    int GetTextMetricsA(struct tagTEXTMETRICA * );
    int GetTextMetricsW(struct tagTEXTMETRICW * );
    struct HDC__ * GetDC();
    HRESULT GetGlyphData(unsigned int ,struct IDirect3DTexture9 ** ,struct tagRECT * ,struct tagPOINT * );
    HRESULT PreloadCharacters(unsigned int ,unsigned int );
    HRESULT PreloadGlyphs(unsigned int ,unsigned int );
    HRESULT PreloadTextA(char * ,int );
    HRESULT PreloadTextW(wchar_t * ,int );
    int DrawTextA(struct ID3DXSprite * ,char * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    int DrawTextW(struct ID3DXSprite * ,wchar_t * ,int ,struct tagRECT * ,unsigned long ,unsigned long );
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    HRESULT GetDesc(struct _D3DXFONT_DESCA * );
    HRESULT PreloadText(char * ,int );
    void ID3DXFont(struct ID3DXFont & );
    void ID3DXFont();
    struct ID3DXFont & operator=(struct ID3DXFont & );
};

struct D2D1_LINEAR_GRADIENT_BRUSH_PROPERTIES
{
    struct D2D_POINT_2F startPoint;
    struct D2D_POINT_2F endPoint;
};

struct CD3D10_TEXTURE2D_DESC : public D3D10_TEXTURE2D_DESC
{
    void CD3D10_TEXTURE2D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D10_TEXTURE2D_DESC(struct D3D10_TEXTURE2D_DESC & );
    void CD3D10_TEXTURE2D_DESC();
    void ~CD3D10_TEXTURE2D_DESC();
    struct D3D10_TEXTURE2D_DESC & operator const struct D3D10_TEXTURE2D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D10_TEXTURE2D_DESC : public D3D10_TEXTURE2D_DESC
{
    void CD3D10_TEXTURE2D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D10_TEXTURE2D_DESC(struct D3D10_TEXTURE2D_DESC & );
    void CD3D10_TEXTURE2D_DESC();
    void ~CD3D10_TEXTURE2D_DESC();
    struct D3D10_TEXTURE2D_DESC & operator const struct D3D10_TEXTURE2D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEXCUBE_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
};

struct D2D1_STROKE_STYLE_PROPERTIES
{
    enum D2D1_CAP_STYLE startCap;
    enum D2D1_CAP_STYLE endCap;
    enum D2D1_CAP_STYLE dashCap;
    enum D2D1_LINE_JOIN lineJoin;
    float miterLimit;
    enum D2D1_DASH_STYLE dashStyle;
    float dashOffset;
};

struct D3D11_TEX2D_RTV
{
    unsigned int MipSlice;
};

struct D2D1_GRADIENT_STOP
{
    float position;
    struct _D3DCOLORVALUE color;
};

struct D3DXMATRIX : public _D3DMATRIX
{
    void D3DXMATRIX(float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    void D3DXMATRIX(struct D3DXFLOAT16 * );
    void D3DXMATRIX(struct _D3DMATRIX & );
    void D3DXMATRIX(float * );
    void D3DXMATRIX();
    float operator()(unsigned int ,unsigned int );
    float & operator()(unsigned int ,unsigned int );
    float * operator float *();
    float * operator const float *();
    struct D3DXMATRIX & operator*=(float );
    struct D3DXMATRIX & operator*=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator+=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator-=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator/=(float );
    struct D3DXMATRIX operator+(struct D3DXMATRIX & );
    struct D3DXMATRIX operator+();
    struct D3DXMATRIX operator-(struct D3DXMATRIX & );
    struct D3DXMATRIX operator-();
    struct D3DXMATRIX operator*(float );
    struct D3DXMATRIX operator*(struct D3DXMATRIX & );
    struct D3DXMATRIX operator/(float );
    int operator==(struct D3DXMATRIX & );
    int operator!=(struct D3DXMATRIX & );
};

struct D3DXMATRIX : public _D3DMATRIX
{
    void D3DXMATRIX(float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float ,float );
    void D3DXMATRIX(struct D3DXFLOAT16 * );
    void D3DXMATRIX(struct _D3DMATRIX & );
    void D3DXMATRIX(float * );
    void D3DXMATRIX();
    float operator()(unsigned int ,unsigned int );
    float & operator()(unsigned int ,unsigned int );
    float * operator float *();
    float * operator const float *();
    struct D3DXMATRIX & operator*=(float );
    struct D3DXMATRIX & operator*=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator+=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator-=(struct D3DXMATRIX & );
    struct D3DXMATRIX & operator/=(float );
    struct D3DXMATRIX operator+(struct D3DXMATRIX & );
    struct D3DXMATRIX operator+();
    struct D3DXMATRIX operator-(struct D3DXMATRIX & );
    struct D3DXMATRIX operator-();
    struct D3DXMATRIX operator*(float );
    struct D3DXMATRIX operator*(struct D3DXMATRIX & );
    struct D3DXMATRIX operator/(float );
    int operator==(struct D3DXMATRIX & );
    int operator!=(struct D3DXMATRIX & );
};

struct D2D1_LAYER_PARAMETERS
{
    struct D2D_RECT_F contentBounds;
    struct ID2D1Geometry * geometricMask;
    enum D2D1_ANTIALIAS_MODE maskAntialiasMode;
    struct D2D_MATRIX_3X2_F maskTransform;
    float opacity;
    struct ID2D1Brush * opacityBrush;
    enum D2D1_LAYER_OPTIONS layerOptions;
};

struct IWICBitmapLock : public IUnknown
{
    HRESULT GetSize(unsigned int * ,unsigned int * );
    HRESULT GetStride(unsigned int * );
    HRESULT GetDataPointer(unsigned int * ,unsigned int ** );
    HRESULT GetPixelFormat(struct _GUID * );
    void IWICBitmapLock(struct IWICBitmapLock & );
    void IWICBitmapLock();
    struct IWICBitmapLock & operator=(struct IWICBitmapLock & );
};

struct IWICBitmapLock : public IUnknown
{
    HRESULT GetSize(unsigned int * ,unsigned int * );
    HRESULT GetStride(unsigned int * );
    HRESULT GetDataPointer(unsigned int * ,unsigned int ** );
    HRESULT GetPixelFormat(struct _GUID * );
    void IWICBitmapLock(struct IWICBitmapLock & );
    void IWICBitmapLock();
    struct IWICBitmapLock & operator=(struct IWICBitmapLock & );
};

struct IDirect3DTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetSurfaceLevel(unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(unsigned int );
    HRESULT AddDirtyRect(struct tagRECT * );
    void IDirect3DTexture9(struct IDirect3DTexture9 & );
    void IDirect3DTexture9();
    struct IDirect3DTexture9 & operator=(struct IDirect3DTexture9 & );
};

struct IDirect3DTexture9 : public IDirect3DBaseTexture9
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT SetPrivateData(struct _GUID & ,void * ,unsigned long ,unsigned long );
    HRESULT GetPrivateData(struct _GUID & ,void * ,unsigned long * );
    HRESULT FreePrivateData(struct _GUID & );
    unsigned long SetPriority(unsigned long );
    unsigned long GetPriority();
    void PreLoad();
    enum _D3DRESOURCETYPE GetType();
    unsigned long SetLOD(unsigned long );
    unsigned long GetLOD();
    unsigned long GetLevelCount();
    HRESULT SetAutoGenFilterType(enum _D3DTEXTUREFILTERTYPE );
    enum _D3DTEXTUREFILTERTYPE GetAutoGenFilterType();
    void GenerateMipSubLevels();
    HRESULT GetLevelDesc(unsigned int ,struct _D3DSURFACE_DESC * );
    HRESULT GetSurfaceLevel(unsigned int ,struct IDirect3DSurface9 ** );
    HRESULT LockRect(unsigned int ,struct _D3DLOCKED_RECT * ,struct tagRECT * ,unsigned long );
    HRESULT UnlockRect(unsigned int );
    HRESULT AddDirtyRect(struct tagRECT * );
    void IDirect3DTexture9(struct IDirect3DTexture9 & );
    void IDirect3DTexture9();
    struct IDirect3DTexture9 & operator=(struct IDirect3DTexture9 & );
};

struct D3DXVECTOR3_16F
{
    void D3DXVECTOR3_16F(struct D3DXVECTOR3_16F & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & ,struct D3DXFLOAT16 & );
    void D3DXVECTOR3_16F(struct D3DXFLOAT16 * );
    void D3DXVECTOR3_16F(struct _D3DVECTOR & );
    void D3DXVECTOR3_16F(float * );
    void D3DXVECTOR3_16F();
    struct D3DXFLOAT16 * operator struct D3DXFLOAT16 *();
    struct D3DXFLOAT16 * operator const struct D3DXFLOAT16 *();
    int operator==(struct D3DXVECTOR3_16F & );
    int operator!=(struct D3DXVECTOR3_16F & );
    struct D3DXFLOAT16 x;
    struct D3DXFLOAT16 y;
    struct D3DXFLOAT16 z;
};

struct ID2D1GeometryGroup : public ID2D1Geometry
{
    enum D2D1_FILL_MODE GetFillMode();
    unsigned int GetSourceGeometryCount();
    void GetSourceGeometries(struct ID2D1Geometry ** ,unsigned int );
    void ID2D1GeometryGroup(struct ID2D1GeometryGroup & );
    void ID2D1GeometryGroup();
    struct ID2D1GeometryGroup & operator=(struct ID2D1GeometryGroup & );
};

struct ID2D1GeometryGroup : public ID2D1Geometry
{
    enum D2D1_FILL_MODE GetFillMode();
    unsigned int GetSourceGeometryCount();
    void GetSourceGeometries(struct ID2D1Geometry ** ,unsigned int );
    void ID2D1GeometryGroup(struct ID2D1GeometryGroup & );
    void ID2D1GeometryGroup();
    struct ID2D1GeometryGroup & operator=(struct ID2D1GeometryGroup & );
};

struct D3D11_TEX2D_ARRAY_RTV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct D2D1_DRAWING_STATE_DESCRIPTION
{
    enum D2D1_ANTIALIAS_MODE antialiasMode;
    enum D2D1_TEXT_ANTIALIAS_MODE textAntialiasMode;
    unsigned int tag1;
    unsigned int tag2;
    struct D2D_MATRIX_3X2_F transform;
};

struct ID2D1Mesh : public ID2D1Resource
{
    HRESULT Open(struct ID2D1TessellationSink ** );
    void ID2D1Mesh(struct ID2D1Mesh & );
    void ID2D1Mesh();
    struct ID2D1Mesh & operator=(struct ID2D1Mesh & );
};

struct ID2D1Mesh : public ID2D1Resource
{
    HRESULT Open(struct ID2D1TessellationSink ** );
    void ID2D1Mesh(struct ID2D1Mesh & );
    void ID2D1Mesh();
    struct ID2D1Mesh & operator=(struct ID2D1Mesh & );
};

struct XAUDIO2_DEBUG_CONFIGURATION
{
    unsigned int TraceMask;
    unsigned int BreakMask;
    int LogThreadID;
    int LogFileline;
    int LogFunctionName;
    int LogTiming;
};

enum D2D1_DEBUG_LEVEL
{
    D2D1_DEBUG_LEVEL_NONE=0,
    D2D1_DEBUG_LEVEL_ERROR=1,
    D2D1_DEBUG_LEVEL_WARNING=2,
    D2D1_DEBUG_LEVEL_INFORMATION=3,
    D2D1_DEBUG_LEVEL_FORCE_DWORD=-1
};

struct D2D1_FACTORY_OPTIONS
{
    enum D2D1_DEBUG_LEVEL debugLevel;
};

struct D3D10_BUFFER_DESC
{
    unsigned int ByteWidth;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

enum DWRITE_PIXEL_GEOMETRY
{
    DWRITE_PIXEL_GEOMETRY_FLAT=0,
    DWRITE_PIXEL_GEOMETRY_RGB=1,
    DWRITE_PIXEL_GEOMETRY_BGR=2
};

struct IDWriteRenderingParams : public IUnknown
{
    float GetGamma();
    float GetEnhancedContrast();
    float GetClearTypeLevel();
    enum DWRITE_PIXEL_GEOMETRY GetPixelGeometry();
    enum DWRITE_RENDERING_MODE GetRenderingMode();
    void IDWriteRenderingParams(struct IDWriteRenderingParams & );
    void IDWriteRenderingParams();
    struct IDWriteRenderingParams & operator=(struct IDWriteRenderingParams & );
};

struct IDWriteRenderingParams : public IUnknown
{
    float GetGamma();
    float GetEnhancedContrast();
    float GetClearTypeLevel();
    enum DWRITE_PIXEL_GEOMETRY GetPixelGeometry();
    enum DWRITE_RENDERING_MODE GetRenderingMode();
    void IDWriteRenderingParams(struct IDWriteRenderingParams & );
    void IDWriteRenderingParams();
    struct IDWriteRenderingParams & operator=(struct IDWriteRenderingParams & );
};

struct DXGI_MAPPED_RECT
{
    int Pitch;
    unsigned int * pBits;
};

struct ID3D11Buffer : public ID3D11Resource
{
    void GetDesc(struct D3D11_BUFFER_DESC * );
    void ID3D11Buffer(struct ID3D11Buffer & );
    void ID3D11Buffer();
    struct ID3D11Buffer & operator=(struct ID3D11Buffer & );
};

struct ID3D11Buffer : public ID3D11Resource
{
    void GetDesc(struct D3D11_BUFFER_DESC * );
    void ID3D11Buffer(struct ID3D11Buffer & );
    void ID3D11Buffer();
    struct ID3D11Buffer & operator=(struct ID3D11Buffer & );
};

struct ID2D1Bitmap : public ID2D1Resource
{
    struct D2D_SIZE_F GetSize();
    struct D2D_SIZE_U GetPixelSize();
    struct D2D1_PIXEL_FORMAT GetPixelFormat();
    void GetDpi(float * ,float * );
    HRESULT CopyFromBitmap(struct D2D_POINT_2U * ,struct ID2D1Bitmap * ,struct D2D_RECT_U * );
    HRESULT CopyFromRenderTarget(struct D2D_POINT_2U * ,struct ID2D1RenderTarget * ,struct D2D_RECT_U * );
    HRESULT CopyFromMemory(struct D2D_RECT_U * ,void * ,unsigned int );
    void ID2D1Bitmap(struct ID2D1Bitmap & );
    void ID2D1Bitmap();
    struct ID2D1Bitmap & operator=(struct ID2D1Bitmap & );
};

struct D2D_POINT_2U
{
    unsigned int x;
    unsigned int y;
};

struct D2D_RECT_U
{
    unsigned int left;
    unsigned int top;
    unsigned int right;
    unsigned int bottom;
};

struct ID2D1Bitmap : public ID2D1Resource
{
    struct D2D_SIZE_F GetSize();
    struct D2D_SIZE_U GetPixelSize();
    struct D2D1_PIXEL_FORMAT GetPixelFormat();
    void GetDpi(float * ,float * );
    HRESULT CopyFromBitmap(struct D2D_POINT_2U * ,struct ID2D1Bitmap * ,struct D2D_RECT_U * );
    HRESULT CopyFromRenderTarget(struct D2D_POINT_2U * ,struct ID2D1RenderTarget * ,struct D2D_RECT_U * );
    HRESULT CopyFromMemory(struct D2D_RECT_U * ,void * ,unsigned int );
    void ID2D1Bitmap(struct ID2D1Bitmap & );
    void ID2D1Bitmap();
    struct ID2D1Bitmap & operator=(struct ID2D1Bitmap & );
};

struct D3DXFLOAT16
{
    void D3DXFLOAT16(struct D3DXFLOAT16 & );
    void D3DXFLOAT16(float );
    void D3DXFLOAT16();
    float operator float();
    int operator==(struct D3DXFLOAT16 & );
    int operator!=(struct D3DXFLOAT16 & );
    unsigned int value;
};

struct D2D1_QUADRATIC_BEZIER_SEGMENT
{
    struct D2D_POINT_2F point1;
    struct D2D_POINT_2F point2;
};

struct D3D11_RASTERIZER_DESC
{
    enum D3D11_FILL_MODE FillMode;
    enum D3D11_CULL_MODE CullMode;
    int FrontCounterClockwise;
    int DepthBias;
    float DepthBiasClamp;
    float SlopeScaledDepthBias;
    int DepthClipEnable;
    int ScissorEnable;
    int MultisampleEnable;
    int AntialiasedLineEnable;
};

struct ID3DXSprite : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetTransform(struct D3DXMATRIX * );
    HRESULT SetTransform(struct D3DXMATRIX * );
    HRESULT SetWorldViewRH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT SetWorldViewLH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT Begin(unsigned long );
    HRESULT Draw(struct IDirect3DTexture9 * ,struct tagRECT * ,struct D3DXVECTOR3 * ,struct D3DXVECTOR3 * ,unsigned long );
    HRESULT Flush();
    HRESULT End();
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    void ID3DXSprite(struct ID3DXSprite & );
    void ID3DXSprite();
    struct ID3DXSprite & operator=(struct ID3DXSprite & );
};

struct ID3DXSprite : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT GetDevice(struct IDirect3DDevice9 ** );
    HRESULT GetTransform(struct D3DXMATRIX * );
    HRESULT SetTransform(struct D3DXMATRIX * );
    HRESULT SetWorldViewRH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT SetWorldViewLH(struct D3DXMATRIX * ,struct D3DXMATRIX * );
    HRESULT Begin(unsigned long );
    HRESULT Draw(struct IDirect3DTexture9 * ,struct tagRECT * ,struct D3DXVECTOR3 * ,struct D3DXVECTOR3 * ,unsigned long );
    HRESULT Flush();
    HRESULT End();
    HRESULT OnLostDevice();
    HRESULT OnResetDevice();
    void ID3DXSprite(struct ID3DXSprite & );
    void ID3DXSprite();
    struct ID3DXSprite & operator=(struct ID3DXSprite & );
};

struct D3D10_TEXTURE2D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int MipLevels;
    unsigned int ArraySize;
    enum DXGI_FORMAT Format;
    struct DXGI_SAMPLE_DESC SampleDesc;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct CD3D11_RENDER_TARGET_VIEW_DESC : public D3D11_RENDER_TARGET_VIEW_DESC
{
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Texture3D * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D11_RTV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D11_RTV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(enum D3D11_RTV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct D3D11_RENDER_TARGET_VIEW_DESC & );
    void CD3D11_RENDER_TARGET_VIEW_DESC();
    void ~CD3D11_RENDER_TARGET_VIEW_DESC();
    struct D3D11_RENDER_TARGET_VIEW_DESC & operator const struct D3D11_RENDER_TARGET_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_RENDER_TARGET_VIEW_DESC : public D3D11_RENDER_TARGET_VIEW_DESC
{
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Texture3D * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D11_RTV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D11_RTV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(enum D3D11_RTV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_RENDER_TARGET_VIEW_DESC(struct D3D11_RENDER_TARGET_VIEW_DESC & );
    void CD3D11_RENDER_TARGET_VIEW_DESC();
    void ~CD3D11_RENDER_TARGET_VIEW_DESC();
    struct D3D11_RENDER_TARGET_VIEW_DESC & operator const struct D3D11_RENDER_TARGET_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEX2DMS_ARRAY_SRV
{
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct ID3D11Resource : public ID3D11DeviceChild
{
    void GetType(enum D3D11_RESOURCE_DIMENSION * );
    void SetEvictionPriority(unsigned int );
    unsigned int GetEvictionPriority();
    void ID3D11Resource(struct ID3D11Resource & );
    void ID3D11Resource();
    struct ID3D11Resource & operator=(struct ID3D11Resource & );
};

struct ID3D11Resource : public ID3D11DeviceChild
{
    void GetType(enum D3D11_RESOURCE_DIMENSION * );
    void SetEvictionPriority(unsigned int );
    unsigned int GetEvictionPriority();
    void ID3D11Resource(struct ID3D11Resource & );
    void ID3D11Resource();
    struct ID3D11Resource & operator=(struct ID3D11Resource & );
};

struct ID2D1BitmapBrush : public ID2D1Brush
{
    void SetExtendModeX(enum D2D1_EXTEND_MODE );
    void SetExtendModeY(enum D2D1_EXTEND_MODE );
    void SetInterpolationMode(enum D2D1_BITMAP_INTERPOLATION_MODE );
    void SetBitmap(struct ID2D1Bitmap * );
    enum D2D1_EXTEND_MODE GetExtendModeX();
    enum D2D1_EXTEND_MODE GetExtendModeY();
    enum D2D1_BITMAP_INTERPOLATION_MODE GetInterpolationMode();
    void GetBitmap(struct ID2D1Bitmap ** );
    void ID2D1BitmapBrush(struct ID2D1BitmapBrush & );
    void ID2D1BitmapBrush();
    struct ID2D1BitmapBrush & operator=(struct ID2D1BitmapBrush & );
};

struct ID2D1BitmapBrush : public ID2D1Brush
{
    void SetExtendModeX(enum D2D1_EXTEND_MODE );
    void SetExtendModeY(enum D2D1_EXTEND_MODE );
    void SetInterpolationMode(enum D2D1_BITMAP_INTERPOLATION_MODE );
    void SetBitmap(struct ID2D1Bitmap * );
    enum D2D1_EXTEND_MODE GetExtendModeX();
    enum D2D1_EXTEND_MODE GetExtendModeY();
    enum D2D1_BITMAP_INTERPOLATION_MODE GetInterpolationMode();
    void GetBitmap(struct ID2D1Bitmap ** );
    void ID2D1BitmapBrush(struct ID2D1BitmapBrush & );
    void ID2D1BitmapBrush();
    struct ID2D1BitmapBrush & operator=(struct ID2D1BitmapBrush & );
};

struct CD3D11_TEXTURE2D_DESC : public D3D11_TEXTURE2D_DESC
{
    void CD3D11_TEXTURE2D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_TEXTURE2D_DESC(struct D3D11_TEXTURE2D_DESC & );
    void CD3D11_TEXTURE2D_DESC();
    void ~CD3D11_TEXTURE2D_DESC();
    struct D3D11_TEXTURE2D_DESC & operator const struct D3D11_TEXTURE2D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_TEXTURE2D_DESC : public D3D11_TEXTURE2D_DESC
{
    void CD3D11_TEXTURE2D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D11_USAGE ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_TEXTURE2D_DESC(struct D3D11_TEXTURE2D_DESC & );
    void CD3D11_TEXTURE2D_DESC();
    void ~CD3D11_TEXTURE2D_DESC();
    struct D3D11_TEXTURE2D_DESC & operator const struct D3D11_TEXTURE2D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D2D1_RADIAL_GRADIENT_BRUSH_PROPERTIES
{
    struct D2D_POINT_2F center;
    struct D2D_POINT_2F gradientOriginOffset;
    float radiusX;
    float radiusY;
};

struct D3DXPLANE
{
    void D3DXPLANE(float ,float ,float ,float );
    void D3DXPLANE(struct D3DXFLOAT16 * );
    void D3DXPLANE(float * );
    void D3DXPLANE();
    float * operator float *();
    float * operator const float *();
    struct D3DXPLANE & operator*=(float );
    struct D3DXPLANE & operator/=(float );
    struct D3DXPLANE operator+();
    struct D3DXPLANE operator-();
    struct D3DXPLANE operator*(float );
    struct D3DXPLANE operator/(float );
    int operator==(struct D3DXPLANE & );
    int operator!=(struct D3DXPLANE & );
    float a;
    float b;
    float c;
    float d;
};

struct D3DXPLANE
{
    void D3DXPLANE(float ,float ,float ,float );
    void D3DXPLANE(struct D3DXFLOAT16 * );
    void D3DXPLANE(float * );
    void D3DXPLANE();
    float * operator float *();
    float * operator const float *();
    struct D3DXPLANE & operator*=(float );
    struct D3DXPLANE & operator/=(float );
    struct D3DXPLANE operator+();
    struct D3DXPLANE operator-();
    struct D3DXPLANE operator*(float );
    struct D3DXPLANE operator/(float );
    int operator==(struct D3DXPLANE & );
    int operator!=(struct D3DXPLANE & );
    float a;
    float b;
    float c;
    float d;
};

struct D2D1_TRIANGLE
{
    struct D2D_POINT_2F point1;
    struct D2D_POINT_2F point2;
    struct D2D_POINT_2F point3;
};

struct ID2D1TessellationSink : public IUnknown
{
    void AddTriangles(struct D2D1_TRIANGLE * ,unsigned int );
    HRESULT Close();
    void ID2D1TessellationSink(struct ID2D1TessellationSink & );
    void ID2D1TessellationSink();
    struct ID2D1TessellationSink & operator=(struct ID2D1TessellationSink & );
};

struct ID2D1TessellationSink : public IUnknown
{
    void AddTriangles(struct D2D1_TRIANGLE * ,unsigned int );
    HRESULT Close();
    void ID2D1TessellationSink(struct ID2D1TessellationSink & );
    void ID2D1TessellationSink();
    struct ID2D1TessellationSink & operator=(struct ID2D1TessellationSink & );
};

struct ID3DX10Sprite : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT Begin(unsigned int );
    HRESULT DrawSpritesBuffered(struct _D3DX10_SPRITE * ,unsigned int );
    HRESULT Flush();
    HRESULT DrawSpritesImmediate(struct _D3DX10_SPRITE * ,unsigned int ,unsigned int ,unsigned int );
    HRESULT End();
    HRESULT GetViewTransform(struct D3DXMATRIX * );
    HRESULT SetViewTransform(struct D3DXMATRIX * );
    HRESULT GetProjectionTransform(struct D3DXMATRIX * );
    HRESULT SetProjectionTransform(struct D3DXMATRIX * );
    HRESULT GetDevice(struct ID3D10Device ** );
    void ID3DX10Sprite(struct ID3DX10Sprite & );
    void ID3DX10Sprite();
    struct ID3DX10Sprite & operator=(struct ID3DX10Sprite & );
};

struct ID3DX10Sprite : public IUnknown
{
    HRESULT QueryInterface(struct _GUID & ,void ** );
    unsigned long AddRef();
    unsigned long Release();
    HRESULT Begin(unsigned int );
    HRESULT DrawSpritesBuffered(struct _D3DX10_SPRITE * ,unsigned int );
    HRESULT Flush();
    HRESULT DrawSpritesImmediate(struct _D3DX10_SPRITE * ,unsigned int ,unsigned int ,unsigned int );
    HRESULT End();
    HRESULT GetViewTransform(struct D3DXMATRIX * );
    HRESULT SetViewTransform(struct D3DXMATRIX * );
    HRESULT GetProjectionTransform(struct D3DXMATRIX * );
    HRESULT SetProjectionTransform(struct D3DXMATRIX * );
    HRESULT GetDevice(struct ID3D10Device ** );
    void ID3DX10Sprite(struct ID3DX10Sprite & );
    void ID3DX10Sprite();
    struct ID3DX10Sprite & operator=(struct ID3DX10Sprite & );
};

struct D3D11_TEX1D_ARRAY_SRV
{
    unsigned int MostDetailedMip;
    unsigned int MipLevels;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

struct CD3D10_TEXTURE1D_DESC : public D3D10_TEXTURE1D_DESC
{
    void CD3D10_TEXTURE1D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int );
    void CD3D10_TEXTURE1D_DESC(struct D3D10_TEXTURE1D_DESC & );
    void CD3D10_TEXTURE1D_DESC();
    void ~CD3D10_TEXTURE1D_DESC();
    struct D3D10_TEXTURE1D_DESC & operator const struct D3D10_TEXTURE1D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D10_TEXTURE1D_DESC : public D3D10_TEXTURE1D_DESC
{
    void CD3D10_TEXTURE1D_DESC(enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int );
    void CD3D10_TEXTURE1D_DESC(struct D3D10_TEXTURE1D_DESC & );
    void CD3D10_TEXTURE1D_DESC();
    void ~CD3D10_TEXTURE1D_DESC();
    struct D3D10_TEXTURE1D_DESC & operator const struct D3D10_TEXTURE1D_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct D3D11_TEX2D_DSV
{
    unsigned int MipSlice;
};

struct ID2D1Brush : public ID2D1Resource
{
    void SetOpacity(float );
    void SetTransform(struct D2D_MATRIX_3X2_F & );
    void SetTransform(struct D2D_MATRIX_3X2_F * );
    float GetOpacity();
    void GetTransform(struct D2D_MATRIX_3X2_F * );
    void ID2D1Brush(struct ID2D1Brush & );
    void ID2D1Brush();
    struct ID2D1Brush & operator=(struct ID2D1Brush & );
};

struct ID2D1Brush : public ID2D1Resource
{
    void SetOpacity(float );
    void SetTransform(struct D2D_MATRIX_3X2_F & );
    void SetTransform(struct D2D_MATRIX_3X2_F * );
    float GetOpacity();
    void GetTransform(struct D2D_MATRIX_3X2_F * );
    void ID2D1Brush(struct ID2D1Brush & );
    void ID2D1Brush();
    struct ID2D1Brush & operator=(struct ID2D1Brush & );
};

struct D3D11_BUFFEREX_SRV
{
    unsigned int FirstElement;
    unsigned int NumElements;
    unsigned int Flags;
};

struct HDC__
{
    int unused;
};

struct ID2D1TransformedGeometry : public ID2D1Geometry
{
    void GetSourceGeometry(struct ID2D1Geometry ** );
    void GetTransform(struct D2D_MATRIX_3X2_F * );
    void ID2D1TransformedGeometry(struct ID2D1TransformedGeometry & );
    void ID2D1TransformedGeometry();
    struct ID2D1TransformedGeometry & operator=(struct ID2D1TransformedGeometry & );
};

struct ID2D1TransformedGeometry : public ID2D1Geometry
{
    void GetSourceGeometry(struct ID2D1Geometry ** );
    void GetTransform(struct D2D_MATRIX_3X2_F * );
    void ID2D1TransformedGeometry(struct ID2D1TransformedGeometry & );
    void ID2D1TransformedGeometry();
    struct ID2D1TransformedGeometry & operator=(struct ID2D1TransformedGeometry & );
};

struct D3D11_TEX1D_ARRAY_UAV
{
    unsigned int MipSlice;
    unsigned int FirstArraySlice;
    unsigned int ArraySize;
};

enum D2D1_SWEEP_DIRECTION
{
    D2D1_SWEEP_DIRECTION_COUNTER_CLOCKWISE=0,
    D2D1_SWEEP_DIRECTION_CLOCKWISE=1,
    D2D1_SWEEP_DIRECTION_FORCE_DWORD=-1
};

enum D2D1_ARC_SIZE
{
    D2D1_ARC_SIZE_SMALL=0,
    D2D1_ARC_SIZE_LARGE=1,
    D2D1_ARC_SIZE_FORCE_DWORD=-1
};

struct D2D1_ARC_SEGMENT
{
    struct D2D_POINT_2F point;
    struct D2D_SIZE_F size;
    float rotationAngle;
    enum D2D1_SWEEP_DIRECTION sweepDirection;
    enum D2D1_ARC_SIZE arcSize;
};

struct ID2D1GradientStopCollection : public ID2D1Resource
{
    unsigned int GetGradientStopCount();
    void GetGradientStops(struct D2D1_GRADIENT_STOP * ,unsigned int );
    enum D2D1_GAMMA GetColorInterpolationGamma();
    enum D2D1_EXTEND_MODE GetExtendMode();
    void ID2D1GradientStopCollection(struct ID2D1GradientStopCollection & );
    void ID2D1GradientStopCollection();
    struct ID2D1GradientStopCollection & operator=(struct ID2D1GradientStopCollection & );
};

struct ID2D1GradientStopCollection : public ID2D1Resource
{
    unsigned int GetGradientStopCount();
    void GetGradientStops(struct D2D1_GRADIENT_STOP * ,unsigned int );
    enum D2D1_GAMMA GetColorInterpolationGamma();
    enum D2D1_EXTEND_MODE GetExtendMode();
    void ID2D1GradientStopCollection(struct ID2D1GradientStopCollection & );
    void ID2D1GradientStopCollection();
    struct ID2D1GradientStopCollection & operator=(struct ID2D1GradientStopCollection & );
};

struct IXAudio2MasteringVoice : public IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    void IXAudio2MasteringVoice(struct IXAudio2MasteringVoice & );
    void IXAudio2MasteringVoice();
    struct IXAudio2MasteringVoice & operator=(struct IXAudio2MasteringVoice & );
};

struct IXAudio2MasteringVoice : public IXAudio2Voice
{
    void GetVoiceDetails(struct XAUDIO2_VOICE_DETAILS * );
    HRESULT SetOutputVoices(struct XAUDIO2_VOICE_SENDS * );
    HRESULT SetEffectChain(struct XAUDIO2_EFFECT_CHAIN * );
    HRESULT EnableEffect(unsigned int ,unsigned int );
    HRESULT DisableEffect(unsigned int ,unsigned int );
    void GetEffectState(unsigned int ,int * );
    HRESULT SetEffectParameters(unsigned int ,void * ,unsigned int ,unsigned int );
    HRESULT GetEffectParameters(unsigned int ,void * ,unsigned int );
    HRESULT SetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetFilterParameters(struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * ,unsigned int );
    void GetOutputFilterParameters(struct IXAudio2Voice * ,struct XAUDIO2_FILTER_PARAMETERS * );
    HRESULT SetVolume(float ,unsigned int );
    void GetVolume(float * );
    HRESULT SetChannelVolumes(unsigned int ,float * ,unsigned int );
    void GetChannelVolumes(unsigned int ,float * );
    HRESULT SetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * ,unsigned int );
    void GetOutputMatrix(struct IXAudio2Voice * ,unsigned int ,unsigned int ,float * );
    void DestroyVoice();
    void IXAudio2MasteringVoice(struct IXAudio2MasteringVoice & );
    void IXAudio2MasteringVoice();
    struct IXAudio2MasteringVoice & operator=(struct IXAudio2MasteringVoice & );
};

struct CD3D11_DEFAULT
{
};

struct CD3D11_COUNTER_DESC : public D3D11_COUNTER_DESC
{
    void CD3D11_COUNTER_DESC(enum D3D11_COUNTER ,unsigned int );
    void CD3D11_COUNTER_DESC(struct D3D11_COUNTER_DESC & );
    void CD3D11_COUNTER_DESC();
    void ~CD3D11_COUNTER_DESC();
    struct D3D11_COUNTER_DESC & operator const struct D3D11_COUNTER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_COUNTER_DESC : public D3D11_COUNTER_DESC
{
    void CD3D11_COUNTER_DESC(enum D3D11_COUNTER ,unsigned int );
    void CD3D11_COUNTER_DESC(struct D3D11_COUNTER_DESC & );
    void CD3D11_COUNTER_DESC();
    void ~CD3D11_COUNTER_DESC();
    struct D3D11_COUNTER_DESC & operator const struct D3D11_COUNTER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D10_BUFFER_DESC : public D3D10_BUFFER_DESC
{
    void CD3D10_BUFFER_DESC(unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int );
    void CD3D10_BUFFER_DESC(struct D3D10_BUFFER_DESC & );
    void CD3D10_BUFFER_DESC();
    void ~CD3D10_BUFFER_DESC();
    struct D3D10_BUFFER_DESC & operator const struct D3D10_BUFFER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D10_BUFFER_DESC : public D3D10_BUFFER_DESC
{
    void CD3D10_BUFFER_DESC(unsigned int ,unsigned int ,enum D3D10_USAGE ,unsigned int ,unsigned int );
    void CD3D10_BUFFER_DESC(struct D3D10_BUFFER_DESC & );
    void CD3D10_BUFFER_DESC();
    void ~CD3D10_BUFFER_DESC();
    struct D3D10_BUFFER_DESC & operator const struct D3D10_BUFFER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct IDXGIObject : public IUnknown
{
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT GetParent(struct _GUID & ,void ** );
    void IDXGIObject(struct IDXGIObject & );
    void IDXGIObject();
    struct IDXGIObject & operator=(struct IDXGIObject & );
};

struct IDXGIObject : public IUnknown
{
    HRESULT SetPrivateData(struct _GUID & ,unsigned int ,void * );
    HRESULT SetPrivateDataInterface(struct _GUID & ,struct IUnknown * );
    HRESULT GetPrivateData(struct _GUID & ,unsigned int * ,void * );
    HRESULT GetParent(struct _GUID & ,void ** );
    void IDXGIObject(struct IDXGIObject & );
    void IDXGIObject();
    struct IDXGIObject & operator=(struct IDXGIObject & );
};

struct D3D11_BUFFER_RTV
{
    unsigned int FirstElement;
    unsigned int ElementOffset;
    unsigned int NumElements;
    unsigned int ElementWidth;
};

struct IWICBitmapSource : public IUnknown
{
    HRESULT GetSize(unsigned int * ,unsigned int * );
    HRESULT GetPixelFormat(struct _GUID * );
    HRESULT GetResolution(float * ,float * );
    HRESULT CopyPalette(struct IWICPalette * );
    HRESULT CopyPixels(struct WICRect * ,unsigned int ,unsigned int ,unsigned int * );
    void IWICBitmapSource(struct IWICBitmapSource & );
    void IWICBitmapSource();
    struct IWICBitmapSource & operator=(struct IWICBitmapSource & );
};

struct IWICBitmapSource : public IUnknown
{
    HRESULT GetSize(unsigned int * ,unsigned int * );
    HRESULT GetPixelFormat(struct _GUID * );
    HRESULT GetResolution(float * ,float * );
    HRESULT CopyPalette(struct IWICPalette * );
    HRESULT CopyPixels(struct WICRect * ,unsigned int ,unsigned int ,unsigned int * );
    void IWICBitmapSource(struct IWICBitmapSource & );
    void IWICBitmapSource();
    struct IWICBitmapSource & operator=(struct IWICBitmapSource & );
};

struct XAUDIO2_PERFORMANCE_DATA
{
    unsigned int AudioCyclesSinceLastQuery;
    unsigned int TotalCyclesSinceLastQuery;
    unsigned int MinimumCyclesPerQuantum;
    unsigned int MaximumCyclesPerQuantum;
    unsigned int MemoryUsageInBytes;
    unsigned int CurrentLatencyInSamples;
    unsigned int GlitchesSinceEngineStarted;
    unsigned int ActiveSourceVoiceCount;
    unsigned int TotalSourceVoiceCount;
    unsigned int ActiveSubmixVoiceCount;
    unsigned int ActiveResamplerCount;
    unsigned int ActiveMatrixMixCount;
    unsigned int ActiveXmaSourceVoices;
    unsigned int ActiveXmaStreams;
};

struct D3D10_TEXTURE3D_DESC
{
    unsigned int Width;
    unsigned int Height;
    unsigned int Depth;
    unsigned int MipLevels;
    enum DXGI_FORMAT Format;
    enum D3D10_USAGE Usage;
    unsigned int BindFlags;
    unsigned int CPUAccessFlags;
    unsigned int MiscFlags;
};

struct CD3D11_UNORDERED_ACCESS_VIEW_DESC : public D3D11_UNORDERED_ACCESS_VIEW_DESC
{
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Texture3D * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D11_UAV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D11_UAV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(enum D3D11_UAV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct D3D11_UNORDERED_ACCESS_VIEW_DESC & );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC();
    void ~CD3D11_UNORDERED_ACCESS_VIEW_DESC();
    struct D3D11_UNORDERED_ACCESS_VIEW_DESC & operator const struct D3D11_UNORDERED_ACCESS_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_UNORDERED_ACCESS_VIEW_DESC : public D3D11_UNORDERED_ACCESS_VIEW_DESC
{
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Texture3D * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Texture2D * ,enum D3D11_UAV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Texture1D * ,enum D3D11_UAV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct ID3D11Buffer * ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(enum D3D11_UAV_DIMENSION ,enum DXGI_FORMAT ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC(struct D3D11_UNORDERED_ACCESS_VIEW_DESC & );
    void CD3D11_UNORDERED_ACCESS_VIEW_DESC();
    void ~CD3D11_UNORDERED_ACCESS_VIEW_DESC();
    struct D3D11_UNORDERED_ACCESS_VIEW_DESC & operator const struct D3D11_UNORDERED_ACCESS_VIEW_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_RASTERIZER_DESC : public D3D11_RASTERIZER_DESC
{
    void CD3D11_RASTERIZER_DESC(enum D3D11_FILL_MODE ,enum D3D11_CULL_MODE ,int ,int ,float ,float ,int ,int ,int ,int );
    void CD3D11_RASTERIZER_DESC(struct CD3D11_DEFAULT );
    void CD3D11_RASTERIZER_DESC(struct D3D11_RASTERIZER_DESC & );
    void CD3D11_RASTERIZER_DESC();
    void ~CD3D11_RASTERIZER_DESC();
    struct D3D11_RASTERIZER_DESC & operator const struct D3D11_RASTERIZER_DESC &();
    void * __vecDelDtor(unsigned int );
};

struct CD3D11_RASTERIZER_DESC : public D3D11_RASTERIZER_DESC
{
    void CD3D11_RASTERIZER_DESC(enum D3D11_FILL_MODE ,enum D3D11_CULL_MODE ,int ,int ,float ,float ,int ,int ,int ,int );
    void CD3D11_RASTERIZER_DESC(struct CD3D11_DEFAULT );
    void CD3D11_RASTERIZER_DESC(struct D3D11_RASTERIZER_DESC & );
    void CD3D11_RASTERIZER_DESC();
    void ~CD3D11_RASTERIZER_DESC();
    struct D3D11_RASTERIZER_DESC & operator const struct D3D11_RASTERIZER_DESC &();
    void * __vecDelDtor(unsigned int );
};

enum DWRITE_BREAK_CONDITION
{
    DWRITE_BREAK_CONDITION_NEUTRAL=0,
    DWRITE_BREAK_CONDITION_CAN_BREAK=1,
    DWRITE_BREAK_CONDITION_MAY_NOT_BREAK=2,
    DWRITE_BREAK_CONDITION_MUST_BREAK=3
};

struct IDWriteInlineObject : public IUnknown
{
    HRESULT Draw(void * ,struct IDWriteTextRenderer * ,float ,float ,int ,int ,struct IUnknown * );
    HRESULT GetMetrics(struct DWRITE_INLINE_OBJECT_METRICS * );
    HRESULT GetOverhangMetrics(struct DWRITE_OVERHANG_METRICS * );
    HRESULT GetBreakConditions(enum DWRITE_BREAK_CONDITION * ,enum DWRITE_BREAK_CONDITION * );
    void IDWriteInlineObject(struct IDWriteInlineObject & );
    void IDWriteInlineObject();
    struct IDWriteInlineObject & operator=(struct IDWriteInlineObject & );
};

struct IDWriteInlineObject : public IUnknown
{
    HRESULT Draw(void * ,struct IDWriteTextRenderer * ,float ,float ,int ,int ,struct IUnknown * );
    HRESULT GetMetrics(struct DWRITE_INLINE_OBJECT_METRICS * );
    HRESULT GetOverhangMetrics(struct DWRITE_OVERHANG_METRICS * );
    HRESULT GetBreakConditions(enum DWRITE_BREAK_CONDITION * ,enum DWRITE_BREAK_CONDITION * );
    void IDWriteInlineObject(struct IDWriteInlineObject & );
    void IDWriteInlineObject();
    struct IDWriteInlineObject & operator=(struct IDWriteInlineObject & );
};

class SFileSystem
{
    private char * BasePath;
    private char AppDataPath[260];
    private class SDArray<SSearchPath> SearchPaths;
    public void SFileSystem(class SFileSystem & );
    public void SFileSystem();
    public void ~SFileSystem();
    public void SetGameDataPath(char * );
    public char * GetGameDataPath();
    public class SStream * OpenRead(char * ,char * );
    public class SStream * OpenWrite(char * ,char * );
    public class SStream * OpenAppend(char * ,char * );
    public bool IsFullPath(char * );
    public char * FindFileInSearchPath(char * );
    public void FindFiles(char * ,char * ,class SDArray<SString> & );
    public char * MakeFullPath(char * );
    public char * MakeAppDataPath(char * );
    public void ReadFile(char * ,char &** ,unsigned int & ,char * );
    public bool GenerateFileCRC(char * ,unsigned long & ,char * );
    public unsigned long GetCRC(unsigned int * ,int );
    public void AddSearchPath(char * );
    public void RemoveAllSearchPaths();
    public struct SArchiveInfo & OpenArchive(char * );
    public void MakePath(class SString );
    public int Stat(char * ,struct stat * );
    public class SFileSystem & operator=(class SFileSystem & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SStack<int>
{
    private int * array;
    private int size;
    private int maxsize;
    public float userdata;
    public void SStack<int>();
    public void ~SStack<int>();
    public void Push(int );
    public int & Pop();
    public int & GetFirst();
    public int & Peek();
    public void SetData(int * ,int ,int );
    public int GetSize();
    public bool IsEmpty();
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SStream
{
    private class SStack<int> Chunks;
    public void SStream(class SStream * );
    public void SStream(class SStream & );
    protected void SStream();
    protected bool NewTypeStrings;
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public unsigned int ReadByte();
    public unsigned int ReadWord();
    public int ReadInt();
    public float ReadFloat();
    public char * ReadString();
    public void WriteByte(unsigned int );
    public void WriteWord(unsigned int );
    public void WriteInt(int );
    public void WriteFloat(float );
    public void WriteString(char * );
    public int ReadChunkHeader();
    public void ReadChunkSkip();
    public void ReadChunkValidate();
    public bool ReadChunkIsEnd();
    public int ReadChunkRemain();
    public void WriteChunkStart(int );
    public void WriteChunkEnd();
    public void ReadSignature();
    public void WriteSignature();
    public void ~SStream();
    public class SStream & operator=(class SStream * );
    public class SStream & operator=(class SStream & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SLogger
{
    private const int LogBufferSize=512;
    private char * LogBufferContent[512];
    private int LogBufferUsed;
    private const int LogBufferLineMaxLength=522;
    private bool LogToFile;
    private bool Logging;
    private char * LogFileName;
    private struct HWND__ * hWnd;
    private int LogLevel;
    public void SLogger(char * ,char * ,bool ,int );
    public void ~SLogger();
    public void Attach(struct HWND__ * );
    public void SetLogLevel(int );
    public void Log(int ,char * ,<btNoType> );
    public void WirteBufferToLog();
    public void Warning(char * ,<btNoType> );
    public void Panic(char * ,<btNoType> );
    public void LogCallStack(int );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SString
{
    private char * buf;
    private int size;
    public void SString(class SStream * );
    public void SString(char );
    public void SString(char * ,int );
    public void SString(char * );
    public void SString(class SString & );
    public void SString();
    private void SString(char * ,int );
    public void ~SString();
    public void operator=(char * );
    public void operator=(class SString & );
    public class SString operator+(char * );
    public class SString operator+(class SString & );
    public void operator+=(char * );
    public void operator+=(class SString & );
    public int GetLength();
    public bool IsEmpty();
    public char * operator const char *();
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void Empty();
    public void Format(char * ,<btNoType> );
    public void Crop(int ,int );
    public const int IndexOf(char & );
    public void ReplaceChars(class SString & ,char & );
    public class SString Copy(int ,int );
    public class SString Dirname();
    public class SString Basename();
    public bool operator==(char * );
    public bool operator==(class SString & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SStreamBuffer : public SStream
{
    private unsigned long RefCount;
    private class SDArray<unsigned char *> Blocks;
    private int Size;
    private int Position;
    public void SStreamBuffer(class SStreamBuffer & );
    public void SStreamBuffer();
    public void ~SStreamBuffer();
    public void AddRef();
    public void Release();
    public void Reset();
    public unsigned long GenerateCRC();
    public int getSize();
    public int canRead(int );
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int getSeek();
    public int Seek(int ,int );
    public class SStreamBuffer & operator=(class SStreamBuffer & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<unsigned char *>
{
    private int size;
    private int maxsize;
    public unsigned int ** array;
    public void SDArray<unsigned char *>(class SDArray<unsigned char *> & );
    public void SDArray<unsigned char *>();
    public void ~SDArray<unsigned char *>();
    public int Add(unsigned int &** );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public unsigned int &** operator[](int );
    public void operator=(class SDArray<unsigned char *> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SFileStream : public SStream
{
    private unsigned long RefCount;
    private int FileDes;
    private const bool Readable;
    private const bool Writeable;
    public void SFileStream(class SFileStream & );
    public void SFileStream(int ,bool ,bool );
    public void ~SFileStream();
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SDArray<SSearchPath>
{
    private int size;
    private int maxsize;
    public struct SSearchPath * array;
    public void SDArray<SSearchPath>(class SDArray<SSearchPath> & );
    public void SDArray<SSearchPath>();
    public void ~SDArray<SSearchPath>();
    public int Add(struct SSearchPath & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public struct SSearchPath & operator[](int );
    public void operator=(class SDArray<SSearchPath> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SArchiveStream : public SStream
{
    private unsigned long RefCount;
    private int FileDes;
    private int Pos;
    private int Size;
    private int Offset;
    public void SArchiveStream(class SArchiveStream & );
    public void SArchiveStream(int ,int ,int );
    public void ~SArchiveStream();
    public void AddRef();
    public void Release();
    public void Read(void * ,int );
    public int ReadMax(void * ,int );
    public void Write(void * ,int );
    public int Seek(int ,int );
    public class SArchiveStream & operator=(class SArchiveStream & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class SProperties
{
    public void SProperties(char * ,bool ,bool );
    public void ~SProperties();
    public char * GetString(char * ,char * ,char * );
    public float GetFloat(char * ,char * ,float );
    public int GetInt(char * ,char * ,int );
    public void EnumPropertyClasses();
    public char * GetNextPropertyClass();
    public void EnumProperties(char * );
    public char * GetNextProperty();
    private struct SPropertyClass * chain;
    private struct SPropertyClass * pc_enum;
    private struct SProperty * p_enum;
    private void ParseFileData(char * ,char * ,bool );
    private struct SPropertyClass * LookupClass(char * );
    private struct SProperty * LookupVariable(struct SPropertyClass * ,char * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

struct SPropertyClass
{
    char * name;
    struct SProperty * chain;
    struct SPropertyClass * next;
};

struct SProperty
{
    char * name;
    char * value;
    struct SProperty * next;
};

enum OfflineFolderStatus
{
    OFS_INACTIVE=-1,
    OFS_ONLINE=0,
    OFS_OFFLINE=1,
    OFS_SERVERBACK=2,
    OFS_DIRTYCACHE=3
};

enum tagBANDSITECID
{
    BSID_BANDADDED=0,
    BSID_BANDREMOVED=1
};

enum tagMENUPOPUPSELECT
{
    MPOS_EXECUTE=0,
    MPOS_FULLCANCEL=1,
    MPOS_CANCELLEVEL=2,
    MPOS_SELECTLEFT=3,
    MPOS_SELECTRIGHT=4,
    MPOS_CHILDTRACKING=5
};

enum FILE_USAGE_TYPE
{
    FUT_PLAYING=0,
    FUT_EDITING=1,
    FUT_GENERIC=2
};

enum ASSOCIATIONLEVEL
{
    AL_MACHINE=0,
    AL_EFFECTIVE=1,
    AL_USER=2
};

enum ASSOCIATIONTYPE
{
    AT_FILEEXTENSION=0,
    AT_URLPROTOCOL=1,
    AT_STARTMENUCLIENT=2,
    AT_MIMETYPE=3
};

enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER=1,
    CLSCTX_INPROC_HANDLER=2,
    CLSCTX_LOCAL_SERVER=4,
    CLSCTX_INPROC_SERVER16=8,
    CLSCTX_REMOTE_SERVER=16,
    CLSCTX_INPROC_HANDLER16=32,
    CLSCTX_RESERVED1=64,
    CLSCTX_RESERVED2=128,
    CLSCTX_RESERVED3=256,
    CLSCTX_RESERVED4=512,
    CLSCTX_NO_CODE_DOWNLOAD=1024,
    CLSCTX_RESERVED5=2048,
    CLSCTX_NO_CUSTOM_MARSHAL=4096,
    CLSCTX_ENABLE_CODE_DOWNLOAD=8192,
    CLSCTX_NO_FAILURE_LOG=16384,
    CLSCTX_DISABLE_AAA=32768,
    CLSCTX_ENABLE_AAA=65536,
    CLSCTX_FROM_DEFAULT_CONTEXT=131072,
    CLSCTX_ACTIVATE_32_BIT_SERVER=262144,
    CLSCTX_ACTIVATE_64_BIT_SERVER=524288,
    CLSCTX_ENABLE_CLOAKING=1048576,
    CLSCTX_PS_DLL=-2147483648
};

enum FFFP_MODE
{
    FFFP_EXACTMATCH=0,
    FFFP_NEARESTPARENTMATCH=1
};

enum tagCONDITION_TYPE
{
    CT_AND_CONDITION=0,
    CT_OR_CONDITION=1,
    CT_NOT_CONDITION=2,
    CT_LEAF_CONDITION=3
};

enum tagCONDITION_OPERATION
{
    COP_IMPLICIT=0,
    COP_EQUAL=1,
    COP_NOTEQUAL=2,
    COP_LESSTHAN=3,
    COP_GREATERTHAN=4,
    COP_LESSTHANOREQUAL=5,
    COP_GREATERTHANOREQUAL=6,
    COP_VALUE_STARTSWITH=7,
    COP_VALUE_ENDSWITH=8,
    COP_VALUE_CONTAINS=9,
    COP_VALUE_NOTCONTAINS=10,
    COP_DOSWILDCARDS=11,
    COP_WORD_EQUAL=12,
    COP_WORD_STARTSWITH=13,
    COP_APPLICATION_SPECIFIC=14
};

enum PKA_FLAGS
{
    PKA_SET=0,
    PKA_APPEND=1,
    PKA_DELETE=2
};

enum MARKUPSIZE
{
    MARKUPSIZE_CALCWIDTH=0,
    MARKUPSIZE_CALCHEIGHT=1
};

enum MARKUPLINKTEXT
{
    MARKUPLINKTEXT_URL=0,
    MARKUPLINKTEXT_ID=1,
    MARKUPLINKTEXT_TEXT=2
};

enum MARKUPMESSAGE
{
    MARKUPMESSAGE_KEYEXECUTE=0,
    MARKUPMESSAGE_CLICKEXECUTE=1,
    MARKUPMESSAGE_WANTFOCUS=2
};

enum CPVIEW
{
    CPVIEW_CLASSIC=0,
    CPVIEW_ALLITEMS=0,
    CPVIEW_CATEGORY=1,
    CPVIEW_HOME=1
};

enum KNOWNDESTCATEGORY
{
    KDC_FREQUENT=1,
    KDC_RECENT=2
};

enum APPDOCLISTTYPE
{
    ADLT_RECENT=0,
    ADLT_FREQUENT=1
};

enum DEFAULTSAVEFOLDERTYPE
{
    DSFT_DETECT=1,
    DSFT_PRIVATE=2,
    DSFT_PUBLIC=3
};

enum _SIGDN
{
    SIGDN_NORMALDISPLAY=0,
    SIGDN_PARENTRELATIVEPARSING=-2147385343,
    SIGDN_DESKTOPABSOLUTEPARSING=-2147319808,
    SIGDN_PARENTRELATIVEEDITING=-2147282943,
    SIGDN_DESKTOPABSOLUTEEDITING=-2147172352,
    SIGDN_FILESYSPATH=-2147123200,
    SIGDN_URL=-2147057664,
    SIGDN_PARENTRELATIVEFORADDRESSBAR=-2146975743,
    SIGDN_PARENTRELATIVE=-2146959359
};

enum _SPACTION
{
    SPACTION_NONE=0,
    SPACTION_MOVING=1,
    SPACTION_COPYING=2,
    SPACTION_RECYCLING=3,
    SPACTION_APPLYINGATTRIBS=4,
    SPACTION_DOWNLOADING=5,
    SPACTION_SEARCHING_INTERNET=6,
    SPACTION_CALCULATING=7,
    SPACTION_UPLOADING=8,
    SPACTION_SEARCHING_FILES=9,
    SPACTION_DELETING=10,
    SPACTION_RENAMING=11,
    SPACTION_FORMATTING=12,
    SPACTION_COPY_MOVING=13
};

enum _SPTEXT
{
    SPTEXT_ACTIONDESCRIPTION=1,
    SPTEXT_ACTIONDETAIL=2
};

class std::exception_ptr
{
    public void exception_ptr(class std::exception_ptr & );
    public void exception_ptr(void * );
    public void exception_ptr();
    public void ~exception_ptr();
    public class std::exception_ptr & operator=(void * );
    public class std::exception_ptr & operator=(class std::exception_ptr & );
    public bool operator bool();
    public void _RethrowException();
    public class std::exception_ptr _Current_exception();
    public class std::exception_ptr _Copy_exception(void * ,void * );
    private void * _Data1;
    private void * _Data2;
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::nested_exception
{
    public void nested_exception(class std::nested_exception & );
    public void nested_exception();
    public class std::nested_exception & operator=(class std::nested_exception & );
    public void ~nested_exception();
    public void rethrow_nested();
    public class std::exception_ptr nested_ptr();
    private class std::exception_ptr _Exc;
    public void __autoclassinit2(unsigned int );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > : public std::_Iterator_base0
{
    public void _String_const_iterator<std::_String_val<std::_Simple_types<char> > >(char * ,struct std::_Container_base0 * );
    public void _String_const_iterator<std::_String_val<std::_Simple_types<char> > >();
    public char & operator*();
    public char * operator->();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator++(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator++();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator--(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator--();
    public void _Verify_offset(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator+=(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator+(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & operator-=(const int );
    public int operator-(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > operator-(const int );
    public char & operator[](const int );
    public bool operator==(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator!=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator<(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator>(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator<=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public bool operator>=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public void _Compat(class std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > > & );
    public char * _Unwrapped();
    public void _Seek_to(char * );
    public char * _Ptr;
    public void __autoclassinit2(unsigned int );
};

class std::initializer_list<char>
{
    public void initializer_list<char>(char * ,char * );
    public void initializer_list<char>();
    public char * begin();
    public char * end();
    public unsigned int size();
    private char * _First;
    private char * _Last;
    public void __autoclassinit2(unsigned int );
};

class std::locale : public std::_Locbase<int>, public std::_Crt_new_delete
{
    class id
    {
        public void id(class std::locale::id & );
        public void id(unsigned int );
        public unsigned int operator unsigned int();
        private unsigned int _Id;
        private int _Id_cnt;
        public class std::locale::id & operator=(class std::locale::id & );
        public void __dflt_ctor_closure();
    };
    class _Locimp : public std::locale::facet
    {
        protected void ~_Locimp();
        private class std::locale::_Locimp * _New_Locimp(class std::locale::_Locimp & );
        private class std::locale::_Locimp * _New_Locimp(bool );
        private void _Locimp_dtor(class std::locale::_Locimp * );
        private void _Locimp_Addfac(class std::locale::_Locimp * ,class std::locale::facet * ,unsigned int );
        private void _Locimp_ctor(class std::locale::_Locimp * ,class std::locale::_Locimp & );
        private void _Locimp(class std::locale::_Locimp & );
        private void _Locimp(bool );
        private void _Addfac(class std::locale::facet * ,unsigned int );
        private class std::locale::_Locimp * _Makeloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makewloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makeushloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private void _Makexloc(class std::_Locinfo & ,int ,class std::locale::_Locimp * ,class std::locale * );
        private class std::locale::facet ** _Facetvec;
        private unsigned int _Facetcount;
        private int _Catmask;
        private bool _Xparent;
        private class std::_Yarn<char> _Name;
        private class std::locale::_Locimp * _Clocptr;
        public class std::locale::_Locimp & operator=(class std::locale::_Locimp & );
        protected void * __vecDelDtor(unsigned int );
    };
    class facet : public std::_Facet_base, public std::_Crt_new_delete
    {
        public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
        public void _Incref();
        public class std::_Facet_base * _Decref();
        private unsigned long _Myrefs;
        public void facet(class std::locale::facet & );
        protected void facet(unsigned int );
        protected void ~facet();
        public class std::locale::facet & operator=(class std::locale::facet & );
        public void __dflt_ctor_closure();
        public void __local_vftable_ctor_closure();
        protected void * __vecDelDtor(unsigned int );
    };
    private void locale(class std::locale::_Locimp * );
    public void locale(class std::locale & ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void locale(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void locale(class std::locale & ,char * ,int );
    public void locale(char * ,int );
    public void locale(class std::locale & ,class std::locale & ,int );
    public void locale();
    public void locale(class std::locale & );
    public void locale(enum std::_Uninitialized );
    private void _Construct(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,int );
    public void ~locale();
    public class std::locale & operator=(class std::locale & );
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > name();
    public char * c_str();
    public class std::locale::facet * _Getfacet(unsigned int );
    public bool operator==(class std::locale & );
    public bool operator!=(class std::locale & );
    public class std::locale & classic();
    public class std::locale global(class std::locale & );
    public class std::locale empty();
    private class std::locale::_Locimp * _Init(bool );
    private class std::locale::_Locimp * _Getgloballocale();
    private void _Setgloballocale(void * );
    private bool _Badname(class std::_Locinfo & );
    private class std::locale::_Locimp * _Ptr;
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::error_condition
{
    public void error_condition(int ,class std::error_category & );
    public void error_condition();
    public void assign(int ,class std::error_category & );
    public void clear();
    public int value();
    public class std::error_category & category();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message();
    public bool operator bool();
    private int _Myval;
    private class std::error_category * _Mycat;
    public void __autoclassinit2(unsigned int );
};

class std::error_code
{
    public void error_code(int ,class std::error_category & );
    public void error_code();
    public void assign(int ,class std::error_category & );
    public void clear();
    public int value();
    public class std::error_category & category();
    public class std::error_condition default_error_condition();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > message();
    public bool operator bool();
    private int _Myval;
    private class std::error_category * _Mycat;
    public void __autoclassinit2(unsigned int );
};

class std::_System_error : public std::runtime_error
{
    private class std::basic_string<char,std::char_traits<char>,std::allocator<char> > _Makestr(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > );
    public void _System_error(class std::_System_error * );
    public void _System_error(class std::_System_error & );
    protected void _System_error(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    protected class std::error_code _Mycode;
    public void ~_System_error();
    public class std::_System_error & operator=(class std::_System_error * );
    public class std::_System_error & operator=(class std::_System_error & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::system_error : public std::_System_error
{
    public void system_error(class std::system_error * );
    public void system_error(class std::system_error & );
    public void system_error(int ,class std::error_category & ,char * );
    public void system_error(int ,class std::error_category & ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void system_error(int ,class std::error_category & );
    public void system_error(class std::error_code ,char * );
    public void system_error(class std::error_code ,class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & );
    public void system_error(class std::error_code );
    public class std::error_code & code();
    public void ~system_error();
    public class std::system_error & operator=(class std::system_error * );
    public class std::system_error & operator=(class std::system_error & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::ios_base::failure : public std::system_error
{
    public void failure(class std::ios_base::failure * );
    public void failure(class std::ios_base::failure & );
    public void failure(char * ,class std::error_code & );
    public void failure(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,class std::error_code & );
    public void ~failure();
    public class std::ios_base::failure & operator=(class std::ios_base::failure * );
    public class std::ios_base::failure & operator=(class std::ios_base::failure & );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > : public std::_Iterator_base0
{
    public void _String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >(wchar_t * ,struct std::_Container_base0 * );
    public void _String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > >();
    public wchar_t & operator*();
    public wchar_t * operator->();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator++(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator++();
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator--(int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator--();
    public void _Verify_offset(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator+=(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator+(const int );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & operator-=(const int );
    public int operator-(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > operator-(const int );
    public wchar_t & operator[](const int );
    public bool operator==(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator!=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator<(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator>(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator<=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public bool operator>=(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public void _Compat(class std::_String_const_iterator<std::_String_val<std::_Simple_types<wchar_t> > > & );
    public wchar_t * _Unwrapped();
    public void _Seek_to(wchar_t * );
    public wchar_t * _Ptr;
    public void __autoclassinit2(unsigned int );
};

class std::initializer_list<wchar_t>
{
    public void initializer_list<wchar_t>(wchar_t * ,wchar_t * );
    public void initializer_list<wchar_t>();
    public wchar_t * begin();
    public wchar_t * end();
    public unsigned int size();
    private wchar_t * _First;
    private wchar_t * _Last;
    public void __autoclassinit2(unsigned int );
};

class std::initializer_list<char16_t>
{
    public void initializer_list<char16_t>(char16_t * ,char16_t * );
    public void initializer_list<char16_t>();
    public char16_t * begin();
    public char16_t * end();
    public unsigned int size();
    private char16_t * _First;
    private char16_t * _Last;
    public void __autoclassinit2(unsigned int );
};

class std::initializer_list<char32_t>
{
    public void initializer_list<char32_t>(char32_t * ,char32_t * );
    public void initializer_list<char32_t>();
    public char32_t * begin();
    public char32_t * end();
    public unsigned int size();
    private char32_t * _First;
    private char32_t * _Last;
    public void __autoclassinit2(unsigned int );
};

struct _tagpropertykey
{
    struct _GUID fmtid;
    unsigned long pid;
};

struct tagBIND_OPTS
{
    unsigned long cbStruct;
    unsigned long grfFlags;
    unsigned long grfMode;
    unsigned long dwTickCountDeadline;
};

struct _IMAGELIST
{
};

struct _DSA
{
};

struct _DPA
{
};

struct _SHITEMID
{
    unsigned int cb;
    unsigned int abID[1];
};

struct _ITEMIDLIST
{
    struct _SHITEMID mkid;
};

struct _ITEMIDLIST
{
    struct _SHITEMID mkid;
};

enum __MIDL_INamespaceWalk_0001
{
    NSWF_DEFAULT=0,
    NSWF_NONE_IMPLIES_ALL=1,
    NSWF_ONE_IMPLIES_ALL=2,
    NSWF_DONT_TRAVERSE_LINKS=4,
    NSWF_DONT_ACCUMULATE_RESULT=8,
    NSWF_TRAVERSE_STREAM_JUNCTIONS=16,
    NSWF_FILESYSTEM_ONLY=32,
    NSWF_SHOW_PROGRESS=64,
    NSWF_FLAG_VIEWORDER=128,
    NSWF_IGNORE_AUTOPLAY_HIDA=256,
    NSWF_ASYNC=512,
    NSWF_DONT_RESOLVE_LINKS=1024,
    NSWF_ACCUMULATE_FOLDERS=2048,
    NSWF_DONT_SORT=4096,
    NSWF_USE_TRANSFER_MEDIUM=8192,
    NSWF_DONT_TRAVERSE_STREAM_JUNCTIONS=16384
};

enum KF_CATEGORY
{
    KF_CATEGORY_VIRTUAL=1,
    KF_CATEGORY_FIXED=2,
    KF_CATEGORY_COMMON=3,
    KF_CATEGORY_PERUSER=4
};

struct KNOWNFOLDER_DEFINITION
{
    enum KF_CATEGORY category;
    wchar_t * pszName;
    wchar_t * pszDescription;
    struct _GUID fidParent;
    wchar_t * pszRelativePath;
    wchar_t * pszParsingName;
    wchar_t * pszTooltip;
    wchar_t * pszLocalizedName;
    wchar_t * pszIcon;
    wchar_t * pszSecurity;
    unsigned long dwAttributes;
    unsigned long kfdFlags;
    struct _GUID ftidType;
};

enum LIBRARYFOLDERFILTER
{
    LFF_FORCEFILESYSTEM=1,
    LFF_STORAGEITEMS=2,
    LFF_ALLITEMS=3
};

enum LIBRARYOPTIONFLAGS
{
    LOF_DEFAULT=0,
    LOF_PINNEDTONAVPANE=1,
    LOF_MASK_ALL=1
};

enum LIBRARYSAVEFLAGS
{
    LSF_FAILIFTHERE=0,
    LSF_OVERRIDEEXISTING=1,
    LSF_MAKEUNIQUENAME=2
};

struct IShellLibrary : public IUnknown
{
    HRESULT LoadLibraryFromItem(struct IShellItem * ,unsigned long );
    HRESULT LoadLibraryFromKnownFolder(struct _GUID & ,unsigned long );
    HRESULT AddFolder(struct IShellItem * );
    HRESULT RemoveFolder(struct IShellItem * );
    HRESULT GetFolders(enum LIBRARYFOLDERFILTER ,struct _GUID & ,void ** );
    HRESULT ResolveFolder(struct IShellItem * ,unsigned long ,struct _GUID & ,void ** );
    HRESULT GetDefaultSaveFolder(enum DEFAULTSAVEFOLDERTYPE ,struct _GUID & ,void ** );
    HRESULT SetDefaultSaveFolder(enum DEFAULTSAVEFOLDERTYPE ,struct IShellItem * );
    HRESULT GetOptions(enum LIBRARYOPTIONFLAGS * );
    HRESULT SetOptions(enum LIBRARYOPTIONFLAGS ,enum LIBRARYOPTIONFLAGS );
    HRESULT GetFolderType(struct _GUID * );
    HRESULT SetFolderType(struct _GUID & );
    HRESULT GetIcon(wchar_t ** );
    HRESULT SetIcon(wchar_t * );
    HRESULT Commit();
    HRESULT Save(struct IShellItem * ,wchar_t * ,enum LIBRARYSAVEFLAGS ,struct IShellItem ** );
    HRESULT SaveInKnownFolder(struct _GUID & ,wchar_t * ,enum LIBRARYSAVEFLAGS ,struct IShellItem ** );
    void IShellLibrary(struct IShellLibrary * );
    void IShellLibrary(struct IShellLibrary & );
    void IShellLibrary();
    struct IShellLibrary & operator=(struct IShellLibrary * );
    struct IShellLibrary & operator=(struct IShellLibrary & );
};

struct IShellLibrary : public IUnknown
{
    HRESULT LoadLibraryFromItem(struct IShellItem * ,unsigned long );
    HRESULT LoadLibraryFromKnownFolder(struct _GUID & ,unsigned long );
    HRESULT AddFolder(struct IShellItem * );
    HRESULT RemoveFolder(struct IShellItem * );
    HRESULT GetFolders(enum LIBRARYFOLDERFILTER ,struct _GUID & ,void ** );
    HRESULT ResolveFolder(struct IShellItem * ,unsigned long ,struct _GUID & ,void ** );
    HRESULT GetDefaultSaveFolder(enum DEFAULTSAVEFOLDERTYPE ,struct _GUID & ,void ** );
    HRESULT SetDefaultSaveFolder(enum DEFAULTSAVEFOLDERTYPE ,struct IShellItem * );
    HRESULT GetOptions(enum LIBRARYOPTIONFLAGS * );
    HRESULT SetOptions(enum LIBRARYOPTIONFLAGS ,enum LIBRARYOPTIONFLAGS );
    HRESULT GetFolderType(struct _GUID * );
    HRESULT SetFolderType(struct _GUID & );
    HRESULT GetIcon(wchar_t ** );
    HRESULT SetIcon(wchar_t * );
    HRESULT Commit();
    HRESULT Save(struct IShellItem * ,wchar_t * ,enum LIBRARYSAVEFLAGS ,struct IShellItem ** );
    HRESULT SaveInKnownFolder(struct _GUID & ,wchar_t * ,enum LIBRARYSAVEFLAGS ,struct IShellItem ** );
    void IShellLibrary(struct IShellLibrary * );
    void IShellLibrary(struct IShellLibrary & );
    void IShellLibrary();
    struct IShellLibrary & operator=(struct IShellLibrary * );
    struct IShellLibrary & operator=(struct IShellLibrary & );
};

struct IShellItem : public IUnknown
{
    HRESULT BindToHandler(struct IBindCtx * ,struct _GUID & ,struct _GUID & ,void ** );
    HRESULT GetParent(struct IShellItem ** );
    HRESULT GetDisplayName(enum _SIGDN ,wchar_t ** );
    HRESULT GetAttributes(unsigned long ,unsigned long * );
    HRESULT Compare(struct IShellItem * ,unsigned long ,int * );
    void IShellItem(struct IShellItem * );
    void IShellItem(struct IShellItem & );
    void IShellItem();
    struct IShellItem & operator=(struct IShellItem * );
    struct IShellItem & operator=(struct IShellItem & );
};

struct IShellItem : public IUnknown
{
    HRESULT BindToHandler(struct IBindCtx * ,struct _GUID & ,struct _GUID & ,void ** );
    HRESULT GetParent(struct IShellItem ** );
    HRESULT GetDisplayName(enum _SIGDN ,wchar_t ** );
    HRESULT GetAttributes(unsigned long ,unsigned long * );
    HRESULT Compare(struct IShellItem * ,unsigned long ,int * );
    void IShellItem(struct IShellItem * );
    void IShellItem(struct IShellItem & );
    void IShellItem();
    struct IShellItem & operator=(struct IShellItem * );
    struct IShellItem & operator=(struct IShellItem & );
};

struct IBindCtx : public IUnknown
{
    HRESULT RegisterObjectBound(struct IUnknown * );
    HRESULT RevokeObjectBound(struct IUnknown * );
    HRESULT ReleaseBoundObjects();
    HRESULT SetBindOptions(struct tagBIND_OPTS * );
    HRESULT GetBindOptions(struct tagBIND_OPTS * );
    HRESULT GetRunningObjectTable(struct IRunningObjectTable ** );
    HRESULT RegisterObjectParam(wchar_t * ,struct IUnknown * );
    HRESULT GetObjectParam(wchar_t * ,struct IUnknown ** );
    HRESULT EnumObjectParam(struct IEnumString ** );
    HRESULT RevokeObjectParam(wchar_t * );
    void IBindCtx(struct IBindCtx * );
    void IBindCtx(struct IBindCtx & );
    void IBindCtx();
    struct IBindCtx & operator=(struct IBindCtx * );
    struct IBindCtx & operator=(struct IBindCtx & );
};

struct IBindCtx : public IUnknown
{
    HRESULT RegisterObjectBound(struct IUnknown * );
    HRESULT RevokeObjectBound(struct IUnknown * );
    HRESULT ReleaseBoundObjects();
    HRESULT SetBindOptions(struct tagBIND_OPTS * );
    HRESULT GetBindOptions(struct tagBIND_OPTS * );
    HRESULT GetRunningObjectTable(struct IRunningObjectTable ** );
    HRESULT RegisterObjectParam(wchar_t * ,struct IUnknown * );
    HRESULT GetObjectParam(wchar_t * ,struct IUnknown ** );
    HRESULT EnumObjectParam(struct IEnumString ** );
    HRESULT RevokeObjectParam(wchar_t * );
    void IBindCtx(struct IBindCtx * );
    void IBindCtx(struct IBindCtx & );
    void IBindCtx();
    struct IBindCtx & operator=(struct IBindCtx * );
    struct IBindCtx & operator=(struct IBindCtx & );
};

struct IPersistStream : public IPersist
{
    HRESULT IsDirty();
    HRESULT Load(struct IStream * );
    HRESULT Save(struct IStream * ,int );
    HRESULT GetSizeMax(union _ULARGE_INTEGER * );
    void IPersistStream(struct IPersistStream * );
    void IPersistStream(struct IPersistStream & );
    void IPersistStream();
    struct IPersistStream & operator=(struct IPersistStream * );
    struct IPersistStream & operator=(struct IPersistStream & );
};

struct IPersistStream : public IPersist
{
    HRESULT IsDirty();
    HRESULT Load(struct IStream * );
    HRESULT Save(struct IStream * ,int );
    HRESULT GetSizeMax(union _ULARGE_INTEGER * );
    void IPersistStream(struct IPersistStream * );
    void IPersistStream(struct IPersistStream & );
    void IPersistStream();
    struct IPersistStream & operator=(struct IPersistStream * );
    struct IPersistStream & operator=(struct IPersistStream & );
};

struct IPersist : public IUnknown
{
    HRESULT GetClassID(struct _GUID * );
    void IPersist(struct IPersist * );
    void IPersist(struct IPersist & );
    void IPersist();
    struct IPersist & operator=(struct IPersist * );
    struct IPersist & operator=(struct IPersist & );
};

struct IPersist : public IUnknown
{
    HRESULT GetClassID(struct _GUID * );
    void IPersist(struct IPersist * );
    void IPersist(struct IPersist & );
    void IPersist();
    struct IPersist & operator=(struct IPersist * );
    struct IPersist & operator=(struct IPersist & );
};

struct IMoniker : public IPersistStream
{
    HRESULT BindToObject(struct IBindCtx * ,struct IMoniker * ,struct _GUID & ,void ** );
    HRESULT BindToStorage(struct IBindCtx * ,struct IMoniker * ,struct _GUID & ,void ** );
    HRESULT Reduce(struct IBindCtx * ,unsigned long ,struct IMoniker ** ,struct IMoniker ** );
    HRESULT ComposeWith(struct IMoniker * ,int ,struct IMoniker ** );
    HRESULT Enum(int ,struct IEnumMoniker ** );
    HRESULT IsEqual(struct IMoniker * );
    HRESULT Hash(unsigned long * );
    HRESULT IsRunning(struct IBindCtx * ,struct IMoniker * ,struct IMoniker * );
    HRESULT GetTimeOfLastChange(struct IBindCtx * ,struct IMoniker * ,struct _FILETIME * );
    HRESULT Inverse(struct IMoniker ** );
    HRESULT CommonPrefixWith(struct IMoniker * ,struct IMoniker ** );
    HRESULT RelativePathTo(struct IMoniker * ,struct IMoniker ** );
    HRESULT GetDisplayName(struct IBindCtx * ,struct IMoniker * ,wchar_t ** );
    HRESULT ParseDisplayName(struct IBindCtx * ,struct IMoniker * ,wchar_t * ,unsigned long * ,struct IMoniker ** );
    HRESULT IsSystemMoniker(unsigned long * );
    void IMoniker(struct IMoniker * );
    void IMoniker(struct IMoniker & );
    void IMoniker();
    struct IMoniker & operator=(struct IMoniker * );
    struct IMoniker & operator=(struct IMoniker & );
};

struct IMoniker : public IPersistStream
{
    HRESULT BindToObject(struct IBindCtx * ,struct IMoniker * ,struct _GUID & ,void ** );
    HRESULT BindToStorage(struct IBindCtx * ,struct IMoniker * ,struct _GUID & ,void ** );
    HRESULT Reduce(struct IBindCtx * ,unsigned long ,struct IMoniker ** ,struct IMoniker ** );
    HRESULT ComposeWith(struct IMoniker * ,int ,struct IMoniker ** );
    HRESULT Enum(int ,struct IEnumMoniker ** );
    HRESULT IsEqual(struct IMoniker * );
    HRESULT Hash(unsigned long * );
    HRESULT IsRunning(struct IBindCtx * ,struct IMoniker * ,struct IMoniker * );
    HRESULT GetTimeOfLastChange(struct IBindCtx * ,struct IMoniker * ,struct _FILETIME * );
    HRESULT Inverse(struct IMoniker ** );
    HRESULT CommonPrefixWith(struct IMoniker * ,struct IMoniker ** );
    HRESULT RelativePathTo(struct IMoniker * ,struct IMoniker ** );
    HRESULT GetDisplayName(struct IBindCtx * ,struct IMoniker * ,wchar_t ** );
    HRESULT ParseDisplayName(struct IBindCtx * ,struct IMoniker * ,wchar_t * ,unsigned long * ,struct IMoniker ** );
    HRESULT IsSystemMoniker(unsigned long * );
    void IMoniker(struct IMoniker * );
    void IMoniker(struct IMoniker & );
    void IMoniker();
    struct IMoniker & operator=(struct IMoniker * );
    struct IMoniker & operator=(struct IMoniker & );
};

struct IEnumMoniker : public IUnknown
{
    HRESULT Next(unsigned long ,struct IMoniker ** ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumMoniker ** );
    void IEnumMoniker(struct IEnumMoniker * );
    void IEnumMoniker(struct IEnumMoniker & );
    void IEnumMoniker();
    struct IEnumMoniker & operator=(struct IEnumMoniker * );
    struct IEnumMoniker & operator=(struct IEnumMoniker & );
};

struct IEnumMoniker : public IUnknown
{
    HRESULT Next(unsigned long ,struct IMoniker ** ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumMoniker ** );
    void IEnumMoniker(struct IEnumMoniker * );
    void IEnumMoniker(struct IEnumMoniker & );
    void IEnumMoniker();
    struct IEnumMoniker & operator=(struct IEnumMoniker * );
    struct IEnumMoniker & operator=(struct IEnumMoniker & );
};

struct IRunningObjectTable : public IUnknown
{
    HRESULT Register(unsigned long ,struct IUnknown * ,struct IMoniker * ,unsigned long * );
    HRESULT Revoke(unsigned long );
    HRESULT IsRunning(struct IMoniker * );
    HRESULT GetObjectA(struct IMoniker * ,struct IUnknown ** );
    HRESULT NoteChangeTime(unsigned long ,struct _FILETIME * );
    HRESULT GetTimeOfLastChange(struct IMoniker * ,struct _FILETIME * );
    HRESULT EnumRunning(struct IEnumMoniker ** );
    void IRunningObjectTable(struct IRunningObjectTable * );
    void IRunningObjectTable(struct IRunningObjectTable & );
    void IRunningObjectTable();
    struct IRunningObjectTable & operator=(struct IRunningObjectTable * );
    struct IRunningObjectTable & operator=(struct IRunningObjectTable & );
};

struct IRunningObjectTable : public IUnknown
{
    HRESULT Register(unsigned long ,struct IUnknown * ,struct IMoniker * ,unsigned long * );
    HRESULT Revoke(unsigned long );
    HRESULT IsRunning(struct IMoniker * );
    HRESULT GetObjectA(struct IMoniker * ,struct IUnknown ** );
    HRESULT NoteChangeTime(unsigned long ,struct _FILETIME * );
    HRESULT GetTimeOfLastChange(struct IMoniker * ,struct _FILETIME * );
    HRESULT EnumRunning(struct IEnumMoniker ** );
    void IRunningObjectTable(struct IRunningObjectTable * );
    void IRunningObjectTable(struct IRunningObjectTable & );
    void IRunningObjectTable();
    struct IRunningObjectTable & operator=(struct IRunningObjectTable * );
    struct IRunningObjectTable & operator=(struct IRunningObjectTable & );
};

struct IEnumString : public IUnknown
{
    HRESULT Next(unsigned long ,wchar_t ** ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumString ** );
    void IEnumString(struct IEnumString * );
    void IEnumString(struct IEnumString & );
    void IEnumString();
    struct IEnumString & operator=(struct IEnumString * );
    struct IEnumString & operator=(struct IEnumString & );
};

struct IEnumString : public IUnknown
{
    HRESULT Next(unsigned long ,wchar_t ** ,unsigned long * );
    HRESULT Skip(unsigned long );
    HRESULT Reset();
    HRESULT Clone(struct IEnumString ** );
    void IEnumString(struct IEnumString * );
    void IEnumString(struct IEnumString & );
    void IEnumString();
    struct IEnumString & operator=(struct IEnumString * );
    struct IEnumString & operator=(struct IEnumString & );
};

enum SHELL_LINK_DATA_FLAGS
{
    SLDF_DEFAULT=0,
    SLDF_HAS_ID_LIST=1,
    SLDF_HAS_LINK_INFO=2,
    SLDF_HAS_NAME=4,
    SLDF_HAS_RELPATH=8,
    SLDF_HAS_WORKINGDIR=16,
    SLDF_HAS_ARGS=32,
    SLDF_HAS_ICONLOCATION=64,
    SLDF_UNICODE=128,
    SLDF_FORCE_NO_LINKINFO=256,
    SLDF_HAS_EXP_SZ=512,
    SLDF_RUN_IN_SEPARATE=1024,
    SLDF_HAS_DARWINID=4096,
    SLDF_RUNAS_USER=8192,
    SLDF_HAS_EXP_ICON_SZ=16384,
    SLDF_NO_PIDL_ALIAS=32768,
    SLDF_FORCE_UNCNAME=65536,
    SLDF_RUN_WITH_SHIMLAYER=131072,
    SLDF_FORCE_NO_LINKTRACK=262144,
    SLDF_ENABLE_TARGET_METADATA=524288,
    SLDF_DISABLE_LINK_PATH_TRACKING=1048576,
    SLDF_DISABLE_KNOWNFOLDER_RELATIVE_TRACKING=2097152,
    SLDF_NO_KF_ALIAS=4194304,
    SLDF_ALLOW_LINK_TO_LINK=8388608,
    SLDF_UNALIAS_ON_SAVE=16777216,
    SLDF_PREFER_ENVIRONMENT_PATH=33554432,
    SLDF_KEEP_LOCAL_IDLIST_FOR_UNC_TARGET=67108864,
    SLDF_VALID=134215679,
    SLDF_RESERVED=-2147483648
};

enum KNOWN_FOLDER_FLAG
{
    KF_FLAG_DEFAULT=0,
    KF_FLAG_CREATE=32768,
    KF_FLAG_DONT_VERIFY=16384,
    KF_FLAG_DONT_UNEXPAND=8192,
    KF_FLAG_NO_ALIAS=4096,
    KF_FLAG_INIT=2048,
    KF_FLAG_DEFAULT_PATH=1024,
    KF_FLAG_NOT_PARENT_RELATIVE=512,
    KF_FLAG_SIMPLE_IDLIST=256,
    KF_FLAG_ALIAS_ONLY=-2147483648
};

class SDArray<SString>
{
    private int size;
    private int maxsize;
    public class SString * array;
    public void SDArray<SString>(class SDArray<SString> & );
    public void SDArray<SString>();
    public void ~SDArray<SString>();
    public int Add(class SString & );
    public int Add();
    public void Insert(int );
    public void Remove(int );
    public void RemoveRange(int );
    public void Clear(int );
    public int GetSize();
    public void QSort(int ,int  ( * )(void * ,void * ));
    public class SString & operator[](int );
    public void operator=(class SDArray<SString> & );
    public void Save(class SStream * );
    public void Load(class SStream * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
{
    public void ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_ostream<wchar_t,std::char_traits<wchar_t> > & );
    public void ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator*();
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++(int );
    public class std::ostreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++();
    public bool failed();
    private bool _Failed;
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    public void __autoclassinit2(unsigned int );
};

class std::numpunct<wchar_t> : public std::locale::facet
{
    public class std::locale::id id;
    public wchar_t decimal_point();
    public wchar_t thousands_sep();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > grouping();
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > falsename();
    public class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > truename();
    protected void numpunct<wchar_t>(char * ,unsigned int ,bool );
    public void numpunct<wchar_t>(class std::_Locinfo & ,unsigned int ,bool );
    public void numpunct<wchar_t>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~numpunct<wchar_t>();
    protected void _Getvals(wchar_t ,struct lconv * ,struct _Cvtvec );
    protected void _Init(class std::_Locinfo & ,bool );
    protected wchar_t do_decimal_point();
    protected wchar_t do_thousands_sep();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_grouping();
    protected class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > do_falsename();
    protected class std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> > do_truename();
    private void _Tidy();
    private char * _Grouping;
    private wchar_t _Dp;
    private wchar_t _Kseparator;
    private wchar_t * _Falsename;
    private wchar_t * _Truename;
    public void __autoclassinit2(unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >
{
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy & );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_istream<wchar_t,std::char_traits<wchar_t> > & );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * );
    public void istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >();
    class _Istreambuf_proxy
    {
        public wchar_t operator*();
        private void _Istreambuf_proxy(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,wchar_t );
        private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
        private wchar_t _Keep;
    };
    public wchar_t operator*();
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy operator++(int );
    public class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & operator++();
    public bool equal(class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> > & );
    private void _Inc();
    private wchar_t _Peek();
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    private bool _Got;
    private wchar_t _Val;
    public void __autoclassinit2(unsigned int );
};

class std::istreambuf_iterator<wchar_t,std::char_traits<wchar_t> >::_Istreambuf_proxy
{
    public wchar_t operator*();
    private void _Istreambuf_proxy(class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * ,wchar_t );
    private class std::basic_streambuf<wchar_t,std::char_traits<wchar_t> > * _Strbuf;
    private wchar_t _Keep;
    public void __autoclassinit2(unsigned int );
};

class std::ostreambuf_iterator<char,std::char_traits<char> >
{
    public void ostreambuf_iterator<char,std::char_traits<char> >(class std::basic_ostream<char,std::char_traits<char> > & );
    public void ostreambuf_iterator<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator*();
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator++(int );
    public class std::ostreambuf_iterator<char,std::char_traits<char> > & operator++();
    public bool failed();
    private bool _Failed;
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    public void __autoclassinit2(unsigned int );
};

class std::numpunct<char> : public std::locale::facet
{
    public class std::locale::id id;
    public char decimal_point();
    public char thousands_sep();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > grouping();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > falsename();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> > truename();
    protected void numpunct<char>(char * ,unsigned int ,bool );
    public void numpunct<char>(class std::_Locinfo & ,unsigned int ,bool );
    public void numpunct<char>(unsigned int );
    public unsigned int _Getcat(class std::locale::facet ** ,class std::locale * );
    protected void ~numpunct<char>();
    protected void _Getvals(wchar_t ,struct lconv * ,struct _Cvtvec );
    protected void _Init(class std::_Locinfo & ,bool );
    protected char do_decimal_point();
    protected char do_thousands_sep();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_grouping();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_falsename();
    protected class std::basic_string<char,std::char_traits<char>,std::allocator<char> > do_truename();
    private void _Tidy();
    private char * _Grouping;
    private char _Dp;
    private char _Kseparator;
    private char * _Falsename;
    private char * _Truename;
    public void __autoclassinit2(unsigned int );
    public void __dflt_ctor_closure();
    public void __local_vftable_ctor_closure();
    protected void * __vecDelDtor(unsigned int );
};

class std::istreambuf_iterator<char,std::char_traits<char> >
{
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy & );
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::basic_istream<char,std::char_traits<char> > & );
    public void istreambuf_iterator<char,std::char_traits<char> >(class std::basic_streambuf<char,std::char_traits<char> > * );
    public void istreambuf_iterator<char,std::char_traits<char> >();
    class _Istreambuf_proxy
    {
        public char operator*();
        private void _Istreambuf_proxy(class std::basic_streambuf<char,std::char_traits<char> > * ,char );
        private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
        private char _Keep;
    };
    public char operator*();
    public class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy operator++(int );
    public class std::istreambuf_iterator<char,std::char_traits<char> > & operator++();
    public bool equal(class std::istreambuf_iterator<char,std::char_traits<char> > & );
    private void _Inc();
    private char _Peek();
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    private bool _Got;
    private char _Val;
    public void __autoclassinit2(unsigned int );
};

class std::istreambuf_iterator<char,std::char_traits<char> >::_Istreambuf_proxy
{
    public char operator*();
    private void _Istreambuf_proxy(class std::basic_streambuf<char,std::char_traits<char> > * ,char );
    private class std::basic_streambuf<char,std::char_traits<char> > * _Strbuf;
    private char _Keep;
    public void __autoclassinit2(unsigned int );
};

class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > : public std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >
{
    public void unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public void unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > * );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > * );
    public class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & operator=(void * );
    public void swap(class std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> > & );
    public void ~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >();
    public class std::_Facet_base & operator*();
    public class std::_Facet_base * operator->();
    public class std::_Facet_base * get();
    public bool operator bool();
    public class std::_Facet_base * release();
    public void reset(class std::_Facet_base * );
    public void __autoclassinit2(unsigned int );
    public void * __vecDelDtor(unsigned int );
};

class std::_Unique_ptr_base<std::_Facet_base,std::default_delete<std::_Facet_base> >
{
    public struct std::default_delete<std::_Facet_base> & get_deleter();
    public struct std::default_delete<std::_Facet_base> & get_deleter();
    public class std::_Facet_base &** _Myptr();
    public class std::_Facet_base &** _Myptr();
    public class std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1> _Mypair;
    public void __autoclassinit2(unsigned int );
};

class std::_Compressed_pair<std::default_delete<std::_Facet_base>,std::_Facet_base *,1> : private std::default_delete<std::_Facet_base>
{
    private class std::_Facet_base * _Myval2;
    public struct std::default_delete<std::_Facet_base> & _Get_first();
    public struct std::default_delete<std::_Facet_base> & _Get_first();
    public class std::_Facet_base &** _Get_second();
    public class std::_Facet_base &** _Get_second();
    public void __autoclassinit2(unsigned int );
};

enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS
{
    JOB_OBJECT_NET_RATE_CONTROL_ENABLE=1,
    JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH=2,
    JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG=4,
    JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS=7
};

enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS
{
    JOB_OBJECT_IO_RATE_CONTROL_ENABLE=1,
    JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME=2,
    JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS=3
};

enum _USER_ACTIVITY_PRESENCE
{
    PowerUserPresent=0,
    PowerUserNotPresent=1,
    PowerUserInactive=2,
    PowerUserMaximum=3,
    PowerUserInvalid=3
};

enum ReplacesCorHdrNumericDefines
{
    COMIMAGE_FLAGS_ILONLY=1,
    COMIMAGE_FLAGS_32BITREQUIRED=2,
    COMIMAGE_FLAGS_IL_LIBRARY=4,
    COMIMAGE_FLAGS_STRONGNAMESIGNED=8,
    COMIMAGE_FLAGS_NATIVE_ENTRYPOINT=16,
    COMIMAGE_FLAGS_TRACKDEBUGDATA=65536,
    COMIMAGE_FLAGS_32BITPREFERRED=131072,
    COR_VERSION_MAJOR_V2=2,
    COR_VERSION_MAJOR=2,
    COR_VERSION_MINOR=5,
    COR_DELETED_NAME_LENGTH=8,
    COR_VTABLEGAP_NAME_LENGTH=8,
    NATIVE_TYPE_MAX_CB=1,
    COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE=255,
    IMAGE_COR_MIH_METHODRVA=1,
    IMAGE_COR_MIH_EHRVA=2,
    IMAGE_COR_MIH_BASICBLOCK=8,
    COR_VTABLE_32BIT=1,
    COR_VTABLE_64BIT=2,
    COR_VTABLE_FROM_UNMANAGED=4,
    COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN=8,
    COR_VTABLE_CALL_MOST_DERIVED=16,
    IMAGE_COR_EATJ_THUNK_SIZE=32,
    MAX_CLASS_NAME=1024,
    MAX_PACKAGE_NAME=1024
};

enum _TP_CALLBACK_PRIORITY
{
    TP_CALLBACK_PRIORITY_HIGH=0,
    TP_CALLBACK_PRIORITY_NORMAL=1,
    TP_CALLBACK_PRIORITY_LOW=2,
    TP_CALLBACK_PRIORITY_INVALID=3,
    TP_CALLBACK_PRIORITY_COUNT=3
};

enum <unnamed-enum-DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED>
{
    DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED=0,
    DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE=1,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED=2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST=2,
    DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST=3,
    DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32=-1
};

struct _anonymous_4561
{
    unsigned long LongFunction:1;
    unsigned long Persistent:1;
    unsigned long Private:30;
};

union _anonymous_4562
{
    unsigned long Flags;
    struct _anonymous_4561 s;
};

struct _TP_CALLBACK_ENVIRON_V3
{
    unsigned long Version;
    struct _TP_POOL * Pool;
    struct _TP_CLEANUP_GROUP * CleanupGroup;
    void  ( * CleanupGroupCancelCallback)(void * ,void * );
    void * RaceDll;
    struct _ACTIVATION_CONTEXT * ActivationContext;
    void  ( * FinalizationCallback)(struct _TP_CALLBACK_INSTANCE * ,void * );
    union _anonymous_4562 u;
    enum _TP_CALLBACK_PRIORITY CallbackPriority;
    unsigned long Size;
};

struct _EVENT_DATA_DESCRIPTOR
{
    unsigned int Ptr;
    unsigned long Size;
    unsigned long Reserved;
    unsigned int Type;
    unsigned int Reserved1;
    unsigned int Reserved2;
};

struct _EVENT_DESCRIPTOR
{
    unsigned int Id;
    unsigned int Version;
    unsigned int Channel;
    unsigned int Level;
    unsigned int Opcode;
    unsigned int Task;
    unsigned int Keyword;
};

struct _FLOATING_SAVE_AREA
{
    unsigned long ControlWord;
    unsigned long StatusWord;
    unsigned long TagWord;
    unsigned long ErrorOffset;
    unsigned long ErrorSelector;
    unsigned long DataOffset;
    unsigned long DataSelector;
    unsigned int RegisterArea[80];
    unsigned long Spare0;
};

struct _EVENT_DESCRIPTOR
{
    unsigned int Id;
    unsigned int Version;
    unsigned int Channel;
    unsigned int Level;
    unsigned int Opcode;
    unsigned int Task;
    unsigned int Keyword;
};

struct _anonymous_4568
{
    unsigned long LowPart;
    long HighPart;
};

union _LARGE_INTEGER
{
    unsigned long LowPart;
    long HighPart;
    struct _anonymous_4568 u;
    int QuadPart;
};

union FT
{
    unsigned int ft_scalar;
    struct _FILETIME ft_struct;
};

struct _RS2_IMAGE_LOAD_CONFIG_DIRECTORY32
{
    unsigned long Size;
    unsigned long TimeDateStamp;
    unsigned int MajorVersion;
    unsigned int MinorVersion;
    unsigned long GlobalFlagsClear;
    unsigned long GlobalFlagsSet;
    unsigned long CriticalSectionDefaultTimeout;
    unsigned long DeCommitFreeBlockThreshold;
    unsigned long DeCommitTotalFreeThreshold;
    unsigned long LockPrefixTable;
    unsigned long MaximumAllocationSize;
    unsigned long VirtualMemoryThreshold;
    unsigned long ProcessHeapFlags;
    unsigned long ProcessAffinityMask;
    unsigned int CSDVersion;
    unsigned int DependentLoadFlags;
    unsigned long EditList;
    unsigned long SecurityCookie;
    unsigned long SEHandlerTable;
    unsigned long SEHandlerCount;
    unsigned long GuardCFCheckFunctionPointer;
    unsigned long GuardCFDispatchFunctionPointer;
    unsigned long GuardCFFunctionTable;
    unsigned long GuardCFFunctionCount;
    unsigned long GuardFlags;
    struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
    unsigned long GuardAddressTakenIatEntryTable;
    unsigned long GuardAddressTakenIatEntryCount;
    unsigned long GuardLongJumpTargetTable;
    unsigned long GuardLongJumpTargetCount;
    unsigned long DynamicValueRelocTable;
    unsigned long CHPEMetadataPointer;
    unsigned long GuardRFFailureRoutine;
    unsigned long GuardRFFailureRoutineFunctionPointer;
    unsigned long DynamicValueRelocTableOffset;
    unsigned int DynamicValueRelocTableSection;
    unsigned int Reserved2;
    unsigned long GuardRFVerifyStackPointerFunctionPointer;
    unsigned long HotPatchTableOffset;
    unsigned long Reserved3;
    unsigned long EnclaveConfigurationPointer;
};

struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY
{
    unsigned int Flags;
    unsigned int Catalog;
    unsigned long CatalogOffset;
    unsigned long Reserved;
};

enum ISA_AVAILABILITY
{
    __ISA_AVAILABLE_X86=0,
    __ISA_AVAILABLE_SSE2=1,
    __ISA_AVAILABLE_SSE42=2,
    __ISA_AVAILABLE_AVX=3,
    __ISA_AVAILABLE_ENFSTRG=4,
    __ISA_AVAILABLE_AVX2=5,
    __ISA_AVAILABLE_ARMNT=0,
    __ISA_AVAILABLE_NEON=1,
    __ISA_AVAILABLE_NEON_ARM64=2
};

struct _EXCEPTION_REGISTRATION_RECORD
{
    struct _EXCEPTION_REGISTRATION_RECORD * Next;
    enum _EXCEPTION_DISPOSITION  ( * Handler)(struct _EXCEPTION_RECORD * ,void * ,struct _CONTEXT * ,void * );
};

enum _crt_argv_mode
{
    _crt_argv_no_arguments=0,
    _crt_argv_unexpanded_arguments=1,
    _crt_argv_expanded_arguments=2
};

enum tagAR_STATE
{
    AR_ENABLED=0,
    AR_DISABLED=1,
    AR_SUPPRESSED=2,
    AR_REMOTESESSION=4,
    AR_MULTIMON=8,
    AR_NOSENSOR=16,
    AR_NOT_SUPPORTED=32,
    AR_DOCKED=64,
    AR_LAPTOP=128
};

struct __scrt_no_argv_policy
{
    int configure_argv();
};

struct __scrt_no_environment_policy
{
    int initialize_environment();
};

struct __scrt_wide_argv_policy
{
    int configure_argv();
};

struct _TP_CALLBACK_ENVIRON_V3
{
    unsigned long Version;
    struct _TP_POOL * Pool;
    struct _TP_CLEANUP_GROUP * CleanupGroup;
    void  ( * CleanupGroupCancelCallback)(void * ,void * );
    void * RaceDll;
    struct _ACTIVATION_CONTEXT * ActivationContext;
    void  ( * FinalizationCallback)(struct _TP_CALLBACK_INSTANCE * ,void * );
    union _TP_CALLBACK_ENVIRON_V3::<unnamed-type-u> u;
    enum _TP_CALLBACK_PRIORITY CallbackPriority;
    unsigned long Size;
};

struct __scrt_narrow_argv_policy
{
    int configure_argv();
};

struct __scrt_narrow_environment_policy
{
    int initialize_environment();
};

struct __crt_fast_encoded_nullptr_t
{
};

struct __scrt_wide_environment_policy
{
    int initialize_environment();
};

struct PMD
{
    int mdisp;
    int pdisp;
    int vdisp;
};

struct TypeDescriptor
{
    unsigned long hash;
    void * spare;
    char name[0];
};

struct _s_CatchableType
{
    unsigned int properties;
    struct TypeDescriptor * pType;
    struct PMD thisDisplacement;
    int sizeOrOffset;
    void  ( * copyFunction)(void * );
};

struct _s_CatchableType
{
    unsigned int properties;
    struct TypeDescriptor * pType;
    struct PMD thisDisplacement;
    int sizeOrOffset;
    void  ( * copyFunction)(void * );
};

struct _s_CatchableTypeArray
{
    int nCatchableTypes;
    struct _s_CatchableType * arrayOfCatchableTypes[0];
};

struct _s_CatchableTypeArray
{
    int nCatchableTypes;
    struct _s_CatchableType * arrayOfCatchableTypes[0];
};

struct _s_ThrowInfo
{
    unsigned int attributes;
    void  ( * pmfnUnwind)(void * );
    int  ( * pForwardCompat)(<btNoType> );
    struct _s_CatchableTypeArray * pCatchableTypeArray;
};

struct EHExceptionRecord
{
    unsigned long ExceptionCode;
    unsigned long ExceptionFlags;
    struct _EXCEPTION_RECORD * ExceptionRecord;
    void * ExceptionAddress;
    unsigned long NumberParameters;
    struct EHParameters
    {
        unsigned long magicNumber;
        void * pExceptionObject;
        struct _s_ThrowInfo * pThrowInfo;
    };
    struct EHExceptionRecord::EHParameters params;
};

struct _s_ThrowInfo
{
    unsigned int attributes;
    void  ( * pmfnUnwind)(void * );
    int  ( * pForwardCompat)(<btNoType> );
    struct _s_CatchableTypeArray * pCatchableTypeArray;
};

struct EHExceptionRecord::EHParameters
{
    unsigned long magicNumber;
    void * pExceptionObject;
    struct _s_ThrowInfo * pThrowInfo;
};

class std::bad_cast : public std::exception
{
    public void bad_cast(class std::bad_cast * );
    public void bad_cast(class std::bad_cast & );
    private void bad_cast(const char * ,int );
    public void bad_cast();
    public class std::bad_cast __construct_from_string_literal(const char * );
    public void ~bad_cast();
    public class std::bad_cast & operator=(class std::bad_cast * );
    public class std::bad_cast & operator=(class std::bad_cast & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::__non_rtti_object : public std::bad_typeid
{
    public class std::__non_rtti_object __construct_from_string_literal(const char * );
    public void __non_rtti_object(class std::__non_rtti_object * );
    public void __non_rtti_object(class std::__non_rtti_object & );
    private void __non_rtti_object(const char * ,int );
    public void ~__non_rtti_object();
    public class std::__non_rtti_object & operator=(class std::__non_rtti_object * );
    public class std::__non_rtti_object & operator=(class std::__non_rtti_object & );
    public void * __vecDelDtor(unsigned int );
};

class std::bad_exception : public std::exception
{
    public void bad_exception(class std::bad_exception * );
    public void bad_exception(class std::bad_exception & );
    public void bad_exception();
    public void ~bad_exception();
    public class std::bad_exception & operator=(class std::bad_exception * );
    public class std::bad_exception & operator=(class std::bad_exception & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::exception
{
    public void exception(class std::exception & );
    public void exception(const char * ,int );
    public void exception(const char * );
    public void exception();
    public class std::exception & operator=(class std::exception & );
    public void ~exception();
    public char * what();
    private struct __std_exception_data _Data;
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_alloc : public std::exception
{
    public void bad_alloc(class std::bad_alloc * );
    public void bad_alloc(class std::bad_alloc & );
    private void bad_alloc(const char * );
    public void bad_alloc();
    public void ~bad_alloc();
    public class std::bad_alloc & operator=(class std::bad_alloc * );
    public class std::bad_alloc & operator=(class std::bad_alloc & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_array_new_length : public std::bad_alloc
{
    public void bad_array_new_length(class std::bad_array_new_length * );
    public void bad_array_new_length(class std::bad_array_new_length & );
    public void bad_array_new_length();
    public void ~bad_array_new_length();
    public class std::bad_array_new_length & operator=(class std::bad_array_new_length * );
    public class std::bad_array_new_length & operator=(class std::bad_array_new_length & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class std::bad_typeid : public std::exception
{
    public void bad_typeid(class std::bad_typeid * );
    public void bad_typeid(class std::bad_typeid & );
    private void bad_typeid(const char * ,int );
    public void bad_typeid();
    public class std::bad_typeid __construct_from_string_literal(const char * );
    public void ~bad_typeid();
    public class std::bad_typeid & operator=(class std::bad_typeid * );
    public class std::bad_typeid & operator=(class std::bad_typeid & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class type_info
{
    public void type_info(class type_info & );
    public class type_info & operator=(class type_info & );
    public unsigned int hash_code();
    public bool operator==(class type_info & );
    public bool operator!=(class type_info & );
    public bool before(class type_info & );
    public char * name();
    public char * raw_name();
    public void ~type_info();
    private struct __std_type_info_data _Data;
    public void * __vecDelDtor(unsigned int );
};

struct __type_info_node
{
    union _SLIST_HEADER _Header;
};

union _SLIST_HEADER
{
    unsigned int Alignment;
    struct _SINGLE_LIST_ENTRY Next;
    unsigned int Depth;
    unsigned int CpuId;
};

struct $_s__CatchableTypeArray$_extraBytes_12
{
    int nCatchableTypes;
    struct _s__CatchableType * arrayOfCatchableTypes[3];
};

struct $_s__CatchableTypeArray$_extraBytes_8
{
    int nCatchableTypes;
    struct _s__CatchableType * arrayOfCatchableTypes[2];
};

struct __std_exception_data
{
    char * _What;
    bool _DoFree;
};

enum wrapEncodedKERNEL32Functions
{
    eFlsAlloc=0,
    eFlsFree=1,
    eFlsGetValue=2,
    eFlsSetValue=3,
    eInitializeCriticalSectionEx=4,
    eInitOnceExecuteOnce=5,
    eCreateEventExW=6,
    eCreateSemaphoreW=7,
    eCreateSemaphoreExW=8,
    eCreateThreadpoolTimer=9,
    eSetThreadpoolTimer=10,
    eWaitForThreadpoolTimerCallbacks=11,
    eCloseThreadpoolTimer=12,
    eCreateThreadpoolWait=13,
    eSetThreadpoolWait=14,
    eCloseThreadpoolWait=15,
    eFlushProcessWriteBuffers=16,
    eFreeLibraryWhenCallbackReturns=17,
    eGetCurrentProcessorNumber=18,
    eCreateSymbolicLinkW=19,
    eGetCurrentPackageId=20,
    eGetTickCount64=21,
    eGetFileInformationByHandleEx=22,
    eSetFileInformationByHandle=23,
    eGetSystemTimePreciseAsFileTime=24,
    eInitializeConditionVariable=25,
    eWakeConditionVariable=26,
    eWakeAllConditionVariable=27,
    eSleepConditionVariableCS=28,
    eInitializeSRWLock=29,
    eAcquireSRWLockExclusive=30,
    eTryAcquireSRWLockExclusive=31,
    eReleaseSRWLockExclusive=32,
    eSleepConditionVariableSRW=33,
    eCreateThreadpoolWork=34,
    eSubmitThreadpoolWork=35,
    eCloseThreadpoolWork=36,
    eCompareStringEx=37,
    eGetLocaleInfoEx=38,
    eLCMapStringEx=39,
    eMaxKernel32Function=40
};

enum <unnamed-enum-__crt_maximum_pointer_shift>
{
    __crt_maximum_pointer_shift=32
};

enum __scrt_module_type
{
    dll=0,
    exe=1
};

enum __scrt_native_startup_state
{
    uninitialized=0,
    initializing=1,
    initialized=2
};

enum _crt_app_type
{
    _crt_unknown_app=0,
    _crt_console_app=1,
    _crt_gui_app=2
};

struct __scrt_winmain_policy
{
    void set_app_type();
};

struct __scrt_nofile_policy
{
    void set_fmode();
    void set_commode();
};

struct __scrt_file_policy
{
    void set_fmode();
    void set_commode();
};

struct __scrt_main_policy
{
    void set_app_type();
};

struct __scrt_enclavemain_policy
{
    void set_app_type();
};

struct _IMAGE_TLS_DIRECTORY32
{
    unsigned long StartAddressOfRawData;
    unsigned long EndAddressOfRawData;
    unsigned long AddressOfIndex;
    unsigned long AddressOfCallBacks;
    unsigned long SizeOfZeroFill;
    unsigned long Characteristics;
    unsigned long Reserved0:20;
    unsigned long Alignment:4;
    unsigned long Reserved1:8;
};

struct _onexit_table_t
{
    void  ( ** _first)();
    void  ( ** _last)();
    void  ( ** _end)();
};

struct _IMAGE_SECTION_HEADER
{
    unsigned int Name[8];
    union _IMAGE_SECTION_HEADER::<unnamed-type-Misc> Misc;
    unsigned long VirtualAddress;
    unsigned long SizeOfRawData;
    unsigned long PointerToRawData;
    unsigned long PointerToRelocations;
    unsigned long PointerToLinenumbers;
    unsigned int NumberOfRelocations;
    unsigned int NumberOfLinenumbers;
    unsigned long Characteristics;
};

struct _TEB
{
};

enum _RTC_ErrorNumber
{
    _RTC_CHKSTK=0,
    _RTC_CVRT_LOSS_INFO=1,
    _RTC_CORRUPT_STACK=2,
    _RTC_UNINIT_LOCAL_USE=3,
    _RTC_CORRUPTED_ALLOCA=4,
    _RTC_ILLEGAL=5
};

class RakNet::CCRakNetSlidingWindow
{
    public void CCRakNetSlidingWindow(class RakNet::CCRakNetSlidingWindow & );
    public void CCRakNetSlidingWindow();
    public void ~CCRakNetSlidingWindow();
    public void Init(unsigned int ,unsigned int );
    public void Update(unsigned int ,bool );
    public int GetRetransmissionBandwidth(unsigned int ,unsigned int ,unsigned int ,bool );
    public int GetTransmissionBandwidth(unsigned int ,unsigned int ,unsigned int ,bool );
    public bool ShouldSendACKs(unsigned int ,unsigned int );
    public struct RakNet::uint24_t GetAndIncrementNextDatagramSequenceNumber();
    public struct RakNet::uint24_t GetNextDatagramSequenceNumber();
    public void OnSendBytes(unsigned int ,unsigned int );
    public void OnGotPacketPair(struct RakNet::uint24_t ,unsigned int ,unsigned int );
    public bool OnGotPacket(struct RakNet::uint24_t ,bool ,unsigned int ,unsigned int ,unsigned int * );
    public void OnResend(unsigned int ,unsigned int );
    public void OnNAK(unsigned int ,struct RakNet::uint24_t );
    public void OnAck(unsigned int ,unsigned int ,bool ,float ,float ,float ,bool ,struct RakNet::uint24_t );
    public void OnDuplicateAck(unsigned int ,struct RakNet::uint24_t );
    public void OnSendAckGetBAndAS(unsigned int ,bool * ,float * ,float * );
    public void OnSendAck(unsigned int ,unsigned int );
    public void OnSendNACK(unsigned int ,unsigned int );
    public unsigned int GetRTOForRetransmission(unsigned int );
    public void SetMTU(unsigned int );
    public unsigned int GetMTU();
    public float GetLocalSendRate();
    public float GetLocalReceiveRate(unsigned int );
    public float GetRemoveReceiveRate();
    public float GetEstimatedBandwidth();
    public float GetLinkCapacityBytesPerSecond();
    public float GetRTT();
    public bool GetIsInSlowStart();
    public unsigned int GetCWNDLimit();
    public bool GreaterThan(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    public bool LessThan(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    public unsigned int GetBytesPerSecondLimitByCongestionControl();
    protected unsigned int MAXIMUM_MTU_INCLUDING_UDP_HEADER;
    protected float cwnd;
    protected float ssThresh;
    protected unsigned int oldestUnsentAck;
    protected unsigned int GetSenderRTOForACK();
    protected struct RakNet::uint24_t nextDatagramSequenceNumber;
    protected struct RakNet::uint24_t nextCongestionControlBlock;
    protected bool backoffThisBlock;
    protected bool speedUpThisBlock;
    protected struct RakNet::uint24_t expectedNextSequenceNumber;
    protected bool _isContinuousSend;
    protected bool IsInSlowStart();
    protected float lastRtt;
    protected float estimatedRTT;
    protected float deviationRtt;
    public class RakNet::CCRakNetSlidingWindow & operator=(class RakNet::CCRakNetSlidingWindow & );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::CCRakNetSlidingWindow
{
    public void CCRakNetSlidingWindow(class RakNet::CCRakNetSlidingWindow & );
    public void CCRakNetSlidingWindow();
    public void ~CCRakNetSlidingWindow();
    public void Init(unsigned int ,unsigned int );
    public void Update(unsigned int ,bool );
    public int GetRetransmissionBandwidth(unsigned int ,unsigned int ,unsigned int ,bool );
    public int GetTransmissionBandwidth(unsigned int ,unsigned int ,unsigned int ,bool );
    public bool ShouldSendACKs(unsigned int ,unsigned int );
    public struct RakNet::uint24_t GetAndIncrementNextDatagramSequenceNumber();
    public struct RakNet::uint24_t GetNextDatagramSequenceNumber();
    public void OnSendBytes(unsigned int ,unsigned int );
    public void OnGotPacketPair(struct RakNet::uint24_t ,unsigned int ,unsigned int );
    public bool OnGotPacket(struct RakNet::uint24_t ,bool ,unsigned int ,unsigned int ,unsigned int * );
    public void OnResend(unsigned int ,unsigned int );
    public void OnNAK(unsigned int ,struct RakNet::uint24_t );
    public void OnAck(unsigned int ,unsigned int ,bool ,float ,float ,float ,bool ,struct RakNet::uint24_t );
    public void OnDuplicateAck(unsigned int ,struct RakNet::uint24_t );
    public void OnSendAckGetBAndAS(unsigned int ,bool * ,float * ,float * );
    public void OnSendAck(unsigned int ,unsigned int );
    public void OnSendNACK(unsigned int ,unsigned int );
    public unsigned int GetRTOForRetransmission(unsigned int );
    public void SetMTU(unsigned int );
    public unsigned int GetMTU();
    public float GetLocalSendRate();
    public float GetLocalReceiveRate(unsigned int );
    public float GetRemoveReceiveRate();
    public float GetEstimatedBandwidth();
    public float GetLinkCapacityBytesPerSecond();
    public float GetRTT();
    public bool GetIsInSlowStart();
    public unsigned int GetCWNDLimit();
    public bool GreaterThan(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    public bool LessThan(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    public unsigned int GetBytesPerSecondLimitByCongestionControl();
    protected unsigned int MAXIMUM_MTU_INCLUDING_UDP_HEADER;
    protected float cwnd;
    protected float ssThresh;
    protected unsigned int oldestUnsentAck;
    protected unsigned int GetSenderRTOForACK();
    protected struct RakNet::uint24_t nextDatagramSequenceNumber;
    protected struct RakNet::uint24_t nextCongestionControlBlock;
    protected bool backoffThisBlock;
    protected bool speedUpThisBlock;
    protected struct RakNet::uint24_t expectedNextSequenceNumber;
    protected bool _isContinuousSend;
    protected bool IsInSlowStart();
    protected float lastRtt;
    protected float estimatedRTT;
    protected float deviationRtt;
    public class RakNet::CCRakNetSlidingWindow & operator=(class RakNet::CCRakNetSlidingWindow & );
    public void * __vecDelDtor(unsigned int );
};

enum CSHA1::REPORT_TYPE
{
    REPORT_HEX=0,
    REPORT_DIGIT=1,
    REPORT_HEX_SHORT=2
};

class CSHA1
{
    enum REPORT_TYPE
    {
        REPORT_HEX=0,
        REPORT_DIGIT=1,
        REPORT_HEX_SHORT=2
    };
    public void CSHA1();
    public void ~CSHA1();
    public void Reset();
    public void Update(unsigned int * ,unsigned int );
    public bool HashFile(char * );
    public void Final();
    public bool ReportHash(char * ,enum CSHA1::REPORT_TYPE );
    public bool ReportHashStl(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,enum CSHA1::REPORT_TYPE );
    public unsigned int * GetHash();
    public bool GetHash(unsigned int * );
    public void HMAC(unsigned int * ,int ,unsigned int * ,int ,unsigned int * );
    private void Transform(unsigned int * ,unsigned int * );
    private unsigned int m_state[5];
    private unsigned int m_count[2];
    private unsigned int m_reserved0[1];
    private unsigned int m_buffer[64];
    private unsigned int m_digest[20];
    private unsigned int m_reserved1[3];
    private unsigned int m_workspace[64];
    private union SHA1_WORKSPACE_BLOCK * m_block;
    public void * __vecDelDtor(unsigned int );
};

class CSHA1
{
    enum REPORT_TYPE
    {
        REPORT_HEX=0,
        REPORT_DIGIT=1,
        REPORT_HEX_SHORT=2
    };
    public void CSHA1();
    public void ~CSHA1();
    public void Reset();
    public void Update(unsigned int * ,unsigned int );
    public bool HashFile(char * );
    public void Final();
    public bool ReportHash(char * ,enum CSHA1::REPORT_TYPE );
    public bool ReportHashStl(class std::basic_string<char,std::char_traits<char>,std::allocator<char> > & ,enum CSHA1::REPORT_TYPE );
    public unsigned int * GetHash();
    public bool GetHash(unsigned int * );
    public void HMAC(unsigned int * ,int ,unsigned int * ,int ,unsigned int * );
    private void Transform(unsigned int * ,unsigned int * );
    private unsigned int m_state[5];
    private unsigned int m_count[2];
    private unsigned int m_reserved0[1];
    private unsigned int m_buffer[64];
    private unsigned int m_digest[20];
    private unsigned int m_reserved1[3];
    private unsigned int m_workspace[64];
    private union SHA1_WORKSPACE_BLOCK * m_block;
    public void * __vecDelDtor(unsigned int );
};

union SHA1_WORKSPACE_BLOCK
{
    unsigned int c[64];
    unsigned int l[16];
};

class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de>
{
    public void operator()(const char * ,const unsigned int ,const char * );
    private void <lambda_invoker_cdecl>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__cdecl *)(char *const ,const unsigned int,const char *const )();
    private void <lambda_invoker_stdcall>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__stdcall *)(char *const ,const unsigned int,const char *const )();
    private void <lambda_invoker_fastcall>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__fastcall *)(char *const ,const unsigned int,const char *const )();
    private void <lambda_invoker_vectorcall>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__vectorcall *)(char *const ,const unsigned int,const char *const )();
    public void <lambda_9366063389c5f42a00a5088cf24e69de>(class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de> * );
    public void <lambda_9366063389c5f42a00a5088cf24e69de>();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de> & operator=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de> & );
};

class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de>
{
    public void operator()(const char * ,const unsigned int ,const char * );
    private void <lambda_invoker_cdecl>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__cdecl *)(char *const ,const unsigned int,const char *const )();
    private void <lambda_invoker_stdcall>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__stdcall *)(char *const ,const unsigned int,const char *const )();
    private void <lambda_invoker_fastcall>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__fastcall *)(char *const ,const unsigned int,const char *const )();
    private void <lambda_invoker_vectorcall>(const char * ,const unsigned int ,const char * );
    public void  ( * )(const char * ,const unsigned int ,const char * ) operator void (__vectorcall *)(char *const ,const unsigned int,const char *const )();
    public void <lambda_9366063389c5f42a00a5088cf24e69de>(class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de> * );
    public void <lambda_9366063389c5f42a00a5088cf24e69de>();
    public class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de> & operator=(class std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign::__l2::<lambda_9366063389c5f42a00a5088cf24e69de> & );
};

class DataStructures::ByteQueue
{
    public void ByteQueue();
    public void ~ByteQueue();
    public void WriteBytes(char * ,unsigned int ,char * ,unsigned int );
    public bool ReadBytes(char * ,unsigned int ,bool );
    public unsigned int GetBytesWritten();
    public char * PeekContiguousBytes(unsigned int * );
    public void IncrementReadOffset(unsigned int );
    public void DecrementReadOffset(unsigned int );
    public void Clear(char * ,unsigned int );
    public void Print();
    protected char * data;
    protected unsigned int readOffset;
    protected unsigned int writeOffset;
    protected unsigned int lengthAllocated;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ByteQueue
{
    public void ByteQueue();
    public void ~ByteQueue();
    public void WriteBytes(char * ,unsigned int ,char * ,unsigned int );
    public bool ReadBytes(char * ,unsigned int ,bool );
    public unsigned int GetBytesWritten();
    public char * PeekContiguousBytes(unsigned int * );
    public void IncrementReadOffset(unsigned int );
    public void DecrementReadOffset(unsigned int );
    public void Clear(char * ,unsigned int );
    public void Print();
    protected char * data;
    protected unsigned int readOffset;
    protected unsigned int writeOffset;
    protected unsigned int lengthAllocated;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::HuffmanEncodingTree
{
    public void HuffmanEncodingTree();
    public void ~HuffmanEncodingTree();
    public void EncodeArray(unsigned int * ,unsigned int ,class RakNet::BitStream * );
    public void DecodeArray(unsigned int * ,unsigned int ,class RakNet::BitStream * );
    public unsigned int DecodeArray(class RakNet::BitStream * ,unsigned int ,unsigned int ,unsigned int * );
    public void GenerateFromFrequencyTable(unsigned int * );
    public void FreeMemory();
    private struct HuffmanEncodingTreeNode * root;
    struct CharacterEncoding
    {
        unsigned int * encoding;
        unsigned int bitLength;
    };
    private struct RakNet::HuffmanEncodingTree::CharacterEncoding encodingTable[256];
    private void InsertNodeIntoSortedList(struct HuffmanEncodingTreeNode * ,class DataStructures::LinkedList<HuffmanEncodingTreeNode *> * );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::HuffmanEncodingTree
{
    public void HuffmanEncodingTree();
    public void ~HuffmanEncodingTree();
    public void EncodeArray(unsigned int * ,unsigned int ,class RakNet::BitStream * );
    public void DecodeArray(unsigned int * ,unsigned int ,class RakNet::BitStream * );
    public unsigned int DecodeArray(class RakNet::BitStream * ,unsigned int ,unsigned int ,unsigned int * );
    public void GenerateFromFrequencyTable(unsigned int * );
    public void FreeMemory();
    private struct HuffmanEncodingTreeNode * root;
    struct CharacterEncoding
    {
        unsigned int * encoding;
        unsigned int bitLength;
    };
    private struct RakNet::HuffmanEncodingTree::CharacterEncoding encodingTable[256];
    private void InsertNodeIntoSortedList(struct HuffmanEncodingTreeNode * ,class DataStructures::LinkedList<HuffmanEncodingTreeNode *> * );
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::HuffmanEncodingTree::CharacterEncoding
{
    unsigned int * encoding;
    unsigned int bitLength;
};

class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>
{
    struct node
    {
        struct HuffmanEncodingTreeNode * item;
        struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * previous;
        struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * next;
    };
    public void CircularLinkedList<HuffmanEncodingTreeNode *>(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    public void CircularLinkedList<HuffmanEncodingTreeNode *>();
    public void ~CircularLinkedList<HuffmanEncodingTreeNode *>();
    public bool operator=(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator++(int );
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator++();
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator--(int );
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator--();
    public bool IsIn(struct HuffmanEncodingTreeNode &** );
    public bool Find(struct HuffmanEncodingTreeNode &** );
    public void Insert(struct HuffmanEncodingTreeNode &** );
    public struct HuffmanEncodingTreeNode &** Add(struct HuffmanEncodingTreeNode &** );
    public void Replace(struct HuffmanEncodingTreeNode &** );
    public void Del();
    public unsigned int Size();
    public struct HuffmanEncodingTreeNode &** Peek();
    public struct HuffmanEncodingTreeNode * Pop();
    public void Clear();
    public void Sort();
    public void Beginning();
    public void End();
    public void Concatenate(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    protected unsigned int list_size;
    protected struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * root;
    protected struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * position;
    protected struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * FindPointer(struct HuffmanEncodingTreeNode &** );
    private class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> Merge(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> ,class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> );
    private class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> Mergesort(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>
{
    struct node
    {
        struct HuffmanEncodingTreeNode * item;
        struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * previous;
        struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * next;
    };
    public void CircularLinkedList<HuffmanEncodingTreeNode *>(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    public void CircularLinkedList<HuffmanEncodingTreeNode *>();
    public void ~CircularLinkedList<HuffmanEncodingTreeNode *>();
    public bool operator=(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator++(int );
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator++();
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator--(int );
    public class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & operator--();
    public bool IsIn(struct HuffmanEncodingTreeNode &** );
    public bool Find(struct HuffmanEncodingTreeNode &** );
    public void Insert(struct HuffmanEncodingTreeNode &** );
    public struct HuffmanEncodingTreeNode &** Add(struct HuffmanEncodingTreeNode &** );
    public void Replace(struct HuffmanEncodingTreeNode &** );
    public void Del();
    public unsigned int Size();
    public struct HuffmanEncodingTreeNode &** Peek();
    public struct HuffmanEncodingTreeNode * Pop();
    public void Clear();
    public void Sort();
    public void Beginning();
    public void End();
    public void Concatenate(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    protected unsigned int list_size;
    protected struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * root;
    protected struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * position;
    protected struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * FindPointer(struct HuffmanEncodingTreeNode &** );
    private class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> Merge(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> ,class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> );
    private class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> Mergesort(class DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *> & );
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node
{
    struct HuffmanEncodingTreeNode * item;
    struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * previous;
    struct DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>::node * next;
};

class DataStructures::LinkedList<HuffmanEncodingTreeNode *> : public DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>
{
    public void LinkedList<HuffmanEncodingTreeNode *>(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & );
    public void LinkedList<HuffmanEncodingTreeNode *>();
    public void ~LinkedList<HuffmanEncodingTreeNode *>();
    public bool operator=(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & );
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator++(int );
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator++();
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator--(int );
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator--();
    private class DataStructures::LinkedList<HuffmanEncodingTreeNode *> Merge(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> ,class DataStructures::LinkedList<HuffmanEncodingTreeNode *> );
    private class DataStructures::LinkedList<HuffmanEncodingTreeNode *> Mergesort(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::LinkedList<HuffmanEncodingTreeNode *> : public DataStructures::CircularLinkedList<HuffmanEncodingTreeNode *>
{
    public void LinkedList<HuffmanEncodingTreeNode *>(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & );
    public void LinkedList<HuffmanEncodingTreeNode *>();
    public void ~LinkedList<HuffmanEncodingTreeNode *>();
    public bool operator=(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & );
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator++(int );
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator++();
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator--(int );
    public class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & operator--();
    private class DataStructures::LinkedList<HuffmanEncodingTreeNode *> Merge(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> ,class DataStructures::LinkedList<HuffmanEncodingTreeNode *> );
    private class DataStructures::LinkedList<HuffmanEncodingTreeNode *> Mergesort(class DataStructures::LinkedList<HuffmanEncodingTreeNode *> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<HuffmanEncodingTreeNode *>
{
    public void Queue<HuffmanEncodingTreeNode *>(class DataStructures::Queue<HuffmanEncodingTreeNode *> & );
    public void Queue<HuffmanEncodingTreeNode *>();
    public void ~Queue<HuffmanEncodingTreeNode *>();
    public bool operator=(class DataStructures::Queue<HuffmanEncodingTreeNode *> & );
    public void Push(struct HuffmanEncodingTreeNode &** ,char * ,unsigned int );
    public void PushAtHead(struct HuffmanEncodingTreeNode &** ,unsigned int ,char * ,unsigned int );
    public struct HuffmanEncodingTreeNode &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct HuffmanEncodingTreeNode * Peek();
    public struct HuffmanEncodingTreeNode * PeekTail();
    public struct HuffmanEncodingTreeNode * Pop();
    public struct HuffmanEncodingTreeNode * PopTail();
    public struct HuffmanEncodingTreeNode * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct HuffmanEncodingTreeNode &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct HuffmanEncodingTreeNode ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<HuffmanEncodingTreeNode *>
{
    public void Queue<HuffmanEncodingTreeNode *>(class DataStructures::Queue<HuffmanEncodingTreeNode *> & );
    public void Queue<HuffmanEncodingTreeNode *>();
    public void ~Queue<HuffmanEncodingTreeNode *>();
    public bool operator=(class DataStructures::Queue<HuffmanEncodingTreeNode *> & );
    public void Push(struct HuffmanEncodingTreeNode &** ,char * ,unsigned int );
    public void PushAtHead(struct HuffmanEncodingTreeNode &** ,unsigned int ,char * ,unsigned int );
    public struct HuffmanEncodingTreeNode &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct HuffmanEncodingTreeNode * Peek();
    public struct HuffmanEncodingTreeNode * PeekTail();
    public struct HuffmanEncodingTreeNode * Pop();
    public struct HuffmanEncodingTreeNode * PopTail();
    public struct HuffmanEncodingTreeNode * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct HuffmanEncodingTreeNode &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct HuffmanEncodingTreeNode ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct HuffmanEncodingTreeNode
{
    unsigned int value;
    unsigned int weight;
    struct HuffmanEncodingTreeNode * left;
    struct HuffmanEncodingTreeNode * right;
    struct HuffmanEncodingTreeNode * parent;
};

class RakNet::StringCompressor
{
    public void ~StringCompressor();
    public class RakNet::StringCompressor * Instance();
    public void GenerateTreeFromStrings(unsigned int * ,unsigned int ,unsigned int );
    public void EncodeString(class RakNet::RakString * ,int ,class RakNet::BitStream * ,unsigned int );
    public void EncodeString(char * ,int ,class RakNet::BitStream * ,unsigned int );
    public bool DecodeString(class RakNet::RakString * ,int ,class RakNet::BitStream * ,unsigned int );
    public bool DecodeString(char * ,int ,class RakNet::BitStream * ,unsigned int );
    public void AddReference();
    public void RemoveReference();
    public void StringCompressor(class RakNet::StringCompressor & );
    public void StringCompressor();
    private class RakNet::StringCompressor * instance;
    private class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > huffmanEncodingTrees;
    private int referenceCount;
    public class RakNet::StringCompressor & operator=(class RakNet::StringCompressor & );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::StringCompressor
{
    public void ~StringCompressor();
    public class RakNet::StringCompressor * Instance();
    public void GenerateTreeFromStrings(unsigned int * ,unsigned int ,unsigned int );
    public void EncodeString(class RakNet::RakString * ,int ,class RakNet::BitStream * ,unsigned int );
    public void EncodeString(char * ,int ,class RakNet::BitStream * ,unsigned int );
    public bool DecodeString(class RakNet::RakString * ,int ,class RakNet::BitStream * ,unsigned int );
    public bool DecodeString(char * ,int ,class RakNet::BitStream * ,unsigned int );
    public void AddReference();
    public void RemoveReference();
    public void StringCompressor(class RakNet::StringCompressor & );
    public void StringCompressor();
    private class RakNet::StringCompressor * instance;
    private class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > huffmanEncodingTrees;
    private int referenceCount;
    public class RakNet::StringCompressor & operator=(class RakNet::StringCompressor & );
    public void * __vecDelDtor(unsigned int );
};

struct _finddata64i32_t
{
    unsigned int attrib;
    int time_create;
    int time_access;
    int time_write;
    unsigned long size;
    char name[260];
};

class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>
{
    public void List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>(class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> & );
    public void List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>();
    public void ~List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> & );
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    public void Replace(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,const struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode
{
    void MapNode(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    void MapNode(int ,class RakNet::HuffmanEncodingTree * );
    void MapNode();
    struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator=(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    int mapNodeKey;
    class RakNet::HuffmanEncodingTree * mapNodeData;
};

class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>
{
    public void List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>(class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> & );
    public void List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>();
    public void ~List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> & );
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    public void Replace(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,const struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
        void MapNode(int ,class RakNet::HuffmanEncodingTree * );
        void MapNode();
        struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator=(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
        int mapNodeKey;
        class RakNet::HuffmanEncodingTree * mapNodeData;
    };
    public int NodeComparisonFunc(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    public void Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >(class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > & );
    public void Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >();
    public void ~Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >();
    public class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > & operator=(class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > & );
    public class RakNet::HuffmanEncodingTree &** Get(int & );
    public class RakNet::HuffmanEncodingTree * Pop(int & );
    public void Set(int & ,class RakNet::HuffmanEncodingTree &** );
    public void SetExisting(int & ,class RakNet::HuffmanEncodingTree &** );
    public void SetNew(int & ,class RakNet::HuffmanEncodingTree &** );
    public bool Has(int & );
    public bool Delete(int & );
    public class RakNet::HuffmanEncodingTree &** operator[](const unsigned int );
    public int GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(int & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(int & ,unsigned int );
    protected bool HasSavedSearchResult(int & );
    protected unsigned int lastSearchIndex;
    protected int lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
        void MapNode(int ,class RakNet::HuffmanEncodingTree * );
        void MapNode();
        struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator=(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
        int mapNodeKey;
        class RakNet::HuffmanEncodingTree * mapNodeData;
    };
    public int NodeComparisonFunc(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    public void Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >(class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > & );
    public void Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >();
    public void ~Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >();
    public class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > & operator=(class DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> > & );
    public class RakNet::HuffmanEncodingTree &** Get(int & );
    public class RakNet::HuffmanEncodingTree * Pop(int & );
    public void Set(int & ,class RakNet::HuffmanEncodingTree &** );
    public void SetExisting(int & ,class RakNet::HuffmanEncodingTree &** );
    public void SetNew(int & ,class RakNet::HuffmanEncodingTree &** );
    public bool Has(int & );
    public bool Delete(int & );
    public class RakNet::HuffmanEncodingTree &** operator[](const unsigned int );
    public int GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(int & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(int & ,unsigned int );
    protected bool HasSavedSearchResult(int & );
    protected unsigned int lastSearchIndex;
    protected int lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode
{
    void MapNode(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    void MapNode(int ,class RakNet::HuffmanEncodingTree * );
    void MapNode();
    struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator=(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & );
    int mapNodeKey;
    class RakNet::HuffmanEncodingTree * mapNodeData;
};

class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>(class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> & );
    public void OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>();
    public void ~OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>();
    public class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> & );
    public bool HasData(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int GetIndexFromKey(int & ,bool * ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public bool GetElementFromKey(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode GetElementFromKey(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int Insert(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int Remove(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int RemoveIfExists(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>(class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> & );
    public void OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>();
    public void ~OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc>();
    public class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<int,DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode,&DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::NodeComparisonFunc> & );
    public bool HasData(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int GetIndexFromKey(int & ,bool * ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public bool GetElementFromKey(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode GetElementFromKey(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int Insert(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int Remove(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public unsigned int RemoveIfExists(int & ,int  ( * )(int & ,struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ));
    public struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<int,RakNet::HuffmanEncodingTree *,&DataStructures::defaultMapKeyComparison<int> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<char *>
{
    public void Queue<char *>(class DataStructures::Queue<char *> & );
    public void Queue<char *>();
    public void ~Queue<char *>();
    public bool operator=(class DataStructures::Queue<char *> & );
    public void Push(char &** ,char * ,unsigned int );
    public void PushAtHead(char &** ,unsigned int ,char * ,unsigned int );
    public char &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public char * Peek();
    public char * PeekTail();
    public char * Pop();
    public char * PopTail();
    public char * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(char &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private char ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<char *>
{
    public void Queue<char *>(class DataStructures::Queue<char *> & );
    public void Queue<char *>();
    public void ~Queue<char *>();
    public bool operator=(class DataStructures::Queue<char *> & );
    public void Push(char &** ,char * ,unsigned int );
    public void PushAtHead(char &** ,unsigned int ,char * ,unsigned int );
    public char &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public char * Peek();
    public char * PeekTail();
    public char * Pop();
    public char * PopTail();
    public char * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(char &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private char ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::RNSPerSecondMetrics
{
    USER_MESSAGE_BYTES_PUSHED=0,
    USER_MESSAGE_BYTES_SENT=1,
    USER_MESSAGE_BYTES_RESENT=2,
    USER_MESSAGE_BYTES_RECEIVED_PROCESSED=3,
    USER_MESSAGE_BYTES_RECEIVED_IGNORED=4,
    ACTUAL_BYTES_SENT=5,
    ACTUAL_BYTES_RECEIVED=6,
    RNS_PER_SECOND_METRICS_COUNT=7
};

struct RakNet::FileListReceiver
{
    void FileListReceiver(struct RakNet::FileListReceiver & );
    void FileListReceiver();
    void ~FileListReceiver();
    class RakNet::FileListTransferCBInterface * downloadHandler;
    struct RakNet::SystemAddress allowedSender;
    unsigned int setID;
    unsigned int setCount;
    unsigned int setTotalCompressedTransmissionLength;
    unsigned int setTotalFinalLength;
    unsigned int setTotalDownloadedLength;
    bool gotSetHeader;
    bool deleteDownloadHandler;
    bool isCompressed;
    int filesReceived;
    class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > pushedFiles;
    unsigned int partLength;
    struct RakNet::FileListReceiver & operator=(struct RakNet::FileListReceiver & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::FileListReceiver
{
    void FileListReceiver(struct RakNet::FileListReceiver & );
    void FileListReceiver();
    void ~FileListReceiver();
    class RakNet::FileListTransferCBInterface * downloadHandler;
    struct RakNet::SystemAddress allowedSender;
    unsigned int setID;
    unsigned int setCount;
    unsigned int setTotalCompressedTransmissionLength;
    unsigned int setTotalFinalLength;
    unsigned int setTotalDownloadedLength;
    bool gotSetHeader;
    bool deleteDownloadHandler;
    bool isCompressed;
    int filesReceived;
    class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > pushedFiles;
    unsigned int partLength;
    struct RakNet::FileListReceiver & operator=(struct RakNet::FileListReceiver & );
    void * __vecDelDtor(unsigned int );
};

class RakNet::IncrementalReadInterface
{
    public void IncrementalReadInterface(class RakNet::IncrementalReadInterface & );
    public void IncrementalReadInterface();
    public void ~IncrementalReadInterface();
    public unsigned int GetFilePart(char * ,unsigned int ,unsigned int ,void * ,struct FileListNodeContext );
    public class RakNet::IncrementalReadInterface & operator=(class RakNet::IncrementalReadInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::IncrementalReadInterface
{
    public void IncrementalReadInterface(class RakNet::IncrementalReadInterface & );
    public void IncrementalReadInterface();
    public void ~IncrementalReadInterface();
    public unsigned int GetFilePart(char * ,unsigned int ,unsigned int ,void * ,struct FileListNodeContext );
    public class RakNet::IncrementalReadInterface & operator=(class RakNet::IncrementalReadInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::RakNetStatistics
{
    unsigned int valueOverLastSecond[7];
    unsigned int runningTotal[7];
    unsigned int connectionStartTime;
    bool isLimitedByCongestionControl;
    unsigned int BPSLimitByCongestionControl;
    bool isLimitedByOutgoingBandwidthLimit;
    unsigned int BPSLimitByOutgoingBandwidthLimit;
    unsigned int messageInSendBuffer[4];
    float bytesInSendBuffer[4];
    unsigned int messagesInResendBuffer;
    unsigned int bytesInResendBuffer;
    float packetlossLastSecond;
    float packetlossTotal;
    struct RakNet::RakNetStatistics & operator+=(struct RakNet::RakNetStatistics & );
};

struct RakNet::RakNetStatistics
{
    unsigned int valueOverLastSecond[7];
    unsigned int runningTotal[7];
    unsigned int connectionStartTime;
    bool isLimitedByCongestionControl;
    unsigned int BPSLimitByCongestionControl;
    bool isLimitedByOutgoingBandwidthLimit;
    unsigned int BPSLimitByOutgoingBandwidthLimit;
    unsigned int messageInSendBuffer[4];
    float bytesInSendBuffer[4];
    unsigned int messagesInResendBuffer;
    unsigned int bytesInResendBuffer;
    float packetlossLastSecond;
    float packetlossTotal;
    struct RakNet::RakNetStatistics & operator+=(struct RakNet::RakNetStatistics & );
};

struct RakNet::FLR_MemoryBlock
{
    char * flrMemoryBlock;
};

class RakNet::RakThread
{
    public int Create(unsigned int  ( * )(void * ),void * ,int );
};

class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned (class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> & );
    public void OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned ();
    public void ~OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned();
    public class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> & );
    public bool HasData(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int GetIndexFromKey(unsigned int & ,bool * ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public bool GetElementFromKey(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode GetElementFromKey(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int Insert(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int Remove(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int RemoveIfExists(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode
{
    void MapNode(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    void MapNode(unsigned int ,struct RakNet::FLR_MemoryBlock );
    void MapNode();
    struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator=(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    unsigned int mapNodeKey;
    struct RakNet::FLR_MemoryBlock mapNodeData;
};

class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned (class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> & );
    public void OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned ();
    public void ~OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned();
    public class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> & );
    public bool HasData(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int GetIndexFromKey(unsigned int & ,bool * ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public bool GetElementFromKey(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode GetElementFromKey(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int Insert(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int Remove(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public unsigned int RemoveIfExists(unsigned int & ,int  ( * )(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ));
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
        void MapNode(unsigned int ,struct RakNet::FLR_MemoryBlock );
        void MapNode();
        struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator=(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
        unsigned int mapNodeKey;
        struct RakNet::FLR_MemoryBlock mapNodeData;
    };
    public int NodeComparisonFunc(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    public void Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >(class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > & );
    public void Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >();
    public void ~Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >();
    public class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > & operator=(class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > & );
    public struct RakNet::FLR_MemoryBlock & Get(unsigned int & );
    public struct RakNet::FLR_MemoryBlock Pop(unsigned int & );
    public void Set(unsigned int & ,struct RakNet::FLR_MemoryBlock & );
    public void SetExisting(unsigned int & ,struct RakNet::FLR_MemoryBlock & );
    public void SetNew(unsigned int & ,struct RakNet::FLR_MemoryBlock & );
    public bool Has(unsigned int & );
    public bool Delete(unsigned int & );
    public struct RakNet::FLR_MemoryBlock & operator[](const unsigned int );
    public unsigned int GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(unsigned int & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(unsigned int & ,unsigned int );
    protected bool HasSavedSearchResult(unsigned int & );
    protected unsigned int lastSearchIndex;
    protected unsigned int lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::FLR_MemoryBlock
{
    char * flrMemoryBlock;
};

class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
        void MapNode(unsigned int ,struct RakNet::FLR_MemoryBlock );
        void MapNode();
        struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator=(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
        unsigned int mapNodeKey;
        struct RakNet::FLR_MemoryBlock mapNodeData;
    };
    public int NodeComparisonFunc(unsigned int & ,struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    public void Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >(class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > & );
    public void Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >();
    public void ~Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >();
    public class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > & operator=(class DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> > & );
    public struct RakNet::FLR_MemoryBlock & Get(unsigned int & );
    public struct RakNet::FLR_MemoryBlock Pop(unsigned int & );
    public void Set(unsigned int & ,struct RakNet::FLR_MemoryBlock & );
    public void SetExisting(unsigned int & ,struct RakNet::FLR_MemoryBlock & );
    public void SetNew(unsigned int & ,struct RakNet::FLR_MemoryBlock & );
    public bool Has(unsigned int & );
    public bool Delete(unsigned int & );
    public struct RakNet::FLR_MemoryBlock & operator[](const unsigned int );
    public unsigned int GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(unsigned int & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<unsigned int,DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode,&DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(unsigned int & ,unsigned int );
    protected bool HasSavedSearchResult(unsigned int & );
    protected unsigned int lastSearchIndex;
    protected unsigned int lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode
{
    void MapNode(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    void MapNode(unsigned int ,struct RakNet::FLR_MemoryBlock );
    void MapNode();
    struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator=(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    unsigned int mapNodeKey;
    struct RakNet::FLR_MemoryBlock mapNodeData;
};

class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>
{
    public void List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>(class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> & );
    public void List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>();
    public void ~List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> & );
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    public void Replace(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,const struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>
{
    public void List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>(class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> & );
    public void List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>();
    public void ~List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode> & );
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    public void Replace(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & ,const struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<unsigned int,RakNet::FLR_MemoryBlock,&DataStructures::defaultMapKeyComparison<unsigned int> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

enum OutOfBandIdentifiers
{
    ID_NAT_ESTABLISH_UNIDIRECTIONAL=0,
    ID_NAT_ESTABLISH_BIDIRECTIONAL=1,
    ID_NAT_TYPE_DETECT=2,
    ID_ROUTER_2_REPLY_TO_SENDER_PORT=3,
    ID_ROUTER_2_REPLY_TO_SPECIFIED_PORT=4,
    ID_ROUTER_2_MINI_PUNCH_REPLY=5,
    ID_ROUTER_2_MINI_PUNCH_REPLY_BOUNCE=6,
    ID_XBOX_360_VOICE=7,
    ID_XBOX_360_GET_NETWORK_ROOM=8,
    ID_XBOX_360_RETURN_NETWORK_ROOM=9,
    ID_NAT_PING=10,
    ID_NAT_PONG=11
};

class RakNet::PacketLogger : public RakNet::PluginInterface2
{
    public class RakNet::PacketLogger * GetInstance();
    public void DestroyInstance(class RakNet::PacketLogger * );
    public void PacketLogger(class RakNet::PacketLogger & );
    public void PacketLogger();
    public void ~PacketLogger();
    public void FormatLine(char * ,char * ,char * ,unsigned int ,unsigned int ,char * ,const unsigned int ,unsigned int ,struct RakNet::SystemAddress & ,struct RakNet::SystemAddress & ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void FormatLine(char * ,char * ,char * ,unsigned int ,unsigned int ,unsigned int ,const unsigned int ,unsigned int ,struct RakNet::SystemAddress & ,struct RakNet::SystemAddress & ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void OnDirectSocketSend(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnDirectSocketReceive(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnReliabilityLayerNotification(char * ,const unsigned int ,struct RakNet::SystemAddress ,bool );
    public void OnInternalPacket(struct RakNet::InternalPacket * ,unsigned int ,struct RakNet::SystemAddress ,unsigned int ,int );
    public void OnAck(unsigned int ,struct RakNet::SystemAddress ,unsigned int );
    public void OnPushBackPacket(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void LogHeader();
    public void WriteLog(char * );
    public void WriteMiscellaneous(char * ,char * );
    public void SetPrintID(bool );
    public void SetPrintAcks(bool );
    public void SetPrefix(char * );
    public void SetSuffix(char * );
    public char * BaseIDTOString(unsigned int );
    public void SetLogDirectMessages(bool );
    protected bool UsesReliabilityLayer();
    protected char * IDTOString(unsigned int );
    protected void AddToLog(char * );
    protected char * UserIDTOString(unsigned int );
    protected void GetLocalTime(char * );
    protected bool logDirectMessages;
    protected bool printId;
    protected bool printAcks;
    protected char prefix[256];
    protected char suffix[256];
    public class RakNet::PacketLogger & operator=(class RakNet::PacketLogger & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::PacketLogger : public RakNet::PluginInterface2
{
    public class RakNet::PacketLogger * GetInstance();
    public void DestroyInstance(class RakNet::PacketLogger * );
    public void PacketLogger(class RakNet::PacketLogger & );
    public void PacketLogger();
    public void ~PacketLogger();
    public void FormatLine(char * ,char * ,char * ,unsigned int ,unsigned int ,char * ,const unsigned int ,unsigned int ,struct RakNet::SystemAddress & ,struct RakNet::SystemAddress & ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void FormatLine(char * ,char * ,char * ,unsigned int ,unsigned int ,unsigned int ,const unsigned int ,unsigned int ,struct RakNet::SystemAddress & ,struct RakNet::SystemAddress & ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public void OnDirectSocketSend(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnDirectSocketReceive(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void OnReliabilityLayerNotification(char * ,const unsigned int ,struct RakNet::SystemAddress ,bool );
    public void OnInternalPacket(struct RakNet::InternalPacket * ,unsigned int ,struct RakNet::SystemAddress ,unsigned int ,int );
    public void OnAck(unsigned int ,struct RakNet::SystemAddress ,unsigned int );
    public void OnPushBackPacket(char * ,const unsigned int ,struct RakNet::SystemAddress );
    public void LogHeader();
    public void WriteLog(char * );
    public void WriteMiscellaneous(char * ,char * );
    public void SetPrintID(bool );
    public void SetPrintAcks(bool );
    public void SetPrefix(char * );
    public void SetSuffix(char * );
    public char * BaseIDTOString(unsigned int );
    public void SetLogDirectMessages(bool );
    protected bool UsesReliabilityLayer();
    protected char * IDTOString(unsigned int );
    protected void AddToLog(char * );
    protected char * UserIDTOString(unsigned int );
    protected void GetLocalTime(char * );
    protected bool logDirectMessages;
    protected bool printId;
    protected bool printAcks;
    protected char prefix[256];
    protected char suffix[256];
    public class RakNet::PacketLogger & operator=(class RakNet::PacketLogger & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughDebugInterface_Printf : public RakNet::NatPunchthroughDebugInterface
{
    void OnClientMessage(char * );
    void NatPunchthroughDebugInterface_Printf(struct RakNet::NatPunchthroughDebugInterface_Printf * );
    void NatPunchthroughDebugInterface_Printf(struct RakNet::NatPunchthroughDebugInterface_Printf & );
    void NatPunchthroughDebugInterface_Printf();
    void ~NatPunchthroughDebugInterface_Printf();
    struct RakNet::NatPunchthroughDebugInterface_Printf & operator=(struct RakNet::NatPunchthroughDebugInterface_Printf * );
    struct RakNet::NatPunchthroughDebugInterface_Printf & operator=(struct RakNet::NatPunchthroughDebugInterface_Printf & );
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

struct RakNet::NatPunchthroughDebugInterface_Printf : public RakNet::NatPunchthroughDebugInterface
{
    void OnClientMessage(char * );
    void NatPunchthroughDebugInterface_Printf(struct RakNet::NatPunchthroughDebugInterface_Printf * );
    void NatPunchthroughDebugInterface_Printf(struct RakNet::NatPunchthroughDebugInterface_Printf & );
    void NatPunchthroughDebugInterface_Printf();
    void ~NatPunchthroughDebugInterface_Printf();
    struct RakNet::NatPunchthroughDebugInterface_Printf & operator=(struct RakNet::NatPunchthroughDebugInterface_Printf * );
    struct RakNet::NatPunchthroughDebugInterface_Printf & operator=(struct RakNet::NatPunchthroughDebugInterface_Printf & );
    void __local_vftable_ctor_closure();
    void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakNetSocket2 *>
{
    public void List<RakNet::RakNetSocket2 *>(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void List<RakNet::RakNetSocket2 *>();
    public void ~List<RakNet::RakNetSocket2 *>();
    public class DataStructures::List<RakNet::RakNetSocket2 *> & operator=(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public class RakNet::RakNetSocket2 &** operator[](const unsigned int );
    public class RakNet::RakNetSocket2 &** Get(const unsigned int );
    public void Push(class RakNet::RakNetSocket2 &** ,char * ,unsigned int );
    public class RakNet::RakNetSocket2 &** Pop();
    public void Insert(class RakNet::RakNetSocket2 &** ,char * ,unsigned int );
    public void Insert(class RakNet::RakNetSocket2 &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::RakNetSocket2 &** );
    public void Replace(class RakNet::RakNetSocket2 &** ,const class RakNet::RakNetSocket2 * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::RakNetSocket2 &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::RakNetSocket2 ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakNetSocket2 *>
{
    public void List<RakNet::RakNetSocket2 *>(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void List<RakNet::RakNetSocket2 *>();
    public void ~List<RakNet::RakNetSocket2 *>();
    public class DataStructures::List<RakNet::RakNetSocket2 *> & operator=(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public class RakNet::RakNetSocket2 &** operator[](const unsigned int );
    public class RakNet::RakNetSocket2 &** Get(const unsigned int );
    public void Push(class RakNet::RakNetSocket2 &** ,char * ,unsigned int );
    public class RakNet::RakNetSocket2 &** Pop();
    public void Insert(class RakNet::RakNetSocket2 &** ,char * ,unsigned int );
    public void Insert(class RakNet::RakNetSocket2 &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::RakNetSocket2 &** );
    public void Replace(class RakNet::RakNetSocket2 &** ,const class RakNet::RakNetSocket2 * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::RakNetSocket2 &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::RakNetSocket2 ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class RakNet::TCPInterface
{
    public class RakNet::TCPInterface * GetInstance();
    public void DestroyInstance(class RakNet::TCPInterface * );
    public void TCPInterface(class RakNet::TCPInterface & );
    public void TCPInterface();
    public void ~TCPInterface();
    public bool Start(unsigned int ,unsigned int ,unsigned int ,int ,unsigned int ,char * );
    public void Stop();
    public struct RakNet::SystemAddress Connect(char * ,unsigned int ,bool ,unsigned int ,char * );
    public void Send(char * ,unsigned int ,struct RakNet::SystemAddress & ,bool );
    public bool SendList(char ** ,unsigned int * ,const int ,struct RakNet::SystemAddress & ,bool );
    public unsigned int GetOutgoingDataBufferSize(struct RakNet::SystemAddress );
    public bool ReceiveHasPackets();
    public struct RakNet::Packet * Receive();
    public void CloseConnection(struct RakNet::SystemAddress );
    public void DeallocatePacket(struct RakNet::Packet * );
    public void GetConnectionList(struct RakNet::SystemAddress * ,unsigned int * );
    public unsigned int GetConnectionCount();
    public struct RakNet::SystemAddress HasCompletedConnectionAttempt();
    public struct RakNet::SystemAddress HasFailedConnectionAttempt();
    public struct RakNet::SystemAddress HasNewIncomingConnection();
    public struct RakNet::SystemAddress HasLostConnection();
    public struct RakNet::Packet * AllocatePacket(unsigned int );
    public void PushBackPacket(struct RakNet::Packet * ,bool );
    public bool WasStarted();
    public void AttachPlugin(class RakNet::PluginInterface2 * );
    public void DetachPlugin(class RakNet::PluginInterface2 * );
    protected struct RakNet::Packet * ReceiveInt();
    protected bool CreateListenSocket(unsigned int ,unsigned int ,unsigned int ,char * );
    protected class DataStructures::List<RakNet::PluginInterface2 *> messageHandlerList;
    protected class RakNet::LocklessUint32_t isStarted;
    protected class RakNet::LocklessUint32_t threadRunning;
    protected unsigned int listenSocket;
    protected class DataStructures::Queue<RakNet::Packet *> headPush;
    protected class DataStructures::Queue<RakNet::Packet *> tailPush;
    protected struct RakNet::RemoteClient * remoteClients;
    protected int remoteClientsLength;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> incomingMessages;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> newIncomingConnections;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> lostConnections;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> requestedCloseConnections;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> newRemoteClients;
    protected class RakNet::SimpleMutex completedConnectionAttemptMutex;
    protected class RakNet::SimpleMutex failedConnectionAttemptMutex;
    protected class DataStructures::Queue<RakNet::SystemAddress> completedConnectionAttempts;
    protected class DataStructures::Queue<RakNet::SystemAddress> failedConnectionAttempts;
    protected int threadPriority;
    protected class DataStructures::List<unsigned int> blockingSocketList;
    protected class RakNet::SimpleMutex blockingSocketListMutex;
    protected unsigned int SocketConnect(char * ,unsigned int ,unsigned int ,char * );
    struct ThisPtrPlusSysAddr
    {
        class RakNet::TCPInterface * tcpInterface;
        struct RakNet::SystemAddress systemAddress;
        bool useSSL;
        char bindAddress[64];
        unsigned int socketFamily;
        void ThisPtrPlusSysAddr();
        struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr * );
        struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr & );
    };
    public class RakNet::TCPInterface & operator=(class RakNet::TCPInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::TCPInterface
{
    public class RakNet::TCPInterface * GetInstance();
    public void DestroyInstance(class RakNet::TCPInterface * );
    public void TCPInterface(class RakNet::TCPInterface & );
    public void TCPInterface();
    public void ~TCPInterface();
    public bool Start(unsigned int ,unsigned int ,unsigned int ,int ,unsigned int ,char * );
    public void Stop();
    public struct RakNet::SystemAddress Connect(char * ,unsigned int ,bool ,unsigned int ,char * );
    public void Send(char * ,unsigned int ,struct RakNet::SystemAddress & ,bool );
    public bool SendList(char ** ,unsigned int * ,const int ,struct RakNet::SystemAddress & ,bool );
    public unsigned int GetOutgoingDataBufferSize(struct RakNet::SystemAddress );
    public bool ReceiveHasPackets();
    public struct RakNet::Packet * Receive();
    public void CloseConnection(struct RakNet::SystemAddress );
    public void DeallocatePacket(struct RakNet::Packet * );
    public void GetConnectionList(struct RakNet::SystemAddress * ,unsigned int * );
    public unsigned int GetConnectionCount();
    public struct RakNet::SystemAddress HasCompletedConnectionAttempt();
    public struct RakNet::SystemAddress HasFailedConnectionAttempt();
    public struct RakNet::SystemAddress HasNewIncomingConnection();
    public struct RakNet::SystemAddress HasLostConnection();
    public struct RakNet::Packet * AllocatePacket(unsigned int );
    public void PushBackPacket(struct RakNet::Packet * ,bool );
    public bool WasStarted();
    public void AttachPlugin(class RakNet::PluginInterface2 * );
    public void DetachPlugin(class RakNet::PluginInterface2 * );
    protected struct RakNet::Packet * ReceiveInt();
    protected bool CreateListenSocket(unsigned int ,unsigned int ,unsigned int ,char * );
    protected class DataStructures::List<RakNet::PluginInterface2 *> messageHandlerList;
    protected class RakNet::LocklessUint32_t isStarted;
    protected class RakNet::LocklessUint32_t threadRunning;
    protected unsigned int listenSocket;
    protected class DataStructures::Queue<RakNet::Packet *> headPush;
    protected class DataStructures::Queue<RakNet::Packet *> tailPush;
    protected struct RakNet::RemoteClient * remoteClients;
    protected int remoteClientsLength;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> incomingMessages;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> newIncomingConnections;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> lostConnections;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> requestedCloseConnections;
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> newRemoteClients;
    protected class RakNet::SimpleMutex completedConnectionAttemptMutex;
    protected class RakNet::SimpleMutex failedConnectionAttemptMutex;
    protected class DataStructures::Queue<RakNet::SystemAddress> completedConnectionAttempts;
    protected class DataStructures::Queue<RakNet::SystemAddress> failedConnectionAttempts;
    protected int threadPriority;
    protected class DataStructures::List<unsigned int> blockingSocketList;
    protected class RakNet::SimpleMutex blockingSocketListMutex;
    protected unsigned int SocketConnect(char * ,unsigned int ,unsigned int ,char * );
    struct ThisPtrPlusSysAddr
    {
        class RakNet::TCPInterface * tcpInterface;
        struct RakNet::SystemAddress systemAddress;
        bool useSSL;
        char bindAddress[64];
        unsigned int socketFamily;
        void ThisPtrPlusSysAddr();
        struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr * );
        struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr & );
    };
    public class RakNet::TCPInterface & operator=(class RakNet::TCPInterface & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::TCPInterface::ThisPtrPlusSysAddr
{
    class RakNet::TCPInterface * tcpInterface;
    struct RakNet::SystemAddress systemAddress;
    bool useSSL;
    char bindAddress[64];
    unsigned int socketFamily;
    void ThisPtrPlusSysAddr();
    struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr * );
    struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr & );
};

struct RakNet::TCPInterface::ThisPtrPlusSysAddr
{
    class RakNet::TCPInterface * tcpInterface;
    struct RakNet::SystemAddress systemAddress;
    bool useSSL;
    char bindAddress[64];
    unsigned int socketFamily;
    void ThisPtrPlusSysAddr();
    struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr * );
    struct RakNet::TCPInterface::ThisPtrPlusSysAddr & operator=(struct RakNet::TCPInterface::ThisPtrPlusSysAddr & );
};

struct RakNet::RemoteClient
{
    void RemoteClient();
    unsigned int socket;
    struct RakNet::SystemAddress systemAddress;
    class DataStructures::ByteQueue outgoingData;
    bool isActive;
    class RakNet::SimpleMutex outgoingDataMutex;
    class RakNet::SimpleMutex isActiveMutex;
    int Send(char * ,unsigned int );
    int Recv(char * ,const int );
    void Reset();
    void SetActive(bool );
    void SendOrBuffer(char ** ,unsigned int * ,const int );
    void ~RemoteClient();
    struct RakNet::RemoteClient & operator=(struct RakNet::RemoteClient * );
    struct RakNet::RemoteClient & operator=(struct RakNet::RemoteClient & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::RemoteClient
{
    void RemoteClient();
    unsigned int socket;
    struct RakNet::SystemAddress systemAddress;
    class DataStructures::ByteQueue outgoingData;
    bool isActive;
    class RakNet::SimpleMutex outgoingDataMutex;
    class RakNet::SimpleMutex isActiveMutex;
    int Send(char * ,unsigned int );
    int Recv(char * ,const int );
    void Reset();
    void SetActive(bool );
    void SendOrBuffer(char ** ,unsigned int * ,const int );
    void ~RemoteClient();
    struct RakNet::RemoteClient & operator=(struct RakNet::RemoteClient * );
    struct RakNet::RemoteClient & operator=(struct RakNet::RemoteClient & );
    void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RemoteClient *>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RemoteClient * userMemory;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * parentPage;
    };
    public void MemoryPool<RakNet::RemoteClient *>();
    public void ~MemoryPool<RakNet::RemoteClient *>();
    public void SetPageSize(int );
    public struct RakNet::RemoteClient ** Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RemoteClient ** ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * ,struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RemoteClient *>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RemoteClient * userMemory;
        struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * parentPage;
    };
    public void MemoryPool<RakNet::RemoteClient *>();
    public void ~MemoryPool<RakNet::RemoteClient *>();
    public void SetPageSize(int );
    public struct RakNet::RemoteClient ** Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RemoteClient ** ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * ,struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RemoteClient * *>
{
    public void Queue<RakNet::RemoteClient * *>(class DataStructures::Queue<RakNet::RemoteClient * *> & );
    public void Queue<RakNet::RemoteClient * *>();
    public void ~Queue<RakNet::RemoteClient * *>();
    public bool operator=(class DataStructures::Queue<RakNet::RemoteClient * *> & );
    public void Push(struct RakNet::RemoteClient &*** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RemoteClient &*** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RemoteClient &*** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RemoteClient ** Peek();
    public struct RakNet::RemoteClient ** PeekTail();
    public struct RakNet::RemoteClient ** Pop();
    public struct RakNet::RemoteClient ** PopTail();
    public struct RakNet::RemoteClient ** PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RemoteClient &*** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RemoteClient *** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RemoteClient * *>
{
    public void Queue<RakNet::RemoteClient * *>(class DataStructures::Queue<RakNet::RemoteClient * *> & );
    public void Queue<RakNet::RemoteClient * *>();
    public void ~Queue<RakNet::RemoteClient * *>();
    public bool operator=(class DataStructures::Queue<RakNet::RemoteClient * *> & );
    public void Push(struct RakNet::RemoteClient &*** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RemoteClient &*** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RemoteClient &*** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RemoteClient ** Peek();
    public struct RakNet::RemoteClient ** PeekTail();
    public struct RakNet::RemoteClient ** Pop();
    public struct RakNet::RemoteClient ** PopTail();
    public struct RakNet::RemoteClient ** PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RemoteClient &*** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RemoteClient *** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::SystemAddress *>
{
    public void Queue<RakNet::SystemAddress *>(class DataStructures::Queue<RakNet::SystemAddress *> & );
    public void Queue<RakNet::SystemAddress *>();
    public void ~Queue<RakNet::SystemAddress *>();
    public bool operator=(class DataStructures::Queue<RakNet::SystemAddress *> & );
    public void Push(struct RakNet::SystemAddress &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::SystemAddress &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::SystemAddress &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::SystemAddress * Peek();
    public struct RakNet::SystemAddress * PeekTail();
    public struct RakNet::SystemAddress * Pop();
    public struct RakNet::SystemAddress * PopTail();
    public struct RakNet::SystemAddress * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::SystemAddress &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::SystemAddress ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::SystemAddress *>
{
    public void Queue<RakNet::SystemAddress *>(class DataStructures::Queue<RakNet::SystemAddress *> & );
    public void Queue<RakNet::SystemAddress *>();
    public void ~Queue<RakNet::SystemAddress *>();
    public bool operator=(class DataStructures::Queue<RakNet::SystemAddress *> & );
    public void Push(struct RakNet::SystemAddress &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::SystemAddress &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::SystemAddress &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::SystemAddress * Peek();
    public struct RakNet::SystemAddress * PeekTail();
    public struct RakNet::SystemAddress * Pop();
    public struct RakNet::SystemAddress * PopTail();
    public struct RakNet::SystemAddress * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::SystemAddress &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::SystemAddress ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>
{
    public void List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>(class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> & );
    public void List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>();
    public void ~List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> & );
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    public void Replace(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,const struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode
{
    void MapNode(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    void MapNode(struct RakNet::SystemAddress ,class DataStructures::ByteQueue * );
    void MapNode();
    struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator=(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    struct RakNet::SystemAddress mapNodeKey;
    class DataStructures::ByteQueue * mapNodeData;
};

class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>
{
    public void List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>(class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> & );
    public void List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>();
    public void ~List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode>();
    public class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> & operator=(class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> & );
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator[](const unsigned int );
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,char * ,unsigned int );
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & Pop();
    public void Insert(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    public void Replace(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,const struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::Packet>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::Packet>::Page * next;
        struct DataStructures::MemoryPool<RakNet::Packet>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::Packet userMemory;
        struct DataStructures::MemoryPool<RakNet::Packet>::Page * parentPage;
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::Packet>();
    public void ~MemoryPool<RakNet::Packet>();
    public void SetPageSize(int );
    public struct RakNet::Packet * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::Packet * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::Packet>::Page * ,struct DataStructures::MemoryPool<RakNet::Packet>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::Packet>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::Packet>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::Packet>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::Packet>::Page * next;
        struct DataStructures::MemoryPool<RakNet::Packet>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::Packet userMemory;
        struct DataStructures::MemoryPool<RakNet::Packet>::Page * parentPage;
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::Packet>();
    public void ~MemoryPool<RakNet::Packet>();
    public void SetPageSize(int );
    public struct RakNet::Packet * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::Packet * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::Packet>::Page * ,struct DataStructures::MemoryPool<RakNet::Packet>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::Packet>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::Packet>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataS(class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> & );
    public void OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataS();
    public void ~OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&Data();
    public class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> & );
    public bool HasData(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int GetIndexFromKey(struct RakNet::SystemAddress & ,bool * ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public bool GetElementFromKey(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode GetElementFromKey(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int Insert(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int Remove(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int RemoveIfExists(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataS(class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> & );
    public void OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataS();
    public void ~OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&Data();
    public class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> & operator=(class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> & );
    public bool HasData(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int GetIndexFromKey(struct RakNet::SystemAddress & ,bool * ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public bool GetElementFromKey(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode GetElementFromKey(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int Insert(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,bool ,char * ,unsigned int ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int Remove(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public unsigned int RemoveIfExists(struct RakNet::SystemAddress & ,int  ( * )(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ));
    public struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet>
{
    public void Push(struct RakNet::Packet * );
    public struct RakNet::Packet * PopInaccurate();
    public struct RakNet::Packet * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::Packet * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::Packet * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::Packet * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::Packet> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::Packet *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::Packet>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> * );
    public void ThreadsafeAllocatingQueue<RakNet::Packet>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & );
    public void ThreadsafeAllocatingQueue<RakNet::Packet>();
    public void ~ThreadsafeAllocatingQueue<RakNet::Packet>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet>
{
    public void Push(struct RakNet::Packet * );
    public struct RakNet::Packet * PopInaccurate();
    public struct RakNet::Packet * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::Packet * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::Packet * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::Packet * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::Packet> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::Packet *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::Packet>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> * );
    public void ThreadsafeAllocatingQueue<RakNet::Packet>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & );
    public void ThreadsafeAllocatingQueue<RakNet::Packet>();
    public void ~ThreadsafeAllocatingQueue<RakNet::Packet>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::Packet> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::SystemAddress>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * next;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::SystemAddress userMemory;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * parentPage;
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::SystemAddress>();
    public void ~MemoryPool<RakNet::SystemAddress>();
    public void SetPageSize(int );
    public struct RakNet::SystemAddress * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::SystemAddress * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * ,struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::SystemAddress>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * next;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::SystemAddress userMemory;
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * parentPage;
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::SystemAddress>();
    public void ~MemoryPool<RakNet::SystemAddress>();
    public void SetPageSize(int );
    public struct RakNet::SystemAddress * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::SystemAddress * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * ,struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<unsigned int>
{
    public void List<unsigned int>(class DataStructures::List<unsigned int> & );
    public void List<unsigned int>();
    public void ~List<unsigned int>();
    public class DataStructures::List<unsigned int> & operator=(class DataStructures::List<unsigned int> & );
    public unsigned int & operator[](const unsigned int );
    public unsigned int & Get(const unsigned int );
    public void Push(unsigned int & ,char * ,unsigned int );
    public unsigned int & Pop();
    public void Insert(unsigned int & ,char * ,unsigned int );
    public void Insert(unsigned int & ,const unsigned int ,char * ,unsigned int );
    public void Replace(unsigned int & );
    public void Replace(unsigned int & ,const unsigned int ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(unsigned int & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private unsigned int * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<unsigned int>
{
    public void List<unsigned int>(class DataStructures::List<unsigned int> & );
    public void List<unsigned int>();
    public void ~List<unsigned int>();
    public class DataStructures::List<unsigned int> & operator=(class DataStructures::List<unsigned int> & );
    public unsigned int & operator[](const unsigned int );
    public unsigned int & Get(const unsigned int );
    public void Push(unsigned int & ,char * ,unsigned int );
    public unsigned int & Pop();
    public void Insert(unsigned int & ,char * ,unsigned int );
    public void Insert(unsigned int & ,const unsigned int ,char * ,unsigned int );
    public void Replace(unsigned int & );
    public void Replace(unsigned int & ,const unsigned int ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(unsigned int & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private unsigned int * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *>
{
    public void Push(struct RakNet::RemoteClient ** );
    public struct RakNet::RemoteClient ** PopInaccurate();
    public struct RakNet::RemoteClient ** Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::RemoteClient ** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::RemoteClient ** Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::RemoteClient ** ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::RemoteClient *> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::RemoteClient * *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::RemoteClient *>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> * );
    public void ThreadsafeAllocatingQueue<RakNet::RemoteClient *>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & );
    public void ThreadsafeAllocatingQueue<RakNet::RemoteClient *>();
    public void ~ThreadsafeAllocatingQueue<RakNet::RemoteClient *>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *>
{
    public void Push(struct RakNet::RemoteClient ** );
    public struct RakNet::RemoteClient ** PopInaccurate();
    public struct RakNet::RemoteClient ** Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::RemoteClient ** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::RemoteClient ** Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::RemoteClient ** ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::RemoteClient *> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::RemoteClient * *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::RemoteClient *>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> * );
    public void ThreadsafeAllocatingQueue<RakNet::RemoteClient *>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & );
    public void ThreadsafeAllocatingQueue<RakNet::RemoteClient *>();
    public void ~ThreadsafeAllocatingQueue<RakNet::RemoteClient *>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RemoteClient *> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress>
{
    public void Push(struct RakNet::SystemAddress * );
    public struct RakNet::SystemAddress * PopInaccurate();
    public struct RakNet::SystemAddress * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::SystemAddress * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::SystemAddress * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::SystemAddress * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::SystemAddress> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::SystemAddress *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::SystemAddress>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> * );
    public void ThreadsafeAllocatingQueue<RakNet::SystemAddress>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & );
    public void ThreadsafeAllocatingQueue<RakNet::SystemAddress>();
    public void ~ThreadsafeAllocatingQueue<RakNet::SystemAddress>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress>
{
    public void Push(struct RakNet::SystemAddress * );
    public struct RakNet::SystemAddress * PopInaccurate();
    public struct RakNet::SystemAddress * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::SystemAddress * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::SystemAddress * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::SystemAddress * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::SystemAddress> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::SystemAddress *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::SystemAddress>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> * );
    public void ThreadsafeAllocatingQueue<RakNet::SystemAddress>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & );
    public void ThreadsafeAllocatingQueue<RakNet::SystemAddress>();
    public void ~ThreadsafeAllocatingQueue<RakNet::SystemAddress>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::SystemAddress> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::Packet *>
{
    public void Queue<RakNet::Packet *>(class DataStructures::Queue<RakNet::Packet *> & );
    public void Queue<RakNet::Packet *>();
    public void ~Queue<RakNet::Packet *>();
    public bool operator=(class DataStructures::Queue<RakNet::Packet *> & );
    public void Push(struct RakNet::Packet &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::Packet &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::Packet &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::Packet * Peek();
    public struct RakNet::Packet * PeekTail();
    public struct RakNet::Packet * Pop();
    public struct RakNet::Packet * PopTail();
    public struct RakNet::Packet * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::Packet &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::Packet ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::Packet *>
{
    public void Queue<RakNet::Packet *>(class DataStructures::Queue<RakNet::Packet *> & );
    public void Queue<RakNet::Packet *>();
    public void ~Queue<RakNet::Packet *>();
    public bool operator=(class DataStructures::Queue<RakNet::Packet *> & );
    public void Push(struct RakNet::Packet &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::Packet &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::Packet &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::Packet * Peek();
    public struct RakNet::Packet * PeekTail();
    public struct RakNet::Packet * Pop();
    public struct RakNet::Packet * PopTail();
    public struct RakNet::Packet * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::Packet &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::Packet ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::PluginInterface2 *>
{
    public void List<RakNet::PluginInterface2 *>(class DataStructures::List<RakNet::PluginInterface2 *> & );
    public void List<RakNet::PluginInterface2 *>();
    public void ~List<RakNet::PluginInterface2 *>();
    public class DataStructures::List<RakNet::PluginInterface2 *> & operator=(class DataStructures::List<RakNet::PluginInterface2 *> & );
    public class RakNet::PluginInterface2 &** operator[](const unsigned int );
    public class RakNet::PluginInterface2 &** Get(const unsigned int );
    public void Push(class RakNet::PluginInterface2 &** ,char * ,unsigned int );
    public class RakNet::PluginInterface2 &** Pop();
    public void Insert(class RakNet::PluginInterface2 &** ,char * ,unsigned int );
    public void Insert(class RakNet::PluginInterface2 &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::PluginInterface2 &** );
    public void Replace(class RakNet::PluginInterface2 &** ,const class RakNet::PluginInterface2 * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::PluginInterface2 &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::PluginInterface2 ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::PluginInterface2 *>
{
    public void List<RakNet::PluginInterface2 *>(class DataStructures::List<RakNet::PluginInterface2 *> & );
    public void List<RakNet::PluginInterface2 *>();
    public void ~List<RakNet::PluginInterface2 *>();
    public class DataStructures::List<RakNet::PluginInterface2 *> & operator=(class DataStructures::List<RakNet::PluginInterface2 *> & );
    public class RakNet::PluginInterface2 &** operator[](const unsigned int );
    public class RakNet::PluginInterface2 &** Get(const unsigned int );
    public void Push(class RakNet::PluginInterface2 &** ,char * ,unsigned int );
    public class RakNet::PluginInterface2 &** Pop();
    public void Insert(class RakNet::PluginInterface2 &** ,char * ,unsigned int );
    public void Insert(class RakNet::PluginInterface2 &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::PluginInterface2 &** );
    public void Replace(class RakNet::PluginInterface2 &** ,const class RakNet::PluginInterface2 * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::PluginInterface2 &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::PluginInterface2 ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::SystemAddress>
{
    public void Queue<RakNet::SystemAddress>(class DataStructures::Queue<RakNet::SystemAddress> & );
    public void Queue<RakNet::SystemAddress>();
    public void ~Queue<RakNet::SystemAddress>();
    public bool operator=(class DataStructures::Queue<RakNet::SystemAddress> & );
    public void Push(struct RakNet::SystemAddress & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::SystemAddress & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::SystemAddress & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::SystemAddress Peek();
    public struct RakNet::SystemAddress PeekTail();
    public struct RakNet::SystemAddress Pop();
    public struct RakNet::SystemAddress PopTail();
    public struct RakNet::SystemAddress PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::SystemAddress & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::SystemAddress * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::SystemAddress>
{
    public void Queue<RakNet::SystemAddress>(class DataStructures::Queue<RakNet::SystemAddress> & );
    public void Queue<RakNet::SystemAddress>();
    public void ~Queue<RakNet::SystemAddress>();
    public bool operator=(class DataStructures::Queue<RakNet::SystemAddress> & );
    public void Push(struct RakNet::SystemAddress & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::SystemAddress & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::SystemAddress & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::SystemAddress Peek();
    public struct RakNet::SystemAddress PeekTail();
    public struct RakNet::SystemAddress Pop();
    public struct RakNet::SystemAddress PopTail();
    public struct RakNet::SystemAddress PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::SystemAddress & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::SystemAddress * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
        void MapNode(struct RakNet::SystemAddress ,class DataStructures::ByteQueue * );
        void MapNode();
        struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator=(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
        struct RakNet::SystemAddress mapNodeKey;
        class DataStructures::ByteQueue * mapNodeData;
    };
    public int NodeComparisonFunc(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    public void Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >(class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> > & );
    public void Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >();
    public void ~Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >();
    public class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> > & operator=(class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> > & );
    public class DataStructures::ByteQueue &** Get(struct RakNet::SystemAddress & );
    public class DataStructures::ByteQueue * Pop(struct RakNet::SystemAddress & );
    public void Set(struct RakNet::SystemAddress & ,class DataStructures::ByteQueue &** );
    public void SetExisting(struct RakNet::SystemAddress & ,class DataStructures::ByteQueue &** );
    public void SetNew(struct RakNet::SystemAddress & ,class DataStructures::ByteQueue &** );
    public bool Has(struct RakNet::SystemAddress & );
    public bool Delete(struct RakNet::SystemAddress & );
    public class DataStructures::ByteQueue &** operator[](const unsigned int );
    public struct RakNet::SystemAddress GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(struct RakNet::SystemAddress & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(struct RakNet::SystemAddress & ,unsigned int );
    protected bool HasSavedSearchResult(struct RakNet::SystemAddress & );
    protected unsigned int lastSearchIndex;
    protected struct RakNet::SystemAddress lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    struct MapNode
    {
        void MapNode(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
        void MapNode(struct RakNet::SystemAddress ,class DataStructures::ByteQueue * );
        void MapNode();
        struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator=(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
        struct RakNet::SystemAddress mapNodeKey;
        class DataStructures::ByteQueue * mapNodeData;
    };
    public int NodeComparisonFunc(struct RakNet::SystemAddress & ,struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    public void Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >(class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> > & );
    public void Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >();
    public void ~Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >();
    public class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> > & operator=(class DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> > & );
    public class DataStructures::ByteQueue &** Get(struct RakNet::SystemAddress & );
    public class DataStructures::ByteQueue * Pop(struct RakNet::SystemAddress & );
    public void Set(struct RakNet::SystemAddress & ,class DataStructures::ByteQueue &** );
    public void SetExisting(struct RakNet::SystemAddress & ,class DataStructures::ByteQueue &** );
    public void SetNew(struct RakNet::SystemAddress & ,class DataStructures::ByteQueue &** );
    public bool Has(struct RakNet::SystemAddress & );
    public bool Delete(struct RakNet::SystemAddress & );
    public class DataStructures::ByteQueue &** operator[](const unsigned int );
    public struct RakNet::SystemAddress GetKeyAtIndex(const unsigned int );
    public unsigned int GetIndexAtKey(struct RakNet::SystemAddress & );
    public void RemoveAtIndex(const unsigned int );
    public void Clear();
    public unsigned int Size();
    protected class DataStructures::OrderedList<RakNet::SystemAddress,DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode,&DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::NodeComparisonFunc> mapNodeList;
    protected void SaveLastSearch(struct RakNet::SystemAddress & ,unsigned int );
    protected bool HasSavedSearchResult(struct RakNet::SystemAddress & );
    protected unsigned int lastSearchIndex;
    protected struct RakNet::SystemAddress lastSearchKey;
    protected bool lastSearchIndexValid;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode
{
    void MapNode(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    void MapNode(struct RakNet::SystemAddress ,class DataStructures::ByteQueue * );
    void MapNode();
    struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & operator=(struct DataStructures::Map<RakNet::SystemAddress,DataStructures::ByteQueue *,&DataStructures::defaultMapKeyComparison<RakNet::SystemAddress> >::MapNode & );
    struct RakNet::SystemAddress mapNodeKey;
    class DataStructures::ByteQueue * mapNodeData;
};

enum RakNet::RNS2BindResult
{
    BR_SUCCESS=0,
    BR_REQUIRES_RAKNET_SUPPORT_IPV6_DEFINE=1,
    BR_FAILED_TO_BIND_SOCKET=2,
    BR_FAILED_SEND_TEST=3
};

class RakNet::IRNS2_Berkley : public RakNet::RakNetSocket2
{
    public bool IsPortInUse(unsigned int ,char * ,unsigned int ,int );
    public enum RakNet::RNS2BindResult Bind(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    public void IRNS2_Berkley(class RakNet::IRNS2_Berkley * );
    public void IRNS2_Berkley(class RakNet::IRNS2_Berkley & );
    public void IRNS2_Berkley();
    public void ~IRNS2_Berkley();
    public class RakNet::IRNS2_Berkley & operator=(class RakNet::IRNS2_Berkley * );
    public class RakNet::IRNS2_Berkley & operator=(class RakNet::IRNS2_Berkley & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::IRNS2_Berkley : public RakNet::RakNetSocket2
{
    public bool IsPortInUse(unsigned int ,char * ,unsigned int ,int );
    public enum RakNet::RNS2BindResult Bind(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    public void IRNS2_Berkley(class RakNet::IRNS2_Berkley * );
    public void IRNS2_Berkley(class RakNet::IRNS2_Berkley & );
    public void IRNS2_Berkley();
    public void ~IRNS2_Berkley();
    public class RakNet::IRNS2_Berkley & operator=(class RakNet::IRNS2_Berkley * );
    public class RakNet::IRNS2_Berkley & operator=(class RakNet::IRNS2_Berkley & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RakNetSocket2Allocator
{
    public class RakNet::RakNetSocket2 * AllocRNS2();
    public void DeallocRNS2(class RakNet::RakNetSocket2 * );
};

struct RakNet::RNS2_BerkleyBindParameters
{
    unsigned int port;
    char * hostAddress;
    unsigned int addressFamily;
    int type;
    int protocol;
    bool nonBlockingSocket;
    int setBroadcast;
    int setIPHdrIncl;
    int doNotFragment;
    int pollingThreadPriority;
    class RakNet::RNS2EventHandler * eventHandler;
    unsigned int remotePortRakNetWasStartedOn_PS3_PS4_PSP2;
};

class RakNet::RNS2_Berkley : public RakNet::IRNS2_Berkley
{
    public void RNS2_Berkley(class RakNet::RNS2_Berkley & );
    public void RNS2_Berkley();
    public void ~RNS2_Berkley();
    public int CreateRecvPollingThread(int );
    public void SignalStopRecvPollingThread();
    public void BlockOnStopRecvPollingThread();
    public struct RakNet::RNS2_BerkleyBindParameters * GetBindings();
    public int GetSocket();
    public void SetDoNotFragment(int );
    protected enum RakNet::RNS2BindResult BindShared(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    protected enum RakNet::RNS2BindResult BindSharedIPV4(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    protected enum RakNet::RNS2BindResult BindSharedIPV4And6(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    protected void GetSystemAddressIPV4(int ,struct RakNet::SystemAddress * );
    protected void GetSystemAddressIPV4And6(int ,struct RakNet::SystemAddress * );
    protected void SetNonBlockingSocket(unsigned long );
    protected void SetSocketOptions();
    protected void SetBroadcastSocket(int );
    protected void SetIPHdrIncl(int );
    protected void RecvFromBlocking(struct RakNet::RNS2RecvStruct * );
    protected void RecvFromBlockingIPV4(struct RakNet::RNS2RecvStruct * );
    protected void RecvFromBlockingIPV4And6(struct RakNet::RNS2RecvStruct * );
    protected int rns2Socket;
    protected struct RakNet::RNS2_BerkleyBindParameters binding;
    protected unsigned int RecvFromLoopInt();
    protected class RakNet::LocklessUint32_t isRecvFromLoopThreadActive;
    protected bool endThreads;
    protected unsigned int RecvFromLoop(void * );
    public class RakNet::RNS2_Berkley & operator=(class RakNet::RNS2_Berkley & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::RNS2_BerkleyBindParameters
{
    unsigned int port;
    char * hostAddress;
    unsigned int addressFamily;
    int type;
    int protocol;
    bool nonBlockingSocket;
    int setBroadcast;
    int setIPHdrIncl;
    int doNotFragment;
    int pollingThreadPriority;
    class RakNet::RNS2EventHandler * eventHandler;
    unsigned int remotePortRakNetWasStartedOn_PS3_PS4_PSP2;
};

class RakNet::RNS2_Berkley : public RakNet::IRNS2_Berkley
{
    public void RNS2_Berkley(class RakNet::RNS2_Berkley & );
    public void RNS2_Berkley();
    public void ~RNS2_Berkley();
    public int CreateRecvPollingThread(int );
    public void SignalStopRecvPollingThread();
    public void BlockOnStopRecvPollingThread();
    public struct RakNet::RNS2_BerkleyBindParameters * GetBindings();
    public int GetSocket();
    public void SetDoNotFragment(int );
    protected enum RakNet::RNS2BindResult BindShared(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    protected enum RakNet::RNS2BindResult BindSharedIPV4(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    protected enum RakNet::RNS2BindResult BindSharedIPV4And6(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    protected void GetSystemAddressIPV4(int ,struct RakNet::SystemAddress * );
    protected void GetSystemAddressIPV4And6(int ,struct RakNet::SystemAddress * );
    protected void SetNonBlockingSocket(unsigned long );
    protected void SetSocketOptions();
    protected void SetBroadcastSocket(int );
    protected void SetIPHdrIncl(int );
    protected void RecvFromBlocking(struct RakNet::RNS2RecvStruct * );
    protected void RecvFromBlockingIPV4(struct RakNet::RNS2RecvStruct * );
    protected void RecvFromBlockingIPV4And6(struct RakNet::RNS2RecvStruct * );
    protected int rns2Socket;
    protected struct RakNet::RNS2_BerkleyBindParameters binding;
    protected unsigned int RecvFromLoopInt();
    protected class RakNet::LocklessUint32_t isRecvFromLoopThreadActive;
    protected bool endThreads;
    protected unsigned int RecvFromLoop(void * );
    public class RakNet::RNS2_Berkley & operator=(class RakNet::RNS2_Berkley & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RNS2_Windows : public RakNet::RNS2_Berkley, public RakNet::RNS2_Windows_Linux_360
{
    public void RNS2_Windows(class RakNet::RNS2_Windows & );
    public void RNS2_Windows();
    public void ~RNS2_Windows();
    public enum RakNet::RNS2BindResult Bind(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    public int Send(struct RakNet::RNS2_SendParameters * ,char * ,unsigned int );
    public void SetSocketLayerOverride(class RakNet::SocketLayerOverride * );
    public class RakNet::SocketLayerOverride * GetSocketLayerOverride();
    public void GetMyIP(struct RakNet::SystemAddress * );
    protected void GetMyIPIPV4(struct RakNet::SystemAddress * );
    protected void GetMyIPIPV4And6(struct RakNet::SystemAddress * );
    protected class RakNet::SocketLayerOverride * slo;
    public class RakNet::RNS2_Windows & operator=(class RakNet::RNS2_Windows & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RNS2_Windows : public RakNet::RNS2_Berkley, public RakNet::RNS2_Windows_Linux_360
{
    public void RNS2_Windows(class RakNet::RNS2_Windows & );
    public void RNS2_Windows();
    public void ~RNS2_Windows();
    public enum RakNet::RNS2BindResult Bind(struct RakNet::RNS2_BerkleyBindParameters * ,char * ,unsigned int );
    public int Send(struct RakNet::RNS2_SendParameters * ,char * ,unsigned int );
    public void SetSocketLayerOverride(class RakNet::SocketLayerOverride * );
    public class RakNet::SocketLayerOverride * GetSocketLayerOverride();
    public void GetMyIP(struct RakNet::SystemAddress * );
    protected void GetMyIPIPV4(struct RakNet::SystemAddress * );
    protected void GetMyIPIPV4And6(struct RakNet::SystemAddress * );
    protected class RakNet::SocketLayerOverride * slo;
    public class RakNet::RNS2_Windows & operator=(class RakNet::RNS2_Windows & );
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

class RakNet::RNS2_Windows_Linux_360
{
    protected int Send_Windows_Linux_360NoVDP(int ,struct RakNet::RNS2_SendParameters * ,char * ,unsigned int );
};

class RakNet::RakNetRandom
{
    public void RakNetRandom();
    public void ~RakNetRandom();
    public void SeedMT(unsigned int );
    public unsigned int ReloadMT();
    public unsigned int RandomMT();
    public float FrandomMT();
    public void FillBufferMT(void * ,unsigned int );
    protected unsigned int state[625];
    protected unsigned int * next;
    protected int left;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::BPSTracker
{
    void BPSTracker(struct RakNet::BPSTracker & );
    void BPSTracker();
    void ~BPSTracker();
    void Reset(char * ,unsigned int );
    void Push1(unsigned int ,unsigned int );
    unsigned int GetBPS1(unsigned int );
    unsigned int GetBPS1Threadsafe(unsigned int );
    unsigned int GetTotal1();
    struct TimeAndValue2
    {
        void TimeAndValue2(unsigned int ,unsigned int );
        void TimeAndValue2();
        void ~TimeAndValue2();
        unsigned int value1;
        unsigned int time;
        void * __vecDelDtor(unsigned int );
    };
    unsigned int total1;
    unsigned int lastSec1;
    class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2> dataQueue;
    void ClearExpired1(unsigned int );
    struct RakNet::BPSTracker & operator=(struct RakNet::BPSTracker & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::BPSTracker
{
    void BPSTracker(struct RakNet::BPSTracker & );
    void BPSTracker();
    void ~BPSTracker();
    void Reset(char * ,unsigned int );
    void Push1(unsigned int ,unsigned int );
    unsigned int GetBPS1(unsigned int );
    unsigned int GetBPS1Threadsafe(unsigned int );
    unsigned int GetTotal1();
    struct TimeAndValue2
    {
        void TimeAndValue2(unsigned int ,unsigned int );
        void TimeAndValue2();
        void ~TimeAndValue2();
        unsigned int value1;
        unsigned int time;
        void * __vecDelDtor(unsigned int );
    };
    unsigned int total1;
    unsigned int lastSec1;
    class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2> dataQueue;
    void ClearExpired1(unsigned int );
    struct RakNet::BPSTracker & operator=(struct RakNet::BPSTracker & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::BPSTracker::TimeAndValue2
{
    void TimeAndValue2(unsigned int ,unsigned int );
    void TimeAndValue2();
    void ~TimeAndValue2();
    unsigned int value1;
    unsigned int time;
    void * __vecDelDtor(unsigned int );
};

struct RakNet::InternalPacketRefCountedData
{
    unsigned int * sharedDataBlock;
    unsigned int refCount;
};

class RakNet::ReliabilityLayer
{
    public void ReliabilityLayer(class RakNet::ReliabilityLayer & );
    public void ReliabilityLayer();
    public void ~ReliabilityLayer();
    public void Reset(bool ,int ,bool );
    public void SetTimeoutTime(unsigned int );
    public unsigned int GetTimeoutTime();
    public bool HandleSocketReceiveFromConnectedPlayer(char * ,unsigned int ,struct RakNet::SystemAddress & ,class DataStructures::List<RakNet::PluginInterface2 *> & ,int ,class RakNet::RakNetSocket2 * ,class RakNet::RakNetRandom * ,unsigned int ,class RakNet::BitStream & );
    public unsigned int Receive(unsigned int ** );
    public bool Send(char * ,unsigned int ,enum PacketPriority ,enum PacketReliability ,unsigned int ,bool ,int ,unsigned int ,unsigned int );
    public void Update(class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,int ,unsigned int ,unsigned int ,class DataStructures::List<RakNet::PluginInterface2 *> & ,class RakNet::RakNetRandom * ,class RakNet::BitStream & );
    public bool IsDeadConnection();
    public void KillConnection();
    public struct RakNet::RakNetStatistics * GetStatistics(struct RakNet::RakNetStatistics * );
    public bool IsOutgoingDataWaiting();
    public bool AreAcksWaiting();
    public void ApplyNetworkSimulator(float ,unsigned int ,unsigned int );
    public bool IsNetworkSimulatorActive();
    public void SetSplitMessageProgressInterval(int );
    public void SetUnreliableTimeout(unsigned int );
    public bool AckTimeout(unsigned int );
    public unsigned int GetNextSendTime();
    public unsigned int GetTimeBetweenPackets();
    public unsigned int GetTimeLastDatagramArrived();
    private void SendBitStream(class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,class RakNet::BitStream * ,class RakNet::RakNetRandom * ,unsigned int );
    private unsigned int WriteToBitStreamFromInternalPacket(class RakNet::BitStream * ,const struct RakNet::InternalPacket * ,unsigned int );
    private struct RakNet::InternalPacket * CreateInternalPacketFromBitStream(class RakNet::BitStream * ,unsigned int );
    private unsigned int RemovePacketFromResendListAndDeleteOlderReliableSequenced(const struct RakNet::uint24_t ,unsigned int ,class DataStructures::List<RakNet::PluginInterface2 *> & ,struct RakNet::SystemAddress & );
    private void SendAcknowledgementPacket(const struct RakNet::uint24_t ,unsigned int );
    private bool IsSendThrottled(int );
    private void UpdateWindowFromPacketloss(unsigned int );
    private void UpdateWindowFromAck(unsigned int );
    private unsigned int GetMaxMessageHeaderLengthBits();
    private unsigned int GetMessageHeaderLengthBits(const struct RakNet::InternalPacket * );
    private void GetSHA1(const unsigned int * ,unsigned int ,char * );
    private bool CheckSHA1(char * ,const unsigned int * ,unsigned int );
    private bool IsOlderOrderedPacket(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    private void SplitPacket(struct RakNet::InternalPacket * );
    private void InsertIntoSplitPacketList(struct RakNet::InternalPacket * ,unsigned int );
    private struct RakNet::InternalPacket * BuildPacketFromSplitPacketList(struct RakNet::SplitPacketChannel * ,unsigned int );
    private struct RakNet::InternalPacket * BuildPacketFromSplitPacketList(unsigned int ,unsigned int ,class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,class RakNet::RakNetRandom * ,class RakNet::BitStream & );
    private struct RakNet::InternalPacket * CreateInternalPacketCopy(struct RakNet::InternalPacket * ,int ,int ,unsigned int );
    private void InsertPacketIntoResendList(struct RakNet::InternalPacket * ,unsigned int ,bool ,bool );
    private void FreeMemory(bool );
    private void FreeThreadSafeMemory();
    private void InitializeVariables();
    private bool IsExpiredTime(unsigned int ,unsigned int );
    private void UpdateNextActionTime();
    private unsigned int GetResendListDataSize();
    private void UpdateThreadedMemory();
    private void CalculateHistogramAckSize();
    private class DataStructures::Queue<RakNet::InternalPacket *> outputQueue;
    private int splitMessageProgressInterval;
    private unsigned int unreliableTimeout;
    struct MessageNumberNode
    {
        struct RakNet::uint24_t messageNumber;
        struct RakNet::ReliabilityLayer::MessageNumberNode * next;
        void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode * );
        void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode & );
        void MessageNumberNode();
        struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode * );
        struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode & );
    };
    struct DatagramHistoryNode
    {
        void DatagramHistoryNode(struct RakNet::ReliabilityLayer::MessageNumberNode * ,unsigned int );
        void DatagramHistoryNode();
        struct RakNet::ReliabilityLayer::MessageNumberNode * head;
        unsigned int timeSent;
    };
    private class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode> datagramHistory;
    private class DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode> datagramHistoryMessagePool;
    struct UnreliableWithAckReceiptNode
    {
        void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
        void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
        void UnreliableWithAckReceiptNode(struct RakNet::uint24_t ,unsigned int ,unsigned int );
        void UnreliableWithAckReceiptNode();
        struct RakNet::uint24_t datagramNumber;
        unsigned int sendReceiptSerial;
        unsigned int nextActionTime;
        struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
        struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    };
    private class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> unreliableWithAckReceiptHistory;
    private void RemoveFromDatagramHistory(struct RakNet::uint24_t );
    private struct RakNet::ReliabilityLayer::MessageNumberNode * GetMessageNumberNodeByDatagramIndex(struct RakNet::uint24_t ,unsigned int * );
    private struct RakNet::ReliabilityLayer::MessageNumberNode * AddFirstToDatagramHistory(struct RakNet::uint24_t ,struct RakNet::uint24_t ,unsigned int );
    private void AddFirstToDatagramHistory(struct RakNet::uint24_t ,unsigned int );
    private struct RakNet::ReliabilityLayer::MessageNumberNode * AddSubsequentToDatagramHistory(struct RakNet::ReliabilityLayer::MessageNumberNode * ,struct RakNet::uint24_t );
    private struct RakNet::uint24_t datagramHistoryPopCount;
    private class DataStructures::MemoryPool<RakNet::InternalPacket> internalPacketPool;
    private struct RakNet::InternalPacket * resendBuffer[512];
    private struct RakNet::InternalPacket * resendLinkedListHead;
    private struct RakNet::InternalPacket * unreliableLinkedListHead;
    private void RemoveFromUnreliableLinkedList(struct RakNet::InternalPacket * );
    private void AddToUnreliableLinkedList(struct RakNet::InternalPacket * );
    private unsigned int timeLastDatagramArrived;
    private class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> outgoingPacketBuffer;
    private unsigned int outgoingPacketBufferNextWeights[4];
    private void InitHeapWeights();
    private unsigned int GetNextWeight(int );
    private class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> splitPacketChannelList;
    private struct RakNet::uint24_t sendReliableMessageNumberIndex;
    private struct RakNet::uint24_t internalOrderIndex;
    private bool deadConnection;
    private bool cheater;
    private unsigned int splitPacketId;
    private unsigned int timeoutTime;
    private struct RakNet::RakNetStatistics statistics;
    private struct RakNet::uint24_t orderedWriteIndex[32];
    private struct RakNet::uint24_t sequencedWriteIndex[32];
    private struct RakNet::uint24_t orderedReadIndex[32];
    private struct RakNet::uint24_t highestSequencedReadIndex[32];
    private class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> orderingHeaps[32];
    private struct RakNet::uint24_t heapIndexOffsets[32];
    private class DataStructures::Queue<bool> hasReceivedPacketQueue;
    private struct RakNet::uint24_t receivedPacketsBaseIndex;
    private bool resetReceivedPackets;
    private unsigned int lastUpdateTime;
    private unsigned int timeBetweenPackets;
    private unsigned int nextSendTime;
    private unsigned int ackPingSum;
    private unsigned int ackPingIndex;
    private unsigned int remoteSystemTime;
    private unsigned int nextAllowedThroughputSample;
    private bool bandwidthExceededStatistic;
    private int throughputCapCountdown;
    private unsigned int receivePacketCount;
    private unsigned int elapsedTimeSinceLastUpdate;
    private unsigned int nextAckTimeToSend;
    private class RakNet::CCRakNetSlidingWindow congestionManager;
    private unsigned int unacknowledgedBytes;
    private bool ResendBufferOverflow();
    private void ValidateResendList();
    private void ResetPacketsAndDatagrams();
    private void PushPacket(unsigned int ,struct RakNet::InternalPacket * ,bool );
    private void PushDatagram();
    private bool TagMostRecentPushAsSecondOfPacketPair();
    private void ClearPacketsAndDatagrams();
    private void MoveToListHead(struct RakNet::InternalPacket * );
    private void RemoveFromList(struct RakNet::InternalPacket * ,bool );
    private void AddToListTail(struct RakNet::InternalPacket * ,bool );
    private void PopListHead(bool );
    private bool IsResendQueueEmpty();
    private void SortSplitPacketList(class DataStructures::List<RakNet::InternalPacket *> & ,unsigned int ,unsigned int );
    private void SendACKs(class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,unsigned int ,class RakNet::RakNetRandom * ,class RakNet::BitStream & );
    private class DataStructures::List<RakNet::InternalPacket *> packetsToSendThisUpdate;
    private class DataStructures::List<bool> packetsToDeallocThisUpdate;
    private class DataStructures::List<unsigned int> packetsToSendThisUpdateDatagramBoundaries;
    private class DataStructures::List<bool> datagramsToSendThisUpdateIsPair;
    private class DataStructures::List<unsigned int> datagramSizesInBytes;
    private unsigned int datagramSizeSoFar;
    private unsigned int allDatagramSizesSoFar;
    private float totalUserDataBytesAcked;
    private unsigned int timeOfLastContinualSend;
    private unsigned int timeToNextUnreliableCull;
    private class DataStructures::RangeList<RakNet::uint24_t> incomingAcks;
    private int countdownToNextPacketPair;
    private struct RakNet::InternalPacket * AllocateFromInternalPacketPool();
    private void ReleaseToInternalPacketPool(struct RakNet::InternalPacket * );
    private class DataStructures::RangeList<RakNet::uint24_t> acknowlegements;
    private class DataStructures::RangeList<RakNet::uint24_t> NAKs;
    private bool remoteSystemNeedsBAndAS;
    private unsigned int GetMaxDatagramSizeExcludingMessageHeaderBytes();
    private unsigned int GetMaxDatagramSizeExcludingMessageHeaderBits();
    private void AllocInternalPacketData(struct RakNet::InternalPacket * ,unsigned int ,bool ,char * ,unsigned int );
    private void AllocInternalPacketData(struct RakNet::InternalPacket * ,unsigned int * );
    private void AllocInternalPacketData(struct RakNet::InternalPacket * ,struct RakNet::InternalPacketRefCountedData ** ,unsigned int * ,unsigned int * );
    private void FreeInternalPacketData(struct RakNet::InternalPacket * ,char * ,unsigned int );
    private class DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData> refCountedDataPool;
    private struct RakNet::BPSTracker bpsMetrics[7];
    private unsigned int lastBpsClear;
    public class RakNet::ReliabilityLayer & operator=(class RakNet::ReliabilityLayer & );
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::InternalPacket : public RakNet::InternalPacketFixedSizeTransmissionHeader
{
    struct RakNet::uint24_t messageInternalOrder;
    bool messageNumberAssigned;
    unsigned int creationTime;
    unsigned int nextActionTime;
    unsigned int retransmissionTime;
    unsigned int headerLength;
    unsigned int * data;
    enum AllocationScheme
    {
        NORMAL=0,
        REF_COUNTED=1,
        STACK=2
    };
    enum RakNet::InternalPacket::AllocationScheme allocationScheme;
    struct RakNet::InternalPacketRefCountedData * refCountedData;
    unsigned int timesSent;
    enum PacketPriority priority;
    unsigned int sendReceiptSerial;
    struct RakNet::InternalPacket * resendPrev;
    struct RakNet::InternalPacket * resendNext;
    struct RakNet::InternalPacket * unreliablePrev;
    struct RakNet::InternalPacket * unreliableNext;
    unsigned int stackData[128];
    void InternalPacket(struct RakNet::InternalPacket * );
    void InternalPacket(struct RakNet::InternalPacket & );
    void InternalPacket();
    struct RakNet::InternalPacket & operator=(struct RakNet::InternalPacket * );
    struct RakNet::InternalPacket & operator=(struct RakNet::InternalPacket & );
};

class RakNet::ReliabilityLayer
{
    public void ReliabilityLayer(class RakNet::ReliabilityLayer & );
    public void ReliabilityLayer();
    public void ~ReliabilityLayer();
    public void Reset(bool ,int ,bool );
    public void SetTimeoutTime(unsigned int );
    public unsigned int GetTimeoutTime();
    public bool HandleSocketReceiveFromConnectedPlayer(char * ,unsigned int ,struct RakNet::SystemAddress & ,class DataStructures::List<RakNet::PluginInterface2 *> & ,int ,class RakNet::RakNetSocket2 * ,class RakNet::RakNetRandom * ,unsigned int ,class RakNet::BitStream & );
    public unsigned int Receive(unsigned int ** );
    public bool Send(char * ,unsigned int ,enum PacketPriority ,enum PacketReliability ,unsigned int ,bool ,int ,unsigned int ,unsigned int );
    public void Update(class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,int ,unsigned int ,unsigned int ,class DataStructures::List<RakNet::PluginInterface2 *> & ,class RakNet::RakNetRandom * ,class RakNet::BitStream & );
    public bool IsDeadConnection();
    public void KillConnection();
    public struct RakNet::RakNetStatistics * GetStatistics(struct RakNet::RakNetStatistics * );
    public bool IsOutgoingDataWaiting();
    public bool AreAcksWaiting();
    public void ApplyNetworkSimulator(float ,unsigned int ,unsigned int );
    public bool IsNetworkSimulatorActive();
    public void SetSplitMessageProgressInterval(int );
    public void SetUnreliableTimeout(unsigned int );
    public bool AckTimeout(unsigned int );
    public unsigned int GetNextSendTime();
    public unsigned int GetTimeBetweenPackets();
    public unsigned int GetTimeLastDatagramArrived();
    private void SendBitStream(class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,class RakNet::BitStream * ,class RakNet::RakNetRandom * ,unsigned int );
    private unsigned int WriteToBitStreamFromInternalPacket(class RakNet::BitStream * ,const struct RakNet::InternalPacket * ,unsigned int );
    private struct RakNet::InternalPacket * CreateInternalPacketFromBitStream(class RakNet::BitStream * ,unsigned int );
    private unsigned int RemovePacketFromResendListAndDeleteOlderReliableSequenced(const struct RakNet::uint24_t ,unsigned int ,class DataStructures::List<RakNet::PluginInterface2 *> & ,struct RakNet::SystemAddress & );
    private void SendAcknowledgementPacket(const struct RakNet::uint24_t ,unsigned int );
    private bool IsSendThrottled(int );
    private void UpdateWindowFromPacketloss(unsigned int );
    private void UpdateWindowFromAck(unsigned int );
    private unsigned int GetMaxMessageHeaderLengthBits();
    private unsigned int GetMessageHeaderLengthBits(const struct RakNet::InternalPacket * );
    private void GetSHA1(const unsigned int * ,unsigned int ,char * );
    private bool CheckSHA1(char * ,const unsigned int * ,unsigned int );
    private bool IsOlderOrderedPacket(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    private void SplitPacket(struct RakNet::InternalPacket * );
    private void InsertIntoSplitPacketList(struct RakNet::InternalPacket * ,unsigned int );
    private struct RakNet::InternalPacket * BuildPacketFromSplitPacketList(struct RakNet::SplitPacketChannel * ,unsigned int );
    private struct RakNet::InternalPacket * BuildPacketFromSplitPacketList(unsigned int ,unsigned int ,class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,class RakNet::RakNetRandom * ,class RakNet::BitStream & );
    private struct RakNet::InternalPacket * CreateInternalPacketCopy(struct RakNet::InternalPacket * ,int ,int ,unsigned int );
    private void InsertPacketIntoResendList(struct RakNet::InternalPacket * ,unsigned int ,bool ,bool );
    private void FreeMemory(bool );
    private void FreeThreadSafeMemory();
    private void InitializeVariables();
    private bool IsExpiredTime(unsigned int ,unsigned int );
    private void UpdateNextActionTime();
    private unsigned int GetResendListDataSize();
    private void UpdateThreadedMemory();
    private void CalculateHistogramAckSize();
    private class DataStructures::Queue<RakNet::InternalPacket *> outputQueue;
    private int splitMessageProgressInterval;
    private unsigned int unreliableTimeout;
    struct MessageNumberNode
    {
        struct RakNet::uint24_t messageNumber;
        struct RakNet::ReliabilityLayer::MessageNumberNode * next;
        void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode * );
        void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode & );
        void MessageNumberNode();
        struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode * );
        struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode & );
    };
    struct DatagramHistoryNode
    {
        void DatagramHistoryNode(struct RakNet::ReliabilityLayer::MessageNumberNode * ,unsigned int );
        void DatagramHistoryNode();
        struct RakNet::ReliabilityLayer::MessageNumberNode * head;
        unsigned int timeSent;
    };
    private class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode> datagramHistory;
    private class DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode> datagramHistoryMessagePool;
    struct UnreliableWithAckReceiptNode
    {
        void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
        void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
        void UnreliableWithAckReceiptNode(struct RakNet::uint24_t ,unsigned int ,unsigned int );
        void UnreliableWithAckReceiptNode();
        struct RakNet::uint24_t datagramNumber;
        unsigned int sendReceiptSerial;
        unsigned int nextActionTime;
        struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
        struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    };
    private class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> unreliableWithAckReceiptHistory;
    private void RemoveFromDatagramHistory(struct RakNet::uint24_t );
    private struct RakNet::ReliabilityLayer::MessageNumberNode * GetMessageNumberNodeByDatagramIndex(struct RakNet::uint24_t ,unsigned int * );
    private struct RakNet::ReliabilityLayer::MessageNumberNode * AddFirstToDatagramHistory(struct RakNet::uint24_t ,struct RakNet::uint24_t ,unsigned int );
    private void AddFirstToDatagramHistory(struct RakNet::uint24_t ,unsigned int );
    private struct RakNet::ReliabilityLayer::MessageNumberNode * AddSubsequentToDatagramHistory(struct RakNet::ReliabilityLayer::MessageNumberNode * ,struct RakNet::uint24_t );
    private struct RakNet::uint24_t datagramHistoryPopCount;
    private class DataStructures::MemoryPool<RakNet::InternalPacket> internalPacketPool;
    private struct RakNet::InternalPacket * resendBuffer[512];
    private struct RakNet::InternalPacket * resendLinkedListHead;
    private struct RakNet::InternalPacket * unreliableLinkedListHead;
    private void RemoveFromUnreliableLinkedList(struct RakNet::InternalPacket * );
    private void AddToUnreliableLinkedList(struct RakNet::InternalPacket * );
    private unsigned int timeLastDatagramArrived;
    private class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> outgoingPacketBuffer;
    private unsigned int outgoingPacketBufferNextWeights[4];
    private void InitHeapWeights();
    private unsigned int GetNextWeight(int );
    private class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> splitPacketChannelList;
    private struct RakNet::uint24_t sendReliableMessageNumberIndex;
    private struct RakNet::uint24_t internalOrderIndex;
    private bool deadConnection;
    private bool cheater;
    private unsigned int splitPacketId;
    private unsigned int timeoutTime;
    private struct RakNet::RakNetStatistics statistics;
    private struct RakNet::uint24_t orderedWriteIndex[32];
    private struct RakNet::uint24_t sequencedWriteIndex[32];
    private struct RakNet::uint24_t orderedReadIndex[32];
    private struct RakNet::uint24_t highestSequencedReadIndex[32];
    private class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> orderingHeaps[32];
    private struct RakNet::uint24_t heapIndexOffsets[32];
    private class DataStructures::Queue<bool> hasReceivedPacketQueue;
    private struct RakNet::uint24_t receivedPacketsBaseIndex;
    private bool resetReceivedPackets;
    private unsigned int lastUpdateTime;
    private unsigned int timeBetweenPackets;
    private unsigned int nextSendTime;
    private unsigned int ackPingSum;
    private unsigned int ackPingIndex;
    private unsigned int remoteSystemTime;
    private unsigned int nextAllowedThroughputSample;
    private bool bandwidthExceededStatistic;
    private int throughputCapCountdown;
    private unsigned int receivePacketCount;
    private unsigned int elapsedTimeSinceLastUpdate;
    private unsigned int nextAckTimeToSend;
    private class RakNet::CCRakNetSlidingWindow congestionManager;
    private unsigned int unacknowledgedBytes;
    private bool ResendBufferOverflow();
    private void ValidateResendList();
    private void ResetPacketsAndDatagrams();
    private void PushPacket(unsigned int ,struct RakNet::InternalPacket * ,bool );
    private void PushDatagram();
    private bool TagMostRecentPushAsSecondOfPacketPair();
    private void ClearPacketsAndDatagrams();
    private void MoveToListHead(struct RakNet::InternalPacket * );
    private void RemoveFromList(struct RakNet::InternalPacket * ,bool );
    private void AddToListTail(struct RakNet::InternalPacket * ,bool );
    private void PopListHead(bool );
    private bool IsResendQueueEmpty();
    private void SortSplitPacketList(class DataStructures::List<RakNet::InternalPacket *> & ,unsigned int ,unsigned int );
    private void SendACKs(class RakNet::RakNetSocket2 * ,struct RakNet::SystemAddress & ,unsigned int ,class RakNet::RakNetRandom * ,class RakNet::BitStream & );
    private class DataStructures::List<RakNet::InternalPacket *> packetsToSendThisUpdate;
    private class DataStructures::List<bool> packetsToDeallocThisUpdate;
    private class DataStructures::List<unsigned int> packetsToSendThisUpdateDatagramBoundaries;
    private class DataStructures::List<bool> datagramsToSendThisUpdateIsPair;
    private class DataStructures::List<unsigned int> datagramSizesInBytes;
    private unsigned int datagramSizeSoFar;
    private unsigned int allDatagramSizesSoFar;
    private float totalUserDataBytesAcked;
    private unsigned int timeOfLastContinualSend;
    private unsigned int timeToNextUnreliableCull;
    private class DataStructures::RangeList<RakNet::uint24_t> incomingAcks;
    private int countdownToNextPacketPair;
    private struct RakNet::InternalPacket * AllocateFromInternalPacketPool();
    private void ReleaseToInternalPacketPool(struct RakNet::InternalPacket * );
    private class DataStructures::RangeList<RakNet::uint24_t> acknowlegements;
    private class DataStructures::RangeList<RakNet::uint24_t> NAKs;
    private bool remoteSystemNeedsBAndAS;
    private unsigned int GetMaxDatagramSizeExcludingMessageHeaderBytes();
    private unsigned int GetMaxDatagramSizeExcludingMessageHeaderBits();
    private void AllocInternalPacketData(struct RakNet::InternalPacket * ,unsigned int ,bool ,char * ,unsigned int );
    private void AllocInternalPacketData(struct RakNet::InternalPacket * ,unsigned int * );
    private void AllocInternalPacketData(struct RakNet::InternalPacket * ,struct RakNet::InternalPacketRefCountedData ** ,unsigned int * ,unsigned int * );
    private void FreeInternalPacketData(struct RakNet::InternalPacket * ,char * ,unsigned int );
    private class DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData> refCountedDataPool;
    private struct RakNet::BPSTracker bpsMetrics[7];
    private unsigned int lastBpsClear;
    public class RakNet::ReliabilityLayer & operator=(class RakNet::ReliabilityLayer & );
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode
{
    void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
    void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    void UnreliableWithAckReceiptNode(struct RakNet::uint24_t ,unsigned int ,unsigned int );
    void UnreliableWithAckReceiptNode();
    struct RakNet::uint24_t datagramNumber;
    unsigned int sendReceiptSerial;
    unsigned int nextActionTime;
    struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
    struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
};

struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode
{
    void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
    void UnreliableWithAckReceiptNode(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    void UnreliableWithAckReceiptNode(struct RakNet::uint24_t ,unsigned int ,unsigned int );
    void UnreliableWithAckReceiptNode();
    struct RakNet::uint24_t datagramNumber;
    unsigned int sendReceiptSerial;
    unsigned int nextActionTime;
    struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * );
    struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator=(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
};

struct RakNet::ReliabilityLayer::DatagramHistoryNode
{
    void DatagramHistoryNode(struct RakNet::ReliabilityLayer::MessageNumberNode * ,unsigned int );
    void DatagramHistoryNode();
    struct RakNet::ReliabilityLayer::MessageNumberNode * head;
    unsigned int timeSent;
};

struct RakNet::ReliabilityLayer::MessageNumberNode
{
    struct RakNet::uint24_t messageNumber;
    struct RakNet::ReliabilityLayer::MessageNumberNode * next;
    void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode * );
    void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode & );
    void MessageNumberNode();
    struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode * );
    struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode & );
};

struct RakNet::ReliabilityLayer::MessageNumberNode
{
    struct RakNet::uint24_t messageNumber;
    struct RakNet::ReliabilityLayer::MessageNumberNode * next;
    void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode * );
    void MessageNumberNode(struct RakNet::ReliabilityLayer::MessageNumberNode & );
    void MessageNumberNode();
    struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode * );
    struct RakNet::ReliabilityLayer::MessageNumberNode & operator=(struct RakNet::ReliabilityLayer::MessageNumberNode & );
};

enum RakNet::InternalPacket::AllocationScheme
{
    NORMAL=0,
    REF_COUNTED=1,
    STACK=2
};

struct RakNet::InternalPacket : public RakNet::InternalPacketFixedSizeTransmissionHeader
{
    struct RakNet::uint24_t messageInternalOrder;
    bool messageNumberAssigned;
    unsigned int creationTime;
    unsigned int nextActionTime;
    unsigned int retransmissionTime;
    unsigned int headerLength;
    unsigned int * data;
    enum AllocationScheme
    {
        NORMAL=0,
        REF_COUNTED=1,
        STACK=2
    };
    enum RakNet::InternalPacket::AllocationScheme allocationScheme;
    struct RakNet::InternalPacketRefCountedData * refCountedData;
    unsigned int timesSent;
    enum PacketPriority priority;
    unsigned int sendReceiptSerial;
    struct RakNet::InternalPacket * resendPrev;
    struct RakNet::InternalPacket * resendNext;
    struct RakNet::InternalPacket * unreliablePrev;
    struct RakNet::InternalPacket * unreliableNext;
    unsigned int stackData[128];
    void InternalPacket(struct RakNet::InternalPacket * );
    void InternalPacket(struct RakNet::InternalPacket & );
    void InternalPacket();
    struct RakNet::InternalPacket & operator=(struct RakNet::InternalPacket * );
    struct RakNet::InternalPacket & operator=(struct RakNet::InternalPacket & );
};

class RakNet::SortedSplittedPackets
{
    private struct RakNet::InternalPacket ** data;
    private unsigned int allocation_size;
    private unsigned int addedPacketsCount;
    private unsigned int packetId;
    public void SortedSplittedPackets();
    public void ~SortedSplittedPackets();
    public void Preallocate(struct RakNet::InternalPacket * ,char * ,unsigned int );
    public bool Add(struct RakNet::InternalPacket * ,char * ,unsigned int );
    public unsigned int AllocSize();
    public unsigned int AddedPacketsCount();
    public struct RakNet::InternalPacket * Get(unsigned int );
    public unsigned int PacketId();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::RemoteSystemIndex
{
    unsigned int index;
    struct RakNet::RemoteSystemIndex * next;
};

class RakNet::RakPeer : public RakNet::RakPeerInterface, public RakNet::RNS2EventHandler
{
    public void RakPeer();
    public void ~RakPeer();
    public enum RakNet::StartupResult Startup(unsigned int ,struct RakNet::SocketDescriptor * ,unsigned int ,int );
    public bool InitializeSecurity(char * ,char * ,bool );
    public void DisableSecurity();
    public void AddToSecurityExceptionList(char * );
    public void RemoveFromSecurityExceptionList(char * );
    public bool IsInSecurityExceptionList(char * );
    public void SetMaximumIncomingConnections(unsigned int );
    public unsigned int GetMaximumIncomingConnections();
    public unsigned int NumberOfConnections();
    public void SetIncomingPassword(char * ,int );
    public void GetIncomingPassword(char * ,int * );
    public enum RakNet::ConnectionAttemptResult Connect(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public enum RakNet::ConnectionAttemptResult ConnectWithSocket(char * ,unsigned int ,char * ,int ,class RakNet::RakNetSocket2 * ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int );
    public void Shutdown(unsigned int ,unsigned int ,enum PacketPriority );
    public bool IsActive();
    public bool GetConnectionList(struct RakNet::SystemAddress * ,unsigned int * );
    public unsigned int GetNextSendReceipt();
    public unsigned int IncrementNextSendReceipt();
    public unsigned int Send(class RakNet::BitStream * ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public unsigned int Send(char * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public void SendLoopback(char * ,const int );
    public unsigned int SendList(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public struct RakNet::Packet * Receive();
    public void DeallocatePacket(struct RakNet::Packet * );
    public unsigned int GetMaximumNumberOfPeers();
    public void CloseConnection(const struct RakNet::AddressOrGUID ,bool ,unsigned int ,enum PacketPriority );
    public void CancelConnectionAttempt(const struct RakNet::SystemAddress );
    public enum RakNet::ConnectionState GetConnectionState(const struct RakNet::AddressOrGUID );
    protected int GetIndexFromSystemAddress(const struct RakNet::SystemAddress ,bool );
    public int GetIndexFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromIndex(unsigned int );
    public struct RakNet::RakNetGUID GetGUIDFromIndex(unsigned int );
    public void GetSystemList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & );
    public void AddToBanList(char * ,unsigned int );
    public void RemoveFromBanList(char * );
    public void ClearBanList();
    public bool IsBanned(char * );
    public void SetLimitIPConnectionFrequency(bool );
    public bool Ping(char * ,unsigned int ,bool ,unsigned int );
    public void Ping(const struct RakNet::SystemAddress );
    public int GetAveragePing(const struct RakNet::AddressOrGUID );
    public int GetLastPing(const struct RakNet::AddressOrGUID );
    public int GetLowestPing(const struct RakNet::AddressOrGUID );
    public void SetOccasionalPing(bool );
    public unsigned int GetClockDifferential(const struct RakNet::AddressOrGUID );
    public void SetOfflinePingResponse(char * ,const unsigned int );
    public void GetOfflinePingResponse(char ** ,unsigned int * );
    public struct RakNet::SystemAddress GetInternalID(const struct RakNet::SystemAddress ,const int );
    public void SetInternalID(struct RakNet::SystemAddress ,int );
    public struct RakNet::SystemAddress GetExternalID(const struct RakNet::SystemAddress );
    public const struct RakNet::RakNetGUID GetMyGUID();
    public struct RakNet::SystemAddress GetMyBoundAddress(const int );
    public struct RakNet::RakNetGUID & GetGuidFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromGuid(const struct RakNet::RakNetGUID );
    public bool GetClientPublicKeyFromSystemAddress(const struct RakNet::SystemAddress ,char * );
    public void SetTimeoutTime(unsigned int ,const struct RakNet::SystemAddress );
    public unsigned int GetTimeoutTime(const struct RakNet::SystemAddress );
    public int GetMTUSize(const struct RakNet::SystemAddress );
    public unsigned int GetNumberOfAddresses();
    public char * GetLocalIP(unsigned int );
    public bool IsLocalIP(char * );
    public void AllowConnectionResponseIPMigration(bool );
    public bool AdvertiseSystem(char * ,unsigned int ,char * ,int ,unsigned int );
    public void SetSplitMessageProgressInterval(int );
    public int GetSplitMessageProgressInterval();
    public void SetUnreliableTimeout(unsigned int );
    public void SendTTL(char * ,unsigned int ,int ,unsigned int );
    public void AttachPlugin(class RakNet::PluginInterface2 * );
    public void DetachPlugin(class RakNet::PluginInterface2 * );
    public void PushBackPacket(struct RakNet::Packet * ,bool );
    public void ChangeSystemAddress(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    public struct RakNet::Packet * AllocatePacket(unsigned int );
    public class RakNet::RakNetSocket2 * GetSocket(const struct RakNet::SystemAddress );
    public void GetSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void ReleaseSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void WriteOutOfBandHeader(class RakNet::BitStream * );
    public void SetUserUpdateThread(void  ( * )(class RakNet::RakPeerInterface * ,void * ),void * );
    public void SetIncomingDatagramEventHandler(bool  ( * )(struct RakNet::RNS2RecvStruct * ));
    public void ApplyNetworkSimulator(float ,unsigned int ,unsigned int );
    public void SetPerConnectionOutgoingBandwidthLimit(unsigned int );
    public bool IsNetworkSimulatorActive();
    public bool GetStatistics(const unsigned int ,struct RakNet::RakNetStatistics * );
    public struct RakNet::RakNetStatistics * GetStatistics(const struct RakNet::SystemAddress ,struct RakNet::RakNetStatistics * );
    public void GetStatisticsList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & ,class DataStructures::List<RakNet::RakNetStatistics> & );
    public unsigned int GetReceiveBufferSize();
    public bool RunUpdateCycle(class RakNet::BitStream & );
    public bool SendOutOfBand(char * ,unsigned int ,char * ,unsigned int ,unsigned int );
    struct PingAndClockDifferential
    {
        unsigned int pingTime;
        unsigned int clockDifferential;
    };
    struct RemoteSystemStruct
    {
        bool isActive;
        struct RakNet::SystemAddress systemAddress;
        struct RakNet::SystemAddress myExternalSystemAddress;
        struct RakNet::SystemAddress theirInternalSystemAddress[10];
        class RakNet::ReliabilityLayer reliabilityLayer;
        bool weInitiatedTheConnection;
        struct RakNet::RakPeer::PingAndClockDifferential pingAndClockDifferential[5];
        unsigned int pingAndClockDifferentialWriteIndex;
        unsigned int lowestPing;
        unsigned int nextPingTime;
        unsigned int lastReliableSend;
        unsigned int connectionTime;
        struct RakNet::RakNetGUID guid;
        int MTUSize;
        class RakNet::RakNetSocket2 * rakNetSocket;
        unsigned int remoteSystemIndex;
        enum ConnectMode
        {
            NO_ACTION=0,
            DISCONNECT_ASAP=1,
            DISCONNECT_ASAP_SILENTLY=2,
            DISCONNECT_ON_NO_ACK=3,
            REQUESTED_CONNECTION=4,
            HANDLING_CONNECTION_REQUEST=5,
            UNVERIFIED_SENDER=6,
            CONNECTED=7
        };
        enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectMode;
        void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct * );
        void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct & );
        void RemoteSystemStruct();
        void ~RemoteSystemStruct();
        struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct * );
        struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct & );
        void * __vecDelDtor(unsigned int );
    };
    protected int GetIndexFromGuid(const struct RakNet::RakNetGUID );
    protected enum RakNet::ConnectionAttemptResult SendConnectionRequest(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    protected enum RakNet::ConnectionAttemptResult SendConnectionRequest(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,class RakNet::RakNetSocket2 * );
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystemFromSystemAddress(const struct RakNet::SystemAddress ,bool ,bool );
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystem(struct RakNet::SystemAddress & );
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystem(const struct RakNet::AddressOrGUID ,bool ,bool );
    protected void ValidateRemoteSystemLookup();
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystemFromGUID(const struct RakNet::RakNetGUID ,bool );
    protected void ParseConnectionRequestPacket(struct RakNet::RakPeer::RemoteSystemStruct * ,struct RakNet::SystemAddress & ,char * ,int );
    protected void OnConnectionRequest(struct RakNet::RakPeer::RemoteSystemStruct * ,unsigned int );
    protected void NotifyAndFlagForShutdown(const struct RakNet::SystemAddress ,bool ,unsigned int ,enum PacketPriority );
    protected unsigned int GetNumberOfRemoteInitiatedConnections();
    protected struct RakNet::RakPeer::RemoteSystemStruct * AssignSystemAddressToRemoteSystemList(const struct RakNet::SystemAddress ,enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode ,class RakNet::RakNetSocket2 * ,bool * ,struct RakNet::SystemAddress ,int ,struct RakNet::RakNetGUID ,bool );
    protected void ShiftIncomingTimestamp(unsigned int * ,struct RakNet::SystemAddress & );
    protected unsigned int GetBestClockDifferential(const struct RakNet::SystemAddress );
    protected bool IsLoopbackAddress(struct RakNet::AddressOrGUID & ,bool );
    protected struct RakNet::SystemAddress GetLoopbackAddress();
    protected bool endThreads;
    protected bool isMainLoopThreadActive;
    protected bool occasionalPing;
    protected unsigned int maximumNumberOfPeers;
    protected unsigned int maximumIncomingConnections;
    protected class RakNet::BitStream offlinePingResponse;
    protected char incomingPassword[256];
    protected unsigned int incomingPasswordLength;
    protected struct RakNet::RakPeer::RemoteSystemStruct * remoteSystemList;
    protected struct RakNet::RakPeer::RemoteSystemStruct ** activeSystemList;
    protected unsigned int activeSystemListSize;
    protected struct RakNet::RemoteSystemIndex ** remoteSystemLookup;
    protected unsigned int RemoteSystemLookupHashIndex(struct RakNet::SystemAddress & );
    protected void ReferenceRemoteSystem(struct RakNet::SystemAddress & ,unsigned int );
    protected void DereferenceRemoteSystem(struct RakNet::SystemAddress & );
    protected unsigned int GetRemoteSystemIndex(struct RakNet::SystemAddress & );
    protected void ClearRemoteSystemLookup();
    protected class DataStructures::MemoryPool<RakNet::RemoteSystemIndex> remoteSystemIndexPool;
    protected void AddToActiveSystemList(unsigned int );
    protected void RemoveFromActiveSystemList(struct RakNet::SystemAddress & );
    enum <unnamed-enum-requestedConnectionList_Mutex>
    {
        requestedConnectionList_Mutex=0,
        offlinePingResponse_Mutex=1,
        NUMBER_OF_RAKPEER_MUTEXES=2
    };
    protected class RakNet::SimpleMutex rakPeerMutexes[2];
    protected bool updateCycleIsRunning;
    protected unsigned int bytesSentPerSecond;
    protected unsigned int bytesReceivedPerSecond;
    protected unsigned int validationInteger;
    protected class RakNet::SimpleMutex incomingQueueMutex;
    protected class RakNet::SimpleMutex banListMutex;
    struct BanStruct
    {
        char * IP;
        unsigned int timeout;
    };
    struct RequestedConnectionStruct
    {
        struct RakNet::SystemAddress systemAddress;
        unsigned int nextRequestTime;
        unsigned int requestsMade;
        char * data;
        unsigned int dataLength;
        char outgoingPassword[256];
        unsigned int outgoingPasswordLength;
        unsigned int socketIndex;
        unsigned int extraData;
        unsigned int sendConnectionAttemptCount;
        unsigned int timeBetweenSendConnectionAttemptsMS;
        unsigned int timeoutTime;
        enum RakNet::PublicKeyMode publicKeyMode;
        class RakNet::RakNetSocket2 * socket;
        enum <unnamed-type-actionToTake>
        {
            CONNECT=1
        };
        enum RakNet::RakPeer::RequestedConnectionStruct::<unnamed-type-actionToTake> actionToTake;
        void RequestedConnectionStruct();
        struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct * );
        struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct & );
    };
    protected class DataStructures::List<RakNet::RakPeer::BanStruct *> banList;
    protected class DataStructures::List<RakNet::PluginInterface2 *> pluginListTS;
    protected class DataStructures::List<RakNet::PluginInterface2 *> pluginListNTS;
    protected class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *> requestedConnectionQueue;
    protected class RakNet::SimpleMutex requestedConnectionQueueMutex;
    struct BufferedCommandStruct
    {
        unsigned int numberOfBitsToSend;
        enum PacketPriority priority;
        enum PacketReliability reliability;
        char orderingChannel;
        struct RakNet::AddressOrGUID systemIdentifier;
        bool broadcast;
        enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectionMode;
        unsigned int networkID;
        bool blockingCommand;
        char * data;
        bool haveRakNetCloseSocket;
        unsigned int connectionSocketIndex;
        unsigned int remotePortRakNetWasStartedOn_PS3;
        unsigned int extraSocketOptions;
        class RakNet::RakNetSocket2 * socket;
        unsigned int port;
        unsigned int receipt;
        enum <unnamed-type-command>
        {
            BCS_SEND=0,
            BCS_CLOSE_CONNECTION=1,
            BCS_GET_SOCKET=2,
            BCS_CHANGE_SYSTEM_ADDRESS=3,
            BCS_DO_NOTHING=4
        };
        enum RakNet::RakPeer::BufferedCommandStruct::<unnamed-type-command> command;
        void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct * );
        void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct & );
        void BufferedCommandStruct();
        struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct * );
        struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct & );
    };
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> bufferedCommands;
    protected class DataStructures::Queue<RakNet::RNS2RecvStruct *> bufferedPacketsFreePool;
    protected class RakNet::SimpleMutex bufferedPacketsFreePoolMutex;
    protected class DataStructures::Queue<RakNet::RNS2RecvStruct *> bufferedPacketsQueue;
    protected class RakNet::SimpleMutex bufferedPacketsQueueMutex;
    protected void DeallocRNS2RecvStruct(struct RakNet::RNS2RecvStruct * ,char * ,unsigned int );
    protected struct RakNet::RNS2RecvStruct * AllocRNS2RecvStruct(char * ,unsigned int );
    protected void SetupBufferedPackets();
    protected void PushBufferedPacket(struct RakNet::RNS2RecvStruct * );
    protected struct RakNet::RNS2RecvStruct * PopBufferedPacket();
    struct SocketQueryOutput
    {
        void SocketQueryOutput(struct RakNet::RakPeer::SocketQueryOutput & );
        void SocketQueryOutput();
        void ~SocketQueryOutput();
        class DataStructures::List<RakNet::RakNetSocket2 *> sockets;
        struct RakNet::RakPeer::SocketQueryOutput & operator=(struct RakNet::RakPeer::SocketQueryOutput & );
        void * __vecDelDtor(unsigned int );
    };
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> socketQueryOutput;
    protected bool AllowIncomingConnections();
    protected void PingInternal(const struct RakNet::SystemAddress ,bool ,enum PacketReliability );
    protected void CloseConnectionInternal(struct RakNet::AddressOrGUID & ,bool ,bool ,unsigned int ,enum PacketPriority );
    protected void SendBuffered(char * ,unsigned int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode ,unsigned int );
    protected void SendBufferedList(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode ,unsigned int );
    protected bool SendImmediate(char * ,unsigned int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,bool ,unsigned int ,unsigned int );
    protected void ClearBufferedCommands();
    protected void ClearBufferedPackets();
    protected void ClearSocketQueryOutput();
    protected void ClearRequestedConnectionList();
    protected void AddPacketToProducer(struct RakNet::Packet * );
    protected unsigned int GenerateSeedFromGuid();
    protected unsigned int GetClockDifferentialInt(struct RakNet::RakPeer::RemoteSystemStruct * );
    protected class RakNet::SimpleMutex securityExceptionMutex;
    protected int defaultMTUSize;
    protected bool trackFrequencyTable;
    protected class DataStructures::List<RakNet::RakNetSocket2 *> socketList;
    protected void DerefAllSockets();
    protected unsigned int GetRakNetSocketFromUserConnectionSocketIndex(unsigned int );
    protected class RakNet::BitStream * replyFromTargetBS;
    protected struct RakNet::SystemAddress replyFromTargetPlayer;
    protected bool replyFromTargetBroadcast;
    protected unsigned int defaultTimeoutTime;
    protected void GenerateGUID();
    protected unsigned int GetSystemIndexFromGuid(const struct RakNet::RakNetGUID );
    protected struct RakNet::RakNetGUID myGuid;
    protected unsigned int maxOutgoingBPS;
    protected bool allowConnectionResponseIPMigration;
    protected struct RakNet::SystemAddress firstExternalID;
    protected int splitMessageProgressInterval;
    protected unsigned int unreliableTimeout;
    protected bool  ( * incomingDatagramEventHandler)(struct RakNet::RNS2RecvStruct * );
    protected class DataStructures::List<RakNet::RakString> securityExceptionList;
    protected struct RakNet::SystemAddress ipList[10];
    protected bool allowInternalRouting;
    protected void  ( * userUpdateThreadPtr)(class RakNet::RakPeerInterface * ,void * );
    protected void * userUpdateThreadData;
    protected class RakNet::SignaledEvent quitAndDataEvents;
    protected bool limitConnectionFrequencyFromTheSameIP;
    protected class RakNet::SimpleMutex packetAllocationPoolMutex;
    protected class DataStructures::MemoryPool<RakNet::Packet> packetAllocationPool;
    protected class RakNet::SimpleMutex packetReturnMutex;
    protected class DataStructures::Queue<RakNet::Packet *> packetReturnQueue;
    protected struct RakNet::Packet * AllocPacket(unsigned int ,unsigned int * ,char * ,unsigned int );
    protected struct RakNet::Packet * AllocPacket(unsigned int ,char * ,unsigned int );
    protected class RakNet::SimpleMutex sendReceiptSerialMutex;
    protected unsigned int sendReceiptSerial;
    protected void ResetSendReceipt();
    protected void OnConnectedPong(unsigned int ,unsigned int ,struct RakNet::RakPeer::RemoteSystemStruct * );
    protected void CallPluginCallbacks(class DataStructures::List<RakNet::PluginInterface2 *> & ,struct RakNet::Packet * );
    protected void OnRNS2Recv(struct RakNet::RNS2RecvStruct * );
    protected void FillIPList();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode
{
    NO_ACTION=0,
    DISCONNECT_ASAP=1,
    DISCONNECT_ASAP_SILENTLY=2,
    DISCONNECT_ON_NO_ACK=3,
    REQUESTED_CONNECTION=4,
    HANDLING_CONNECTION_REQUEST=5,
    UNVERIFIED_SENDER=6,
    CONNECTED=7
};

enum RakNet::RakPeer::<unnamed-enum-requestedConnectionList_Mutex>
{
    requestedConnectionList_Mutex=0,
    offlinePingResponse_Mutex=1,
    NUMBER_OF_RAKPEER_MUTEXES=2
};

class RakNet::RakPeer : public RakNet::RakPeerInterface, public RakNet::RNS2EventHandler
{
    public void RakPeer();
    public void ~RakPeer();
    public enum RakNet::StartupResult Startup(unsigned int ,struct RakNet::SocketDescriptor * ,unsigned int ,int );
    public bool InitializeSecurity(char * ,char * ,bool );
    public void DisableSecurity();
    public void AddToSecurityExceptionList(char * );
    public void RemoveFromSecurityExceptionList(char * );
    public bool IsInSecurityExceptionList(char * );
    public void SetMaximumIncomingConnections(unsigned int );
    public unsigned int GetMaximumIncomingConnections();
    public unsigned int NumberOfConnections();
    public void SetIncomingPassword(char * ,int );
    public void GetIncomingPassword(char * ,int * );
    public enum RakNet::ConnectionAttemptResult Connect(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    public enum RakNet::ConnectionAttemptResult ConnectWithSocket(char * ,unsigned int ,char * ,int ,class RakNet::RakNetSocket2 * ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int );
    public void Shutdown(unsigned int ,unsigned int ,enum PacketPriority );
    public bool IsActive();
    public bool GetConnectionList(struct RakNet::SystemAddress * ,unsigned int * );
    public unsigned int GetNextSendReceipt();
    public unsigned int IncrementNextSendReceipt();
    public unsigned int Send(class RakNet::BitStream * ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public unsigned int Send(char * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public void SendLoopback(char * ,const int );
    public unsigned int SendList(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,unsigned int );
    public struct RakNet::Packet * Receive();
    public void DeallocatePacket(struct RakNet::Packet * );
    public unsigned int GetMaximumNumberOfPeers();
    public void CloseConnection(const struct RakNet::AddressOrGUID ,bool ,unsigned int ,enum PacketPriority );
    public void CancelConnectionAttempt(const struct RakNet::SystemAddress );
    public enum RakNet::ConnectionState GetConnectionState(const struct RakNet::AddressOrGUID );
    protected int GetIndexFromSystemAddress(const struct RakNet::SystemAddress ,bool );
    public int GetIndexFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromIndex(unsigned int );
    public struct RakNet::RakNetGUID GetGUIDFromIndex(unsigned int );
    public void GetSystemList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & );
    public void AddToBanList(char * ,unsigned int );
    public void RemoveFromBanList(char * );
    public void ClearBanList();
    public bool IsBanned(char * );
    public void SetLimitIPConnectionFrequency(bool );
    public bool Ping(char * ,unsigned int ,bool ,unsigned int );
    public void Ping(const struct RakNet::SystemAddress );
    public int GetAveragePing(const struct RakNet::AddressOrGUID );
    public int GetLastPing(const struct RakNet::AddressOrGUID );
    public int GetLowestPing(const struct RakNet::AddressOrGUID );
    public void SetOccasionalPing(bool );
    public unsigned int GetClockDifferential(const struct RakNet::AddressOrGUID );
    public void SetOfflinePingResponse(char * ,const unsigned int );
    public void GetOfflinePingResponse(char ** ,unsigned int * );
    public struct RakNet::SystemAddress GetInternalID(const struct RakNet::SystemAddress ,const int );
    public void SetInternalID(struct RakNet::SystemAddress ,int );
    public struct RakNet::SystemAddress GetExternalID(const struct RakNet::SystemAddress );
    public const struct RakNet::RakNetGUID GetMyGUID();
    public struct RakNet::SystemAddress GetMyBoundAddress(const int );
    public struct RakNet::RakNetGUID & GetGuidFromSystemAddress(const struct RakNet::SystemAddress );
    public struct RakNet::SystemAddress GetSystemAddressFromGuid(const struct RakNet::RakNetGUID );
    public bool GetClientPublicKeyFromSystemAddress(const struct RakNet::SystemAddress ,char * );
    public void SetTimeoutTime(unsigned int ,const struct RakNet::SystemAddress );
    public unsigned int GetTimeoutTime(const struct RakNet::SystemAddress );
    public int GetMTUSize(const struct RakNet::SystemAddress );
    public unsigned int GetNumberOfAddresses();
    public char * GetLocalIP(unsigned int );
    public bool IsLocalIP(char * );
    public void AllowConnectionResponseIPMigration(bool );
    public bool AdvertiseSystem(char * ,unsigned int ,char * ,int ,unsigned int );
    public void SetSplitMessageProgressInterval(int );
    public int GetSplitMessageProgressInterval();
    public void SetUnreliableTimeout(unsigned int );
    public void SendTTL(char * ,unsigned int ,int ,unsigned int );
    public void AttachPlugin(class RakNet::PluginInterface2 * );
    public void DetachPlugin(class RakNet::PluginInterface2 * );
    public void PushBackPacket(struct RakNet::Packet * ,bool );
    public void ChangeSystemAddress(struct RakNet::RakNetGUID ,struct RakNet::SystemAddress & );
    public struct RakNet::Packet * AllocatePacket(unsigned int );
    public class RakNet::RakNetSocket2 * GetSocket(const struct RakNet::SystemAddress );
    public void GetSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void ReleaseSockets(class DataStructures::List<RakNet::RakNetSocket2 *> & );
    public void WriteOutOfBandHeader(class RakNet::BitStream * );
    public void SetUserUpdateThread(void  ( * )(class RakNet::RakPeerInterface * ,void * ),void * );
    public void SetIncomingDatagramEventHandler(bool  ( * )(struct RakNet::RNS2RecvStruct * ));
    public void ApplyNetworkSimulator(float ,unsigned int ,unsigned int );
    public void SetPerConnectionOutgoingBandwidthLimit(unsigned int );
    public bool IsNetworkSimulatorActive();
    public bool GetStatistics(const unsigned int ,struct RakNet::RakNetStatistics * );
    public struct RakNet::RakNetStatistics * GetStatistics(const struct RakNet::SystemAddress ,struct RakNet::RakNetStatistics * );
    public void GetStatisticsList(class DataStructures::List<RakNet::SystemAddress> & ,class DataStructures::List<RakNet::RakNetGUID> & ,class DataStructures::List<RakNet::RakNetStatistics> & );
    public unsigned int GetReceiveBufferSize();
    public bool RunUpdateCycle(class RakNet::BitStream & );
    public bool SendOutOfBand(char * ,unsigned int ,char * ,unsigned int ,unsigned int );
    struct PingAndClockDifferential
    {
        unsigned int pingTime;
        unsigned int clockDifferential;
    };
    struct RemoteSystemStruct
    {
        bool isActive;
        struct RakNet::SystemAddress systemAddress;
        struct RakNet::SystemAddress myExternalSystemAddress;
        struct RakNet::SystemAddress theirInternalSystemAddress[10];
        class RakNet::ReliabilityLayer reliabilityLayer;
        bool weInitiatedTheConnection;
        struct RakNet::RakPeer::PingAndClockDifferential pingAndClockDifferential[5];
        unsigned int pingAndClockDifferentialWriteIndex;
        unsigned int lowestPing;
        unsigned int nextPingTime;
        unsigned int lastReliableSend;
        unsigned int connectionTime;
        struct RakNet::RakNetGUID guid;
        int MTUSize;
        class RakNet::RakNetSocket2 * rakNetSocket;
        unsigned int remoteSystemIndex;
        enum ConnectMode
        {
            NO_ACTION=0,
            DISCONNECT_ASAP=1,
            DISCONNECT_ASAP_SILENTLY=2,
            DISCONNECT_ON_NO_ACK=3,
            REQUESTED_CONNECTION=4,
            HANDLING_CONNECTION_REQUEST=5,
            UNVERIFIED_SENDER=6,
            CONNECTED=7
        };
        enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectMode;
        void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct * );
        void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct & );
        void RemoteSystemStruct();
        void ~RemoteSystemStruct();
        struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct * );
        struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct & );
        void * __vecDelDtor(unsigned int );
    };
    protected int GetIndexFromGuid(const struct RakNet::RakNetGUID );
    protected enum RakNet::ConnectionAttemptResult SendConnectionRequest(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int );
    protected enum RakNet::ConnectionAttemptResult SendConnectionRequest(char * ,unsigned int ,char * ,int ,struct RakNet::PublicKey * ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,unsigned int ,class RakNet::RakNetSocket2 * );
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystemFromSystemAddress(const struct RakNet::SystemAddress ,bool ,bool );
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystem(struct RakNet::SystemAddress & );
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystem(const struct RakNet::AddressOrGUID ,bool ,bool );
    protected void ValidateRemoteSystemLookup();
    protected struct RakNet::RakPeer::RemoteSystemStruct * GetRemoteSystemFromGUID(const struct RakNet::RakNetGUID ,bool );
    protected void ParseConnectionRequestPacket(struct RakNet::RakPeer::RemoteSystemStruct * ,struct RakNet::SystemAddress & ,char * ,int );
    protected void OnConnectionRequest(struct RakNet::RakPeer::RemoteSystemStruct * ,unsigned int );
    protected void NotifyAndFlagForShutdown(const struct RakNet::SystemAddress ,bool ,unsigned int ,enum PacketPriority );
    protected unsigned int GetNumberOfRemoteInitiatedConnections();
    protected struct RakNet::RakPeer::RemoteSystemStruct * AssignSystemAddressToRemoteSystemList(const struct RakNet::SystemAddress ,enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode ,class RakNet::RakNetSocket2 * ,bool * ,struct RakNet::SystemAddress ,int ,struct RakNet::RakNetGUID ,bool );
    protected void ShiftIncomingTimestamp(unsigned int * ,struct RakNet::SystemAddress & );
    protected unsigned int GetBestClockDifferential(const struct RakNet::SystemAddress );
    protected bool IsLoopbackAddress(struct RakNet::AddressOrGUID & ,bool );
    protected struct RakNet::SystemAddress GetLoopbackAddress();
    protected bool endThreads;
    protected bool isMainLoopThreadActive;
    protected bool occasionalPing;
    protected unsigned int maximumNumberOfPeers;
    protected unsigned int maximumIncomingConnections;
    protected class RakNet::BitStream offlinePingResponse;
    protected char incomingPassword[256];
    protected unsigned int incomingPasswordLength;
    protected struct RakNet::RakPeer::RemoteSystemStruct * remoteSystemList;
    protected struct RakNet::RakPeer::RemoteSystemStruct ** activeSystemList;
    protected unsigned int activeSystemListSize;
    protected struct RakNet::RemoteSystemIndex ** remoteSystemLookup;
    protected unsigned int RemoteSystemLookupHashIndex(struct RakNet::SystemAddress & );
    protected void ReferenceRemoteSystem(struct RakNet::SystemAddress & ,unsigned int );
    protected void DereferenceRemoteSystem(struct RakNet::SystemAddress & );
    protected unsigned int GetRemoteSystemIndex(struct RakNet::SystemAddress & );
    protected void ClearRemoteSystemLookup();
    protected class DataStructures::MemoryPool<RakNet::RemoteSystemIndex> remoteSystemIndexPool;
    protected void AddToActiveSystemList(unsigned int );
    protected void RemoveFromActiveSystemList(struct RakNet::SystemAddress & );
    enum <unnamed-enum-requestedConnectionList_Mutex>
    {
        requestedConnectionList_Mutex=0,
        offlinePingResponse_Mutex=1,
        NUMBER_OF_RAKPEER_MUTEXES=2
    };
    protected class RakNet::SimpleMutex rakPeerMutexes[2];
    protected bool updateCycleIsRunning;
    protected unsigned int bytesSentPerSecond;
    protected unsigned int bytesReceivedPerSecond;
    protected unsigned int validationInteger;
    protected class RakNet::SimpleMutex incomingQueueMutex;
    protected class RakNet::SimpleMutex banListMutex;
    struct BanStruct
    {
        char * IP;
        unsigned int timeout;
    };
    struct RequestedConnectionStruct
    {
        struct RakNet::SystemAddress systemAddress;
        unsigned int nextRequestTime;
        unsigned int requestsMade;
        char * data;
        unsigned int dataLength;
        char outgoingPassword[256];
        unsigned int outgoingPasswordLength;
        unsigned int socketIndex;
        unsigned int extraData;
        unsigned int sendConnectionAttemptCount;
        unsigned int timeBetweenSendConnectionAttemptsMS;
        unsigned int timeoutTime;
        enum RakNet::PublicKeyMode publicKeyMode;
        class RakNet::RakNetSocket2 * socket;
        enum <unnamed-type-actionToTake>
        {
            CONNECT=1
        };
        enum RakNet::RakPeer::RequestedConnectionStruct::<unnamed-type-actionToTake> actionToTake;
        void RequestedConnectionStruct();
        struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct * );
        struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct & );
    };
    protected class DataStructures::List<RakNet::RakPeer::BanStruct *> banList;
    protected class DataStructures::List<RakNet::PluginInterface2 *> pluginListTS;
    protected class DataStructures::List<RakNet::PluginInterface2 *> pluginListNTS;
    protected class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *> requestedConnectionQueue;
    protected class RakNet::SimpleMutex requestedConnectionQueueMutex;
    struct BufferedCommandStruct
    {
        unsigned int numberOfBitsToSend;
        enum PacketPriority priority;
        enum PacketReliability reliability;
        char orderingChannel;
        struct RakNet::AddressOrGUID systemIdentifier;
        bool broadcast;
        enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectionMode;
        unsigned int networkID;
        bool blockingCommand;
        char * data;
        bool haveRakNetCloseSocket;
        unsigned int connectionSocketIndex;
        unsigned int remotePortRakNetWasStartedOn_PS3;
        unsigned int extraSocketOptions;
        class RakNet::RakNetSocket2 * socket;
        unsigned int port;
        unsigned int receipt;
        enum <unnamed-type-command>
        {
            BCS_SEND=0,
            BCS_CLOSE_CONNECTION=1,
            BCS_GET_SOCKET=2,
            BCS_CHANGE_SYSTEM_ADDRESS=3,
            BCS_DO_NOTHING=4
        };
        enum RakNet::RakPeer::BufferedCommandStruct::<unnamed-type-command> command;
        void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct * );
        void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct & );
        void BufferedCommandStruct();
        struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct * );
        struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct & );
    };
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> bufferedCommands;
    protected class DataStructures::Queue<RakNet::RNS2RecvStruct *> bufferedPacketsFreePool;
    protected class RakNet::SimpleMutex bufferedPacketsFreePoolMutex;
    protected class DataStructures::Queue<RakNet::RNS2RecvStruct *> bufferedPacketsQueue;
    protected class RakNet::SimpleMutex bufferedPacketsQueueMutex;
    protected void DeallocRNS2RecvStruct(struct RakNet::RNS2RecvStruct * ,char * ,unsigned int );
    protected struct RakNet::RNS2RecvStruct * AllocRNS2RecvStruct(char * ,unsigned int );
    protected void SetupBufferedPackets();
    protected void PushBufferedPacket(struct RakNet::RNS2RecvStruct * );
    protected struct RakNet::RNS2RecvStruct * PopBufferedPacket();
    struct SocketQueryOutput
    {
        void SocketQueryOutput(struct RakNet::RakPeer::SocketQueryOutput & );
        void SocketQueryOutput();
        void ~SocketQueryOutput();
        class DataStructures::List<RakNet::RakNetSocket2 *> sockets;
        struct RakNet::RakPeer::SocketQueryOutput & operator=(struct RakNet::RakPeer::SocketQueryOutput & );
        void * __vecDelDtor(unsigned int );
    };
    protected class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> socketQueryOutput;
    protected bool AllowIncomingConnections();
    protected void PingInternal(const struct RakNet::SystemAddress ,bool ,enum PacketReliability );
    protected void CloseConnectionInternal(struct RakNet::AddressOrGUID & ,bool ,bool ,unsigned int ,enum PacketPriority );
    protected void SendBuffered(char * ,unsigned int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode ,unsigned int );
    protected void SendBufferedList(char ** ,int * ,const int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode ,unsigned int );
    protected bool SendImmediate(char * ,unsigned int ,enum PacketPriority ,enum PacketReliability ,char ,const struct RakNet::AddressOrGUID ,bool ,bool ,unsigned int ,unsigned int );
    protected void ClearBufferedCommands();
    protected void ClearBufferedPackets();
    protected void ClearSocketQueryOutput();
    protected void ClearRequestedConnectionList();
    protected void AddPacketToProducer(struct RakNet::Packet * );
    protected unsigned int GenerateSeedFromGuid();
    protected unsigned int GetClockDifferentialInt(struct RakNet::RakPeer::RemoteSystemStruct * );
    protected class RakNet::SimpleMutex securityExceptionMutex;
    protected int defaultMTUSize;
    protected bool trackFrequencyTable;
    protected class DataStructures::List<RakNet::RakNetSocket2 *> socketList;
    protected void DerefAllSockets();
    protected unsigned int GetRakNetSocketFromUserConnectionSocketIndex(unsigned int );
    protected class RakNet::BitStream * replyFromTargetBS;
    protected struct RakNet::SystemAddress replyFromTargetPlayer;
    protected bool replyFromTargetBroadcast;
    protected unsigned int defaultTimeoutTime;
    protected void GenerateGUID();
    protected unsigned int GetSystemIndexFromGuid(const struct RakNet::RakNetGUID );
    protected struct RakNet::RakNetGUID myGuid;
    protected unsigned int maxOutgoingBPS;
    protected bool allowConnectionResponseIPMigration;
    protected struct RakNet::SystemAddress firstExternalID;
    protected int splitMessageProgressInterval;
    protected unsigned int unreliableTimeout;
    protected bool  ( * incomingDatagramEventHandler)(struct RakNet::RNS2RecvStruct * );
    protected class DataStructures::List<RakNet::RakString> securityExceptionList;
    protected struct RakNet::SystemAddress ipList[10];
    protected bool allowInternalRouting;
    protected void  ( * userUpdateThreadPtr)(class RakNet::RakPeerInterface * ,void * );
    protected void * userUpdateThreadData;
    protected class RakNet::SignaledEvent quitAndDataEvents;
    protected bool limitConnectionFrequencyFromTheSameIP;
    protected class RakNet::SimpleMutex packetAllocationPoolMutex;
    protected class DataStructures::MemoryPool<RakNet::Packet> packetAllocationPool;
    protected class RakNet::SimpleMutex packetReturnMutex;
    protected class DataStructures::Queue<RakNet::Packet *> packetReturnQueue;
    protected struct RakNet::Packet * AllocPacket(unsigned int ,unsigned int * ,char * ,unsigned int );
    protected struct RakNet::Packet * AllocPacket(unsigned int ,char * ,unsigned int );
    protected class RakNet::SimpleMutex sendReceiptSerialMutex;
    protected unsigned int sendReceiptSerial;
    protected void ResetSendReceipt();
    protected void OnConnectedPong(unsigned int ,unsigned int ,struct RakNet::RakPeer::RemoteSystemStruct * );
    protected void CallPluginCallbacks(class DataStructures::List<RakNet::PluginInterface2 *> & ,struct RakNet::Packet * );
    protected void OnRNS2Recv(struct RakNet::RNS2RecvStruct * );
    protected void FillIPList();
    public void __local_vftable_ctor_closure();
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::RakPeer::SocketQueryOutput
{
    void SocketQueryOutput(struct RakNet::RakPeer::SocketQueryOutput & );
    void SocketQueryOutput();
    void ~SocketQueryOutput();
    class DataStructures::List<RakNet::RakNetSocket2 *> sockets;
    struct RakNet::RakPeer::SocketQueryOutput & operator=(struct RakNet::RakPeer::SocketQueryOutput & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::RakPeer::SocketQueryOutput
{
    void SocketQueryOutput(struct RakNet::RakPeer::SocketQueryOutput & );
    void SocketQueryOutput();
    void ~SocketQueryOutput();
    class DataStructures::List<RakNet::RakNetSocket2 *> sockets;
    struct RakNet::RakPeer::SocketQueryOutput & operator=(struct RakNet::RakPeer::SocketQueryOutput & );
    void * __vecDelDtor(unsigned int );
};

enum RakNet::RakPeer::BufferedCommandStruct::<unnamed-type-command>
{
    BCS_SEND=0,
    BCS_CLOSE_CONNECTION=1,
    BCS_GET_SOCKET=2,
    BCS_CHANGE_SYSTEM_ADDRESS=3,
    BCS_DO_NOTHING=4
};

struct RakNet::RakPeer::BufferedCommandStruct
{
    unsigned int numberOfBitsToSend;
    enum PacketPriority priority;
    enum PacketReliability reliability;
    char orderingChannel;
    struct RakNet::AddressOrGUID systemIdentifier;
    bool broadcast;
    enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectionMode;
    unsigned int networkID;
    bool blockingCommand;
    char * data;
    bool haveRakNetCloseSocket;
    unsigned int connectionSocketIndex;
    unsigned int remotePortRakNetWasStartedOn_PS3;
    unsigned int extraSocketOptions;
    class RakNet::RakNetSocket2 * socket;
    unsigned int port;
    unsigned int receipt;
    enum <unnamed-type-command>
    {
        BCS_SEND=0,
        BCS_CLOSE_CONNECTION=1,
        BCS_GET_SOCKET=2,
        BCS_CHANGE_SYSTEM_ADDRESS=3,
        BCS_DO_NOTHING=4
    };
    enum RakNet::RakPeer::BufferedCommandStruct::<unnamed-type-command> command;
    void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct * );
    void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct & );
    void BufferedCommandStruct();
    struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct * );
    struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct & );
};

struct RakNet::RakPeer::BufferedCommandStruct
{
    unsigned int numberOfBitsToSend;
    enum PacketPriority priority;
    enum PacketReliability reliability;
    char orderingChannel;
    struct RakNet::AddressOrGUID systemIdentifier;
    bool broadcast;
    enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectionMode;
    unsigned int networkID;
    bool blockingCommand;
    char * data;
    bool haveRakNetCloseSocket;
    unsigned int connectionSocketIndex;
    unsigned int remotePortRakNetWasStartedOn_PS3;
    unsigned int extraSocketOptions;
    class RakNet::RakNetSocket2 * socket;
    unsigned int port;
    unsigned int receipt;
    enum <unnamed-type-command>
    {
        BCS_SEND=0,
        BCS_CLOSE_CONNECTION=1,
        BCS_GET_SOCKET=2,
        BCS_CHANGE_SYSTEM_ADDRESS=3,
        BCS_DO_NOTHING=4
    };
    enum RakNet::RakPeer::BufferedCommandStruct::<unnamed-type-command> command;
    void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct * );
    void BufferedCommandStruct(struct RakNet::RakPeer::BufferedCommandStruct & );
    void BufferedCommandStruct();
    struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct * );
    struct RakNet::RakPeer::BufferedCommandStruct & operator=(struct RakNet::RakPeer::BufferedCommandStruct & );
};

enum RakNet::RakPeer::RequestedConnectionStruct::<unnamed-type-actionToTake>
{
    CONNECT=1
};

struct RakNet::RakPeer::RequestedConnectionStruct
{
    struct RakNet::SystemAddress systemAddress;
    unsigned int nextRequestTime;
    unsigned int requestsMade;
    char * data;
    unsigned int dataLength;
    char outgoingPassword[256];
    unsigned int outgoingPasswordLength;
    unsigned int socketIndex;
    unsigned int extraData;
    unsigned int sendConnectionAttemptCount;
    unsigned int timeBetweenSendConnectionAttemptsMS;
    unsigned int timeoutTime;
    enum RakNet::PublicKeyMode publicKeyMode;
    class RakNet::RakNetSocket2 * socket;
    enum <unnamed-type-actionToTake>
    {
        CONNECT=1
    };
    enum RakNet::RakPeer::RequestedConnectionStruct::<unnamed-type-actionToTake> actionToTake;
    void RequestedConnectionStruct();
    struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct * );
    struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct & );
};

struct RakNet::RakPeer::RequestedConnectionStruct
{
    struct RakNet::SystemAddress systemAddress;
    unsigned int nextRequestTime;
    unsigned int requestsMade;
    char * data;
    unsigned int dataLength;
    char outgoingPassword[256];
    unsigned int outgoingPasswordLength;
    unsigned int socketIndex;
    unsigned int extraData;
    unsigned int sendConnectionAttemptCount;
    unsigned int timeBetweenSendConnectionAttemptsMS;
    unsigned int timeoutTime;
    enum RakNet::PublicKeyMode publicKeyMode;
    class RakNet::RakNetSocket2 * socket;
    enum <unnamed-type-actionToTake>
    {
        CONNECT=1
    };
    enum RakNet::RakPeer::RequestedConnectionStruct::<unnamed-type-actionToTake> actionToTake;
    void RequestedConnectionStruct();
    struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct * );
    struct RakNet::RakPeer::RequestedConnectionStruct & operator=(struct RakNet::RakPeer::RequestedConnectionStruct & );
};

struct RakNet::RakPeer::BanStruct
{
    char * IP;
    unsigned int timeout;
};

struct RakNet::RakPeer::RemoteSystemStruct
{
    bool isActive;
    struct RakNet::SystemAddress systemAddress;
    struct RakNet::SystemAddress myExternalSystemAddress;
    struct RakNet::SystemAddress theirInternalSystemAddress[10];
    class RakNet::ReliabilityLayer reliabilityLayer;
    bool weInitiatedTheConnection;
    struct RakNet::RakPeer::PingAndClockDifferential pingAndClockDifferential[5];
    unsigned int pingAndClockDifferentialWriteIndex;
    unsigned int lowestPing;
    unsigned int nextPingTime;
    unsigned int lastReliableSend;
    unsigned int connectionTime;
    struct RakNet::RakNetGUID guid;
    int MTUSize;
    class RakNet::RakNetSocket2 * rakNetSocket;
    unsigned int remoteSystemIndex;
    enum ConnectMode
    {
        NO_ACTION=0,
        DISCONNECT_ASAP=1,
        DISCONNECT_ASAP_SILENTLY=2,
        DISCONNECT_ON_NO_ACK=3,
        REQUESTED_CONNECTION=4,
        HANDLING_CONNECTION_REQUEST=5,
        UNVERIFIED_SENDER=6,
        CONNECTED=7
    };
    enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectMode;
    void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct * );
    void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct & );
    void RemoteSystemStruct();
    void ~RemoteSystemStruct();
    struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct * );
    struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::RakPeer::RemoteSystemStruct
{
    bool isActive;
    struct RakNet::SystemAddress systemAddress;
    struct RakNet::SystemAddress myExternalSystemAddress;
    struct RakNet::SystemAddress theirInternalSystemAddress[10];
    class RakNet::ReliabilityLayer reliabilityLayer;
    bool weInitiatedTheConnection;
    struct RakNet::RakPeer::PingAndClockDifferential pingAndClockDifferential[5];
    unsigned int pingAndClockDifferentialWriteIndex;
    unsigned int lowestPing;
    unsigned int nextPingTime;
    unsigned int lastReliableSend;
    unsigned int connectionTime;
    struct RakNet::RakNetGUID guid;
    int MTUSize;
    class RakNet::RakNetSocket2 * rakNetSocket;
    unsigned int remoteSystemIndex;
    enum ConnectMode
    {
        NO_ACTION=0,
        DISCONNECT_ASAP=1,
        DISCONNECT_ASAP_SILENTLY=2,
        DISCONNECT_ON_NO_ACK=3,
        REQUESTED_CONNECTION=4,
        HANDLING_CONNECTION_REQUEST=5,
        UNVERIFIED_SENDER=6,
        CONNECTED=7
    };
    enum RakNet::RakPeer::RemoteSystemStruct::ConnectMode connectMode;
    void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct * );
    void RemoteSystemStruct(struct RakNet::RakPeer::RemoteSystemStruct & );
    void RemoteSystemStruct();
    void ~RemoteSystemStruct();
    struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct * );
    struct RakNet::RakPeer::RemoteSystemStruct & operator=(struct RakNet::RakPeer::RemoteSystemStruct & );
    void * __vecDelDtor(unsigned int );
};

struct RakNet::RakPeer::PingAndClockDifferential
{
    unsigned int pingTime;
    unsigned int clockDifferential;
};

struct RakNet::SplitPacketChannel
{
    unsigned int lastUpdateTime;
    class RakNet::SortedSplittedPackets splitPacketList;
    struct RakNet::InternalPacket * firstPacket;
    void SplitPacketChannel();
    void ~SplitPacketChannel();
    void * __vecDelDtor(unsigned int );
};

class RakNet::StringTable
{
    public void ~StringTable();
    public class RakNet::StringTable * Instance();
    public void AddString(char * ,bool );
    public void EncodeString(char * ,int ,class RakNet::BitStream * );
    public bool DecodeString(char * ,int ,class RakNet::BitStream * );
    public void AddReference();
    public void RemoveReference();
    public void StringTable(class RakNet::StringTable & );
    public void StringTable();
    protected void LogStringNotFound(char * );
    protected class RakNet::StringTable * instance;
    protected int referenceCount;
    protected class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> orderedStringList;
    public class RakNet::StringTable & operator=(class RakNet::StringTable & );
    public void * __vecDelDtor(unsigned int );
};

class RakNet::StringTable
{
    public void ~StringTable();
    public class RakNet::StringTable * Instance();
    public void AddString(char * ,bool );
    public void EncodeString(char * ,int ,class RakNet::BitStream * );
    public bool DecodeString(char * ,int ,class RakNet::BitStream * );
    public void AddReference();
    public void RemoveReference();
    public void StringTable(class RakNet::StringTable & );
    public void StringTable();
    protected void LogStringNotFound(char * );
    protected class RakNet::StringTable * instance;
    protected int referenceCount;
    protected class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> orderedStringList;
    public class RakNet::StringTable & operator=(class RakNet::StringTable & );
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::InternalPacketFixedSizeTransmissionHeader
{
    struct RakNet::uint24_t reliableMessageNumber;
    struct RakNet::uint24_t orderingIndex;
    struct RakNet::uint24_t sequencingIndex;
    unsigned int orderingChannel;
    unsigned int splitPacketId;
    unsigned int splitPacketIndex;
    unsigned int splitPacketCount;
    unsigned int dataBitLength;
    enum PacketReliability reliability;
    void InternalPacketFixedSizeTransmissionHeader(struct RakNet::InternalPacketFixedSizeTransmissionHeader * );
    void InternalPacketFixedSizeTransmissionHeader(struct RakNet::InternalPacketFixedSizeTransmissionHeader & );
    void InternalPacketFixedSizeTransmissionHeader();
    struct RakNet::InternalPacketFixedSizeTransmissionHeader & operator=(struct RakNet::InternalPacketFixedSizeTransmissionHeader * );
    struct RakNet::InternalPacketFixedSizeTransmissionHeader & operator=(struct RakNet::InternalPacketFixedSizeTransmissionHeader & );
};

struct RakNet::InternalPacketFixedSizeTransmissionHeader
{
    struct RakNet::uint24_t reliableMessageNumber;
    struct RakNet::uint24_t orderingIndex;
    struct RakNet::uint24_t sequencingIndex;
    unsigned int orderingChannel;
    unsigned int splitPacketId;
    unsigned int splitPacketIndex;
    unsigned int splitPacketCount;
    unsigned int dataBitLength;
    enum PacketReliability reliability;
    void InternalPacketFixedSizeTransmissionHeader(struct RakNet::InternalPacketFixedSizeTransmissionHeader * );
    void InternalPacketFixedSizeTransmissionHeader(struct RakNet::InternalPacketFixedSizeTransmissionHeader & );
    void InternalPacketFixedSizeTransmissionHeader();
    struct RakNet::InternalPacketFixedSizeTransmissionHeader & operator=(struct RakNet::InternalPacketFixedSizeTransmissionHeader * );
    struct RakNet::InternalPacketFixedSizeTransmissionHeader & operator=(struct RakNet::InternalPacketFixedSizeTransmissionHeader & );
};

class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> >
{
    public void List<DataStructures::RangeNode<RakNet::uint24_t> >(class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > & );
    public void List<DataStructures::RangeNode<RakNet::uint24_t> >();
    public void ~List<DataStructures::RangeNode<RakNet::uint24_t> >();
    public class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > & operator=(class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > & );
    public struct DataStructures::RangeNode<RakNet::uint24_t> & operator[](const unsigned int );
    public struct DataStructures::RangeNode<RakNet::uint24_t> & Get(const unsigned int );
    public void Push(struct DataStructures::RangeNode<RakNet::uint24_t> & ,char * ,unsigned int );
    public struct DataStructures::RangeNode<RakNet::uint24_t> & Pop();
    public void Insert(struct DataStructures::RangeNode<RakNet::uint24_t> & ,char * ,unsigned int );
    public void Insert(struct DataStructures::RangeNode<RakNet::uint24_t> & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    public void Replace(struct DataStructures::RangeNode<RakNet::uint24_t> & ,const struct DataStructures::RangeNode<RakNet::uint24_t> ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::RangeNode<RakNet::uint24_t> * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::RangeNode<RakNet::uint24_t>
{
    void RangeNode<RakNet::uint24_t>(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    void RangeNode<RakNet::uint24_t>(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    void RangeNode<RakNet::uint24_t>();
    void ~RangeNode<RakNet::uint24_t>();
    struct RakNet::uint24_t minIndex;
    struct RakNet::uint24_t maxIndex;
    struct DataStructures::RangeNode<RakNet::uint24_t> & operator=(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    void * __vecDelDtor(unsigned int );
};

class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> >
{
    public void List<DataStructures::RangeNode<RakNet::uint24_t> >(class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > & );
    public void List<DataStructures::RangeNode<RakNet::uint24_t> >();
    public void ~List<DataStructures::RangeNode<RakNet::uint24_t> >();
    public class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > & operator=(class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > & );
    public struct DataStructures::RangeNode<RakNet::uint24_t> & operator[](const unsigned int );
    public struct DataStructures::RangeNode<RakNet::uint24_t> & Get(const unsigned int );
    public void Push(struct DataStructures::RangeNode<RakNet::uint24_t> & ,char * ,unsigned int );
    public struct DataStructures::RangeNode<RakNet::uint24_t> & Pop();
    public void Insert(struct DataStructures::RangeNode<RakNet::uint24_t> & ,char * ,unsigned int );
    public void Insert(struct DataStructures::RangeNode<RakNet::uint24_t> & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    public void Replace(struct DataStructures::RangeNode<RakNet::uint24_t> & ,const struct DataStructures::RangeNode<RakNet::uint24_t> ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::RangeNode<RakNet::uint24_t> * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >(class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > & );
    public void OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >();
    public void ~OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >();
    public class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > & operator=(class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > & );
    public bool HasData(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int GetIndexFromKey(struct RakNet::uint24_t & ,bool * ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public bool GetElementFromKey(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public struct DataStructures::RangeNode<RakNet::uint24_t> GetElementFromKey(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int Insert(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ,bool ,char * ,unsigned int ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int Remove(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int RemoveIfExists(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public struct DataStructures::RangeNode<RakNet::uint24_t> & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::RangeNode<RakNet::uint24_t> & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::RangeNode<RakNet::uint24_t> & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >(class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > & );
    public void OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >();
    public void ~OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> >();
    public class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > & operator=(class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > & );
    public bool HasData(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int GetIndexFromKey(struct RakNet::uint24_t & ,bool * ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public bool GetElementFromKey(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public struct DataStructures::RangeNode<RakNet::uint24_t> GetElementFromKey(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int Insert(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ,bool ,char * ,unsigned int ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int Remove(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public unsigned int RemoveIfExists(struct RakNet::uint24_t & ,int  ( * )(struct RakNet::uint24_t & ,struct DataStructures::RangeNode<RakNet::uint24_t> & ));
    public struct DataStructures::RangeNode<RakNet::uint24_t> & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct DataStructures::RangeNode<RakNet::uint24_t> & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct DataStructures::RangeNode<RakNet::uint24_t> & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<DataStructures::RangeNode<RakNet::uint24_t> > orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>
{
    public void List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>(class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> & );
    public void List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>();
    public void ~List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>();
    public class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> & operator=(class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> & );
    public struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & operator[](const unsigned int );
    public struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,char * ,unsigned int );
    public struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & Pop();
    public void Insert(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & );
    public void Replace(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,const struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode
{
    void HeapNode(unsigned int & ,struct RakNet::InternalPacket &** );
    void HeapNode();
    unsigned int weight;
    struct RakNet::InternalPacket * data;
};

class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>
{
    public void List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>(class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> & );
    public void List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>();
    public void ~List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode>();
    public class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> & operator=(class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> & );
    public struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & operator[](const unsigned int );
    public struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & Get(const unsigned int );
    public void Push(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,char * ,unsigned int );
    public struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & Pop();
    public void Insert(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,char * ,unsigned int );
    public void Insert(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & );
    public void Replace(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & ,const struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::SplitPacketChannel *>
{
    public void List<RakNet::SplitPacketChannel *>(class DataStructures::List<RakNet::SplitPacketChannel *> & );
    public void List<RakNet::SplitPacketChannel *>();
    public void ~List<RakNet::SplitPacketChannel *>();
    public class DataStructures::List<RakNet::SplitPacketChannel *> & operator=(class DataStructures::List<RakNet::SplitPacketChannel *> & );
    public struct RakNet::SplitPacketChannel &** operator[](const unsigned int );
    public struct RakNet::SplitPacketChannel &** Get(const unsigned int );
    public void Push(struct RakNet::SplitPacketChannel &** ,char * ,unsigned int );
    public struct RakNet::SplitPacketChannel &** Pop();
    public void Insert(struct RakNet::SplitPacketChannel &** ,char * ,unsigned int );
    public void Insert(struct RakNet::SplitPacketChannel &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::SplitPacketChannel &** );
    public void Replace(struct RakNet::SplitPacketChannel &** ,const struct RakNet::SplitPacketChannel * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::SplitPacketChannel &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::SplitPacketChannel ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::SplitPacketChannel *>
{
    public void List<RakNet::SplitPacketChannel *>(class DataStructures::List<RakNet::SplitPacketChannel *> & );
    public void List<RakNet::SplitPacketChannel *>();
    public void ~List<RakNet::SplitPacketChannel *>();
    public class DataStructures::List<RakNet::SplitPacketChannel *> & operator=(class DataStructures::List<RakNet::SplitPacketChannel *> & );
    public struct RakNet::SplitPacketChannel &** operator[](const unsigned int );
    public struct RakNet::SplitPacketChannel &** Get(const unsigned int );
    public void Push(struct RakNet::SplitPacketChannel &** ,char * ,unsigned int );
    public struct RakNet::SplitPacketChannel &** Pop();
    public void Insert(struct RakNet::SplitPacketChannel &** ,char * ,unsigned int );
    public void Insert(struct RakNet::SplitPacketChannel &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::SplitPacketChannel &** );
    public void Replace(struct RakNet::SplitPacketChannel &** ,const struct RakNet::SplitPacketChannel * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::SplitPacketChannel &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::SplitPacketChannel ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>(class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> & );
    public void OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>();
    public void ~OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>();
    public class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> & operator=(class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> & );
    public bool HasData(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int GetIndexFromKey(unsigned int & ,bool * ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public bool GetElementFromKey(unsigned int & ,struct RakNet::SplitPacketChannel &** ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public struct RakNet::SplitPacketChannel * GetElementFromKey(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int Insert(unsigned int & ,struct RakNet::SplitPacketChannel &** ,bool ,char * ,unsigned int ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int Remove(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int RemoveIfExists(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public struct RakNet::SplitPacketChannel &** operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct RakNet::SplitPacketChannel &** ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct RakNet::SplitPacketChannel &** ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<RakNet::SplitPacketChannel *> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>(class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> & );
    public void OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>();
    public void ~OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp>();
    public class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> & operator=(class DataStructures::OrderedList<unsigned short,RakNet::SplitPacketChannel *,&RakNet::SplitPacketChannelComp> & );
    public bool HasData(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int GetIndexFromKey(unsigned int & ,bool * ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public bool GetElementFromKey(unsigned int & ,struct RakNet::SplitPacketChannel &** ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public struct RakNet::SplitPacketChannel * GetElementFromKey(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int Insert(unsigned int & ,struct RakNet::SplitPacketChannel &** ,bool ,char * ,unsigned int ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int Remove(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public unsigned int RemoveIfExists(unsigned int & ,int  ( * )(unsigned int & ,struct RakNet::SplitPacketChannel &** ));
    public struct RakNet::SplitPacketChannel &** operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct RakNet::SplitPacketChannel &** ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct RakNet::SplitPacketChannel &** ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<RakNet::SplitPacketChannel *> orderedList;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage
{
    struct RakNet::Packet userMemory;
    struct DataStructures::MemoryPool<RakNet::Packet>::Page * parentPage;
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage
{
    struct RakNet::Packet userMemory;
    struct DataStructures::MemoryPool<RakNet::Packet>::Page * parentPage;
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::Packet>::Page
{
    struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::Packet>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::Packet>::Page * next;
    struct DataStructures::MemoryPool<RakNet::Packet>::Page * prev;
};

class DataStructures::RangeList<RakNet::uint24_t>
{
    public void RangeList<RakNet::uint24_t>(class DataStructures::RangeList<RakNet::uint24_t> & );
    public void RangeList<RakNet::uint24_t>();
    public void ~RangeList<RakNet::uint24_t>();
    public void Insert(struct RakNet::uint24_t );
    public void Clear();
    public unsigned int Size();
    public unsigned int RangeSum();
    public unsigned int Serialize(class RakNet::BitStream * ,unsigned int ,bool );
    public bool Deserialize(class RakNet::BitStream * );
    public class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > ranges;
    public class DataStructures::RangeList<RakNet::uint24_t> & operator=(class DataStructures::RangeList<RakNet::uint24_t> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::RangeList<RakNet::uint24_t>
{
    public void RangeList<RakNet::uint24_t>(class DataStructures::RangeList<RakNet::uint24_t> & );
    public void RangeList<RakNet::uint24_t>();
    public void ~RangeList<RakNet::uint24_t>();
    public void Insert(struct RakNet::uint24_t );
    public void Clear();
    public unsigned int Size();
    public unsigned int RangeSum();
    public unsigned int Serialize(class RakNet::BitStream * ,unsigned int ,bool );
    public bool Deserialize(class RakNet::BitStream * );
    public class DataStructures::OrderedList<RakNet::uint24_t,DataStructures::RangeNode<RakNet::uint24_t>,&DataStructures::RangeNodeComp<RakNet::uint24_t> > ranges;
    public class DataStructures::RangeList<RakNet::uint24_t> & operator=(class DataStructures::RangeList<RakNet::uint24_t> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>
{
    public void Push(struct RakNet::RakPeer::SocketQueryOutput * );
    public struct RakNet::RakPeer::SocketQueryOutput * PopInaccurate();
    public struct RakNet::RakPeer::SocketQueryOutput * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::RakPeer::SocketQueryOutput * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::RakPeer::SocketQueryOutput * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::RakPeer::SocketQueryOutput * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> * );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>();
    public void ~ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>
{
    public void Push(struct RakNet::RakPeer::SocketQueryOutput * );
    public struct RakNet::RakPeer::SocketQueryOutput * PopInaccurate();
    public struct RakNet::RakPeer::SocketQueryOutput * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::RakPeer::SocketQueryOutput * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::RakPeer::SocketQueryOutput * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::RakPeer::SocketQueryOutput * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> * );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>();
    public void ~ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::SocketQueryOutput> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakPeer::BanStruct *>
{
    public void List<RakNet::RakPeer::BanStruct *>(class DataStructures::List<RakNet::RakPeer::BanStruct *> & );
    public void List<RakNet::RakPeer::BanStruct *>();
    public void ~List<RakNet::RakPeer::BanStruct *>();
    public class DataStructures::List<RakNet::RakPeer::BanStruct *> & operator=(class DataStructures::List<RakNet::RakPeer::BanStruct *> & );
    public struct RakNet::RakPeer::BanStruct &** operator[](const unsigned int );
    public struct RakNet::RakPeer::BanStruct &** Get(const unsigned int );
    public void Push(struct RakNet::RakPeer::BanStruct &** ,char * ,unsigned int );
    public struct RakNet::RakPeer::BanStruct &** Pop();
    public void Insert(struct RakNet::RakPeer::BanStruct &** ,char * ,unsigned int );
    public void Insert(struct RakNet::RakPeer::BanStruct &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakPeer::BanStruct &** );
    public void Replace(struct RakNet::RakPeer::BanStruct &** ,const struct RakNet::RakPeer::BanStruct * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakPeer::BanStruct &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakPeer::BanStruct ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakPeer::BanStruct *>
{
    public void List<RakNet::RakPeer::BanStruct *>(class DataStructures::List<RakNet::RakPeer::BanStruct *> & );
    public void List<RakNet::RakPeer::BanStruct *>();
    public void ~List<RakNet::RakPeer::BanStruct *>();
    public class DataStructures::List<RakNet::RakPeer::BanStruct *> & operator=(class DataStructures::List<RakNet::RakPeer::BanStruct *> & );
    public struct RakNet::RakPeer::BanStruct &** operator[](const unsigned int );
    public struct RakNet::RakPeer::BanStruct &** Get(const unsigned int );
    public void Push(struct RakNet::RakPeer::BanStruct &** ,char * ,unsigned int );
    public struct RakNet::RakPeer::BanStruct &** Pop();
    public void Insert(struct RakNet::RakPeer::BanStruct &** ,char * ,unsigned int );
    public void Insert(struct RakNet::RakPeer::BanStruct &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakPeer::BanStruct &** );
    public void Replace(struct RakNet::RakPeer::BanStruct &** ,const struct RakNet::RakPeer::BanStruct * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakPeer::BanStruct &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakPeer::BanStruct ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>
{
    public void List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>(class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> & );
    public void List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>();
    public void ~List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>();
    public class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> & operator=(class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> & );
    public struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator[](const unsigned int );
    public struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & Get(const unsigned int );
    public void Push(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,char * ,unsigned int );
    public struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & Pop();
    public void Insert(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,char * ,unsigned int );
    public void Insert(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    public void Replace(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,const struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>
{
    public void List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>(class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> & );
    public void List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>();
    public void ~List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode>();
    public class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> & operator=(class DataStructures::List<RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode> & );
    public struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & operator[](const unsigned int );
    public struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & Get(const unsigned int );
    public void Push(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,char * ,unsigned int );
    public struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & Pop();
    public void Insert(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,char * ,unsigned int );
    public void Insert(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    public void Replace(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & ,const struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::ReliabilityLayer::UnreliableWithAckReceiptNode * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::SystemAddress>
{
    public void List<RakNet::SystemAddress>(class DataStructures::List<RakNet::SystemAddress> & );
    public void List<RakNet::SystemAddress>();
    public void ~List<RakNet::SystemAddress>();
    public class DataStructures::List<RakNet::SystemAddress> & operator=(class DataStructures::List<RakNet::SystemAddress> & );
    public struct RakNet::SystemAddress & operator[](const unsigned int );
    public struct RakNet::SystemAddress & Get(const unsigned int );
    public void Push(struct RakNet::SystemAddress & ,char * ,unsigned int );
    public struct RakNet::SystemAddress & Pop();
    public void Insert(struct RakNet::SystemAddress & ,char * ,unsigned int );
    public void Insert(struct RakNet::SystemAddress & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::SystemAddress & );
    public void Replace(struct RakNet::SystemAddress & ,const struct RakNet::SystemAddress ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::SystemAddress & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::SystemAddress * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::SystemAddress>
{
    public void List<RakNet::SystemAddress>(class DataStructures::List<RakNet::SystemAddress> & );
    public void List<RakNet::SystemAddress>();
    public void ~List<RakNet::SystemAddress>();
    public class DataStructures::List<RakNet::SystemAddress> & operator=(class DataStructures::List<RakNet::SystemAddress> & );
    public struct RakNet::SystemAddress & operator[](const unsigned int );
    public struct RakNet::SystemAddress & Get(const unsigned int );
    public void Push(struct RakNet::SystemAddress & ,char * ,unsigned int );
    public struct RakNet::SystemAddress & Pop();
    public void Insert(struct RakNet::SystemAddress & ,char * ,unsigned int );
    public void Insert(struct RakNet::SystemAddress & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::SystemAddress & );
    public void Replace(struct RakNet::SystemAddress & ,const struct RakNet::SystemAddress ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::SystemAddress & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::SystemAddress * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<bool>
{
    public void Queue<bool>(class DataStructures::Queue<bool> & );
    public void Queue<bool>();
    public void ~Queue<bool>();
    public bool operator=(class DataStructures::Queue<bool> & );
    public void Push(bool & ,char * ,unsigned int );
    public void PushAtHead(bool & ,unsigned int ,char * ,unsigned int );
    public bool & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public bool Peek();
    public bool PeekTail();
    public bool Pop();
    public bool PopTail();
    public bool PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(bool & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private bool * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<bool>
{
    public void Queue<bool>(class DataStructures::Queue<bool> & );
    public void Queue<bool>();
    public void ~Queue<bool>();
    public bool operator=(class DataStructures::Queue<bool> & );
    public void Push(bool & ,char * ,unsigned int );
    public void PushAtHead(bool & ,unsigned int ,char * ,unsigned int );
    public bool & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public bool Peek();
    public bool PeekTail();
    public bool Pop();
    public bool PopTail();
    public bool PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(bool & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private bool * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2>
{
    public void Queue<RakNet::BPSTracker::TimeAndValue2>(class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2> & );
    public void Queue<RakNet::BPSTracker::TimeAndValue2>();
    public void ~Queue<RakNet::BPSTracker::TimeAndValue2>();
    public bool operator=(class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2> & );
    public void Push(struct RakNet::BPSTracker::TimeAndValue2 & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::BPSTracker::TimeAndValue2 & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::BPSTracker::TimeAndValue2 & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::BPSTracker::TimeAndValue2 Peek();
    public struct RakNet::BPSTracker::TimeAndValue2 PeekTail();
    public struct RakNet::BPSTracker::TimeAndValue2 Pop();
    public struct RakNet::BPSTracker::TimeAndValue2 PopTail();
    public struct RakNet::BPSTracker::TimeAndValue2 PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::BPSTracker::TimeAndValue2 & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::BPSTracker::TimeAndValue2 * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::BPSTracker::TimeAndValue2
{
    void TimeAndValue2(unsigned int ,unsigned int );
    void TimeAndValue2();
    void ~TimeAndValue2();
    unsigned int value1;
    unsigned int time;
    void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2>
{
    public void Queue<RakNet::BPSTracker::TimeAndValue2>(class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2> & );
    public void Queue<RakNet::BPSTracker::TimeAndValue2>();
    public void ~Queue<RakNet::BPSTracker::TimeAndValue2>();
    public bool operator=(class DataStructures::Queue<RakNet::BPSTracker::TimeAndValue2> & );
    public void Push(struct RakNet::BPSTracker::TimeAndValue2 & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::BPSTracker::TimeAndValue2 & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::BPSTracker::TimeAndValue2 & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::BPSTracker::TimeAndValue2 Peek();
    public struct RakNet::BPSTracker::TimeAndValue2 PeekTail();
    public struct RakNet::BPSTracker::TimeAndValue2 Pop();
    public struct RakNet::BPSTracker::TimeAndValue2 PopTail();
    public struct RakNet::BPSTracker::TimeAndValue2 PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::BPSTracker::TimeAndValue2 & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::BPSTracker::TimeAndValue2 * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>
{
    public void Push(struct RakNet::RakPeer::BufferedCommandStruct * );
    public struct RakNet::RakPeer::BufferedCommandStruct * PopInaccurate();
    public struct RakNet::RakPeer::BufferedCommandStruct * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::RakPeer::BufferedCommandStruct * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::RakPeer::BufferedCommandStruct * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::RakPeer::BufferedCommandStruct * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> * );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>();
    public void ~ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>
{
    public void Push(struct RakNet::RakPeer::BufferedCommandStruct * );
    public struct RakNet::RakPeer::BufferedCommandStruct * PopInaccurate();
    public struct RakNet::RakPeer::BufferedCommandStruct * Pop();
    public void SetPageSize(int );
    public bool IsEmpty();
    public struct RakNet::RakPeer::BufferedCommandStruct * operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public unsigned int Size();
    public struct RakNet::RakPeer::BufferedCommandStruct * Allocate(char * ,unsigned int );
    public void Deallocate(struct RakNet::RakPeer::BufferedCommandStruct * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    protected class DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct> memoryPool;
    protected class RakNet::SimpleMutex memoryPoolMutex;
    protected class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *> queue;
    protected class RakNet::SimpleMutex queueMutex;
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> * );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & );
    public void ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>();
    public void ~ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct>();
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> * );
    public class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & operator=(class DataStructures::ThreadsafeAllocatingQueue<RakNet::RakPeer::BufferedCommandStruct> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakNetGUID>
{
    public void List<RakNet::RakNetGUID>(class DataStructures::List<RakNet::RakNetGUID> & );
    public void List<RakNet::RakNetGUID>();
    public void ~List<RakNet::RakNetGUID>();
    public class DataStructures::List<RakNet::RakNetGUID> & operator=(class DataStructures::List<RakNet::RakNetGUID> & );
    public struct RakNet::RakNetGUID & operator[](const unsigned int );
    public struct RakNet::RakNetGUID & Get(const unsigned int );
    public void Push(struct RakNet::RakNetGUID & ,char * ,unsigned int );
    public struct RakNet::RakNetGUID & Pop();
    public void Insert(struct RakNet::RakNetGUID & ,char * ,unsigned int );
    public void Insert(struct RakNet::RakNetGUID & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakNetGUID & );
    public void Replace(struct RakNet::RakNetGUID & ,const struct RakNet::RakNetGUID ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakNetGUID & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakNetGUID * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakNetGUID>
{
    public void List<RakNet::RakNetGUID>(class DataStructures::List<RakNet::RakNetGUID> & );
    public void List<RakNet::RakNetGUID>();
    public void ~List<RakNet::RakNetGUID>();
    public class DataStructures::List<RakNet::RakNetGUID> & operator=(class DataStructures::List<RakNet::RakNetGUID> & );
    public struct RakNet::RakNetGUID & operator[](const unsigned int );
    public struct RakNet::RakNetGUID & Get(const unsigned int );
    public void Push(struct RakNet::RakNetGUID & ,char * ,unsigned int );
    public struct RakNet::RakNetGUID & Pop();
    public void Insert(struct RakNet::RakNetGUID & ,char * ,unsigned int );
    public void Insert(struct RakNet::RakNetGUID & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakNetGUID & );
    public void Replace(struct RakNet::RakNetGUID & ,const struct RakNet::RakNetGUID ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakNetGUID & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakNetGUID * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *>
{
    public void Queue<RakNet::RakPeer::SocketQueryOutput *>(class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *> & );
    public void Queue<RakNet::RakPeer::SocketQueryOutput *>();
    public void ~Queue<RakNet::RakPeer::SocketQueryOutput *>();
    public bool operator=(class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *> & );
    public void Push(struct RakNet::RakPeer::SocketQueryOutput &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RakPeer::SocketQueryOutput &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RakPeer::SocketQueryOutput &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RakPeer::SocketQueryOutput * Peek();
    public struct RakNet::RakPeer::SocketQueryOutput * PeekTail();
    public struct RakNet::RakPeer::SocketQueryOutput * Pop();
    public struct RakNet::RakPeer::SocketQueryOutput * PopTail();
    public struct RakNet::RakPeer::SocketQueryOutput * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RakPeer::SocketQueryOutput &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RakPeer::SocketQueryOutput ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *>
{
    public void Queue<RakNet::RakPeer::SocketQueryOutput *>(class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *> & );
    public void Queue<RakNet::RakPeer::SocketQueryOutput *>();
    public void ~Queue<RakNet::RakPeer::SocketQueryOutput *>();
    public bool operator=(class DataStructures::Queue<RakNet::RakPeer::SocketQueryOutput *> & );
    public void Push(struct RakNet::RakPeer::SocketQueryOutput &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RakPeer::SocketQueryOutput &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RakPeer::SocketQueryOutput &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RakPeer::SocketQueryOutput * Peek();
    public struct RakNet::RakPeer::SocketQueryOutput * PeekTail();
    public struct RakNet::RakPeer::SocketQueryOutput * Pop();
    public struct RakNet::RakPeer::SocketQueryOutput * PopTail();
    public struct RakNet::RakPeer::SocketQueryOutput * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RakPeer::SocketQueryOutput &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RakPeer::SocketQueryOutput ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::InternalPacket *>
{
    public void List<RakNet::InternalPacket *>(class DataStructures::List<RakNet::InternalPacket *> & );
    public void List<RakNet::InternalPacket *>();
    public void ~List<RakNet::InternalPacket *>();
    public class DataStructures::List<RakNet::InternalPacket *> & operator=(class DataStructures::List<RakNet::InternalPacket *> & );
    public struct RakNet::InternalPacket &** operator[](const unsigned int );
    public struct RakNet::InternalPacket &** Get(const unsigned int );
    public void Push(struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public struct RakNet::InternalPacket &** Pop();
    public void Insert(struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public void Insert(struct RakNet::InternalPacket &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::InternalPacket &** );
    public void Replace(struct RakNet::InternalPacket &** ,const struct RakNet::InternalPacket * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::InternalPacket &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::InternalPacket ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::InternalPacket *>
{
    public void List<RakNet::InternalPacket *>(class DataStructures::List<RakNet::InternalPacket *> & );
    public void List<RakNet::InternalPacket *>();
    public void ~List<RakNet::InternalPacket *>();
    public class DataStructures::List<RakNet::InternalPacket *> & operator=(class DataStructures::List<RakNet::InternalPacket *> & );
    public struct RakNet::InternalPacket &** operator[](const unsigned int );
    public struct RakNet::InternalPacket &** Get(const unsigned int );
    public void Push(struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public struct RakNet::InternalPacket &** Pop();
    public void Insert(struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public void Insert(struct RakNet::InternalPacket &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::InternalPacket &** );
    public void Replace(struct RakNet::InternalPacket &** ,const struct RakNet::InternalPacket * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::InternalPacket &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::InternalPacket ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * next;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::ReliabilityLayer::MessageNumberNode userMemory;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>();
    public void ~MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>();
    public void SetPageSize(int );
    public struct RakNet::ReliabilityLayer::MessageNumberNode * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::ReliabilityLayer::MessageNumberNode * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * ,struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * next;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::ReliabilityLayer::MessageNumberNode userMemory;
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>();
    public void ~MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>();
    public void SetPageSize(int );
    public struct RakNet::ReliabilityLayer::MessageNumberNode * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::ReliabilityLayer::MessageNumberNode * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * ,struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<bool>
{
    public void List<bool>(class DataStructures::List<bool> & );
    public void List<bool>();
    public void ~List<bool>();
    public class DataStructures::List<bool> & operator=(class DataStructures::List<bool> & );
    public bool & operator[](const unsigned int );
    public bool & Get(const unsigned int );
    public void Push(bool & ,char * ,unsigned int );
    public bool & Pop();
    public void Insert(bool & ,char * ,unsigned int );
    public void Insert(bool & ,const unsigned int ,char * ,unsigned int );
    public void Replace(bool & );
    public void Replace(bool & ,const bool ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(bool & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private bool * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<bool>
{
    public void List<bool>(class DataStructures::List<bool> & );
    public void List<bool>();
    public void ~List<bool>();
    public class DataStructures::List<bool> & operator=(class DataStructures::List<bool> & );
    public bool & operator[](const unsigned int );
    public bool & Get(const unsigned int );
    public void Push(bool & ,char * ,unsigned int );
    public bool & Pop();
    public void Insert(bool & ,char * ,unsigned int );
    public void Insert(bool & ,const unsigned int ,char * ,unsigned int );
    public void Replace(bool & );
    public void Replace(bool & ,const bool ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(bool & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private bool * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * next;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::InternalPacketRefCountedData userMemory;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * parentPage;
    };
    public void MemoryPool<RakNet::InternalPacketRefCountedData>();
    public void ~MemoryPool<RakNet::InternalPacketRefCountedData>();
    public void SetPageSize(int );
    public struct RakNet::InternalPacketRefCountedData * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::InternalPacketRefCountedData * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * ,struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * next;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::InternalPacketRefCountedData userMemory;
        struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * parentPage;
    };
    public void MemoryPool<RakNet::InternalPacketRefCountedData>();
    public void ~MemoryPool<RakNet::InternalPacketRefCountedData>();
    public void SetPageSize(int );
    public struct RakNet::InternalPacketRefCountedData * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::InternalPacketRefCountedData * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * ,struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RNS2RecvStruct *>
{
    public void Queue<RakNet::RNS2RecvStruct *>(class DataStructures::Queue<RakNet::RNS2RecvStruct *> & );
    public void Queue<RakNet::RNS2RecvStruct *>();
    public void ~Queue<RakNet::RNS2RecvStruct *>();
    public bool operator=(class DataStructures::Queue<RakNet::RNS2RecvStruct *> & );
    public void Push(struct RakNet::RNS2RecvStruct &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RNS2RecvStruct &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RNS2RecvStruct &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RNS2RecvStruct * Peek();
    public struct RakNet::RNS2RecvStruct * PeekTail();
    public struct RakNet::RNS2RecvStruct * Pop();
    public struct RakNet::RNS2RecvStruct * PopTail();
    public struct RakNet::RNS2RecvStruct * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RNS2RecvStruct &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RNS2RecvStruct ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RNS2RecvStruct *>
{
    public void Queue<RakNet::RNS2RecvStruct *>(class DataStructures::Queue<RakNet::RNS2RecvStruct *> & );
    public void Queue<RakNet::RNS2RecvStruct *>();
    public void ~Queue<RakNet::RNS2RecvStruct *>();
    public bool operator=(class DataStructures::Queue<RakNet::RNS2RecvStruct *> & );
    public void Push(struct RakNet::RNS2RecvStruct &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RNS2RecvStruct &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RNS2RecvStruct &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RNS2RecvStruct * Peek();
    public struct RakNet::RNS2RecvStruct * PeekTail();
    public struct RakNet::RNS2RecvStruct * Pop();
    public struct RakNet::RNS2RecvStruct * PopTail();
    public struct RakNet::RNS2RecvStruct * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RNS2RecvStruct &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RNS2RecvStruct ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *>
{
    public void Queue<RakNet::RakPeer::RequestedConnectionStruct *>(class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *> & );
    public void Queue<RakNet::RakPeer::RequestedConnectionStruct *>();
    public void ~Queue<RakNet::RakPeer::RequestedConnectionStruct *>();
    public bool operator=(class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *> & );
    public void Push(struct RakNet::RakPeer::RequestedConnectionStruct &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RakPeer::RequestedConnectionStruct &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RakPeer::RequestedConnectionStruct &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RakPeer::RequestedConnectionStruct * Peek();
    public struct RakNet::RakPeer::RequestedConnectionStruct * PeekTail();
    public struct RakNet::RakPeer::RequestedConnectionStruct * Pop();
    public struct RakNet::RakPeer::RequestedConnectionStruct * PopTail();
    public struct RakNet::RakPeer::RequestedConnectionStruct * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RakPeer::RequestedConnectionStruct &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RakPeer::RequestedConnectionStruct ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *>
{
    public void Queue<RakNet::RakPeer::RequestedConnectionStruct *>(class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *> & );
    public void Queue<RakNet::RakPeer::RequestedConnectionStruct *>();
    public void ~Queue<RakNet::RakPeer::RequestedConnectionStruct *>();
    public bool operator=(class DataStructures::Queue<RakNet::RakPeer::RequestedConnectionStruct *> & );
    public void Push(struct RakNet::RakPeer::RequestedConnectionStruct &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RakPeer::RequestedConnectionStruct &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RakPeer::RequestedConnectionStruct &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RakPeer::RequestedConnectionStruct * Peek();
    public struct RakNet::RakPeer::RequestedConnectionStruct * PeekTail();
    public struct RakNet::RakPeer::RequestedConnectionStruct * Pop();
    public struct RakNet::RakPeer::RequestedConnectionStruct * PopTail();
    public struct RakNet::RakPeer::RequestedConnectionStruct * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RakPeer::RequestedConnectionStruct &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RakPeer::RequestedConnectionStruct ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>
{
    struct HeapNode
    {
        void HeapNode(unsigned int & ,struct RakNet::InternalPacket &** );
        void HeapNode();
        unsigned int weight;
        struct RakNet::InternalPacket * data;
    };
    public void Heap<unsigned __int64,RakNet::InternalPacket *,0>(class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> & );
    public void Heap<unsigned __int64,RakNet::InternalPacket *,0>();
    public void ~Heap<unsigned __int64,RakNet::InternalPacket *,0>();
    public void Push(unsigned int & ,struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public void StartSeries();
    public void PushSeries(unsigned int & ,struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public struct RakNet::InternalPacket * Pop(const unsigned int );
    public struct RakNet::InternalPacket * Peek(const unsigned int );
    public unsigned int PeekWeight(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public struct RakNet::InternalPacket &** operator[](const unsigned int );
    public unsigned int Size();
    protected unsigned int LeftChild(const unsigned int );
    protected unsigned int RightChild(const unsigned int );
    protected unsigned int Parent(const unsigned int );
    protected void Swap(const unsigned int ,const unsigned int );
    protected class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> heap;
    protected bool optimizeNextSeriesPush;
    public class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> & operator=(class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>
{
    struct HeapNode
    {
        void HeapNode(unsigned int & ,struct RakNet::InternalPacket &** );
        void HeapNode();
        unsigned int weight;
        struct RakNet::InternalPacket * data;
    };
    public void Heap<unsigned __int64,RakNet::InternalPacket *,0>(class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> & );
    public void Heap<unsigned __int64,RakNet::InternalPacket *,0>();
    public void ~Heap<unsigned __int64,RakNet::InternalPacket *,0>();
    public void Push(unsigned int & ,struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public void StartSeries();
    public void PushSeries(unsigned int & ,struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public struct RakNet::InternalPacket * Pop(const unsigned int );
    public struct RakNet::InternalPacket * Peek(const unsigned int );
    public unsigned int PeekWeight(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public struct RakNet::InternalPacket &** operator[](const unsigned int );
    public unsigned int Size();
    protected unsigned int LeftChild(const unsigned int );
    protected unsigned int RightChild(const unsigned int );
    protected unsigned int Parent(const unsigned int );
    protected void Swap(const unsigned int ,const unsigned int );
    protected class DataStructures::List<DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode> heap;
    protected bool optimizeNextSeriesPush;
    public class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> & operator=(class DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0> & );
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RakPeer::SocketQueryOutput userMemory;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
        void MemoryWithPage();
        void ~MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
        void * __vecDelDtor(unsigned int );
    };
    public void MemoryPool<RakNet::RakPeer::SocketQueryOutput>();
    public void ~MemoryPool<RakNet::RakPeer::SocketQueryOutput>();
    public void SetPageSize(int );
    public struct RakNet::RakPeer::SocketQueryOutput * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RakPeer::SocketQueryOutput * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * ,struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RakPeer::SocketQueryOutput userMemory;
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
        void MemoryWithPage();
        void ~MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
        void * __vecDelDtor(unsigned int );
    };
    public void MemoryPool<RakNet::RakPeer::SocketQueryOutput>();
    public void ~MemoryPool<RakNet::RakPeer::SocketQueryOutput>();
    public void SetPageSize(int );
    public struct RakNet::RakPeer::SocketQueryOutput * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RakPeer::SocketQueryOutput * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * ,struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage
{
    struct RakNet::RakPeer::SocketQueryOutput userMemory;
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
    void MemoryWithPage();
    void ~MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
    void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage
{
    struct RakNet::RakPeer::SocketQueryOutput userMemory;
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
    void MemoryWithPage();
    void ~MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage & );
    void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page
{
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * next;
    struct DataStructures::MemoryPool<RakNet::RakPeer::SocketQueryOutput>::Page * prev;
};

class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *>
{
    public void Queue<RakNet::RakPeer::BufferedCommandStruct *>(class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *> & );
    public void Queue<RakNet::RakPeer::BufferedCommandStruct *>();
    public void ~Queue<RakNet::RakPeer::BufferedCommandStruct *>();
    public bool operator=(class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *> & );
    public void Push(struct RakNet::RakPeer::BufferedCommandStruct &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RakPeer::BufferedCommandStruct &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RakPeer::BufferedCommandStruct &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RakPeer::BufferedCommandStruct * Peek();
    public struct RakNet::RakPeer::BufferedCommandStruct * PeekTail();
    public struct RakNet::RakPeer::BufferedCommandStruct * Pop();
    public struct RakNet::RakPeer::BufferedCommandStruct * PopTail();
    public struct RakNet::RakPeer::BufferedCommandStruct * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RakPeer::BufferedCommandStruct &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RakPeer::BufferedCommandStruct ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *>
{
    public void Queue<RakNet::RakPeer::BufferedCommandStruct *>(class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *> & );
    public void Queue<RakNet::RakPeer::BufferedCommandStruct *>();
    public void ~Queue<RakNet::RakPeer::BufferedCommandStruct *>();
    public bool operator=(class DataStructures::Queue<RakNet::RakPeer::BufferedCommandStruct *> & );
    public void Push(struct RakNet::RakPeer::BufferedCommandStruct &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::RakPeer::BufferedCommandStruct &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::RakPeer::BufferedCommandStruct &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::RakPeer::BufferedCommandStruct * Peek();
    public struct RakNet::RakPeer::BufferedCommandStruct * PeekTail();
    public struct RakNet::RakPeer::BufferedCommandStruct * Pop();
    public struct RakNet::RakPeer::BufferedCommandStruct * PopTail();
    public struct RakNet::RakPeer::BufferedCommandStruct * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::RakPeer::BufferedCommandStruct &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::RakPeer::BufferedCommandStruct ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::RangeNode<RakNet::uint24_t>
{
    void RangeNode<RakNet::uint24_t>(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    void RangeNode<RakNet::uint24_t>(struct RakNet::uint24_t ,struct RakNet::uint24_t );
    void RangeNode<RakNet::uint24_t>();
    void ~RangeNode<RakNet::uint24_t>();
    struct RakNet::uint24_t minIndex;
    struct RakNet::uint24_t maxIndex;
    struct DataStructures::RangeNode<RakNet::uint24_t> & operator=(struct DataStructures::RangeNode<RakNet::uint24_t> & );
    void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakString>
{
    public void List<RakNet::RakString>(class DataStructures::List<RakNet::RakString> & );
    public void List<RakNet::RakString>();
    public void ~List<RakNet::RakString>();
    public class DataStructures::List<RakNet::RakString> & operator=(class DataStructures::List<RakNet::RakString> & );
    public class RakNet::RakString & operator[](const unsigned int );
    public class RakNet::RakString & Get(const unsigned int );
    public void Push(class RakNet::RakString & ,char * ,unsigned int );
    public class RakNet::RakString & Pop();
    public void Insert(class RakNet::RakString & ,char * ,unsigned int );
    public void Insert(class RakNet::RakString & ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::RakString & );
    public void Replace(class RakNet::RakString & ,const class RakNet::RakString ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::RakString & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::RakString * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakString>
{
    public void List<RakNet::RakString>(class DataStructures::List<RakNet::RakString> & );
    public void List<RakNet::RakString>();
    public void ~List<RakNet::RakString>();
    public class DataStructures::List<RakNet::RakString> & operator=(class DataStructures::List<RakNet::RakString> & );
    public class RakNet::RakString & operator[](const unsigned int );
    public class RakNet::RakString & Get(const unsigned int );
    public void Push(class RakNet::RakString & ,char * ,unsigned int );
    public class RakNet::RakString & Pop();
    public void Insert(class RakNet::RakString & ,char * ,unsigned int );
    public void Insert(class RakNet::RakString & ,const unsigned int ,char * ,unsigned int );
    public void Replace(class RakNet::RakString & );
    public void Replace(class RakNet::RakString & ,const class RakNet::RakString ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(class RakNet::RakString & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private class RakNet::RakString * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::InternalPacket>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * next;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::InternalPacket userMemory;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::InternalPacket>();
    public void ~MemoryPool<RakNet::InternalPacket>();
    public void SetPageSize(int );
    public struct RakNet::InternalPacket * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::InternalPacket * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * ,struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::InternalPacket>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * next;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::InternalPacket userMemory;
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::InternalPacket>();
    public void ~MemoryPool<RakNet::InternalPacket>();
    public void SetPageSize(int );
    public struct RakNet::InternalPacket * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::InternalPacket * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * ,struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RakPeer::BufferedCommandStruct userMemory;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::RakPeer::BufferedCommandStruct>();
    public void ~MemoryPool<RakNet::RakPeer::BufferedCommandStruct>();
    public void SetPageSize(int );
    public struct RakNet::RakPeer::BufferedCommandStruct * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RakPeer::BufferedCommandStruct * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * ,struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RakPeer::BufferedCommandStruct userMemory;
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * parentPage;
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
        void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
        void MemoryWithPage();
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
        struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
    };
    public void MemoryPool<RakNet::RakPeer::BufferedCommandStruct>();
    public void ~MemoryPool<RakNet::RakPeer::BufferedCommandStruct>();
    public void SetPageSize(int );
    public struct RakNet::RakPeer::BufferedCommandStruct * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RakPeer::BufferedCommandStruct * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * ,struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage
{
    struct RakNet::RakPeer::BufferedCommandStruct userMemory;
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage
{
    struct RakNet::RakPeer::BufferedCommandStruct userMemory;
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page
{
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * next;
    struct DataStructures::MemoryPool<RakNet::RakPeer::BufferedCommandStruct>::Page * prev;
};

class DataStructures::List<RakNet::RakNetStatistics>
{
    public void List<RakNet::RakNetStatistics>(class DataStructures::List<RakNet::RakNetStatistics> & );
    public void List<RakNet::RakNetStatistics>();
    public void ~List<RakNet::RakNetStatistics>();
    public class DataStructures::List<RakNet::RakNetStatistics> & operator=(class DataStructures::List<RakNet::RakNetStatistics> & );
    public struct RakNet::RakNetStatistics & operator[](const unsigned int );
    public struct RakNet::RakNetStatistics & Get(const unsigned int );
    public void Push(struct RakNet::RakNetStatistics & ,char * ,unsigned int );
    public struct RakNet::RakNetStatistics & Pop();
    public void Insert(struct RakNet::RakNetStatistics & ,char * ,unsigned int );
    public void Insert(struct RakNet::RakNetStatistics & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakNetStatistics & );
    public void Replace(struct RakNet::RakNetStatistics & ,const struct RakNet::RakNetStatistics ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakNetStatistics & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakNetStatistics * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakNetStatistics>
{
    public void List<RakNet::RakNetStatistics>(class DataStructures::List<RakNet::RakNetStatistics> & );
    public void List<RakNet::RakNetStatistics>();
    public void ~List<RakNet::RakNetStatistics>();
    public class DataStructures::List<RakNet::RakNetStatistics> & operator=(class DataStructures::List<RakNet::RakNetStatistics> & );
    public struct RakNet::RakNetStatistics & operator[](const unsigned int );
    public struct RakNet::RakNetStatistics & Get(const unsigned int );
    public void Push(struct RakNet::RakNetStatistics & ,char * ,unsigned int );
    public struct RakNet::RakNetStatistics & Pop();
    public void Insert(struct RakNet::RakNetStatistics & ,char * ,unsigned int );
    public void Insert(struct RakNet::RakNetStatistics & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakNetStatistics & );
    public void Replace(struct RakNet::RakNetStatistics & ,const struct RakNet::RakNetStatistics ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakNetStatistics & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakNetStatistics * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>
{
    public void Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>(class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode> & );
    public void Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>();
    public void ~Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>();
    public bool operator=(class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode> & );
    public void Push(struct RakNet::ReliabilityLayer::DatagramHistoryNode & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::ReliabilityLayer::DatagramHistoryNode & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode Peek();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode PeekTail();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode Pop();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode PopTail();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::ReliabilityLayer::DatagramHistoryNode & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::ReliabilityLayer::DatagramHistoryNode * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct RakNet::ReliabilityLayer::DatagramHistoryNode
{
    void DatagramHistoryNode(struct RakNet::ReliabilityLayer::MessageNumberNode * ,unsigned int );
    void DatagramHistoryNode();
    struct RakNet::ReliabilityLayer::MessageNumberNode * head;
    unsigned int timeSent;
};

class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>
{
    public void Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>(class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode> & );
    public void Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>();
    public void ~Queue<RakNet::ReliabilityLayer::DatagramHistoryNode>();
    public bool operator=(class DataStructures::Queue<RakNet::ReliabilityLayer::DatagramHistoryNode> & );
    public void Push(struct RakNet::ReliabilityLayer::DatagramHistoryNode & ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::ReliabilityLayer::DatagramHistoryNode & ,unsigned int ,char * ,unsigned int );
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode & operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode Peek();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode PeekTail();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode Pop();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode PopTail();
    public struct RakNet::ReliabilityLayer::DatagramHistoryNode PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::ReliabilityLayer::DatagramHistoryNode & );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::ReliabilityLayer::DatagramHistoryNode * array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RemoteSystemIndex>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RemoteSystemIndex userMemory;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * parentPage;
    };
    public void MemoryPool<RakNet::RemoteSystemIndex>();
    public void ~MemoryPool<RakNet::RemoteSystemIndex>();
    public void SetPageSize(int );
    public struct RakNet::RemoteSystemIndex * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RemoteSystemIndex * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * ,struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::MemoryPool<RakNet::RemoteSystemIndex>
{
    struct Page
    {
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage ** availableStack;
        int availableStackSize;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage * block;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * next;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * prev;
    };
    struct MemoryWithPage
    {
        struct RakNet::RemoteSystemIndex userMemory;
        struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * parentPage;
    };
    public void MemoryPool<RakNet::RemoteSystemIndex>();
    public void ~MemoryPool<RakNet::RemoteSystemIndex>();
    public void SetPageSize(int );
    public struct RakNet::RemoteSystemIndex * Allocate(char * ,unsigned int );
    public void Release(struct RakNet::RemoteSystemIndex * ,char * ,unsigned int );
    public void Clear(char * ,unsigned int );
    public int GetAvailablePagesSize();
    public int GetUnavailablePagesSize();
    public int GetMemoryPoolPageSize();
    protected int BlocksPerPage();
    protected void AllocateFirst();
    protected bool InitPage(struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * ,struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * ,char * ,unsigned int );
    protected struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * availablePages;
    protected struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * unavailablePages;
    protected int availablePagesSize;
    protected int unavailablePagesSize;
    protected int memoryPoolPageSize;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage
{
    struct RakNet::RemoteSystemIndex userMemory;
    struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * parentPage;
};

struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page
{
    struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * next;
    struct DataStructures::MemoryPool<RakNet::RemoteSystemIndex>::Page * prev;
};

class DataStructures::Queue<RakNet::InternalPacket *>
{
    public void Queue<RakNet::InternalPacket *>(class DataStructures::Queue<RakNet::InternalPacket *> & );
    public void Queue<RakNet::InternalPacket *>();
    public void ~Queue<RakNet::InternalPacket *>();
    public bool operator=(class DataStructures::Queue<RakNet::InternalPacket *> & );
    public void Push(struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::InternalPacket &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::InternalPacket &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::InternalPacket * Peek();
    public struct RakNet::InternalPacket * PeekTail();
    public struct RakNet::InternalPacket * Pop();
    public struct RakNet::InternalPacket * PopTail();
    public struct RakNet::InternalPacket * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::InternalPacket &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::InternalPacket ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::Queue<RakNet::InternalPacket *>
{
    public void Queue<RakNet::InternalPacket *>(class DataStructures::Queue<RakNet::InternalPacket *> & );
    public void Queue<RakNet::InternalPacket *>();
    public void ~Queue<RakNet::InternalPacket *>();
    public bool operator=(class DataStructures::Queue<RakNet::InternalPacket *> & );
    public void Push(struct RakNet::InternalPacket &** ,char * ,unsigned int );
    public void PushAtHead(struct RakNet::InternalPacket &** ,unsigned int ,char * ,unsigned int );
    public struct RakNet::InternalPacket &** operator[](unsigned int );
    public void RemoveAtIndex(unsigned int );
    public struct RakNet::InternalPacket * Peek();
    public struct RakNet::InternalPacket * PeekTail();
    public struct RakNet::InternalPacket * Pop();
    public struct RakNet::InternalPacket * PopTail();
    public struct RakNet::InternalPacket * PopDeref();
    public unsigned int Size();
    public bool IsEmpty();
    public unsigned int AllocationSize();
    public void Clear(char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    public bool Find(struct RakNet::InternalPacket &** );
    public void ClearAndForceAllocation(int ,char * ,unsigned int );
    private struct RakNet::InternalPacket ** array;
    private unsigned int head;
    private unsigned int tail;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakString::SharedString *>
{
    public void List<RakNet::RakString::SharedString *>(class DataStructures::List<RakNet::RakString::SharedString *> & );
    public void List<RakNet::RakString::SharedString *>();
    public void ~List<RakNet::RakString::SharedString *>();
    public class DataStructures::List<RakNet::RakString::SharedString *> & operator=(class DataStructures::List<RakNet::RakString::SharedString *> & );
    public struct RakNet::RakString::SharedString &** operator[](const unsigned int );
    public struct RakNet::RakString::SharedString &** Get(const unsigned int );
    public void Push(struct RakNet::RakString::SharedString &** ,char * ,unsigned int );
    public struct RakNet::RakString::SharedString &** Pop();
    public void Insert(struct RakNet::RakString::SharedString &** ,char * ,unsigned int );
    public void Insert(struct RakNet::RakString::SharedString &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakString::SharedString &** );
    public void Replace(struct RakNet::RakString::SharedString &** ,const struct RakNet::RakString::SharedString * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakString::SharedString &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakString::SharedString ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::List<RakNet::RakString::SharedString *>
{
    public void List<RakNet::RakString::SharedString *>(class DataStructures::List<RakNet::RakString::SharedString *> & );
    public void List<RakNet::RakString::SharedString *>();
    public void ~List<RakNet::RakString::SharedString *>();
    public class DataStructures::List<RakNet::RakString::SharedString *> & operator=(class DataStructures::List<RakNet::RakString::SharedString *> & );
    public struct RakNet::RakString::SharedString &** operator[](const unsigned int );
    public struct RakNet::RakString::SharedString &** Get(const unsigned int );
    public void Push(struct RakNet::RakString::SharedString &** ,char * ,unsigned int );
    public struct RakNet::RakString::SharedString &** Pop();
    public void Insert(struct RakNet::RakString::SharedString &** ,char * ,unsigned int );
    public void Insert(struct RakNet::RakString::SharedString &** ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct RakNet::RakString::SharedString &** );
    public void Replace(struct RakNet::RakString::SharedString &** ,const struct RakNet::RakString::SharedString * ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct RakNet::RakString::SharedString &** );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct RakNet::RakString::SharedString ** listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class RakStringCleanup
{
    public void ~RakStringCleanup();
    public void * __vecDelDtor(unsigned int );
};

struct __vcrt_assert_va_start_is_not_reference<unsigned char const *>
{
};

enum __vcrt_va_list_is_reference<unsigned char const *>::<unnamed-enum-__the_value>
{
    __the_value=0
};

struct __vcrt_va_list_is_reference<unsigned char const *>
{
    enum <unnamed-enum-__the_value>
    {
        __the_value=0
    };
};

struct DatagramHeaderFormat
{
    struct RakNet::uint24_t datagramNumber;
    float AS;
    bool isACK;
    bool isNAK;
    bool isPacketPair;
    bool hasBAndAS;
    bool isContinuousSend;
    bool needsBAndAs;
    bool isValid;
    unsigned int GetDataHeaderBitLength();
    unsigned int GetDataHeaderByteLength();
    void Serialize(class RakNet::BitStream * );
    void Deserialize(class RakNet::BitStream * );
    void DatagramHeaderFormat(struct DatagramHeaderFormat * );
    void DatagramHeaderFormat(struct DatagramHeaderFormat & );
    void DatagramHeaderFormat();
    struct DatagramHeaderFormat & operator=(struct DatagramHeaderFormat * );
    struct DatagramHeaderFormat & operator=(struct DatagramHeaderFormat & );
};

struct DatagramHeaderFormat
{
    struct RakNet::uint24_t datagramNumber;
    float AS;
    bool isACK;
    bool isNAK;
    bool isPacketPair;
    bool hasBAndAS;
    bool isContinuousSend;
    bool needsBAndAs;
    bool isValid;
    unsigned int GetDataHeaderBitLength();
    unsigned int GetDataHeaderByteLength();
    void Serialize(class RakNet::BitStream * );
    void Deserialize(class RakNet::BitStream * );
    void DatagramHeaderFormat(struct DatagramHeaderFormat * );
    void DatagramHeaderFormat(struct DatagramHeaderFormat & );
    void DatagramHeaderFormat();
    struct DatagramHeaderFormat & operator=(struct DatagramHeaderFormat * );
    struct DatagramHeaderFormat & operator=(struct DatagramHeaderFormat & );
};

struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage
{
    struct RakNet::ReliabilityLayer::MessageNumberNode userMemory;
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage
{
    struct RakNet::ReliabilityLayer::MessageNumberNode userMemory;
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page
{
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * next;
    struct DataStructures::MemoryPool<RakNet::ReliabilityLayer::MessageNumberNode>::Page * prev;
};

struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage
{
    struct RakNet::InternalPacketRefCountedData userMemory;
    struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * parentPage;
};

struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page
{
    struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * next;
    struct DataStructures::MemoryPool<RakNet::InternalPacketRefCountedData>::Page * prev;
};

struct DataStructures::Heap<unsigned __int64,RakNet::InternalPacket *,0>::HeapNode
{
    void HeapNode(unsigned int & ,struct RakNet::InternalPacket &** );
    void HeapNode();
    unsigned int weight;
    struct RakNet::InternalPacket * data;
};

struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage
{
    struct RakNet::InternalPacket userMemory;
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage
{
    struct RakNet::InternalPacket userMemory;
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * parentPage;
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
    void MemoryWithPage(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page
{
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * next;
    struct DataStructures::MemoryPool<RakNet::InternalPacket>::Page * prev;
};

union sockaddr_gen
{
    struct sockaddr Address;
    struct sockaddr_in AddressIn;
    struct sockaddr_in6_old AddressIn6;
};

struct _INTERFACE_INFO
{
    unsigned long iiFlags;
    union sockaddr_gen iiAddress;
    union sockaddr_gen iiBroadcastAddress;
    union sockaddr_gen iiNetmask;
};

struct sockaddr_in6_old
{
    int sin6_family;
    unsigned int sin6_port;
    unsigned long sin6_flowinfo;
    struct in6_addr sin6_addr;
};

class RakNet::SocketLayer
{
    public void SocketLayer();
    public void ~SocketLayer();
    public class RakNet::RakString GetSubNetForSocketAndIp(unsigned int ,class RakNet::RakString );
    public void GetMyIP(struct RakNet::SystemAddress * );
    public unsigned int GetLocalPort(unsigned int );
    public void GetSystemAddress_Old(unsigned int ,struct RakNet::SystemAddress * );
    public void GetSystemAddress(unsigned int ,struct RakNet::SystemAddress * );
    public void SetSocketOptions(unsigned int ,bool ,bool );
    public bool GetFirstBindableIP(char * ,int );
    public void * __vecDelDtor(unsigned int );
};

struct StrAndBool
{
    char * str;
    bool b;
};

class DataStructures::List<StrAndBool>
{
    public void List<StrAndBool>(class DataStructures::List<StrAndBool> & );
    public void List<StrAndBool>();
    public void ~List<StrAndBool>();
    public class DataStructures::List<StrAndBool> & operator=(class DataStructures::List<StrAndBool> & );
    public struct StrAndBool & operator[](const unsigned int );
    public struct StrAndBool & Get(const unsigned int );
    public void Push(struct StrAndBool & ,char * ,unsigned int );
    public struct StrAndBool & Pop();
    public void Insert(struct StrAndBool & ,char * ,unsigned int );
    public void Insert(struct StrAndBool & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct StrAndBool & );
    public void Replace(struct StrAndBool & ,const struct StrAndBool ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct StrAndBool & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct StrAndBool * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

struct StrAndBool
{
    char * str;
    bool b;
};

class DataStructures::List<StrAndBool>
{
    public void List<StrAndBool>(class DataStructures::List<StrAndBool> & );
    public void List<StrAndBool>();
    public void ~List<StrAndBool>();
    public class DataStructures::List<StrAndBool> & operator=(class DataStructures::List<StrAndBool> & );
    public struct StrAndBool & operator[](const unsigned int );
    public struct StrAndBool & Get(const unsigned int );
    public void Push(struct StrAndBool & ,char * ,unsigned int );
    public struct StrAndBool & Pop();
    public void Insert(struct StrAndBool & ,char * ,unsigned int );
    public void Insert(struct StrAndBool & ,const unsigned int ,char * ,unsigned int );
    public void Replace(struct StrAndBool & );
    public void Replace(struct StrAndBool & ,const struct StrAndBool ,const unsigned int ,char * ,unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void RemoveAtIndexFast(const unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public unsigned int GetIndexOf(struct StrAndBool & );
    public unsigned int Size();
    public void Clear(bool ,char * ,unsigned int );
    public void Preallocate(unsigned int ,char * ,unsigned int );
    public void Compress(char * ,unsigned int );
    private struct StrAndBool * listArray;
    private unsigned int list_size;
    private unsigned int allocation_size;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>(class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> & );
    public void OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>();
    public void ~OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>();
    public class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> & operator=(class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> & );
    public bool HasData(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int GetIndexFromKey(char &** ,bool * ,int  ( * )(char &** ,struct StrAndBool & ));
    public bool GetElementFromKey(char &** ,struct StrAndBool & ,int  ( * )(char &** ,struct StrAndBool & ));
    public struct StrAndBool GetElementFromKey(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int Insert(char &** ,struct StrAndBool & ,bool ,char * ,unsigned int ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int Remove(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int RemoveIfExists(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public struct StrAndBool & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct StrAndBool & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct StrAndBool & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<StrAndBool> orderedList;
    public void * __vecDelDtor(unsigned int );
};

class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>
{
    public void IMPLEMENT_DEFAULT_COMPARISON();
    public void OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>(class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> & );
    public void OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>();
    public void ~OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp>();
    public class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> & operator=(class DataStructures::OrderedList<char *,StrAndBool,&RakNet::StrAndBoolComp> & );
    public bool HasData(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int GetIndexFromKey(char &** ,bool * ,int  ( * )(char &** ,struct StrAndBool & ));
    public bool GetElementFromKey(char &** ,struct StrAndBool & ,int  ( * )(char &** ,struct StrAndBool & ));
    public struct StrAndBool GetElementFromKey(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int Insert(char &** ,struct StrAndBool & ,bool ,char * ,unsigned int ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int Remove(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public unsigned int RemoveIfExists(char &** ,int  ( * )(char &** ,struct StrAndBool & ));
    public struct StrAndBool & operator[](const unsigned int );
    public void RemoveAtIndex(const unsigned int );
    public void InsertAtIndex(struct StrAndBool & ,const unsigned int ,char * ,unsigned int );
    public void InsertAtEnd(struct StrAndBool & ,char * ,unsigned int );
    public void RemoveFromEnd(const unsigned int );
    public void Clear(bool ,char * ,unsigned int );
    public unsigned int Size();
    protected class DataStructures::List<StrAndBool> orderedList;
    public void * __vecDelDtor(unsigned int );
};

struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage
{
    struct RakNet::SystemAddress userMemory;
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * parentPage;
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage
{
    struct RakNet::SystemAddress userMemory;
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * parentPage;
    void MemoryWithPage();
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * );
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & operator=(struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage & );
};

struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page
{
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * next;
    struct DataStructures::MemoryPool<RakNet::SystemAddress>::Page * prev;
};

struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage
{
    struct RakNet::RemoteClient * userMemory;
    struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * parentPage;
};

struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page
{
    struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage ** availableStack;
    int availableStackSize;
    struct DataStructures::MemoryPool<RakNet::RemoteClient *>::MemoryWithPage * block;
    struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * next;
    struct DataStructures::MemoryPool<RakNet::RemoteClient *>::Page * prev;
};

#endif
